<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Node.js 进阶 —— Koa2 源码分析</title>
    <url>/20180902141819/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180902141819/koa-cover.png" title="Koa 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><strong><code>Koa 2.x</code> 版本是当下最流行的 <code>Node.js</code> 框架，同时社区涌现出一大批围绕 <code>Koa 2.x</code> 的中间件以及基于 <code>Koa 2.x</code> 封装的企业级框架，如 <code>egg.js</code>，然而 <code>Koa</code> 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 <code>2000</code> 行，本篇就围绕着这 <code>2000</code> 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 <code>200</code> 行不到的简易版 <code>Koa</code>。</strong></p></blockquote><a id="more"></a><h2 id="Koa-分析过程"><a href="#Koa-分析过程" class="headerlink" title="Koa 分析过程"></a>Koa 分析过程</h2><p>在下面的内容中，我们将对 <code>Koa</code> 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 <code>Koa</code> 诞生的过程，在此之前我们打开 <a href="https://github.com/koajs/koa/tree/master/lib" target="_blank">Koa 源码地址</a>。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180902141819/koa-dir.png" alt="Koa 文件目录"></div><div class="image-caption">Koa 文件目录</div></figure><p><br></p><p>通过上面对 <code>Koa</code> 源码目录的截图，发现只有 <code>4</code> 个核心文件，为了方便理解，封装简版 <code>Koa</code> 的文件目录结构也将严格与源码同步。</p><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>在引入 <code>Koa</code> 时我们需要创建一个 <code>Koa</code> 的实例，而启动服务是通过 <code>listen</code> 监听一个端口号实现的，代码如下。</p><pre><code class="lang-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>通过使用我们可以分析出 <code>Koa</code> 导出的应该是一个类，或者构造函数，鉴于 <code>Koa</code> 诞生的时间以及基于 <code>node v7.6.0</code> 以上版本的情况来分析，正是 <code>ES6</code> 开始流行的时候，所以推测 <code>Koa</code> 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 <code>class</code> 的方式来实现。</p><p>而从启动服务的方式上看，<code>app.listen</code> 的调用方式与原生 <code>http</code> 模块提供的 <code>server.listen</code> 几乎相同，我们分析，<code>listen</code> 方法应该是对原生 <code>http</code> 模块的一个封装，启动服务的本质还是靠 <code>http</code> 模块来实现的。</p><pre><code class="lang-js">/* 文件路径：~koa/application.js */
const http = require(&#39;http&#39;);

class Koa {
  handleRequest(req, res) {
    // 请求回调
  }
  listen(...args) {
    // 创建服务
    const server = http.createServer(this.handleRequest.bind(this));

    // 启动服务
    server.listen(...args);
  }
}

module.exports = Koa;
</code></pre><p>上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 <code>handleRequest</code> 的实例方法，内部的逻辑在后面完善，现在可以创建这个 <code>Koa</code> 类的实例，通过调用实例的 <code>listen</code> 方法启动一个服务器。</p><h2 id="上下文对象-ctx-的封装"><a href="#上下文对象-ctx-的封装" class="headerlink" title="上下文对象 ctx 的封装"></a>上下文对象 ctx 的封装</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>Koa</code> 还有一个很重要的特性，就是它的 <code>ctx</code> 上下文对象，我们可以调用 <code>ctx</code> 的 <code>request</code> 和 <code>response</code> 属性获取原 <code>req</code> 和 <code>res</code> 的属性和方法，也在 <code>ctx</code> 上增加了一些原生没有的属性和方法，总之 <code>ctx</code> 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。</p><pre><code class="lang-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.use((ctx, next) =&gt; {
  // 原生的 req 对象的 url 属性
  console.log(ctx.req.url);
  console.log(ctx.request.req.url);
  console.log(ctx.response.req.url);

  // Koa 扩展的 url
  console.log(ctx.url);
  console.log(ctx.request.req.url);

  // 设置状态码和响应内容
  ctx.response.status = 200;
  ctx.body = &#39;Hello World&#39;;
});

app.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><h3 id="创建-ctx-的引用关系"><a href="#创建-ctx-的引用关系" class="headerlink" title="创建 ctx 的引用关系"></a>创建 ctx 的引用关系</h3><p>从上面我们可以看出，<code>ctx</code> 为 <code>use</code> 方法的第一个参数，<code>request</code> 和 <code>response</code> 是 <code>ctx</code> 新增的，而通过这两个属性又都可以获取原生的 <code>req</code> 和 <code>res</code> 属性，<code>ctx</code> 本身也可以获取到原生的 <code>req</code> 和 <code>res</code>，我们可以分析出，<code>ctx</code> 是对这些属性做了一个集成，或者说特殊处理。</p><p>源码的文件目录中正好有与 <code>request</code>、<code>response</code> 名字相对应的文件，并且还有 <code>context</code> 名字的文件，我们其实可以分析出这三个文件就是用于封装 <code>ctx</code> 上下文对象使用的，而封装 <code>ctx</code> 中也会用到 <code>req</code> 和 <code>res</code>，所以核心逻辑应该在 <code>handleRequest</code> 中实现。</p><p>在使用案例中 <code>ctx</code> 是作为 <code>use</code> 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 <code>use</code> 后传入的函数，<code>Koa</code> 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。</p><pre><code class="lang-js">/* 文件路径：~koa/application.js */
const http = require(&#39;http&#39;);

// ************************** 以下为新增代码 **************************
const context = require(&#39;./context&#39;);
const request = require(&#39;./request&#39;);
const response = require(&#39;./response&#39;);
// ************************** 以上为新增代码 **************************

class Koa {
// ************************** 以下为新增代码 **************************
  contructor() {
    // 存储中间件
    this.middlewares = [];

    // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
  }
  use(fn) {
    // 将传给 use 的函数存入数组中
    this.middlewares.push(fn);
  }
  createContext(req, res) {
    // 或取定义的上下文
    const ctx = this.context;

    // 增加 request 和 response
    ctx.request = this.request;
    ctx.response = this.response;

    // 让 ctx、request、response 都具有原生的 req 和 res
    ctx.req = ctx.request.req = ctx.response.req = req;
    ctx.res = ctx.response.res = ctx.request.res = res;

    // 返回上下文对象
    return ctx;
  }
// ************************** 以上为新增代码 **************************
  handleRequest(req, res) {
    // 创建 ctx 上下文对象
    const ctx = this.createContext(req, res);
  }
  listen(...args) {
    // 创建服务
    const server = http.createServer(this.handleRequest.bind(this));

    // 启动服务
    server.listen(...args);
  }
}

module.exports = Koa;
</code></pre><p>首先，给实例创建了三个属性 <code>context</code>、<code>request</code> 和 <code>response</code> 分别继承了 <code>context.js</code>、<code>request.js</code> 和 <code>response.js</code> 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。</p><p>其次，给实例挂载了 <code>middlewares</code> 属性，值为数组，为了存储 <code>use</code> 方法调用时传入的函数，在 <code>handleRequest</code> 把创建 <code>ctx</code> 属性及引用的过程单独抽取成了 <code>createContext</code> 方法，并在 <code>handleRequest</code> 中调用，返回值为创建好的 <code>ctx</code> 对象，而在 <code>createContext</code> 中我们根据案例中的规则构建了 <code>ctx</code> 的属性相关的各种引用关系。</p><h3 id="实现-request-取值"><a href="#实现-request-取值" class="headerlink" title="实现 request 取值"></a>实现 request 取值</h3><p>上面构建的属性中，所有通过访问原生 <code>req</code> 或 <code>res</code> 的属性都能获取到，反之则是 <code>undefined</code>，这就需要我们去构建 <code>request.js</code>。</p><pre><code class="lang-js">/* 文件路径：~koa/request.js */
const url = require(&#39;url&#39;);

// 给 url 和 path 添加 getter
const request = {
  get url() {
    return this.req.url;
  },
  get path() {
    return url.parse(this.req.url).pathname;
  }
};

module.exports = request;
</code></pre><p>上面我们只构造了两个属性 <code>url</code> 和 <code>path</code>，我们知道 <code>url</code> 是原生所自带的属性，我们在使用 <code>ctx.request.url</code> 获取是通过 <code>request</code> 对象设置的 <code>getter</code>，将 <code>ctx.request.req.url</code> 的值返回了。</p><p><code>path</code> 是原生 <code>req</code> 所没有的属性，但却是通过原生 <code>req</code> 的 <code>url</code> 属性和 <code>url</code> 模块共同构建出来的，所以我们同样用了给 <code>request</code> 对象设置 <code>getter</code> 的方式获取 <code>req</code> 的 <code>url</code> 属性，并使用 <code>url</code> 模块将转换对象中的 <code>pathname</code> 返回，此时就可以通过 <code>ctx.request.path</code> 来获取访问路径，至于源码中我们没有处理的 <code>req</code> 属性都是通过这样的方式建立的引用关系。</p><h3 id="实现-response-的取值和赋值"><a href="#实现-response-的取值和赋值" class="headerlink" title="实现 response 的取值和赋值"></a>实现 response 的取值和赋值</h3><p><code>Koa</code> 中 <code>response</code> 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 <code>response</code> 获取的属性都是 <code>undefined</code>，我们这里先不管响应给浏览器的问题，首先要让 <code>response</code> 下的某个属性有值才行，下面我们来实现 <code>response.js</code>。</p><pre><code class="lang-js">/* 文件路径：~koa/response.js */
// 给 body 和 status 添加 getter 和 setter
const response = {
  get body() {
    return this._body;
  },
  set body(val) {
    // 只要给 body 赋值就代表响应成功
    this.status = 200;
    this._body = val;
  },
  get status() {
    return this.res.statusCode;
  },
  set status(val) {
    this.res.statusCode = val;
  }
};

module.exports = response;
</code></pre><p>这里选择了 <code>Koa</code> 在使用时，<code>response</code> 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 <code>request.js</code> 的方式给 <code>body</code> 和 <code>status</code> 设置了 <code>getter</code>，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 <code>setter</code>，对于 <code>status</code> 来说，直接操作原生 <code>res</code> 对象的 <code>statusCode</code> 属性即可，因为同为赋值操作。</p><p>还有一点，响应是通过给 <code>body</code> 赋值实现，我们认为只要触发了 <code>body</code> 的 <code>setter</code> 就成功响应，所以在 <code>body</code> 的 <code>getter</code> 中将响应状态码设置为 <code>200</code>，至于 <code>body</code> 赋值是如何实现响应的，放在后面再说。</p><h3 id="ctx-代理-request、response-的属性"><a href="#ctx-代理-request、response-的属性" class="headerlink" title="ctx 代理 request、response 的属性"></a>ctx 代理 request、response 的属性</h3><p>上面实现了通过 <code>request</code> 和 <code>response</code> 对属性的操作，<code>Koa</code> 虽然给我们提供了多样的属性操作方式，但由于我们程序员们都很 “懒”，几乎没有人会在开发的时候愿意增加获取某个属性值的路径长度，大部分情况都是通过 <code>ctx</code> 直接操作 <code>request</code> 和 <code>response</code> 上的属性，这就是我们现在的问题所在，这些属性通过 <code>ctx</code> 访问不到。</p><p>我们需要给 <code>ctx</code> 对象做一个代理，让 <code>ctx</code> 可以访问到 <code>request</code> 和 <code>response</code> 上的属性，这个场景何曾相识，不正是 <code>Vue2</code> 创建实例时，将传入参数对象 <code>options</code> 的 <code>data</code> 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 <code>context</code> 模块作为实例的 <code>context</code> 属性所继承的对象，而剩下的最后一个核心文件 <code>context.js</code> 正是用来做这件事的，代码如下。</p><pre><code class="lang-js">/* 文件路径：~koa/context.js */
const proto = {};

// 将传入对象属性代理给 ctx
function defineGetter(property, key) {
  proto.__defineGetter__(key, function () {
    return this[property][key];
  });
}

// 设置 ctx 值时直接操作传入对象的属性
function defineSetter(property, key) {
  proto.__defineSetter__(key, function (val) {
    this[property][key] = val;
  });
}

// 将 request 的 url 和 path 代理给 ctx
defineGetter(&#39;request&#39;, &#39;url&#39;);
defineGetter(&#39;request&#39;, &#39;path&#39;);

// 将 response 的 body 和 status 代理给 ctx
defineGetter(&#39;response&#39;, &#39;body&#39;);
defineSetter(&#39;response&#39;, &#39;body&#39;);
defineGetter(&#39;response&#39;, &#39;status&#39;);
defineSetter(&#39;response&#39;, &#39;status&#39;);

module.exports = proto;
</code></pre><p>在 <code>Vue</code> 中是使用 <code>Object.defineProperty</code> 来时实现的代理，而在 <code>Koa</code> 源码中借助了 <code>delegate</code> 第三方模块来实现的，并在添加代理时链式调用了 <code>delegate</code> 封装的方法，我们并没有直接使用 <code>delegate</code> 模块，而是将 <code>delegate</code> 内部的核心逻辑抽取出来在 <code>context.js</code> 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。</p><p>我们封装了两个方法 <code>defineGetter</code> 和 <code>defineSetter</code> 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__" target="_blank">Object.prototype.__defineGetter__</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__" target="_blank">Object.prototype.__defineSetter__</a> 实现的。</p><h2 id="洋葱模型-——-实现中间件的串行"><a href="#洋葱模型-——-实现中间件的串行" class="headerlink" title="洋葱模型 —— 实现中间件的串行"></a>洋葱模型 —— 实现中间件的串行</h2><blockquote class="pullquote info"><p><strong>现在已经实现了 <code>ctx</code> 上下文对象的创建，但是会发现我们封装 <code>ctx</code> 之前所写的案例 <code>use</code> 回调中的代码并不能执行，也不会报错，根本原因是 <code>use</code> 方法内传入的函数没有调用，在使用 <code>Koa</code> 的过程中会发现，我们往往使用多个 <code>use</code>，并且传入 <code>use</code> 的回调函数除了 <code>ctx</code> 还有第二个参数 <code>next</code>，而这个 <code>next</code> 也是一个函数，调用 <code>next</code> 则执行下一个 <code>use</code> 中的回调函数，否则就会 “卡住”，这种执行机制被称为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。</strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180902141819/onion-model.png" alt="洋葱模型执行过程"></div><div class="image-caption">洋葱模型执行过程</div></figure><p><br></p><h3 id="洋葱模型分析"><a href="#洋葱模型分析" class="headerlink" title="洋葱模型分析"></a>洋葱模型分析</h3><p>下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。</p><pre><code class="lang-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.use((ctx, next) =&gt; {
  console.log(1);
  next();
  console.log(2);
});

app.use((ctx, next) =&gt; {
  console.log(3);
  next();
  console.log(4);
});

app.use((ctx, next) =&gt; {
  console.log(5);
  next();
  console.log(6);
});

app.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>根据上面的执行特性我们不妨来分析以下，我们知道 <code>use</code> 方法执行时其实是把传入的回调函数放入了实例的 <code>middlewares</code> 数组中，而执行结果打印了 <code>1</code> 说明第一个回调函数被执行了，接着又打印了 <code>2</code> 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 <code>next</code> 肯定是一个函数，可能就是下一个回调函数，或者是 <code>next</code> 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 <code>next</code> 执行完毕，即出栈后，继续执行上一个回调函数的代码。</p><h3 id="支持异步的中间件串行"><a href="#支持异步的中间件串行" class="headerlink" title="支持异步的中间件串行"></a>支持异步的中间件串行</h3><p>在实现中间件串行之前需要补充一点，中间件函数内调用 <code>next</code> 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 <code>await</code> 进行等待（包括 <code>next</code>，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 <code>use</code> 的回调函数只要有异步代码需要 <code>await</code>，所以应该是 <code>async</code> 函数，而了解 <code>ES7</code> 特性 <code>async/await</code> 的我们来说，一定能分析出 <code>next</code> 返回的应该是一个 Promise 实例，下面是我们在之前 <code>application.js</code> 基础上的实现。</p><pre><code class="lang-js">/* 文件路径：~koa/application.js */
const http = require(&#39;http&#39;);
const context = require(&#39;./context&#39;);
const request = require(&#39;./request&#39;);
const response = require(&#39;./response&#39;);

class Koa {
  contructor() {
    // 存储中间件
    this.middlewares = [];

    // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
  }
  use(fn) {
    // 将传给 use 的函数存入数组中
    this.middlewares.push(fn);
  }
  createContext(req, res) {
    // 或取定义的上下文
    const ctx = this.context;

    // 增加 request 和 response
    ctx.request = this.request;
    ctx.response = this.response;

    // 让 ctx、request、response 都具有原生的 req 和 res
    ctx.req = ctx.request.req = ctx.response.req = req;
    ctx.res = ctx.response.res = ctx.request.res = res;

    // 返回上下文对象
    return ctx;
  }
// ************************** 以下为新增代码 **************************
  compose(ctx, middles) {
    // 创建一个递归函数，参数为存储中间件的索引，从 0 开始
    function dispatch(index) {
      // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）
      if (index === middles.length) return Promise.resolve();

      // 取出第 index 个中间件函数
      const route = middles[index];

      // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise
      return Promise.resolve(route(ctx, () =&gt; dispatch(++index)));
    }
    return dispatch(0); // 默认执行一次
  }
// ************************** 以上为新增代码 **************************
  handleRequest(req, res) {
    // 创建 ctx 上下文对象
    const ctx = this.createContext(req, res);

// ************************** 以下为新增代码 **************************
    // 执行 compose 将中间件组合在一起
    this.compose(ctx, this.middlewares);
// ************************** 以上为新增代码 **************************
  }
  listen(...args) {
    // 创建服务
    const server = http.createServer(this.handleRequest.bind(this));

    // 启动服务
    server.listen(...args);
  }
}

module.exports = Koa;
</code></pre><p>仔细想想我们其实在利用循环执行每一个 <code>middlewares</code> 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 <code>next</code> 传入，那么在上一个中间件函数内部调用 <code>next</code> 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 <code>next</code>，又先执行了下一个的下一个中间件函数，依次类推。</p><p>直到执行到最后一个中间件函数，调用了 <code>next</code>，但是 <code>middlewares</code> 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 <code>middlewares</code> 索引的变量等于了 <code>middlewares</code> 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 <code>return</code> 的函数，而并没有报错。</p><p>在这整个过程中如果有任意一个 <code>next</code> 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 <code>Koa</code> 中间件的执行规则，而 <code>await</code> 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 <code>next</code> 调用下面的代码，这也就是 <code>1、3、5、6、4、2</code> 的由来。</p><p>为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 <code>compose</code> 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 <code>compose</code> 创建 <code>dispatch</code> 递归函数，参数为当前数组函数的索引，初始值为 <code>0</code>，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 <code>dispatch</code>，参数 <code>+1</code>，这样就会将整个中间件串行起来了。</p><p>但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用的 <code>next</code> 函数必须返回一个 <code>Promise</code> 实例，有些中间件没有执行异步，则不需要 <code>async</code> 函数，也不会返回 <code>Promise</code>，而 <code>Koa</code> 规定只要遇到 <code>next</code> 就需要等待，则将取出每一个中间件函数执行后的结果使用 <code>Promise.resolve</code> 强行包装成一个成功态的 <code>Promise</code>，就对异步进行了兼容。</p><p>我们最后也希望 <code>compose</code> 返回一个 <code>Promise</code> 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 <code>return</code> 了的函数（包含一个中间件也没有的情况），此时 <code>compose</code> 返回了 <code>undefined</code>，无法调用 <code>then</code> 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 <code>return</code> 关键字后面加上了 <code>Promise.resolve()</code>，直接返回了一个成功态的 <code>Promise</code>。</p><blockquote class="pullquote warning"><p><strong>注意：官方只是推荐我们在调用 <code>next</code> 的时候使用 <code>await</code> 等待，即使执行的 <code>next</code> 真的存在异步，也不是非 <code>await</code> 不可，我们完全可以使用 <code>return</code> 来代替 <code>await</code>，唯一的区别就是 <code>next</code> 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，同一个中间件中，如果 <code>next</code> 后面不再有任何逻辑需要执行，就可以这样去做。</strong></p></blockquote><h2 id="实现真正的响应"><a href="#实现真正的响应" class="headerlink" title="实现真正的响应"></a>实现真正的响应</h2><p>在对 <code>ctx</code> 实现属性代理后，我们通过 <code>ctx.body</code> 重新赋值其实只是改变了 <code>response.js</code> 导出对象的 <code>_body</code> 属性，而并没有实现真正的响应，看下面这个 <code>Koa</code> 的例子。</p><pre><code class="lang-js">const Koa = require(&#39;koa&#39;);
const fs = require(&#39;fs&#39;);

const app = new Koa();

app.use(async (ctx, next) =&gt; {
  ctx.body = &#39;hello&#39;;
  await next();
});

app.use(async (ctx, next) =&gt; {
  ctx.body = fs.createReadStream(&#39;1.txt&#39;);

  ctx.body = await new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; resolve(&#39;panda&#39;), 3000);
  });
});

app.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>其实最后响应给客户端的值是 <code>panda</code>，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，<code>ctx.body</code> 最后的值应该是 <code>1.txt</code> 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，<code>compose</code> 在串行执行中间件后为什么要返回一个 <code>Promise</code> 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 <code>use</code> 传入的中间件函数执行完毕调用，也就是说在执行 <code>compose</code> 返回值的 <code>then</code> 时，<code>ctx.body</code> 的值已经是 <code>panda</code> 了。</p><pre><code class="lang-js">/* 文件路径：~koa/application.js */
const http = require(&#39;http&#39;);

// ************************** 以下为新增代码 **************************
const Stream = require(&#39;stream&#39;);
// ************************** 以上为新增代码 **************************

const context = require(&#39;./context&#39;);
const request = require(&#39;./request&#39;);
const response = require(&#39;./response&#39;);

class Koa {
  contructor() {
    // 存储中间件
    this.middlewares = [];

    // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
  }
  use(fn) {
    // 将传给 use 的函数存入数组中
    this.middlewares.push(fn);
  }
  createContext(req, res) {
    // 或取定义的上下文
    const ctx = this.context;

    // 增加 request 和 response
    ctx.request = this.request;
    ctx.response = this.response;

    // 让 ctx、request、response 都具有原生的 req 和 res
    ctx.req = ctx.request.req = ctx.response.req = req;
    ctx.res = ctx.response.res = ctx.request.res = res;

    // 返回上下文对象
    return ctx;
  }
  compose(ctx, middles) {
    // 创建一个递归函数，参数为存储中间件的索引，从 0 开始
    function dispatch(index) {
      // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）
      if (index === middles.length) return Promise.resolve();

      // 取出第 index 个中间件函数
      const route = middles[index];

      // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise
      return Promise.resolve(route(ctx, () =&gt; dispatch(++index)));
    }
    return dispatch(0); // 默认执行一次
  }
  handleRequest(req, res) {
    // 创建 ctx 上下文对象
    const ctx = this.createContext(req, res);

// ************************** 以下为修改代码 **************************
    // 设置默认状态码（Koa 规定默认状态码为 404），必须在调用中间件之前
    ctx.status = 404;

    // 执行 compose 将中间件组合在一起
    this.compose(ctx, this.middlewares).then(() =&gt; {
      // 获取最后 body 的值
      const body = ctx.body;

      // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器
      if (Buffer.isBuffer(body) || typeof body === &#39;string&#39;) {
        // 处理 Buffer 类型的数据
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);
        res.end(body);
      } else if (typeof body === &#39;object&#39;) {
        // 处理对象类型
        res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);
        res.end(JSON.stringify(body));
      } else if (body instanceof Stream) {
        // 处理流类型的数据
        body.pipe(res);
      } else {
        res.end(&#39;Not Found&#39;);
      }
    });
// ************************** 以上为修改代码 **************************
  }
  listen(...args) {
    // 创建服务
    const server = http.createServer(this.handleRequest.bind(this));

    // 启动服务
    server.listen(...args);
  }
}

module.exports = Koa;
</code></pre><p>处理 <code>response</code> 时，在 <code>body</code> 的 <code>setter</code> 中将状态码设置为了 <code>200</code>，就是说需要设置 <code>ctx.body</code> 去触发 <code>setter</code> 让响应成功，如果没有给 <code>ctx.body</code> 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 <code>404</code> 的明确说明，所以在 <code>handleRequest</code> 把状态码设置为了 <code>404</code>，但必须在 <code>compose</code> 执行之前才叫默认状态码，因为中间件中可能会操作 <code>ctx.body</code>，重新设置状态码。</p><p>在 <code>comose</code> 的 <code>then</code> 中，也就是在所有中间件执行后，我们取出 <code>ctx.body</code> 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 <code>Buffer</code>、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用原生 <code>res</code> 对象的 <code>end</code> 方法。</p><h2 id="中间件错误处理"><a href="#中间件错误处理" class="headerlink" title="中间件错误处理"></a>中间件错误处理</h2><p>在上面的逻辑当中我们实现了很多 <code>Koa</code> 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。</p><pre><code class="lang-js">const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.use((ctx, next) =&gt; {
  // 抛出异常
  throw new Error(&#39;Error&#39;);
});

// 添加 error 监听
app.on(&#39;error&#39;, err =&gt; {
  console.log(err);
});

app.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>我们之所以让 <code>compose</code> 方法在执行所有中间件后返回一个 <code>Promise</code> 还有一个更重要的意义，因为在 <code>Promise</code> 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 <code>then</code> 方法中错误的回调或者最后的 <code>catch</code> 方法，对于 <code>Koa</code> 中间件的串行而言，最后一个 <code>then</code> 调用 <code>catch</code> 方法就是 <code>compose</code> 的返回值调用 <code>then</code> 后继续调用的 <code>catch</code>，<code>catch</code> 内可以捕获到任意一个中间件执行时出现的错误。</p><pre><code class="lang-js">/* 文件路径：~koa/application.js */
const http = require(&#39;http&#39;);
const Stream = require(&#39;stream&#39;);

// ************************** 以下为新增代码 **************************
const EventEmitter = require(&#39;events&#39;);
const httpServer = require(&#39;_http_server&#39;);
// ************************** 以上为新增代码 **************************

const context = require(&#39;./context&#39;);
const request = require(&#39;./request&#39;);
const response = require(&#39;./response&#39;);

// ************************** 以下为修改代码 **************************
// 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听
class Koa extends EventEmitter {
  contructor() {
    supper();
// ************************** 以上为修改代码 **************************

    // 存储中间件
    this.middlewares = [];

    // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承
    this.context = Object.create(context);
    this.request = Object.create(request);
    this.response = Object.create(response);
  }
  use(fn) {
    // 将传给 use 的函数存入数组中
    this.middlewares.push(fn);
  }
  createContext(req, res) {
    // 或取定义的上下文
    const ctx = this.context;

    // 增加 request 和 response
    ctx.request = this.request;
    ctx.response = this.response;

    // 让 ctx、request、response 都具有原生的 req 和 res
    ctx.req = ctx.request.req = ctx.response.req = req;
    ctx.res = ctx.response.res = ctx.request.res = res;

    // 返回上下文对象
    return ctx;
  }
  compose(ctx, middles) {
    // 创建一个递归函数，参数为存储中间件的索引，从 0 开始
    function dispatch(index) {
      // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况）
      if (index === middles.length) return Promise.resolve();

      // 取出第 index 个中间件函数
      const route = middles[index];

      // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise
      return Promise.resolve(route(ctx, () =&gt; dispatch(++index)));
    }
    return dispatch(0); // 默认执行一次
  }
  handleRequest(req, res) {
    // 创建 ctx 上下文对象
    const ctx = this.createContext(req, res);

    // 设置默认状态码（Koa 规定默认状态码为 404），必须在调用中间件之前
    ctx.status = 404;

    // 执行 compose 将中间件组合在一起
    this.compose(ctx, this.middlewares).then(() =&gt; {
      // 获取最后 body 的值
      const body = ctx.body;

      // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器
      if (Buffer.isBuffer(body) || typeof body === &#39;string&#39;) {
        // 处理 Buffer 类型的数据
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);
        res.end(body);
      } else if (typeof body === &#39;object&#39;) {
        // 处理对象类型
        res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);
        res.end(JSON.stringify(body));
      } else if (body instanceof Stream) {
        // 处理流类型的数据
        body.pipe(res);
      } else {
        res.end(&#39;Not Found&#39;);
      }
// ************************** 以下为修改代码 **************************
    }).catch(err =&gt; {
      // 执行 error 事件
      this.emit(&#39;error&#39;, err);

      // 设置 500 状态码
      ctx.status = 500;

      // 返回状态码对应的信息响应浏览器
      res.end(httpServer.STATUS_CODES[ctx.status]);
    });
// ************************** 以上为修改代码 **************************
  }
  listen(...args) {
    // 创建服务
    const server = http.createServer(this.handleRequest.bind(this));

    // 启动服务
    server.listen(...args);
  }
}

module.exports = Koa;
</code></pre><p>在使用的案例当中，使用 <code>app</code>（即 <code>Koa</code> 创建的实例）监听了一个 <code>error</code> 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 <code>Node.js</code> 中一个重要的核心模块 <code>events</code>，这个模块帮我们提供了一个事件机制，通过 <code>on</code> 方法添加监听，通过 <code>emit</code> 触发监听，所以我们引入了 <code>events</code>，并让 <code>Koa</code> 类继承了 <code>events</code> 导入的 <code>EventEmitter</code> 类，此时 <code>Koa</code> 的实例就可以使用 <code>EventEmitter</code> 原型对象上的 <code>on</code> 和 <code>emit</code> 方法。</p><p>在 <code>compose</code> 执行后调用的 <code>catch</code> 中，通过实例调用了 <code>emit</code>，并传入了事件类型 <code>error</code> 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。</p><h2 id="让引入的-Koa-直接指向-application-js"><a href="#让引入的-Koa-直接指向-application-js" class="headerlink" title="让引入的 Koa 直接指向 application.js"></a>让引入的 Koa 直接指向 application.js</h2><p>在上面我们实现了 <code>Koa</code> 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 <code>Koa</code> 时，默认会查找 <code>koa</code> 路径下的 <code>index.js</code>，想要执行我们的 <code>Koa</code> 必须要使用路径找到 <code>application.js</code>，代码如下。</p><pre><code class="lang-js">/* 现在的引入方式 */
const Koa = require(&#39;./koa/application&#39;);
</code></pre><pre><code class="lang-js">/* 希望的引入方式 */
const Koa = require(&#39;./koa&#39;);
</code></pre><p>我们更希望像直接引入指定 <code>koa</code> 文件夹，就可以找到 <code>application.js</code> 文件并执行，这就需要我们在 <code>koa</code> 文件夹创建 <code>package.json</code> 文件，并在动一点小小的 “手脚” 如下。</p><pre><code class="lang-json">/* 文件路径：~koa/package.js */
{
  // ...
  &quot;main&quot;: &quot;./application.js&quot;,
  // ...
}
</code></pre><h2 id="Koa-原理图"><a href="#Koa-原理图" class="headerlink" title="Koa 原理图"></a>Koa 原理图</h2><p>在文章最后一节送给大家一张 <code>Koa</code> 执行的原理图，这张图片是准备写这篇文章时在 <code>Google</code> 上发现的，把 <code>Koa</code> 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 <code>Koa</code> 框架的原理和执行过程。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180902141819/koa-flow-chart.png" alt="Koa 原理图"></div><div class="image-caption">Koa 原理图</div></figure><p><br></p><p>之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 <code>Koa</code> 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 <code>Koa</code>，梳理 <code>Koa</code> 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>最后还是在这里做一个总结，在 <code>Koa</code> 中主要的部分有 <code>listen</code> 创建服务器、封装上下文对象 <code>ctx</code> 并代理属性、<code>use</code> 方法添加中间件、<code>compose</code> 串行执行中间、让 <code>Koa</code> 继承 <code>EventEmitter</code> 实现错误监听，而我个人觉得最重要的就是 <code>compose</code>，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 <code>compose</code> 已经不再只是一个方法名，而是函数式编程的一个重要的特性，用于将多个程序串行在一起，或同步，或异步，在 <code>Koa</code> 中自不必多说，因为大家已经见识过了，<code>compose</code> 在 <code>Redux</code> 中也起着串联中间件的作用，如串联<code>redux-saga</code>, <code>promise</code>、<code>redux-thunk</code>、<code>logger</code> 等中间件，在 <code>Webpack</code> 源码依赖的核心模块 <code>tapable</code> 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>async/await</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基础篇 —— React Hooks</title>
    <url>/20190507155411/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><strong><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</strong></p></blockquote><a id="more"></a><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code> 等），会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染，为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件（<code>HOC</code>）、属性渲染（<code>Render props</code>）、渲染回调（<code>Prop callback</code>）等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件。</p><blockquote class="pullquote success"><p><strong>推荐使用函数组件主要原因总结如下：</strong></p><ul><li><strong>为了状态相关逻辑的提取和复用；</strong></li><li><strong>解决复杂组件代码变得难以理解的问题；</strong></li><li><strong>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</strong></li><li><strong>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</strong></p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><blockquote class="pullquote danger"><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li><strong>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</strong></li><li><strong>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</strong></li></ul></blockquote><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（强制遵守），在此提前声明。</p><blockquote class="pullquote warning"><ul><li><strong>只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></li><li><strong>只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></li></ul></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><pre><code class="lang-jsx">/* 类组件实现的计数器 */
import React, { Components } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Components {
  constructor() {
    super();
    this.state = { count: 0 };
  }
  handleClick = () =&gt; {
    this.setState({ count: this.state.count + 1 })
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={this.handleClick}&gt;
          Click!
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><pre><code class="lang-jsx">/* Hooks 实现的计数器 */
import React, { useState } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Counter() {
  const [ count, setCount ] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click!
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><pre><code class="lang-jsx">/* 实现每次加 2 的计数器 */
import React, { useState } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Counter() {
  const [ count, setCount ] = useState(0);
  const countAction = (preCount, n) =&gt; preCount + n;

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(countAction(count, 2))}&gt;
        Click!
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><pre><code class="lang-jsx">/* 类组件实现的模态切换功能 */
import React, { Component, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import { Button, Modal } from &#39;antd&#39;;
import &#39;antd/dist/antd.css&#39;;

// Toggle 组件专门提供切换状态和切换方法
class Toggle extends Component {
  constructor(props) {
    super(props);

    // 初始化 on 的值
    this.state.on = this.props.initial;
  }
  state = { on: false }
  toggle = () =&gt; {
    this.setState({ on: !this.state.on });
  }
  render() {
    return this.props.children(this.state.on, this.toggle);
  }
}

function App() {
  return (
    &lt;Toggle initial={false}&gt;
      {
        (on, toggle) =&gt; (
          &lt;Fragment&gt;
            &lt;Button type=&quot;primary&quot; onClick={toggle}&gt;
              Open Model
            &lt;/Button&gt;
            &lt;Modal visible={on} onCancel={toggle} /&gt;
          &lt;/Fragment&gt;
        )
      }
    &lt;/Toggle&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><pre><code class="lang-jsx">/* useState 重构切换模态的功能 */
import React, { useState, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import { Button, Modal } from &#39;antd&#39;;
import &#39;antd/dist/antd.css&#39;;

function App() {
  const [ on, setOn ] = useState(false);

  return (
    &lt;Fragment&gt;
      &lt;Button type=&quot;primary&quot; onClick={() =&gt; setOn(true)}&gt;
        Open Model
      &lt;/Button&gt;
      &lt;Modal visible={on} onCancel={() =&gt; setOn(false)}/&gt;
    &lt;/Fragment&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新的粒度更细。</strong></p></blockquote><p><code>useState</code> 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。</p><pre><code class="lang-jsx">/* 当 useState 更新的状态依赖于上一次的值 */
import React, { useState } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Counter() {
  const [ count, setCount ] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt;
        Click!
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><pre><code class="lang-jsx">import React, { useState, useEffect } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function App() {
  const [ count, setCount ] = useState(0);

  // 每次渲染后执行
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  // 初次渲染后执行
  useEffect(() =&gt; {
    console.log(&#39;Execute once&#39;);
  }, []);

  // 当 count 更改时才执行
  useEffect(() =&gt; {
    console.log(&#39;count changed&#39;);
  }, [ count ]);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click!
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count)}&gt;
        Click no change!
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的生命周期 <code>componentDidMount</code>。</p><pre><code class="lang-jsx">import React, { useState, useEffect, Component, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 使用 Hooks 的函数组件
function HooksCom() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    document.title = `You clicked ${count} times (hooks)`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click!
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

// 类组件
class ClassCom extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 1 };
  }
  componentDidMount() {
    document.title = `You clicked ${this.state.count} times (class)`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times (class)`;
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({
          count: this.state.count + 1
        })}&gt;
          Click!
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

function App() {
  return (
    &lt;Fragment&gt;
      &lt;HooksCom /&gt;
      &lt;ClassCom /&gt;
    &lt;/Fragment&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><pre><code class="lang-jsx">import React, { useState, useEffect, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const ChatAPI = {
  handle: null,
  isOnline: false,
  login() {
    this.isOnline = true;
    this.handle &amp;&amp; this.handle({ isOnline: true });
  },
  logout() {
    this.isOnline = false;
    this.handle &amp;&amp; this.handle({ isOnline: false });
  },
  subscribeToFriendStatus(id, handle) {
    console.log(`订阅好友：${id}`);
    this.handle = handle;
  },
  unsubscribeToFriendStatus(id, handle) {
    console.log(`清理好友：${id}`);
    this.handle = null;
  }
};

// 用于渲染好友在线状态的函数组件
function FriendStatus(props) {
  // 控制好友在线的变量和方法
  const [ isOnline, setIsOnline ] = useState(null);

  // 设置好友状态的函数
  const handleStatusChange = (status) =&gt; setIsOnline(status.isOnline);

  useEffect(() =&gt; {
    // 订阅好友状态
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    return () =&gt; {
      // 清除好友状态
      ChatAPI.unsubscribeToFriendStatus(props.friend.id);
    }
  }, [ props.friend.id ]);

  if (isOnline === null) {
    return &#39;Loading...&#39;
  }

  return (
    &lt;div&gt;
      &lt;span&gt;计数器：{props.friend.count}&lt;/span&gt;
      &lt;br/&gt;
      &lt;span&gt;
        登录状态：
        {
          isOnline ? &#39;Online&#39; : &#39;Offline&#39;
        }
      &lt;/span&gt;
    &lt;/div&gt;
  )
}

function App() {
  const [ show, setShow ] = useState(true);
  const [ count, setCount ] = useState(0);
  const [ userId, setUserId ] = useState(1);

  return (
    &lt;div&gt;
      &lt;span&gt;用户ID：{userId}&lt;/span&gt;
      &lt;br/&gt;
      {
        show &amp;&amp; &lt;FriendStatus friend={{ id: userId, name: 'Hello' }}/&gt;
      }
      &lt;button onClick={() =&gt; setShow(!show)}&gt;显示/关闭&lt;/button&gt;
      &lt;button onClick={() =&gt; setUserId(userId + 1)}&gt;增加用户ID&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;增加计数器&lt;/button&gt;
      &lt;button onClick={ChatAPI.login.bind(ChatAPI)}&gt;登录&lt;/button&gt;
      &lt;button onClick={ChatAPI.logout.bind(ChatAPI)}&gt;退出&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p><blockquote class="pullquote default"><p><strong>如果在 <code>useEffect</code> 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</strong></p></blockquote><pre><code class="lang-jsx">/* 频繁更新未被监听的变量不变 */
import React, { useState, useEffect } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Counter() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; setCount(count + 1), 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><p>上面的案例是一个状态频繁变化的组件，但是我们给 <code>useEffect</code> 传入的第二个参数为空数组，这就会产生一个 <code>Bug</code>，由于 <code>useEffect</code> 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是初始的状态值，还记得上面一节 <code>useState</code> 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 <code>Bug</code>。</p><pre><code class="lang-jsx">/* 解决频繁更新未被监听变量不变的问题 */
import React, { useState, useEffect } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Counter() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; setCount(prev =&gt; prev + 1), 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}

ReactDOM.render(&lt;Counter /&gt;, root);
</code></pre><blockquote class="pullquote warning"><p><strong>所以说在有些时候，对于 <code>useEffect</code> 第二个参数传入 <code>[ ]</code> 的行为不是绝对安全的，并且不建议这样使用。</strong></p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，用来处理复杂的 <code>state</code> 更新，看到这个名字大家可能会想到 <code>Redux</code> 中的 <code>reducer</code>，其实 <code>useReducer</code> 就是 <code>React Hooks</code> 中用来替代 <code>Redux</code> 解决问题的，让我们从此不需要 <code>Redux</code>。</p><pre><code class="lang-jsx">import React, { useReducer, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 初始 state
const initalCountState = { count: 0 };

// reducer 函数
function reducer(state, action) {
  switch (action.type) {
    case &#39;reset&#39;:
      return { count: action.payload };
    case &#39;increment&#39;:
      return { count: state.count + 1 };
    case &#39;decrement&#39;:
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 默认初始 state 函数
function init(initalCountState) {
  return { count: initalCountState.count + 1 };
}

function Counter({ initalCount }) {
  const [ state, dispatch ] = useReducer(reducer, initalCountState, init);

  return (
    &lt;Fragment&gt;
      count: { state.count }
      &lt;button onClick={() =&gt; dispatch({
        type: &#39;reset&#39;,
        payload: initalCount
      })}&gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
    &lt;/Fragment&gt;
  )
}

function App() {
  return &lt;Counter initalCount={0} /&gt;
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><blockquote class="pullquote primary"><p><strong><code>useReducer</code> 有三个参数：</strong></p><ul><li><strong>第一个参数为 <code>reducer</code> 函数（根据 <code>action</code> 的类型匹配新的 <code>state</code> 值）；</strong></li><li><strong>第二个参数为监听状态对象 <code>state</code> 的初始值；</strong></li><li><strong>第三个参数是一个函数，参数为初始的 <code>state</code>，作用是输出一个新的 <code>state</code> 替换初始的 <code>state</code>，只在最初执行一次。</strong></li></ul><p><strong><code>useReducer</code> 的返回值为数组：</strong></p><ul><li><strong>数组第一项是监听的 <code>state</code> 对象；</strong></li><li><strong>数组第二项是用来触发 <code>state</code> 更新的函数，参数为 <code>action</code>。</strong></li></ul></blockquote><pre><code class="lang-jsx">/* useReducer 不传第三个参数 */
import React, { useReducer, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function reducer(state, action) {
  switch (action.type) {
    case &#39;reset&#39;:
      return { count: action.payload };
    case &#39;increment&#39;:
      return { count: state.count + 1 };
    case &#39;decrement&#39;:
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter({ initalCount }) {
  const [ state, dispatch ] = useReducer(reducer, initalCount);

  return (
    &lt;Fragment&gt;
      count: { state.count }
      &lt;button onClick={() =&gt; dispatch({
        type: &#39;reset&#39;,
        payload: initalCount.count
      })}&gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
    &lt;/Fragment&gt;
  )
}

function App() {
  return &lt;Counter initalCount={{ count: 0 }} /&gt;
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>这个案例跟之前的稍有差别，去掉了 <code>useReducer</code> 的第三个参数，并将 <code>Counter</code> 组件的入参 <code>initalCount</code> 作为了初始 <code>state</code>。</p><blockquote class="pullquote success"><p><strong>使用 <code>React</code> 进行过项目开发应该都是用过 <code>Redux</code> 和 <code>Mobx</code> 之类的状态管理工具，但其实他们并不是专门针对 <code>React</code> 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 <code>React</code> 搭配使用时更舒适，而 <code>React hooks</code> 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 <code>Facebook</code> 挖来了 <code>Redux</code> 的作者开发了 <code>React hooks</code> 中状态管理相关的 <code>API</code>。</strong></p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>想了解 <code>useContext</code> 首先要了解 <code>context API</code>，即 <code>React.createContext</code> 方法，执行后返回一个对象，其中包含两个属性分别为 <code>Provider</code> 和 <code>Consumer</code>，都为组件，<code>Provider</code> 用于包裹提供状态的容器组件，<code>Consumer</code> 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 <a href="https://react.docschina.org/docs/context.html" target="_blank">React 官方文档</a>。</p><pre><code class="lang-jsx">import React, { useState, useContext } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const myContext = React.createContext();

// 子组件
function Com() {
  const { count, setCount } = useContext(myContext);

  return (
    &lt;div&gt;
      子组件：{count}
      &lt;br /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 父组件
function App() {
  const [ count, setCount ] = useState(0);

  return (
    &lt;myContext.Provider value={{ count, setCount }}&gt;
      父组件：{count}
      &lt;br /&gt;
      &lt;Com /&gt;
    &lt;/myContext.Provider&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面是 <code>useContext</code> 的一个简单用法，我们创建了 <code>context</code>，在父组件 <code>App</code> 中创建了 <code>count</code> 和更改 <code>count</code> 的函数 <code>setCount</code>，并将它们通过 <code>context</code> 的 <code>Provider</code> 组件提供给子组件 <code>Com</code>，子组件中调用 <code>useContext</code> 并传入这个创建的 <code>context</code> 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 <code>count</code> 都发生了变化。</p><p>上面说 <code>React hooks</code> 中提供了自己的状态管理解决方案，也就是说可以替代 <code>Redux</code> 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 <code>useContext</code> 和 <code>useReducer</code> 来实现一个简单的状态管理逻辑。</p><pre><code class="lang-jsx">/* reducer.js */
import React, { useReducer } from &#39;react&#39;;

// 初始状态（默认值）
const initalState = { count: 0 };

// 导出共用的上下文
export const myContext = React.createContext();

// 导出 reducer 函数
export function reducer(state, action) {
  switch (action.type) {
    case &#39;reset&#39;:
      return initalState;
    case &#39;increment&#39;:
      return { count: state.count + 1 };
    case &#39;decrement&#39;:
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 导出提供状态的函数组件
export const ContextProvider = props =&gt; {
  const [ state, dispatch ] = useReducer(reducer, initalState);

  return (
    &lt;myContext.Provider value={{ state, dispatch }}&gt;
      {props.children}
    &lt;/myContext.Provider&gt;
  )
}
</code></pre><p>上面的 <code>reducer.js</code> 文件用来提供整个状态管理的核心逻辑，创建了初始的 <code>state</code>，创建了共用的上下文对象，创建了 <code>reducer</code> 函数（通过 <code>action</code> 来匹配并返回新的 <code>state</code>），创建了用来提供 <code>state</code> 和 <code>dispatch</code> 的公共组件 <code>ContextProvider</code>，该组件内部通过创建上下文的 <code>Provider</code> 组件给该组件中间包裹的所有子组件 <code>children</code> 通过 <code>value</code> 提供 <code>state</code> 和 <code>dispatch</code>（通过 <code>useReducer</code> 创建）。</p><pre><code class="lang-jsx">/* App.js */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import { ContextProvider } from &#39;./reducer&#39;;
import Counter from &#39;./Counter&#39;;

function App() {
  return (
    &lt;div&gt;
      &lt;ContextProvider&gt;
        &lt;Counter /&gt;
      &lt;/ContextProvider&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p><code>App</code> 组件，是提供状态的容器（一般使用根组件），根据 <code>reducer.js</code> 的用法，只需要引入 <code>ContextProvider</code> 组件包裹需要使用状态的子组件，与 <code>react-redux</code> 的 <code>Provider</code> 组件提供 <code>store</code> 的模式相似，这样被 <code>ContextProvider</code> 组件包裹的子组件就可以使用 <code>reducer.js</code> 中所 <code>useReducer</code> 所提供的 <code>state</code> 和 <code>dispatch</code>，<code>Counter</code> 子组件代码如下。</p><pre><code class="lang-jsx">import React, { useContext } from &#39;react&#39;;
import { myContext } from &#39;./reducer&#39;;

function Counter() {
  const { state, dispatch } = useContext(myContext);

  return (
    &lt;div&gt;
      Counter count: {state.count}
      &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39; })}&gt;Reset&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Counter;
</code></pre><p>在使用 <code>reducer.js</code> 中实现的状态管理逻辑的组件中，只需要引入 <code>reducer.js</code> 提供的 <code>context</code>，并使用 <code>useContext</code> 就可以解构出 <code>state</code> 和 <code>dispatch</code>，并通过 <code>action</code> 实现三种不同的对状态的 <code>state</code> 的操作。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是 <code>React</code> 针对函数组件的优化考虑所设计的 <code>Hook API</code>，在函数被渲染时，<code>React</code> 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 <code>React Hooks</code> 以后，函数组件中需要的函数可以通过 <code>useCallback</code> 创建。</p><pre><code class="lang-jsx">import React, { useCallback, Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 用来存储 useCallback 返回的函数
let fn = null;

// 使用 useCallback 的函数组件
function TestUseCallback({ nums, name }) {
  const memoizedCallback = useCallback(() =&gt; {
    console.log(nums, &#39;Hello world!&#39;);
  }, [ nums ]);

  console.log(&#39;callback 是否相同：&#39;, Object.is(fn, memoizedCallback));
  console.log(&#39;nums &gt; &#39;, nums, &#39;name &gt; &#39;, name);
  fn = memoizedCallback;

  return (
    &lt;div&gt;
      &lt;button onClick={memoizedCallback}&gt;TestUseCallback&lt;/button&gt;
    &lt;/div&gt;
  )
}

// 用来触发重新 render 的类组件
class App extends Component {
  state = {
    nums: [1, 2, 3],
    count: 0,
    name: &#39;hello&#39;
  };

  componentDidMount() {
    setInterval(() =&gt; {
      this.setState((state) =&gt; ({ count: state.count + 1 }));
    }, 3000);
  }

  handleChangeNum = () =&gt; this.setState({ nums: [4, 5, 6], name: &#39;world&#39; });

  render() {
    const { nums, name } = this.state;

    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;
        &lt;button onClick={this.handleChangeNum}&gt;修改传入的 nums 值&lt;/button&gt;
        &lt;TestUseCallback nums={nums} name={name} /&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>在上面的案例中渲染的组件 <code>App</code> 是一个类组件，该组件在挂载后会创建一个定时器，每 <code>3s</code> 更新 <code>state</code> 的 <code>count</code> 值，来完成重渲染，内部的 <code>TestUseCallback</code> 组件也会跟着重渲染，在内部检测 <code>useCallback</code> 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 <code>useCallback</code> 是否会新创建返回的值。</p><blockquote class="pullquote info"><p><strong>执行 <code>useCallback</code> 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，<code>React</code> 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 <code>GC</code> 的压力。</strong></p></blockquote><pre><code class="lang-jsx">/* 组件中不同方式事件处理函数的区别 */
class Com1 extends Component {
  handleClick() {
    console.log(&#39;click happened&#39;);
  }
  render() {
    return &lt;button onClick={() =&gt; this.handleClick()}&gt;Click me&lt;/button&gt;
  }
}

class Com2 extends Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    console.log(&#39;click happened&#39;);
  }
  render() {
    return &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt;
  }
}

function Com3() {
  const handleClick = () =&gt; {
    console.log(&#39;click happened&#39;);
  }
  return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
}

function Com4() {
  const memoizedHandleClick = useCallback(() =&gt; {
    console.log(&#39;click happened&#39;);
  }, []);

  return &lt;button onClick={memoizedHandleClick}&gt;Click me&lt;/button&gt;
}
</code></pre><blockquote class="pullquote warning"><ul><li><strong><code>Com1</code>：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；</strong></li><li><strong><code>Com2</code>：类组件，在 <code>constructor</code> 中使用 <code>bind</code> 绑定 <code>this</code>，每次重新渲染都使用同一个函数；</strong></li><li><strong><code>Com3</code>：函数组件，直接创建函数，每次重新渲染都产生新的函数；</strong></li><li><strong><code>Com4</code>：函数组件，使用 <code>useCallback</code> 创建函数，每次重新渲染都使用同一个函数；</strong></li></ul></blockquote><pre><code class="lang-jsx">import React, { useState, useCallback } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const Child = React.memo(({ a, memo }) =&gt; {
  return (
    &lt;div&gt;
      {console.log(&#39;Child 渲染&#39;)}
      &lt;span&gt;a: {a}&lt;/span&gt;
      &lt;button onClick={memo}&gt;Click in child&lt;/button&gt;
    &lt;/div&gt;
  )
});

const App = props =&gt; {
  const [ a, setA ] = useState(0);
  const [ b, setB ] = useState(0);

  // 直接创建的函数
  // const handleClick = () =&gt; console.log(&#39;click&#39;);

  // 使用 useCallback 创建的函数
  const handleClick = useCallback(() =&gt; console.log(&#39;click&#39;), []);

  return (
    &lt;div&gt;
      {console.log(&#39;App 渲染&#39;)}
      &lt;Child a={a} memo={handleClick} /&gt;
      &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt;
      &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt;
      &lt;button onClick={handleClick}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面案例中使用了 <code>React.memo</code> 的函数组件优化方法来进一步验证了 <code>useCallback</code> 的作用，方法 <code>React.memo</code> 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 <code>props</code> 不发生变化时，则不会重新渲染。</p><p>父组件 <code>App</code> 中使用 <code>useCallback</code> 创建的函数和使用 <code>useState</code> 创建的状态 <code>a</code> 作为参数传递给子组件 <code>Child</code>，并通过点击事件改变 <code>a</code> 和 <code>b</code> 的状态，初次渲染时控制台打印 <code>App 渲染</code> 和 <code>Child 渲染</code>，当点击 <code>改变 a</code> 时，父、子组件同时渲染，是因为子组件 <code>props</code> 中的 <code>a</code> 发生变化，当点击 <code>改变 b</code> 时，父组件重新渲染，但是子组件并没有，说明 <code>useCallback</code> 并没有产生新的函数传递给子组件，当使用 <code>App</code> 组件注释中直接创建的函数时，则点击 <code>改变 b</code>，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。</p><pre><code class="lang-jsx">import React, { useState, useCallback } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 存储两个组件的函数
let fun1 = null;
let fun2 = null;

// 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时）
const ExpensiveCom = React.memo(({ onClick }) =&gt; {
  const date = new Date();
  return (
    &lt;h1 onClick={onClick}&gt;
      {console.log(&#39;昂贵组件渲染了！&#39;)}
      {date.getSeconds()}
      我是一个昂贵的组件！渲染耗时！
    &lt;/h1&gt;
  )
});

function Com1({ p1 }) {
  const fn = () =&gt; console.log(&#39;fn&#39;, p1);
  console.log(&#39;Com1&#39;, Object.is(fun1, fn));
  fun1 = fn;
  return (
    &lt;ExpensiveCom onClick={fn} /&gt;
  )
}

function Com2({ p2 }) {
  const fn = useCallback(() =&gt; console.log(&#39;fn&#39;, p2), [ p2 ]);
  console.log(&#39;Com2&#39;, Object.is(fun2, fn));
  fun2 = fn;
  return (
    &lt;ExpensiveCom onClick={fn} /&gt;
  )
}

function App() {
  const [ p1, setP1 ] = useState(0);
  const [ p2, setP2 ] = useState(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt;
      &lt;Com1 p1={p1} /&gt;
      &lt;button onClick={() =&gt; setP1({ p1: p1 + 1 })}&gt;p1 + 1&lt;/button&gt;
      &lt;br/&gt;
      &lt;h2&gt;不用重复生成 fn&lt;/h2&gt;
      &lt;Com2 p2={p2} /&gt;
      &lt;button onClick={() =&gt; setP2({ p2: p2 + 1 })}&gt;p2 + 1&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面例子中假设 <code>ExpensiveCom</code> 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 <code>Com1</code> 和 <code>Com2</code> 中对比，<code>ExpensiveCom</code> 参数是在父组件 <code>Com1</code> 和 <code>Com2</code> 中创建的函数，前者直接创建，后者使用 <code>useCallback</code> 创建，在 <code>App</code> 组件中渲染 <code>Com1</code> 和 <code>Com2</code>，分别传入状态 <code>p1</code> 和 <code>p2</code>，并在 <code>Com1</code> 和 <code>Com2</code> 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。</p><p>当在页面点击 <code>p1 + 1</code> 或 <code>p2 + 1</code> 时，都会导致 <code>App</code> 的状态变化，也就是 <code>App</code> 的重渲染，而作为 <code>App</code> 的子组件, <code>Com1</code> 和 <code>Com2</code>，也会跟着重新渲染，点击 <code>p1 + 1</code>，从控制台打印结果看，只有 <code>Com1</code> 内部的 “昂贵” 组件重新渲染，而 <code>Com2</code> 中并没有，是因为 <code>useCallback</code> 中依赖的 <code>p2</code> 没有改变，没有生成新的函数，当点击 <code>p2 + 1</code> 时，<code>Com2</code> 内部的 “昂贵” 组件重新渲染，同时 <code>Com1</code> 内部的 “昂贵” 组件也重新渲染，由此可以看出 <code>Com2</code> 的性能是要优于 <code>Com1</code> 的。</p><blockquote class="pullquote default"><p><strong>在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 <code>useCallback</code> 对函数组件进行优化是非常有必要的。</strong></p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是第一个参数传入函数执行后的返回结果，在函数组件渲染时，其中的 <code>useMemo</code> 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。</p><pre><code class="lang-jsx">import React, { useState, useMemo } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 存储 useMemo 的返回结果
let ch = null;

// 用于观察是否重渲染的组件
const Com = ({ val }) =&gt; {
  console.log(&#39;Com 重新渲染了&#39;);
  return &lt;h2&gt;{val}&lt;/h2&gt;
}

// 父组件
function Parent({ a, b }) {
  const child1 = useMemo(() =&gt; (
    &lt;div&gt;
      {console.log(&#39;child1 重新计算&#39;)}
      &lt;Com val={b} /&gt;
    &lt;/div&gt;
  ), [ a ]);

  console.log(&#39;child1 是否和之前相等&#39;, child1 === ch);
  ch = child1;

  const child2 = (
    &lt;div&gt;
      {console.log(&#39;child2 重新计算&#39;)}
      &lt;Com val={b} /&gt;
    &lt;/div&gt;
  )

  return (
    &lt;div&gt;
      {child1}
      {child2}
    &lt;/div&gt;
  )
}

// 提供状态的容器组件
const App = props =&gt; {
  const [ a, setA ] = useState(0);
  const [ b, setB ] = useState(0);

  return (
    &lt;div&gt;
      &lt;Parent a={a} b={b} /&gt;
      &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt;
      &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面例子中 <code>App</code> 组件提供状态 <code>a</code> 和 <code>b</code> 作为参数提供给 <code>Parent</code> 组件，<code>App</code> 中可以通过 <code>改变 a</code> 和 <code>改变 b</code> 按钮更新状态 <code>a</code> 和 <code>b</code>，当 <code>a</code> 和 <code>b</code> 发生变化时导致 <code>Parent</code> 组件重新渲染，内部的 <code>child1</code> 和 <code>child2</code> 分别是通过 <code>useMemo</code> 和直接创建的组件，其中分别渲染 <code>Com</code> 组件，默认情况下 <code>child1</code> 和 <code>child2</code> 都会渲染，点击 <code>改变 a</code>，<code>child1</code> 和 <code>child2</code> 重新渲染，因为 <code>child1</code> 的依赖 <code>a</code> 发生变化，点击 <code>改变 b</code>，发现只有 <code>child2</code> 重新渲染，而再此点击 <code>改变 a</code>，由于都重新渲染导致 <code>child1</code> 和 <code>child2</code> 渲染的值同步了。</p><blockquote class="pullquote primary"><p><strong><code>useMemo</code> 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 <code>useMemo</code> 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 <code>useEffect</code> 的范畴，而不是 <code>useMemo</code>。</strong></p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在 <code>React</code> 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 <code>onChange</code> 事件和 <code>state</code> 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 <code>ref</code> 属性获取 <code>Dom</code> 的引用，进而对表单进行操作，在 <code>React 16.3</code> 以后推荐使用 <code>React.createRef</code> 方法创建。</p><p>类组件中使用 <code>ref</code> 通常是将引用关联到类组件的实例属性上，方便操作，而 <code>useRef</code> 就是为了在函数组件中实现这个功能而存在的。</p><pre><code class="lang-jsx">import React, { useState, useRef, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function TextInputWithFocusButton() {
  const inputEl = useRef();
  const onButtonClick = () =&gt; {
    inputEl.current.focus();
  }

  return (
    &lt;Fragment&gt;
      &lt;input ref={inputEl} type=&quot;text&quot; /&gt;
      &lt;button onClick={onButtonClick}&gt;获取焦点&lt;/button&gt;
    &lt;/Fragment&gt;
  )
}

const App = props =&gt; {
  const [ count, setCount ] = useState(0);

  return (
    &lt;div&gt;
      {count}
      &lt;TextInputWithFocusButton /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><blockquote class="pullquote success"><p><strong>在函数组件中同样可以 <code>React.createRef</code> 来实现，但是函数组件的每一次重新渲染都会导致 <code>ref</code> 对象的重新创建，浪费内存和性能，<code>useRef</code> 的参数为创建 <code>ref</code> 对象 <code>current</code> 属性的初始值，<code>ref</code> 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。</strong></p></blockquote><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在介绍 <code>useImperativeHandle</code> 之前一定要清楚 <code>React</code> 关于 <code>ref</code> 转发（也叫透传）的知识点，是使用 <code>React.forwardRef</code> 方法实现的，该方法返回一个组件，参数为函数（<code>Prop callback</code>，并不是函数组件），函数的第一个参数为父组件传递的 <code>props</code>，第二给参数为父组件传递的 <code>ref</code>，其目的就是希望可以在封装组件时，外层组件可以通过 <code>ref</code> 直接控制内层组件或元素的行为。</p><pre><code class="lang-jsx">/* 一个关于 ref 转发的例子 */
import React, { useCallback, useRef } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 实现 ref 的转发
const FancyButton = React.forwardRef((props, ref) =&gt; (
  &lt;div&gt;
    &lt;input ref={ref} type=&quot;text&quot; /&gt;
    &lt;button&gt;{props.children}&lt;/button&gt;
  &lt;/div&gt;
));

// 父组件中使用子组件的 ref
function App() {
  const ref = useRef();
  const handleClick = useCallback(() =&gt; ref.current.focus(), [ ref ]);

  return (
    &lt;div&gt;
      &lt;FancyButton ref={ref}&gt;Click Me&lt;/FancyButton&gt;
      &lt;button onClick={handleClick}&gt;获取焦点&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面例子中创建了一个 <code>FancyButton</code> 组件，内部渲染了一个 <code>button</code> 元素，我们希望在父元素 <code>App</code> 中渲染 <code>FancyButton</code>，并通过传递给 <code>FancyButton</code> 的 <code>ref</code> 直接操作内部的 <code>button</code>。</p><pre><code class="lang-jsx">/* 一个官方的 useImperativeHandle 例子 */
import React, { useRef, useImperativeHandle } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const FancyInput = React.forwardRef((props, ref) =&gt; {
  const inputRef = useRef();
  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; {
      inputRef.current.focus();
    }
  }));

  return &lt;input ref={inputRef} type=&quot;text&quot; /&gt;
});

const App = (props) =&gt; {
  const fancyInputRef = useRef();

  return (
    &lt;div&gt;
      &lt;FancyInput ref={fancyInputRef} /&gt;
      &lt;button onClick={() =&gt; fancyInputRef.current.focus()}&gt;
        父组件调用子组件的 focus
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面这个例子中与直接转发 <code>ref</code> 不同，直接转发 <code>ref</code> 是将 <code>React.forwardRef</code> 中函数上的 <code>ref</code> 参数直接应用在了返回元素的 <code>ref</code> 属性上，其实父、子组件引用的是同一个 <code>ref</code> 的 <code>current</code> 对象，官方不建议使用这样的 <code>ref</code> 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 <code>ref</code>，通过 <code>React.forwardRef</code> 将父组件的 <code>ref</code> 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 <code>current</code>。</p><p><code>useImperativeHandle</code> 的第一个参数是定义 <code>current</code> 对象的 <code>ref</code>，第二个参数是一个函数，返回值是一个对象，即这个 <code>ref</code> 的 <code>current</code> 对象，这样可以像上面的案例一样，通过自定义父组件的 <code>ref</code> 来使用子组件 <code>ref</code> 的某些方法，进而将子组件的 <code>ref</code> 保护起来，符合开放封闭原则。</p><blockquote class="pullquote warning"><p><strong><code>useImperativeHandle</code> 和 <code>React.forwardRef</code> 是需要配合使用的，这也是为什么在开头要介绍 <code>ref</code> 的转发。</strong></p></blockquote><pre><code class="lang-jsx">import React, { useState, useRef, useImperativeHandle, useCallback } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const FancyInput = React.forwardRef((props, ref) =&gt; {
  const [ fresh, setFresh ] = useState(false)
  const attRef = useRef(0);
  useImperativeHandle(ref, () =&gt; ({
    attRef,
    fresh
  }), [ fresh ]);

  const handleClick = useCallback(() =&gt; {
    attRef.current++;
  }, []);

  return (
    &lt;div&gt;
      {attRef.current}
      &lt;button onClick={handleClick}&gt;Fancy&lt;/button&gt;
      &lt;button onClick={() =&gt; setFresh(!fresh)}&gt;刷新&lt;/button&gt;
    &lt;/div&gt;
  )
});

const App = props =&gt; {
  const fancyInputRef = useRef();

  return (
    &lt;div&gt;
      &lt;FancyInput ref={fancyInputRef} /&gt;
      &lt;button onClick={() =&gt; console.log(fancyInputRef.current)}&gt;
        父组件访问子组件的实例属性
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面的案例相对于官方的例子意图更明显一些，通过 <code>useImperativeHandle</code> 将子组件的实例属性输出到父组件，而子组件内部通过 <code>ref</code> 更改 <code>current</code> 对象后，组件不会重新渲染，需要改变 <code>useState</code> 设置的状态才能更改。</p><blockquote class="pullquote info"><p><strong><code>useImperativeHandle</code> 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件 <code>ref</code> 的 <code>current</code> 属性上，如果为空数组，则不会重新输出。</strong></p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 的使用方法和 <code>useEffect</code> 相同，唯一的区别就是执行时机不一样。</p><pre><code class="lang-jsx">/* 对比 useLayoutEffect 与 useEffect 的执行时机 */
import React, { useState, useEffect, useLayoutEffect } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Com() {
  useEffect(() =&gt; {
    console.log(&#39;useEffect 执行...&#39;);
    return () =&gt; {
      console.log(&#39;useEffect 销毁...&#39;);
    }
  });

  useLayoutEffect(() =&gt; {
    console.log(&#39;useLayoutEffect 执行...&#39;);
    return () =&gt; {
      console.log(&#39;useLayoutEffect 销毁...&#39;);
    }
  });

  return (
    &lt;div&gt;
      {console.log(&#39;Com 渲染&#39;)}
      &lt;h2&gt;Com1&lt;/h2&gt;
    &lt;/div&gt;
  )
}

const App = props =&gt; {
  const [ count, setCount ] = useState(0)
  return (
    &lt;div&gt;
      &lt;Com /&gt;
      {count}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面的例子中在 <code>Com</code> 组件中同时使用了 <code>useLayoutEffect</code> 和 <code>useEffect</code>，在页面初次渲染时可以看到控制台打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 执行...</code>。</p><p>当点击 <code>App</code> 组件按钮更新状态导致 <code>Com</code> 重新渲染，打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><p>在刚接触 <code>React Hooks</code> 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 <code>useLayoutEffect</code>、<code>useEffect</code> 与类组件生命周期配合使用的例子。</p><pre><code class="lang-jsx">/* 对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机 */
import React, { useEffect, useLayoutEffect, Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 使用 useLayoutEffect 和 useEffect 的函数组件
function Com() {
  useEffect(() =&gt; {
    console.log(&#39;useEffect 执行...&#39;);
    return () =&gt; {
      console.log(&#39;useEffect 销毁...&#39;);
    }
  });

  useLayoutEffect(() =&gt; {
    console.log(&#39;useLayoutEffect 执行...&#39;);
    return () =&gt; {
      console.log(&#39;useLayoutEffect 销毁...&#39;);
    }
  });

  return (
    &lt;div&gt;
      {console.log(&#39;Com 渲染&#39;)}
      &lt;h2&gt;Com1&lt;/h2&gt;
    &lt;/div&gt;
  )
}

// 使用生命周期的类组件
class App extends Component {
  state = { count: 0 }

  setCount = () =&gt; {
    this.setState({ count: this.state.count + 1 });
  }

  componentDidMount() {
    console.log(&#39;App componentDidMount&#39;);
  }

  componentDidUpdate() {
    console.log(&#39;App componentDidUpdate&#39;);
  }

  render() {
    return (
      &lt;div&gt;
        {this.state.count}
        &lt;Com /&gt;
        {console.log(&#39;App 渲染&#39;)}
        &lt;button onClick={this.setCount}&gt;count + 1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面例子中 <code>useLayoutEffect</code> 和 <code>useEffect</code> 依然在 <code>Com</code> 组件中使用，<code>App</code> 组件为类组件，<code>Com</code> 作为 <code>App</code> 的子组件，在首次渲染时控制台的打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidMount</code> → <code>useEffect 执行...</code>。</p><p>而点击按钮更改状态触发重渲染时，打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidUpdate</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><blockquote class="pullquote default"><p><strong><code>useLayoutEffect</code> 的执行时机要早于 <code>useEffect</code>，<code>useLayoutEffect</code> 的执行在类组件生命周期前，<code>useEffect</code> 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 <code>useEffect</code>，以避免阻塞视觉更新，如果是将代码从类组件重构为 <code>React Hooks</code>，并且使用 <code>useEffect</code> 出现问题，再考虑使用 <code>useLayoutEffect</code>，服务端渲染时使用 <code>useLayoutEffect</code> 会触发警告。</strong></p></blockquote><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 用于在 <code>React</code> 开发者工具（如果已安装，在浏览器控制台 <code>React</code> 选项查看）中显示 <a href="/20190507155411/#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook" target="_blank">自定义 Hook</a> 的标签。</p><pre><code class="lang-jsx">import React, { useState, useDebugValue } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 自定义 Hook
function useMyCount(num) {
  const [ count, setCount ] = useState(0);

  // 调试自定义 Hook，显示在 devtools 上
  useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;);

  const myCount = () =&gt; {
    setCount(count + 2);
  }

  return [ count, myCount ];
}

function App() {
  const [ count, setCount ] = useMyCount(10);

  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面例子中创建了 <code>useMyCount</code> 自定义 <code>Hook</code>，在内部使用 <code>useDebugValue</code> 对 <code>count</code> 的状态进行了调试，在开发工具中显示如下图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20190507155411/usedebugvalue.png" alt="useDebugValue 调试效果图"></div><div class="image-caption">useDebugValue 调试效果图</div></figure><p><br></p><p><code>useDebugValue</code> 还支持第二个参数，类型为函数，函数的默认参数为 <code>debug</code> 的状态，作用是对 <code>debug</code> 的值进行格式化，官方叫做 “延迟格式化”。</p><pre><code class="lang-jsx">/* 延迟格式化 */
import React, { useState, useDebugValue } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 自定义 Hook
function useMyCount(num) {
  const [ count, setCount ] = useState(0);

  // 延迟格式化
  useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;, (status) =&gt; {
    return status === &#39;溢出&#39; ? 1 : 0;
  });

  const myCount = () =&gt; {
    setCount(count + 2);
  }

  return [ count, myCount ];
}

function App() {
  const [ count, setCount ] = useMyCount(10);

  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt;
    &lt;/div&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面的例子只是做了小小的改动，增加了一个格式化函数作为 <code>useDebugValue</code> 的第二个参数，当状态为 <code>不足</code> 时显示 <code>0</code>，为 <code>溢出</code> 时显示 <code>1</code>。</p><blockquote class="pullquote info"><p><strong>提示：我们不推荐你向每个自定义 <code>Hook</code> 使用 <code>useDebugValue</code>，只有自定义 <code>Hook</code> 被复用时才最有意义。</strong></p></blockquote><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>在开篇介绍 <code>React Hooks</code> 产生的动机时，提到了在类组件中使用 “高阶组件”（<code>HOC</code>）和 “渲染回调”（<code>Prop callback</code>）的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 <code>React 16.8</code> 以后可以通过自定义 <code>Hook</code> 来解决这些问题。</p><pre><code class="lang-jsx">/* 一个没有解决问题的例子 */
import React, { useState, useEffect, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 计数器 1
function Counter1() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    console.log(&#39;开启一个新的定时器&#39;)
    const timer = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);

    return () =&gt; {
      console.log(&#39;销毁老的定时器&#39;)
      clearInterval(timer);
    }
  });

  return &lt;p&gt;{count}&lt;/p&gt;
}

// 计数器 2
function Counter2() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    console.log(&#39;开启一个新的定时器&#39;)
    const timer = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; {
      console.log(&#39;销毁老的定时器&#39;)
      clearInterval(timer);
    }
  });

  return &lt;p&gt;{count}&lt;/p&gt;
}

function App() {
  return (
    &lt;Fragment&gt;
      &lt;Counter1 /&gt;
      &lt;Counter2 /&gt;
    &lt;/Fragment&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 <code>React Hooks</code> 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 <code>Hook</code> 改写的例子。</p><pre><code class="lang-jsx">/* 使用自定义 Hook 对状态逻辑进行抽离 */
import React, { useState, useEffect, Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 自定义 Hook
function useNumber() {
  const [ count, setCount ] = useState(0);

  useEffect(() =&gt; {
    console.log(&#39;开启一个新的定时器&#39;)
    const timer = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; {
      console.log(&#39;销毁老的定时器&#39;)
      clearInterval(timer);
    }
  });

  return count;
}

// 计数器 1
function Counter1() {
  let number = useNumber();
  return &lt;p&gt;{number}&lt;/p&gt;
}

// 计数器 2
function Counter2() {
  let number = useNumber();
  return &lt;p&gt;{number}&lt;/p&gt;
}

function App() {
  return (
    &lt;Fragment&gt;
      &lt;Counter1 /&gt;
      &lt;Counter2 /&gt;
    &lt;/Fragment&gt;
  )
}

ReactDOM.render(&lt;App /&gt;, root);
</code></pre><p>使用自定义 <code>Hook</code> 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。</p><blockquote class="pullquote primary"><p><strong>注意：官方建议在创建自定义 <code>Hook</code> 时，也采用 <code>use</code> 开头的命名方式，以保持命名的默认约定，便于识别，非强制，所以项目中可以使用 <code>ESlint</code> 进行检查和约束。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>React Hooks</code> 出现后让我们对使用 <code>React</code> 编程如释重负，好的技术就是应该尽量减小学习坡度和上手难度，越用越简单，编写大家都读得懂又直观的代码才是优秀的代码，上面就是在学习完 <code>React Hooks</code> 后的一些总结，最后附上相关案例的</strong> <a href="https://github.com/shenqiuhui/react-hooks-examples" target="_blank">Guthub 地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2 洋葱模型 —— compose 串联中间件的四种实现</title>
    <url>/20180906170854/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180906170854/compose-logo.png" title="Koa 洋葱模型"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>Koa</code> 是当下主流 <code>Node.js</code> 框架，以轻量见长，与相对传统的 <code>Express</code> 比较，它的中间件机制支持了异步，所以编码时可以使用 <code>async/await</code>，将异步代码用同步的方式编写，提高了可读性，使代码变得更优雅，上一篇文章</strong> <a href="/20180902141819/" target="_blank">Node.js 进阶 —— Koa2 源码分析</a><strong>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</strong></p></blockquote><a id="more"></a><h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用过 <code>Koa</code>，对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p><pre><code class="lang-js">const Koa = require(&quot;koa&quot;);
const app = new Koa();

app.use(async (ctx, next) =&gt; {
  console.log(1);
  await next();
  console.log(2);
});

app.use(async (ctx, next) =&gt; {
  console.log(3);
  await next();
  console.log(4);
});

app.use(async (ctx, next) =&gt; {
  console.log(5);
  await next();
  console.log(6);
});

app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p><pre><code class="lang-js">/* 文件：app.js */
// 模拟 Koa 创建的实例
const app = {
  middlewares: []
};

// 创建 use 方法
app.use = function(fn) {
  app.middlewares.push(fn);
};

// app.compose.....

module.exports = app;
</code></pre><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p><h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  // 递归函数
  function dispatch(index) {
    // 如果所有中间件都执行完跳出
    if (index === app.middlewares.length) return;

    // 取出第 index 个中间件并执行
    const route = app.middlewares[index];
    return route(() =&gt; dispatch(++index));
  }

  // 取出第一个中间件函数执行
  dispatch(0);
}
</code></pre><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p><pre><code class="lang-js">/* 文件：sync-test.js */
const app = require(&quot;./app&quot;);

app.use(next =&gt; {
  console.log(1);
  next();
  console.log(2);
});

app.use(next =&gt; {
  console.log(3);
  next();
  console.log(4);
});

app.use(next =&gt; {
  console.log(5);
  next();
  console.log(6);
});

app.compose();
// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><pre><code class="lang-js">/* 文件：async-test.js */
const app = require(&quot;./app&quot;);

// 异步函数
function fn() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve();
      console.log(&quot;hello&quot;);
    }, 3000);
  });
}

app.use(async next =&gt; {
  console.log(1);
  await next();
  console.log(2);
});

app.use(async next =&gt; {
  console.log(3);
  await fn(); // 调用异步函数
  await next();
  console.log(4);
});

app.use(async next =&gt; {
  console.log(5);
  await next();
  console.log(6);
});

app.compose();
</code></pre><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 <code>Promise</code> 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 <code>Promise</code>，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p><blockquote class="pullquote warning"><p><strong>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</strong></p></blockquote><h3 id="升级为支持异步"><a href="#升级为支持异步" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  // 递归函数
  function dispatch(index) {
    // 如果所有中间件都执行完跳出，并返回一个 Promise
    if (index === app.middlewares.length) return Promise.resolve();

    // 取出第 index 个中间件并执行
    const route = app.middlewares[index];

    // 执行后返回成功态的 Promise
    return Promise.resolve(route(() =&gt; dispatch(++index)));
  }

  // 取出第一个中间件函数执行
  dispatch(0);
}
</code></pre><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 <code>Promise</code>，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 <code>Promise</code>，使用 <code>async-test.js</code> 进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p><h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})();
}
</code></pre><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p><pre><code class="lang-js">// 第 1 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn3(() =&gt; {});

// 第 2 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn2(() =&gt; fn3(() =&gt; {}));

// 第 3 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p><p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p><h3 id="升级为支持异步-1"><a href="#升级为支持异步-1" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  return Promise.resolve(
    app.middlewares.reduceRight(
      (a, b) =&gt; () =&gt; Promise.resolve(b(a)),
      () =&gt; Promise.resolve()
    )()
  );
}
</code></pre><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 <code>Promise</code>，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 <code>Promise</code>，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 <code>Promise</code>，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p><h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="同步的实现-2"><a href="#同步的实现-2" class="headerlink" title="同步的实现"></a>同步的实现</h3><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {});
}
</code></pre><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p><p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p><pre><code class="lang-js">// 第 1 次 reduce 的返回值，下一次将作为 a
arg =&gt; fn1(() =&gt; fn2(arg));

// 第 2 次 reduce 的返回值，下一次将作为 a
arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));

// 等价于...
arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));

// 执行最后返回的函数连接中间件，返回值等价于...
fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p><h3 id="升级为支持异步-2"><a href="#升级为支持异步-2" class="headerlink" title="升级为支持异步"></a>升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  return Promise.resolve(
    app.middlewares.reduce((a, b) =&gt; {
      return arg =&gt; a(() =&gt; Promise.resolve(b(arg)));
    })(() =&gt; Promise.resolve())
  );
}
</code></pre><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 <code>Promise</code>，并让 <code>compose</code> 也返回 <code>Promise</code>。</p><h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>由于是利用 <code>async</code> 函数实现的，所以默认就是用同步的编码方式去支持异步的，因为 <code>async</code> 函数会返回一个 <code>Promise</code>。</p><pre><code class="lang-js">/* 文件：app.js */
app.compose = function() {
  // 自执行 async 函数返回 Promise
  return (async function () {
    // 定义默认的 next，最后一个中间件内执行的 next
    let next = async () =&gt; Promise.resolve();

    // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next
    // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题
    function createNext(middleware, oldNext) {
      return async () =&gt; {
        await middleware(oldNext);
      }
    }

    // 反向遍历中间件数组，先把 next 传给最后一个中间件函数
    // 将新的中间件函数存入 next 变量
    // 调用下一个中间件函数，将新生成的 next 传入
    for (let i = app.middlewares.length - 1; i &gt;= 0; i--) {
      next = createNext(app.middlewares[i], next);
    }

    await next();
  })();
}
</code></pre><p>上面代码中的 <code>next</code> 是一个只返回成功态 <code>Promise</code> 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code> 作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p><p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p><p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 <code>Promise</code>，而最外层的自执行 <code>async</code> 函数返回的也是 <code>Promise</code>，也就是说 <code>compose</code> 最后返回的是 <code>Promise</code>，因此完全支持异步。</p><blockquote class="pullquote info"><p><strong>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 <code>JavaScript</code> 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 <code>JavaScript</code> 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>async/await</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 基础知识总结</title>
    <url>/20190416160637/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/TypeScript/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><strong><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</strong></p></blockquote><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/TypeScript/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图"></div><div class="image-caption">TypeScript 与 JavaScript 关系图</div></figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装，安装 <code>TS</code> 的命令：</p><pre><code class="lang-bash">$ npm install typescript -g
</code></pre><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><p><strong>编译单个文件：</strong></p><pre><code class="lang-bash">$ tsc &lt;filename&gt;
</code></pre><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下：</p><pre><code class="lang-bash">tsc --init
</code></pre><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看（<code>TO DO</code>）。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><pre><code class="lang-json">/* package.json 文件 */
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc&quot;,
    &quot;start&quot;: &quot;tsc --watch&quot;
  }
}
</code></pre><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时根据智能提示及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><pre><code class="lang-ts">let name: string = &#39;panda&#39;;
let age: number = 18;
let merried: boolean = false;
let un: undefined = undefined;
let nu: null = null;
let sym: symbol = Symbol();
</code></pre><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><blockquote class="pullquote warning"><p><strong><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型：</strong></p><ul><li><strong>类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>；</strong></li><li><strong>类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>；</strong></li><li><strong>类型定义为除 <code>undefined</code> 和 <code>null</code> 以外的其他类型，可以赋值为 <code>undefined</code> 和 <code>null</code>。</strong></li></ul></blockquote><pre><code class="lang-ts">/* 默认会报错 */
let name: string = undefined;
let age: number = null;
</code></pre><p>其他类型的赋值也必须严格与其定义相对应（默认行为，也被叫做严格类型检查模式），可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性值为 <code>false</code> 跳过严格检查。</p><pre><code class="lang-json">/* tsconfig.json 文件 */
{
  &quot;compilerOptions&quot;: {
    &quot;strictNullChecks&quot;: false
  }
}
</code></pre><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何类型的值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>（戏称 <code>AnyScript</code>）。</p><pre><code class="lang-ts">let value: any = 18;
value = &#39;hello world&#39;;
value = true;
value = null;
value = undefined;
value = Symbol();
</code></pre><blockquote class="pullquote default"><p><strong>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</strong></p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><pre><code class="lang-js">let num = 10;
num = &#39;hello&#39;; // 报错，不能将类型“&quot;hello&quot;”分配给类型“number”

let str = &#39;world&#39;;
str = 1; // 报错，不能将类型“1”分配给类型“string”

let value; // let value: any
</code></pre><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><pre><code class="lang-ts">/* 基本数据类型调用方法的包装 */
let num = 10;
num.toFixed(2);

// new Number(num).toFixed(2);
</code></pre><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><pre><code class="lang-ts">/* 联合类型 */
let value: string | number = &#39;hello&#39;;
value = 10;
value = true; // 报错
</code></pre><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><pre><code class="lang-ts">// 冗余的写法
let x: string | number | boolean = &#39;hello&#39;;
let y: string | number | boolean = 10;
let z: string | number | boolean = true;

// 更改后...
type MyType = string | number | boolean;
let x: MyType = &#39;hello&#39;;
let y: MyType = 10;
let z: MyType = true;
</code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><pre><code class="lang-ts">let value: string | number | boolean;
value = &#39;hello&#39;;
value = 10;
value = true;

console.log((value as string).length); // 报错
</code></pre><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><pre><code class="lang-ts">let point: 1 | 6 | 10;
point = 10;
point = &#39;hello&#39;; // 报错

let level: &#39;A&#39; | &#39;B&#39; | &#39;C&#39;;
level = &#39;B&#39;;
level = &#39;b&#39;; // 报错
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><pre><code class="lang-ts">/* 普通数组类型定义 */
let names: string[] = [&#39;Jim&#39;, &#39;Peter&#39;];
let ages: number[] = [18, 20];
</code></pre><pre><code class="lang-ts">/* 泛型定义（泛型会在后面详细说明） */
let names: Array&lt;string&gt; = [&#39;Jim&#39;, &#39;Peter&#39;];
let ages: Array&lt;number&gt; = [18, 20];
</code></pre><p>上面两种方式定义的数组内元素类型必须统一，如果数组内要支持多种数据类型则可以使用联合类型或元组类型。</p><pre><code class="lang-ts">let data: Array&lt;string | number&gt; = [&#39;James&#39;, 25];
</code></pre><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><pre><code class="lang-ts">/* 元组类型定义 */
let people: [string, number] = [&#39;Jim&#39;, 18];
</code></pre><p><strong>元组的越界问题：</strong></p><pre><code class="lang-ts">let tuple: [string, number] = [&#39;hello&#39;, 100];

tuple.push(false);
console.log(tuple); // [&#39;hello&#39;, 100, false]
tuple[2] // 报错
</code></pre><p>元组类型可以越界添加元素，如使用数组的 <code>push</code> 方法，但是访问越界元素会报错，强烈不建议让元组越界。</p><p><strong>元组类型和数组类型的特点如下表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table></div><p><br></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><code>TS</code> 可以通过 <code>object</code> 来声明对象类型。</p><pre><code class="lang-ts">let obj: object = {x: 1, y: 2};
obj.x = 3; // 报错
</code></pre><p>用 <code>object</code> 类型并不能定义对象上具体属性的类型，所以对 <code>x</code> 属性重新赋值会报错，也可以在创建对象时直接定义属性的类型如下：</p><pre><code class="lang-ts">let obj: {x: number, y: number} = {x: 1, y: 2};
obj.x = 3
</code></pre><blockquote class="pullquote info"><p><strong>对象类型内部成员的类型很少使用上面的方式，通常使用接口（后面介绍）进行定义。</strong></p></blockquote><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><pre><code class="lang-ts">enum Gender {
  BOY,
  GIRL
}
</code></pre><pre><code class="lang-js">/* 编译后 */
var Gender;
(function (Gender) {
  Gender[Gender[&quot;BOY&quot;] = 0] = &quot;BOY&quot;;
  Gender[Gender[&quot;GIRL&quot;] = 1] = &quot;GIRL&quot;;
})(Gender || (Gender = {}));
</code></pre><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象（实现原理，反向映射），所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><pre><code class="lang-ts">/* 获取枚举值 */
console.log(Gender.BOY); // 0
console.log(Gender[1]); // &quot;GIRL&quot;
</code></pre><blockquote class="pullquote success"><p><strong>如果给第一个枚举值设置数值类型的初始值，则后面的枚举值会依次递增。</strong></p></blockquote><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="lang-ts">enum Week {
  MONDAY = &#39;1&#39;,
  TUESDAY = &#39;2&#39;
}
</code></pre><pre><code class="lang-js">/* 编译后 */
var Week;
(function (Week) {
  Week[&quot;MONDAY&quot;] = &quot;1&quot;;
  Week[&quot;TUESDAY&quot;] = &quot;2&quot;;
})(Week || (Week = {}));
</code></pre><p>字符串枚举是在枚举过程中给枚举项明确赋值，值类型为字符串类型。</p><h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>异构枚举是将数字枚举和字符串枚举混合使用（容易引起混淆，不建议使用）。</p><pre><code class="lang-ts">enum Answer {
  N,
  Y = &#39;Yes&#39;
}
</code></pre><h4 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h4><p>常量枚举的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><pre><code class="lang-ts">const enum Colors {
  RED,
  YELLOW,
  BLUE
}

let colors: Array&lt;number&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];
</code></pre><pre><code class="lang-js">/* 编译后 */
var colors = [0 /* RED */, 1 /* YELLOW */, 2 /* BLUE */];
</code></pre><blockquote class="pullquote success"><p><strong>常数枚举与其他类型枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</strong></p></blockquote><h4 id="枚举成员"><a href="#枚举成员" class="headerlink" title="枚举成员"></a>枚举成员</h4><blockquote class="pullquote warning"><p><strong>枚举成员主要分为两类：</strong></p><ul><li><strong><code>const member</code>：以编译阶段计算结果，以常量的形式出现在运行时环境；</strong><ul><li><strong>没有初始值的枚举值；</strong></li><li><strong>对已有枚举成员的引用；</strong></li><li><strong>常量的表达式。</strong></li></ul></li><li><strong><code>computed member</code>：编译阶段不会计算，会被保留在程序的执行阶段。</strong><ul><li><strong>动态计算的表达式；</strong></li><li><strong>后面的枚举值必须赋值初始值。</strong></li></ul></li></ul></blockquote><pre><code class="lang-ts">enum Char {
  // const member
  a, // 无初始值
  b = Char.a, // 对已有成员的引用
  c = 1 + 2, // 常量表达式
  // computed member
  d = Math.random(),
  e = &#39;123&#39;.length,
}
</code></pre><pre><code class="lang-ts">Char.a = 1 // 报错
</code></pre><blockquote class="pullquote warning"><p><strong>枚举成员的值为只读类型，在定义后不能重新赋值。</strong></p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><pre><code class="lang-ts">function sum(a: number, b: number) {
  return a + b;
}

sum(1, 2); // 3
</code></pre><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><pre><code class="lang-ts">/* 可选参数 */
function people(name: string, age?: number) {
  console.log(name);
}

people(&#39;jim&#39;);
</code></pre><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><pre><code class="lang-ts">/* 默认参数 */
function fn(sum: number = 0) {
  console.log(sum);
}

fn(); // 0
</code></pre><pre><code class="lang-ts">/* 剩余参数 */
function sum(prefix: string, ...args: number[]) {
  return prefix + args.reduce((sum, val) =&gt; sum + val, 0);
}

sum(&#39;$&#39;, 1, 2, 3); // 6
</code></pre><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><pre><code class="lang-ts">function sum(a: number, b: number): number {
  return a + b;
}
</code></pre><blockquote class="pullquote danger"><p><strong>特殊的返回值类型：</strong></p><ul><li><strong><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完成；</strong></li><li><strong><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</strong></li></ul></blockquote><pre><code class="lang-ts">/* never 为返回值类型的函数 */
function fn1(): nerver {
  throw new Error(&#39;报错了&#39;);
  console.log(1);
}

function fn2(): nerver {
  while (true) {}
  console.log(1);
}
</code></pre><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><pre><code class="lang-ts">/* void 为返回值类型的函数 */
function fn1(): void {
  console.log(1);
}

function fn2(): void {
  return null;
}
</code></pre><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><pre><code class="lang-ts">let fullName: (x: string, y: string) =&gt; string;

fullName = function (firstName:string, lastName:string): string {
  return firstName + lastName;
}
</code></pre><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><pre><code class="lang-ts">type Fn = (x: string, y: string) =&gt; string;

let fullName: Fn = function (firstName: string, lastName: string): string {
  return firstName + lastName;
}
</code></pre><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，赋值函数的返回值类型必须与变量声明的函数返回值类型严格一致。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><pre><code class="lang-ts">// 联合类型
type MyType = string | number | boolean

// 重载限定函数 double
function double(val: string): string;
function double(val: number): number;
function double(val: boolean): boolean;

// 函数
function double(val: MyType) {
  if (typeof val === &#39;string&#39;) return val + val;
  if (typeof val === &#39;number&#39;) return 2 * val;
  if (typeof val === &#39;boolean&#39;) return !val;
}

double(&#39;hello&#39;); // hellohello
double(5); // 10
double(true); // false
</code></pre><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><pre><code class="lang-ts">class Person {
  name: string
  getName(): void {
    console.log(this.name)
  }
}

let p = new Person();
p.name = &#39;neil&#39;;
p.getName(); // neil
</code></pre><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><pre><code class="lang-ts">class Person {
  myName: string,
  constructor(myName: string) {
    this.myName = myName;
  }
  get name(): string {
    return this.myName;
  }
  set name(newVal: string) {
    this.myName = newVal;
  }
}

let p = new Person(&#39;neil&#39;);
console.log(p.name); // neil

p.name = &#39;jim&#39;;
console.log(p.name); // jim
</code></pre><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><pre><code class="lang-ts">/* 简化前 */
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}
</code></pre><pre><code class="lang-ts">/* 简化后 */
class Person {
  constructor(public myName: string) {}
}

let p = new Person(&#39;neil&#39;);
console.log(p.myName); // neil
</code></pre><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><pre><code class="lang-ts">class Person {
  constructor(public readonly myName: string) {
    this.myName = myName;
  }
}

let p = new Person(&#39;neil&#39;);
console.log(p.myName); // neil
p.myName = &#39;jim&#39;; // 报错
</code></pre><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><pre><code class="lang-ts">// 父类
class Parent {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  getName(): string {
    return this.name;
  }
  setName(name: string): void {
    this.name = name;
  }
}

// 子类继承父类
class Child extends Parent {
  hobby: string;
  constructor(name: string, age: number, hobby: number) {
    super(name, age);
    this.hobby = hobby;
  }
  getHobby(): number {
    return this.hobby;
  }
}

let c = new Child(&#39;neil&#39;, 20, &#39;swim&#39;);
console.log(c.getHobby()); // swim
console.log(c.getName()); // neil
console.log(c.getAge()); // 20
</code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><blockquote class="pullquote default"><p><strong>在 <code>TS</code> 的类中有三种访问控制修饰符：</strong></p><ul><li><strong><code>public</code>：公有的属性，所有地方都能访问；</strong></li><li><strong><code>protected</code>：受保护的属性，不能被实例化只能被继承，只能在自己和自己的子类中被访问；</strong></li><li><strong><code>private</code>：私有属性，既不能被实例化也不能被继承，只有自己内部可以访问。</strong></li></ul></blockquote><pre><code class="lang-ts">// 父类
class Parent {
  public name: string;
  protected age: number;
  private money: number;
  constructor(name: string, age: number, money: number) {
    this.name = name;
    this.age = age;
    this.money = money;
  }
  getName() {
    console.log(&#39;父类：&#39; + this.name);
  }
  getAge() {
    console.log(&#39;父类：&#39; + this.age);
  }
  getMoney() {
    console.log(&#39;父类：&#39; + this.money);
  }
}

// 子类
class Child extends Parent {
  constructor(name, age, money) {
    super(name, age, money);
  }
  getName() {
    console.log(&#39;子类：&#39; + this.name);
  }
  getAge() {
    console.log(&#39;子类：&#39; + this.age);
  }
  getMoney() {
    console.log(&#39;子类：&#39; + this.money); // 报错
  }
}
</code></pre><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><pre><code class="lang-ts">class Father {
  static myName: string = &#39;hello&#39;;
  static getMyName(): string {
    return Father.myName;
  }
}

console.log(Father.myName); // hello
console.log(Father.getMyName()); // hello
</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，且必须实现。</p><pre><code class="lang-ts">abstract class Animal {
  abstract name: string;
  abstract speak();
}

class Cat extends Animal {
  name: string;
  speak() {
    console.log(&#39;喵喵喵&#39;);
  }
}

class Dog extends Animal {
  name: string;
  speak() {
    console.log(&#39;汪汪汪&#39;);
  }
}
</code></pre><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承过程，子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote class="pullquote info"><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li><strong>用于描述或约束一种对象结构，描述属性的名称和值的类型；</strong></li><li><strong>用来表示行为的抽象，让类去实现接口。</strong></li></ul></blockquote><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><pre><code class="lang-ts">/* 定义接口，使用接口创建对象 */
interface UserInterface {
  name: string;
  age: number;
}

let user: UserInterface = {
  name: &#39;hello&#39;,
  age: 20
};
</code></pre><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><pre><code class="lang-ts">/* 让类去实现定义的接口 */
interface Flyable {
  fly(): void;
}

class Bird implements Flyable {
  fly() {
    console.log(&#39;bird fly&#39;);
  }
}
</code></pre><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><pre><code class="lang-ts">/* 一个类实现多个接口 */
// 接口
interface Speakable {
  name: string;
  speak(): void;
}

interface Eatable {
  food: string;
  eat(): void;
}

// 类
class Person implements Speakable, Eatable {
  name: &#39;hello&#39;;
  food: &#39;cake&#39;;
  speak() {
    console.log(&#39;say hello&#39;);
  }
  eat() {
    console.log(&#39;eat cake&#39;);
  }
}
</code></pre><blockquote class="pullquote default"><p><strong>继承与实现接口的区别：</strong></p><ul><li><strong>一个类可以实现多个接口，一个接口可以被多个类实现；</strong></li><li><strong>而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></li></ul></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><pre><code class="lang-ts">/* 接口的只读属性 */
interface Person {
  id: number;
  readonly name: string;
}

let p: Person = {
  id: 1;
  name: &#39;hello&#39;;
};

console.log(p.id); // 1
p.name = 2; // 报错
</code></pre><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><pre><code class="lang-ts">/* 接口的可选属性 */
interface Person {
  id: number;
  name: string;
  age?: number;
}

let p1: Person = {
  id: 1,
  name: &#39;hello&#39;,
  age: 20
};

let p2: Person = {
  id: 2,
  name: &#39;world&#39;
};
</code></pre><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><pre><code class="lang-ts">interface Person {
  id: number;
  name: string;
  [proName: string]: any;
}

let p: Person = {
  id: 1,
  name: &#39;hello&#39;,
  age: 20,
  city: &#39;Beijing&#39;
};
</code></pre><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><pre><code class="lang-ts">/* 限制数组 */
interface UserInterface {
  [index: number]: string;
}

let userArr: UserInterface = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
userArr = [&#39;a&#39;, &#39;b&#39;, 1]; // 报错
</code></pre><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><pre><code class="lang-ts">/* 限制对象 */
interface UserInterface {
  [index: string]: string;
}

let userObj: UserInterface = {
  jim: &#39;1&#39;,
  bob: &#39;2&#39;
};
</code></pre><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><pre><code class="lang-ts">// 父接口
interface Speakable {
  speak(): void;
}

// 子接口
interface SpeakChinese extends Speakable {
  speakChinese(): void;
}

// 类实现接口
class ChinesePerson implements SpeakChinese {
  speak() {
    console.log(&#39;speak&#39;);
  }
  speakChinese() {
    console.log(&#39;你好&#39;);
  }
}
</code></pre><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><pre><code class="lang-ts">interface Discount {
  (price: number): number;
}

function discount(price: number): number {
  return price * 0.8;
}

const dFun: Discount = discount;
</code></pre><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><pre><code class="lang-ts">// 被约束实例化动作的类
class Animal {
  constructor(public name: string) {}
}

// 约束实例化的接口
interface WithNameClazz {
  new (name: string): Animal;
}

// 工厂函数
function createAnimal(Clazz: WithNameClazz, name: string) {
  return new Clazz(name);
}

let animal = createAnimal(Animal, &#39;hellop&#39;);
</code></pre><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote class="pullquote primary"><p><strong>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</strong></p></blockquote><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><pre><code class="lang-ts">/* 为使用泛型定义的函数 */
function createArray(len: number, val: any): any[] {
  const result: any[] = [];
  for (let i = 0; i &lt; len; i++) {
    result[i] = val;
  }
  return result;
}

console.log(createArray(3, &#39;x&#39;)); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]
</code></pre><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><pre><code class="lang-ts">function createArray&lt;T&gt;(len: number, val: T): T[] {
  const result: T[] = [];
  for (let i = 0; i &lt; len; i++) {
    result[i] = val;
  }
  return result;
}

console.log(createArray&lt;string&gt;(3, 1)); // 报错
</code></pre><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code class="lang-ts">class MyArray&lt;T&gt; {
  list: T[] = [];
  add(val: T) {
    this.list.push(val);
  }
  getFirst(): T {
    return this.list[0];
  }
}

let myArray = new MyArray&lt;number&gt;();
myArray.add(1);
myArray.add(2);
console.log(myArray.getFirst());
</code></pre><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中，接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><pre><code class="lang-ts">interface SUM&lt;T&gt; {
  (a: T, b: T): T
}

const sum: SUM&lt;number&gt; = function (a: number, b: number): number {
  return a + b;
}
</code></pre><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><pre><code class="lang-ts">class MyArray&lt;T = number&gt; {
  list: T[] = [];
  add(val: T) {
    this.list.push(val);
  }
}

let myArray = new MyArray();
myArray.add(1);
myArray.add(&#39;a&#39;); // 报错
</code></pre><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><pre><code class="lang-ts">function swap&lt;A, B&gt;(tuple: [A, B]): [B, A] {
  return [tuple[1], tuple[0]];
}

console.log(swap&lt;string, number&gt;([&#39;a&#39;, 1])); // [1, &#39;a&#39;]
</code></pre><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><pre><code class="lang-ts">function logger&lt;T&gt;(val: T): void {
  console.log(val.length); // 报错
}
</code></pre><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><pre><code class="lang-ts">// 接口
interface LengthWise {
  length: number;
}

// 函数
function logger&lt;T extends LengthWise&gt;(val: T): void {
  console.log(val.length);
}

logger&lt;number&gt;(&#39;hello&#39;); // 报错
logger&lt;string&gt;(&#39;hello&#39;); // 5
</code></pre><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><pre><code class="lang-ts">interface Fish {
  nameFish: string;
}

interface Water {
  nameWater: string;
}

interface Bird {
  nameBird: string;
}

interface Sky {
  nameSky: string;
}

type Condition&lt;T&gt; = T extends Fish ? Water : Sky;

let con: Condition&lt;Fish&gt; = {
  nameWater: &#39;hello&#39;
}
</code></pre><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><pre><code class="lang-ts">let arr: Array&lt;string&gt; = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
</code></pre><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><pre><code class="lang-ts">// 定义泛型别名
type Cart&lt;T&gt; = { list: T[] } | T[];

// 使用泛型别名
let cart1: Cart&lt;string&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
let cart2: Cart&lt;string&gt; = {
  list: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
};
</code></pre><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><pre><code class="lang-ts">/* arguments 对象的泛型 */
function sum(...args: number[]) {
  let params: IArguments = arguments;
  let result = 0;
  for (let i = 0; i &lt; params.length; i++) {
    result += params[i];
  }
  return result;
}
</code></pre><pre><code class="lang-ts">/* DOM 节点类数组对象的泛型 */
let root = document.getElementById(&#39;root&#39;);
let children: HTMLCollection = root.children;
let childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;
</code></pre><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，泛型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><pre><code class="lang-ts">let num1: string | number;
let str1: string;
num1 = str1;

let num2: {
  toString(): string;
};
let str2: number;
num2 = str2;

type People = {
  name: string;
  age: number;
}

let p: People = {
  name: &#39;hello&#39;,
  age: 20,
  gender: &#39;male&#39; // 报错
};
</code></pre><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><pre><code class="lang-ts">enum Colors {
  RED,
  YELLOW,
  BLUE
}

// 兼容数字类型
let colorRed: number = Colors.RED;

// 兼容枚举类型
let colorYello: Colors;
colorYello = Colors.Red;
colorYello = 1;
</code></pre><pre><code class="lang-ts">// 所有枚举值没有初始值
enum E {
  a,
  b
}

// 所有枚举值初始值都为数值
enum F {
  a = 1,
  b = 2
}

// 所有枚举值类型都为字符串
enum G {
  a = &#39;apple&#39;,
  b = &#39;banana&#39;
}
</code></pre><p><strong>赋值可以超出枚举值范围：</strong></p><pre><code class="lang-ts">let e: E = 3; // 不报错
</code></pre><p><strong>不同枚举约束的变量不可以进行比较：</strong></p><pre><code class="lang-ts">let e: E = 1;
let f: F = 2;

console.log(e === f); // 报错
</code></pre><p><strong>相同枚举不同枚举值约束的变量不可以进行比较：</strong></p><pre><code class="lang-ts">let e1: E.a = 1;
let e2: E.b = 2;
let e3: E.a = 1;

console.log(e1 === e2) // 报错
console.log(e1 === e3) // true
</code></pre><p><strong>字符串枚举和字符串枚举值约束赋值：</strong></p><pre><code class="lang-ts">// 字符串枚举约束赋值必须是类型中的枚举值
let g1: G = G.a

// 字符串的枚举值约束赋值必须是这个枚举值
let g2: G.b = G.b
</code></pre><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><pre><code class="lang-ts">/* 参数的类型比较 */
type SumFunc = (a: number, b: number) =&gt; number;
let sum: SumFunc;

// 不报错的赋值
sum = function(a: number, b: number): number {
  return a + b;
}

sum = function(a: number): number {
  return a;
}

sum = function(): number {
  return 0;
}

// 报错的赋值
sum = function(a: number, b: number, c: number): number {
  return a + b + c;
}
</code></pre><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的 “双向协变” 是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><pre><code class="lang-ts">type LogFunc = (val: number | string) =&gt; void;
let log: LogFunc;

// 变量定义类型兼容赋值定义类型
log = function (val: string) {
  console.log(val);
}

// 变量赋值类型兼容变量定义的类型
log = function (val: number | string | boolean) {
  console.log(val);
}
</code></pre><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><pre><code class="lang-ts">/* 返回值的类型比较 */
type GetPerson = () =&gt; { name: string, age: number };
let getPerson: GetPerson;

// 不报错的赋值
getPerson = function () {
  return { name: &#39;hello&#39;, age: 20 };
}

getPerson = function () {
  return { name: &#39;hello&#39;, age: 20, gender: 1 };
}

// 报错的赋值
getPerson = function () {
  return { name: &#39;hello&#39; };
}

// 可能调用 age 属性的方法
getPerson().age.toFixed(2);
</code></pre><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><pre><code class="lang-ts">class Parent {
  name: string;
}

class Child extends Parent {
  age: number;
}

let p1: Parent = new Parent();
let c1: Child = new Child();

let p2: Parent = new Child();
let c2: Child = new Parent(); // 报错
</code></pre><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><h4 id="比较属性的兼容性"><a href="#比较属性的兼容性" class="headerlink" title="比较属性的兼容性"></a>比较属性的兼容性</h4><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><pre><code class="lang-ts">interface Person {
  name: string;
  age: number;
  gender: number;
}

let p: Person = {
  name: &#39;hello&#39;,
  age: 20,
  gender: 0
};
</code></pre><h4 id="鸭式变形法"><a href="#鸭式变形法" class="headerlink" title="鸭式变形法"></a>鸭式变形法</h4><p>“鸭式变形法” 是很多动态语言的类型风格，指的是一只鸟如果看起来像鸭子，游起来像鸭子，叫起来像鸭子，这只鸟就可以被当做一直鸭子，回到 <code>TS</code> 中，传入接口的对象只要符合接口的必要条件，即传入的属性不必接口约束的少，就认为可以通过校验，不会报错。</p><p>上面的案例可以稍微做改造如下：</p><pre><code class="lang-ts">interface Animal {
  name: string;
  age: number;
}

interface Person {
  name: string;
  age: number;
  gender: number;
}

let p: Person = {
  name: &#39;hello&#39;,
  age: 20,
  gender: 0
};

function getName(a: Animal): string {
  return a.name;
}

getName(p); // hello;
</code></pre><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。、</p><p>在实际的开发应用中，有一个常见的场景，就是前端代码要对后端返回的数据进行定义和约束，往往后端返回的数据及类型对于前端并不是全部必要的，则可以利用该特性使用接口对必要的字段进行兼容。</p><pre><code class="lang-ts">interface List {
  id: number;
  name: string;
}

interface Result {
  data: List[];
}

function render(result: Result) {
  result.data.forEach(({ id, name }) =&gt; {
    console.log(id, name)
  });
}

render({
  data: [
    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错
    {id: 2, name: &#39;B&#39;}
  ]
});
</code></pre><blockquote class="pullquote danger"><p><strong>有一种特殊情况，就是直接传入对象字面量，则 <code>TS</code> 会对额外的字段进行检查，绕过检查的方式一共有三种：</strong></p><ul><li><strong>将对象字面量直接赋值给变量；</strong></li><li><strong>使用类型断言；</strong></li><li><strong>在定义接口时使用可索引签名；</strong></li></ul></blockquote><pre><code class="lang-ts">// 第一种方式：对象字面量赋值给变量
let result = {
  data: [
    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;},
    {id: 2, name: &#39;B&#39;},
  ]
};

render(result);
</code></pre><pre><code class="lang-ts">// 第二种方式：使用类型断言
render({
  data: [
    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错
    {id: 2, name: &#39;B&#39;},
  ]
} as Result);

// 或

// React 中容易产生歧义
render(&lt;Result&gt;{
  data: [
    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错
    {id: 2, name: &#39;B&#39;},
  ]
});
</code></pre><pre><code class="lang-ts">// 第三种方式：定义接口使用可索引签名
interface List {
  id: number;
  name: string;
  [x: string]: any;
}
</code></pre><h4 id="可索引接口的兼容性"><a href="#可索引接口的兼容性" class="headerlink" title="可索引接口的兼容性"></a>可索引接口的兼容性</h4><p>用数值类型去索引一个接口，相当于给数组创建接口，可索引返回值的具体类型约束数组成员类型。</p><pre><code class="lang-ts">interface StringArray {
  [index: number]: string;
}

const chars: StringArray = [&#39;A&#39;, &#39;B&#39;]
</code></pre><p><strong>使用字符串类型作为可索引类型，则不能添加其他类型的属性：</strong></p><pre><code class="lang-ts">interface Names {
  [x: string]: string;
  y: number; // 报错
}
</code></pre><p><strong>可是使用字符串和数值类型同时作为可索引类型，数字类型返回值必须是字符串类型返回值的子类型：</strong></p><pre><code class="lang-ts">interface Names {
  [x: string]: string;
  [y: number]: string;
}
</code></pre><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><pre><code class="lang-ts">/* 空接口 */
interface Empty&lt;T&gt; {}

let x: Empty&lt;string&gt;;
let y: Empty&lt;number&gt;;
x = y;
</code></pre><pre><code class="lang-ts">/* 属性使用了泛型的接口 */
interface NotEmpty&lt;T&gt; {
  data: T;
}

let x: NotEmpty&lt;string&gt;;
let y: NotEmpty&lt;number&gt;;
x = y; // 报错，因为 number 类型的属性不能赋值给 string 类型的定义

// 等价于
interface NotEmptyString{
  data: string
}

interface NotEmptyNumber{
  data: number
}

let xString: NotEmptyString;
let yNumber: NotEmptyNumber;
xString = yNumber; // 报错
</code></pre><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><pre><code class="lang-ts">/* typeof 类型保护 */
function double(val: string | number | boolean) {
  if (typeof val === &#39;string&#39;) {
    return val.repeat(2);
  }
  if (typeof val === &#39;number&#39;) {
    return val * 2;
  }
  if (typeof val === &#39;boolean&#39;) {
    return !val;
  }
}
</code></pre><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><pre><code class="lang-ts">/* instanceof 类型保护 */
class Bird {
  nameBird: string;
}

class Dog {
  nameDog: string;
}

function getName(animal: Bird | Dog) {
  if (animal instanceof Bird) {
    return animal.nameBird;
  }

  if (animal instanceof Dog) {
    return animal.nameDog;
  }
}
</code></pre><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {
  return str.charAt(0); // 报错
}
</code></pre><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><pre><code class="lang-ts">/* 方法一 */
function getFirstLetter(str: string | null) {
  str = str || &#39;&#39;;
  return str.charAt(0);
}
</code></pre><pre><code class="lang-ts">/* 方法二 */
function getFirstLetter(str: string | null) {
  if (str == null) {
    return &#39;&#39;;
  }
  return str.charAt(0);
}
</code></pre><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {
  function log() {
    console.log(str.tirm()); // 报错
  }

  str = str || &#39;&#39;;
  log();
  return str.charAt(0);
}
</code></pre><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {
  function log() {
    console.log(str!.tirm()); // 强制调用
  }

  str = str || &#39;&#39;;
  log();
  return str.charAt(0);
}
</code></pre><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><pre><code class="lang-js">/* 链判断运算符的几种用法 */
a?.b;
// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于
a == null ? undefined : a.b;

a?.[b];
// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于
a == null ? undefined : a[b];

a?.b()
// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()，如果 a.b 不是一个函数抛出类型错误，等同于
a == null ? undefined : a.b();

a?.()
// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于
a == null ? undefined : a();
</code></pre><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><pre><code class="lang-ts">interface WarningButton {
  class: &#39;warning&#39;;
  name1: &#39;modified&#39;;
}

interface DangerButton {
  class: &#39;danger&#39;;
  name2: &#39;delete&#39;;
}

// 定义联合类型
type Button = WarningButton | DangerButton;

function getButton(button: Button) {
  if (button.class === &#39;warning&#39;) {
    return button.name1;
  }

  if (button.class === &#39;danger&#39;) {
    return button.name2;
  }
}
</code></pre><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><pre><code class="lang-ts">interface Bird {
  talon: number;
}

interface Dog {
  leg: number;
}

function getNumber(animal: Bird | Dog) {
  if (&#39;talon&#39; in animal) {
    console.log(animal.talon);
  }

  if (&#39;leg&#39; in animal) {
    console.log(animal.leg);
  }
}
</code></pre><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><pre><code class="lang-ts">interface Bird {
  talon: number;
}

interface Dog {
  leg: number;
}

// 自定义类型保护函数
function isBird(animal: Bird | Dog): animal is Bird {
  // return (animal as Bird).talon &gt; 0;
  return (&lt;Bird&gt;animal).talon &gt; 0;
}

function getNumber(animal: Bird | Dog) {
  if (isBird(animal)) {
    console.log(animal.talon);
  } else {
    console.log(animal.leg);
  }
}
</code></pre><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><pre><code class="lang-ts">interface Bird {
  name: string;
  fly(): void;
}

interface Person {
  name: string;
  eat(): void;
}

// 取的是接口的并集
type BirdMan = Bird &amp; Person;

// 实现接口必须包含两个接口所有的属性和方法
let birdMan: BirdMan = {
  name: &#39;niao&#39;,
  fly() {
    console.log(&#39;fly&#39;);
  },
  eat() {
    console.log(&#39;eat&#39;);
  }
};
</code></pre><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><pre><code class="lang-ts">/* 先定义类型，后定义变量 */
interface People {
  name: string;
  age: number;
}

let p: People = {
  name: &#39;hello&#39;,
  age: 20;
};
</code></pre><pre><code class="lang-ts">/* 先定义变量，后定义接口 */
let p: People = {
  name: &#39;hello&#39;,
  age: 20;
};

type People = typeof p;

function getName(p: People) {
  return p.name;
}
</code></pre><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><pre><code class="lang-ts">// 定义嵌套类型接口
interface Person {
  name: string;
  age: number;
  // 对象，包含 name 属性
  job: {
    name: string;
  };
  // 成员为对象组成的数组，对象中含有 name 和 level 属性
  hobbies: { name: string; level: number }[];
}

// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型
let FEJob: Person[&quot;job&quot;] = {
  name: &quot;FE&quot;
};

// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型
let hobbyLevel: Person[&#39;hobbies&#39;][0][&#39;level&#39;] = 10;
</code></pre><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><pre><code class="lang-ts">interface Person {
  name: string;
  age: number;
  gender: &#39;male&#39; | &#39;female&#39;;
}

// 使用 keyof 定义类型
type PersonKey = keyof Person;

function getValueByKey(p: Person, key: PersonKey) {
  return p[key];
}

let: person: Person = {
  name: &#39;hello&#39;,
  age: 20,
  gender: &#39;male&#39;
};

getValueByKey(person, &#39;name&#39;); // hello
getValueByKey(person, &#39;say&#39;); // 报错
</code></pre><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><pre><code class="lang-ts">interface Person {
  name: string;
  age: number;
  gender: &#39;male&#39; | &#39;female&#39;;
}

// 映射 Person 接口定义的类型，把每一个属性都变成可选的
type PartPerson = {
  [key in keyof Person]?: Person[key];
}

let p1: PartPerson = {
  name: &#39;hello&#39;
};
</code></pre><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><pre><code class="lang-ts">// 定义接口
interface Person {
  name: string;
  age: number;
}

// 使用 Partial
let p: Partial&lt;Person&gt; = {
  name: &#39;hello&#39;
};

// Partial 的原理
type Partial&lt;T&gt; = {
  [key in keyof T]?: T[key]
}
</code></pre><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><pre><code class="lang-ts">// 定义接口
interface Person {
  name: string;
  age: number;
}

// 使用 Required
let p: Required&lt;Person&gt; = {
  name: &#39;hello&#39;
}; // 报错

// Required 的原理
type MyRequired&lt;T&gt; = {
  [key in keyof T]-?: T[key]
}
</code></pre><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><pre><code class="lang-ts">// 定义接口
interface Person {
  name: string;
  age: number;
}

// 使用 Readonly
let p: Readonly&lt;Person&gt; = {
  name: &#39;hello&#39;,
  age: 10
};

p.name = &#39;world&#39;; // 报错

// Readonly 的原理
type MyReadonly&lt;T&gt; = {
  readonly [key in keyof T]: T[key];
}
</code></pre><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><pre><code class="lang-ts">// 定义接口
interface Person {
  name: string;
  age: number;
}

// 使用 Pick
let p: Pick&lt;Person, &#39;name&#39;&gt; = {
  name: &#39;hello&#39;
};

// Pick 的原理
type MyPick&lt;T, K extends keyof T&gt; = {
  [key in K]: T[key];
}
</code></pre><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><pre><code class="lang-ts">// 定义
Exclude&lt;T, U&gt; // 从 T 可分配给的类型中排除 U

// 使用
type E = Exclude&lt;string | number, string&gt;
let x: E = 10;
let y: E = &#39;hello&#39;; // 报错
</code></pre><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><pre><code class="lang-ts">// 定义
Extract&lt;T, U&gt; // 从 T 可分配的类型中提取 U

// 使用
type E = Extract&lt;string | number, string&gt;
let x: E = 10; // 报错
let y: E = &#39;hello&#39;;
</code></pre><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><pre><code class="lang-ts">// 定义
NonNullable&lt;T&gt; // 从 T 中排除 null 和 undefined

// 使用
type E = NonNullable&lt;string | null | undefined&gt;
let x: E = null; // 报错
let y: E = &#39;hello&#39;;
</code></pre><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><pre><code class="lang-ts">// 定义
ReturnType&lt;T&gt; // 获取函数类型的返回类型

// 使用
function getUserInfo() {
  return { name: &quot;hello&quot;, age: 10 };
}

type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;

let user: UserInfo = {
  name: &#39;haha&#39;,
  age: 18
};
</code></pre><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><pre><code class="lang-ts">// 定义
InstanceType&lt;T&gt; // 获取构造函数类型的实例类型

// 使用
class Person {
  constructor(public name) {}
  getName() {
    console.log(this.name);
  }
}

type P = InstanceType&lt;typeof Person&gt;;

let p: P = {
  name: &#39;hello&#39;,
  getName() {
    console.log(&#39;myName&#39;);
  }
};
</code></pre><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14 —— 最长公共前缀</title>
    <url>/20220428135918/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>strs = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;]</code><br><strong>输出：</strong> <code>&quot;fl&quot;</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>strs = [&quot;dog&quot;, &quot;racecar&quot;, &quot;car&quot;]</code><br><strong>输出：</strong> <code>&quot;&quot;</code><br><strong>解释：</strong> 输入不存在公共前缀。</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h3><p>横向比较的思路就是我们每次传入两个字符串对比，得到这两项的公共前缀，再拿得到的结果和下一个字符串对比，直到所有字符串都对比完得到最大公共前缀。</p><blockquote class="pullquote info"><p><strong>$LCP(S_1…S_n) = LCP(LCP(LCP(LCP(S_1, S_2), S_3), S_4), …S_n)$</strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220428135918/horizontal.png" alt="横向扫描示意图"></div><div class="image-caption">横向扫描示意图</div></figure><p><br></p><p>根据示意图可以知道，我们首先应该用一个变量存储 <code>LCP</code> 过程的结果，默认为字符串数组的第一项，并遍历字符串数组，用当前的公共前缀去和每一项字符串对比得出新的公共前缀。</p><p>在获取两个字符串公共前缀的过程中需要遍历字符串，所以当遍历次数达到较短的字符串长度时，或者出现某次遍历字符串对应位置上两个字符不相等时，则可以停止遍历得出当前的公共前缀，当所字符串数组遍历完可以得出最终的公共前缀并返回。</p><pre><code class="lang-js">const longestCommonPrefix = (strs) =&gt; {
  if (strs.length === 0) return &#39;&#39;;

  const lcp = (str1, str2) =&gt; {
    const length = Math.min(str1.length, str2.length);
    let index = 0;

    while (index &lt; length &amp;&amp; str1[index] === str2[index]) {
      index++;
    }

    return str1.slice(0, index);
  }

  return strs.reduce((prev, next) =&gt; lcp(prev, next));
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>n</code> 为字符串数组的规模，<code>m</code> 为 <code>lcp</code> 函数遍历的平均次数，故为 <strong>$O(m * n)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul><h3 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h3><p>相比于横向扫描，整个字符串为维度两两求公共前缀，纵向扫描是以每一个字符为维度的遍历，最后得到公共前缀，我们也可以把字符串的看做一个不规则的表格，每个字符代表一个单元格。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220428135918/vertical.png" alt="纵向扫描示意图"></div><div class="image-caption">纵向扫描示意图</div></figure><p><br></p><p>在每次一个字符一个字符的比对时，当有内层遍历一个字符串对应位置的字符与其他不符合，或者外层遍历到最短的那个字符串时结束。</p><pre><code class="lang-js">const longestCommonPrefix = (strs) =&gt; {
  if (strs.length === 0) return &#39;&#39;;

  const len = strs.length;
  const count = strs[0].length;

  for (let i = 0; i &lt; count; i++) {
    for (let j = 0; j &lt; len; j++) {
      if (i === strs[j].length || strs[0][i] !== strs[j][i]) {
        return strs[0].slice(0, i);
      }
    }
  }

  return strs[0];
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>n</code> 为字符串数组的规模，<code>m</code> 字符串的平均长度，故为 <strong>$O(m * n)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul><h3 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h3><p>分治算法满足的条件：</p><ul><li>分解：将要解决的问题划分成规模更小的问题；</li><li>求解：将划分的足够小的子问题用相对简单的方法解决；</li><li>合并：按照原问题的要求将子问题的解逐层合并为原问题的解。</li></ul><p>通过横向扫描法我们可以知道两个字符串可以求解公共前缀，<strong>$n = 2$</strong> 这个规模就是我们要求解的子问题，而通过结合律有以下结论：</p><blockquote class="pullquote info"><p><strong><script type="math/tex">LCP(S_1...S_n) = LCP(LCP(S_1...S_K), LCP(S_{k + 1}...S_n))</script></strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220428135918/divide-conquer.png" alt="分治策略示意图"></div><div class="image-caption">分治策略示意图</div></figure><p><br></p><p>每一个大问题都可以通过求解的中间值 <code>mid</code> 范围划分为两个子问题 <strong>$LCP(S_1…S_mid)$</strong> 和 <strong>$LCP(S_{mid + 1}…S_n)$</strong>，子问题继续划分为两个子问题，依次类推，划分到最小颗粒度为止（范围内不大于两个字符串求解），再通过子问题得到的结果逐级合并，所以使用递归回溯更适合解决分治的问题。</p><pre><code class="lang-js">const longestCommonPrefix = (strs) =&gt; {
  if (strs.length === 0) return &#39;&#39;;

  const commonPrefix = (lcpLeft, lcpRight) =&gt; {
    const len = Math.min(lcpLeft.length, lcpRight.length);

    for (let i = 0; i &lt; len; i++) {
      if (lcpLeft[i] !== lcpRight[i]) {
        return lcpLeft.slice(0, i);
      }
    }

    return lcpLeft.slice(0, len);
  }

  const lcp = (start, end) =&gt; {
    if (start === end) return strs[start];

    const mid = Math.floor((start + end) / 2);
    return commonPrefix(lcp(start, mid), lcp(mid + 1, end));
  }

  return lcp(0, strs.length - 1);
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：通过分治策略的递推公式 <strong>$T(n) = k * T(n / k) + O(n - 1)$</strong><ul><li>其中每个问题每次分治的子问题数为 <code>2</code></li><li>分治 <strong>$logn$</strong> 次得：<strong><script type="math/tex">k = 2 ^ {logn} = n</script></strong></li><li>推导得：<strong>$T(n) = n * T(1) + O(n - 1) = O(n) + O(n - 1) = O(n)$</strong></li><li>因每次子问题执行复杂度为 <strong>$O(m)$</strong>，<code>m</code> 为字符串平均长度，最终可推出时间复杂度为 <strong>$O(m * n)$</strong></li></ul></li><li>空间复杂度：主要取决于递归调用的次数，故为 <strong>$O(logn)$</strong></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>寻找最大公共前缀的过程中有一点在其他的实现方式中也有应用，就是最大前缀的长度一定不会超过最短的字符串的长度，那是不是可以高效的在 <strong>$[0, minLength]$</strong> 范围中尝试寻找最大前缀长度的范围？</p><p>我们粗略的把最短的字符串不断的分成两个范围，一个是已经确定是公共前缀的范围，一个是未确定公共前缀的范围，然后不断的去在未确定公共前缀的范围中寻找边界，不断的缩短未知的范围直到找到最大公共前缀。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220428135918/binary.png" alt="二分查找示意图"></div><div class="image-caption">二分查找示意图</div></figure><p><br></p><p>此时我们就可以通过二分查找法来实现，设置变量 <code>low</code> 和 <code>high</code> 指向未知范围的起点和终点，通过起点终点求出中间点 <code>mid</code>，此时两个范围 <strong>$[low, mid)$</strong> 和 <strong>$[mid, high)$</strong></p><ul><li>被确定为公共前缀，则让 <code>low</code> 指定到 <code>mid</code> 所在的位置缩小未知范围；</li><li>被确定不是公共前缀，则让 <code>high</code> 指定到 <code>mid - 1</code> 的位置缩小未知范围；</li><li>直到 <code>low</code> 和 <code>hight</code> 重叠或相交，数组中任何一个字符串的 <strong>$[0, low)$</strong> 就是最大公共前缀。</li></ul><pre><code class="lang-js">const longestCommonPrefix = (strs) =&gt; {
  if (strs.length === 0) return &#39;&#39;;

  const isCommonPrefix = (strs, len) =&gt; {
    const [first, ...other] = strs;
    return other.every((str) =&gt; first.slice(0, len) === str.slice(0, len));
  }

  let low = 0;
  let high = strs.reduce((min, str) =&gt; Math.min(min, str.length), Infinity);

  while (low &lt; high) {
    const mid = Math.ceil((low + high) / 2);

    if (isCommonPrefix(strs, mid)) {
      low = mid;
    } else {
      high = mid - 1;
    }
  }

  return strs[0].slice(0, low);
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>n</code> 为字符串数组的规模，<code>m</code> 字符串的平均长度，二分查找迭代次数为 <strong>$O(logm)$</strong>，每次判断是否是公共前缀需要执行 <strong>$O(m * n)$</strong> 次，故为 <strong>$O(mnlogm)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 48 —— 旋转图像</title>
    <url>/20220422115115/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-image/</a></li><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像，请你将图像顺时针旋转 <code>90</code> 度。你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵，请不要使用另一个矩阵来旋转图像。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/mat3x3.jpeg" title="示例 1"><p><br></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code><br><strong>输出：</strong> <code>[[7, 4, 1], [8, 5, 2], [9, 6, 3]]</code></p></blockquote><p><strong>示例 2：</strong></p><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/mat4x4.jpeg" title="示例 2"><p><br></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]</code><br><strong>输出：</strong> <code>[[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="使用辅助矩阵"><a href="#使用辅助矩阵" class="headerlink" title="使用辅助矩阵"></a>使用辅助矩阵</h3><p>虽然题目要求 <strong>原地</strong> 算法，不能使用辅助矩阵，我们为了更好的理解元素旋转前和旋转后的关系，先使用辅助矩阵实现旋转。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/rotate.png" alt="旋转示意图"></div><div class="image-caption">旋转示意图</div></figure><p><br></p><p>其实我们主要理解的是当前行 <code>i</code> 和当前列 <code>j</code> 在旋转后的变化关系，如上图，第一行旋转完后变成了倒数第一列，第二行旋转后变成了倒数第二列，依次类推。</p><p>对于 <code>n x n</code> 矩阵的一个元素 <strong>$matrix[i][j]$</strong> 而言，旋转后列的值 <code>j</code> 转换成了行的值，旋转后列的值变成了倒数第 <code>i</code> 列，即 <code>n - 1 - i</code> 列。</p><blockquote class="pullquote success"><p><strong>我们假设 <code>row</code> 代表行，<code>col</code> 代表列，则可以总结出公式：</strong></p><ul><li><strong><script type="math/tex">row_{旋转后} = col_{旋转前}</script></strong></li><li><strong><script type="math/tex">col_{旋转后} = n - row_{旋转前} - 1</script></strong></li></ul><p><strong>推出：$matrix[i][j] → matrix[j][n - i - 1]$</strong></p></blockquote><pre><code class="lang-js">const rotate = (matrix) =&gt; {
  const n = matrix.length;
  const newMatrix = Array(n).fill(0).map(() =&gt; Array(n).fill(0));

  for (let i = 0; i &lt; n; i++) {
    for (let j = 0; j &lt; n; j++) {
      newMatrix[j][n - i -1] = matrix[i][j];
    }
  }

  for (let i = 0; i &lt; n; i++) {
    for (let j = 0; j &lt; n; j++) {
      matrix[i][j] = newMatrix[i][j];
    }
  }
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(n ^ 2)$</strong></li><li>空间复杂度：因为需要使用 <code>n x n</code> 的辅助矩阵，故为 <strong>$O(n ^ 2)$</strong></li></ul><h3 id="原地旋转"><a href="#原地旋转" class="headerlink" title="原地旋转"></a>原地旋转</h3><p>上一种方法之所以需要辅助矩阵来完成是因为都是整行转换成整列，如果使用这样的方式原地旋转第二行时最后一个元素的值就是已经不是原值了。</p><p>其实我们可以把一个 <code>n x n</code> 的矩阵分成四个区块，每次都将四个区块相对应位置的元素进行旋转互换即可，区块划分如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/4x4.png" alt="n 为偶数"></div><div class="image-caption">n 为偶数</div></figure><p><br></p><p>当 <code>n</code> 为偶数时，需要枚举 <strong>$n ^ 2 / 4 = (n / 2) * (n / 2)$</strong> 次，以 <code>4 x 4</code> 的矩阵为例。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/5x5.png" alt="n 为奇数"></div><div class="image-caption">n 为奇数</div></figure><p><br></p><p>当 <code>n</code> 为奇数时，需要枚举 <strong>$(n ^ 2 - 1) / 4 = ((n - 1) / 2) * ((n + 1) / 2)$</strong>，以 <code>5 x 5</code> 的矩阵为例，最中心的元素不需要遍历。</p><p>根据 <strong><script type="math/tex">row_{旋转后} = col_{旋转前}</script></strong>和 <strong><script type="math/tex">col_{旋转后} = n - row_{旋转前} - 1</script></strong>可推导出每次遍历需要旋转的四个位置的元素如下：</p><blockquote class="pullquote warning"><ul><li><strong>左上区块：$matrix[i][j]$</strong></li><li><strong>右上区块：$matrix[j][n - i - 1]$</strong></li><li><strong>右下区块：$matrix[n - i - 1][n - j - 1]$</strong></li><li><strong>左下区块：$matrix[n - j - 1][i] = matrix[n - j - 1][n - (n - i - 1) - 1]$</strong></li></ul></blockquote><p>找到了每次遍历四个元素的位置，则可以通过一个中间变量 <code>tmp</code> 帮助四个元素完成旋转互换，过程如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/rotate.gif" alt="原地旋转执行过程"></div><div class="image-caption">原地旋转执行过程</div></figure><p><br></p><pre><code class="lang-js">const rotate = (matrix) =&gt; {
  const n = matrix.length;

  for (let i = 0; i &lt; Math.floor(n / 2); i++) {
    for (let j = 0; j &lt; Math.floor((n + 1) / 2); j++) {
      const tmp = matrix[i][j];

      matrix[i][j] = matrix[n - j - 1][i];
      matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
      matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
      matrix[j][n - i - 1] = tmp;
    }
  }
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：枚举的子矩阵复杂度为 <strong>$O((n / 2) * ((n + 1) / 2))$</strong>，故为 <strong>$O(n ^ 2)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul><h3 id="上下翻转-左对角线翻转"><a href="#上下翻转-左对角线翻转" class="headerlink" title="上下翻转 + 左对角线翻转"></a>上下翻转 + 左对角线翻转</h3><p>其实 <strong>原地</strong> 算法不仅仅原地旋转一种方式，我们可以通过如下方式实现旋转 <code>90</code> 度的操作：</p><blockquote class="pullquote warning"><ul><li><strong>上下翻转 + 左对角线翻转</strong></li><li><strong>左对角线翻转 + 左右翻转</strong></li><li><strong>左右翻转 + 右对角线翻转</strong></li><li><strong>右对角线翻转 + 上下翻转</strong></li></ul></blockquote><p>因为矩阵使用的数据结构是一个二维数组，所以为了便于程序的编写，我们选择先 <strong>上下翻转</strong>，再 <strong>左对角线翻转</strong>，过程如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220422115115/diagonal.png" alt="上下翻转 + 左对角线翻转示意图"></div><div class="image-caption">上下翻转 + 左对角线翻转示意图</div></figure><p><br></p><p>左对角线翻转的实现逻辑就是把第 <code>i</code> 行的第 <code>j</code> 列换到第 <code>j</code> 行的第 <code>i</code> 列，最重要的是要控制交换次数以防止重复交换。</p><p>遍历是从行开始的，应以 <code>i</code> 为基准，所以 <code>j</code> 的值一定要小于 <code>i</code>，即列的遍历次数随着行的增加而递增。</p><pre><code class="lang-js">const rotate = (matrix) =&gt; {
  const n = matrix.length;
  matrix.reverse();

  for (let i = 0; i &lt; n; i++) {
    for (let j = 0; j &lt; i; j++) {
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：上下翻转的时间复杂度为 <strong>$O(n)$</strong>，对角线翻转的的时间复杂度为 <strong>$O(n ^ 2)$</strong>，故为 <strong>$O(n ^ 2)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 73 —— 矩阵置零</title>
    <url>/20220421115308/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/set-matrix-zeroes/</a></li><li><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zero-matrix-lcci/</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地</strong> 算法。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220421115308/mat3x3.jpeg" title="示例 1"><p><br></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]</code><br><strong>输出：</strong> <code>[[1, 0, 1], [0, 0, 0], [1, 0, 1]]</code></p></blockquote><p><strong>示例 2：</strong></p><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220421115308/mat4x3.jpeg" title="示例 2"><p><br></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]</code><br><strong>输出：</strong> <code>[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="辅助行和列"><a href="#辅助行和列" class="headerlink" title="辅助行和列"></a>辅助行和列</h3><p>通过上图案例，其实我们可以把矩阵看做一个表格，整个矩阵是表格的内容，那我们其实可以通过给为 <code>0</code> 的元素所在的行和列进行标记，可以给表格横向和纵向分别增加一行和一列来存储标记。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220421115308/add-row-col.png" alt="辅助行和列示意图"></div><div class="image-caption">辅助行和列示意图</div></figure><p><br></p><p>我们定义行或列存在值为 <code>0</code> 的元素，标记为 <code>true</code>，否则为 <code>false</code>，我们假设矩阵中不包含 <code>0</code>，存储标记行和列的默认值都为 <code>false</code>，只需要遍历矩阵的每一个元素，如果值 <code>0</code>，则将该元素的行标记和列标记都改为 <code>true</code>。</p><p>根据题目要求，只要元素所在行或列存在 <code>0</code>，即行或列的标记有存在 <code>true</code> 标记，我们就将这一项设置为 <code>0</code>，所以只需再次遍历矩阵根据条件将值设置一遍即可。</p><pre><code class="lang-js">const setZeroes = (matrix) =&gt; {
  const m = matrix.length;
  const n = matrix[0].length;
  const row = new Array(m).fill(false);
  const col = new Array(n).fill(false);

  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (matrix[i][j] === 0) {
        matrix[0][j] = matrix[i][0] = true;
      }
    }
  }

  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (row[i] || col[j]) {
        matrix[i][j] = 0;
      }
    }
  }
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(m * n)$</strong></li><li>空间复杂度：由于创建了行和列的两个辅助数组，空间复杂度为 <strong>$O(m + n)$</strong>。</li></ul><h3 id="原地算法"><a href="#原地算法" class="headerlink" title="原地算法"></a>原地算法</h3><p>其实题目中明确要求使用 <strong>原地</strong> 算法，其实就是不使用额外的空间，完成值的置零操作。</p><p>在上一个方法基础上延伸思考，如果不能增加额外的行和列来进行标识，那是不是可以用默认的第一行和第一列来标识，假设遍历的某一项值为 <code>0</code>，将所在行和列的第一项进行置零并作为行或列的参考标识，全部标识后再次遍历矩阵，根据标识更改需要置零的元素。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220421115308/in-place.png" alt="原地算法示意图"></div><div class="image-caption">原地算法示意图</div></figure><p><br></p><blockquote class="pullquote warning"><p><strong>遍历过程中，以第一列为基准，所以遍历列时应从第一项开始，在置零过程中，防止用于标识的行和列原本就有 <code>0</code> 第一列优先被置零，导致后边元素无法参照标识，所以遍历行时使用反向遍历。</strong></p></blockquote><pre><code class="lang-js">const setZeroes = (matrix) =&gt; {
  const m = matrix.length;
  const n = matrix[0].length;
  let flag = false;

  for (let i = 0; i &lt; m; i++) {
    if (matrix[i][0] === 0) {
      flag = true;
    }

    for (let j = 1; j &lt; n; j++) {
      if (matrix[i][j] === 0) {
        matrix[0][j] = matrix[i][0] = 0;
      }
    }
  }

  for (let i = m - 1; i &gt;= 0; i--) {
    for (let j = 1; j &lt; n; j++) {
      if (matrix[0][j] === 0 || matrix[i][0] === 0) {
        matrix[i][j] = 0;
      }
    }

    if (flag) {
      matrix[i][0] = 0;
    }
  }
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(m * n)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35 —— 搜索插入位置</title>
    <url>/20220420162619/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 <strong>$O(logn)$</strong> 的算法。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1, 3, 5, 6]</code>, <code>target = 5</code><br><strong>输出：</strong> <code>2</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1, 3, 5, 6]</code>, <code>target = 2</code><br><strong>输出：</strong> <code>1</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1, 3, 5, 6]</code>, <code>target = 7</code><br><strong>输出：</strong> <code>-1</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在正常思路下只要遍历一次就能直接找到 <code>target</code> 项对应的索引，时间复杂度为 <strong>$O(n)$</strong>，但是题目要求时间复杂度 <strong>$O(logn)$</strong>，所以应该使用 <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分查找法</a> 来解决该问题。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420162619/bsearch.gif" alt="示意图"></div><div class="image-caption">示意图</div></figure><p><br></p><p>什么是二分查找呢？举一个例子，就比如我们在英文字典查一个单词，翻开字典我们就能通过单词的开头字母确认在字典的前半部分还是后半部分，如果在前半部分，那么后半部分就都不需要查看了，重复这个动作直到找到单词所在的页码为止。</p><blockquote class="pullquote info"><p><strong>所以，使用二分查找的前提是，集合一定是有序排列的。</strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420162619/execute.gif" alt="执行过程"></div><div class="image-caption">执行过程</div></figure><p><br></p><p>回到题目本身，想要从中间将数组一分为二则需要一个指针 <code>mid</code> 指向当前保留集合的中间（让值是整数通常向下取整），同时需要左右两个边界指针 <code>left</code> 和 <code>right</code>，并在每次查找时动态变更。</p><p>若数组中没有查找到 <code>target</code>，则 <code>left</code> 和 <code>right</code> 指针最终会 <strong>重合</strong>（最后一次移动左侧指针）或 <strong>交叉</strong>（最后一次移动右侧指针，且左侧指针和中间指针重合），所以插入的位置应为左侧指针（向下取整的情况下）的位置。</p><p><strong>循环版本：</strong></p><pre><code class="lang-js">const searchInsert = (nums, target) =&gt; {
  let left = 0;
  let right = nums.length - 1;
  let mid;

  while (left &lt;= right) {
    mid = Math.floor((left + right) / 2);

    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return left;
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(logn)$</strong>；</li><li>空间复杂度：<strong>$O(1)$</strong>。</li></ul><p>大部分情况下循环和递归都可以互相转换，原因是循环体内部和递归的函数本身都是在解决一类问题的子问题。</p><p><strong>递归版本：</strong></p><pre><code class="lang-js">const searchInsert = (
  nums,
  target,
  left = 0,
  right = nums.length - 1
) =&gt; {
  if (left &gt; right) return left;

  const mid = Math.floor((left + right) / 2);

  if (nums[mid] === target) return mid;

  return mid &lt; nums[mid]
    ? searchInsert(nums, target, mid + 1, right)
    : searchInsert(nums, target, left, mid - 1);
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(logn)$</strong>；</li><li>空间复杂度：在使用语言存在 <a href="https://zh.wikipedia.org/zh-hans/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">尾递归</a> 优化时为 <strong>$O(1)$</strong>，否则为 <strong>$O(logn)$</strong>。</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 498 —— 对角线遍历</title>
    <url>/20220420110547/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diagonal-traverse/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code>，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/example.jpeg" alt="遍历路径"></div><div class="image-caption">遍历路径</div></figure><p><br></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code><br><strong>输出：</strong> <code>[1, 2, 4, 7, 5, 3, 6, 8, 9]</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>mat = [[1, 2], [3, 4]]</code><br><strong>输出：</strong> <code>[1, 2, 3, 4]</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题目描述不难分析出遍历对角线的元素时，偶数列为反方向遍历，奇数列为正方向遍历，如果全使用正方向遍历，则存储偶数列的数组只需要做翻转就可以更正顺序。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/diagonal.png" alt="正方向遍历"></div><div class="image-caption">正方向遍历</div></figure><p><br></p><p>已知矩阵共有 <code>m</code> 行和 <code>n</code> 列，通过正方向遍历图可知总共的遍历次数为 <strong>$m + n - 1$</strong> 次，其中到达拐点 <strong>$n - 1$</strong> 之前，<code>row</code> 一直为 <code>0</code>，列 <code>col</code> 递增，拐点之后，<code>col</code> 不变，<code>row</code> 开始递增。</p><p>在每次遍历时要沿着对角线的方向找到对角线上的所有元素，如果当前项为 <strong>$mat[row][col]$</strong>，则对角线的下一项为 <strong>$mat[row + 1][col - 1]$</strong>，直到边界。</p><p>通过上图不难看出，边界条件限制的其实是 <code>row</code> 和 <code>col</code> 的值，<code>col</code> 不能小于 <code>0</code>，<code>row</code> 不能大于等于 <code>m</code>。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/reverse.png" alt="偶数列翻转"></div><div class="image-caption">偶数列翻转</div></figure><p><br></p><p>当偶数列对角线所有项都遍历后保存，并对保存的列表进行翻转，再依次合并进最终的结果中就可以完成对角线遍历输出结果的顺序要求，实现代码如下：</p><pre><code class="lang-js">const findDiagonalOrder = (mat) =&gt; {
  const result = [];
  const m = mat.length;
  const n = mat[0].length;
  const index = n - 1;
  let row = 0;
  let col = 0;

  for (let i = 0; i &lt; m + n - 1; i++) {
    const diagonal = [];
    const inflexed = i &gt; index;
    row = inflexed ? i - index : 0;
    col = inflexed ? index : i;

    while (row &lt; m &amp;&amp; col &gt;= 0) {
      diagonal.push(mat[row][col]);
      row++;
      col--;
    }

    if (i % 2 === 0) {
      diagonal.reverse();
    }

    result.push(...diagonal);
  }

  return result;
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：由于矩阵的每一个点都遍历到，并且不存在重复遍历，所以时间复杂度为 <strong>$O(m * n)$</strong>；</li><li>空间复杂度：由于存储对角线元素的个数最大为 <code>m</code> 和 <code>n</code> 的最小值，空间复杂度为 <strong>$O(min(m, n))$</strong>。</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 56 —— 合并区间</title>
    <url>/20220418231027/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <strong>$intervals[i] = [start_i, end_i]$</strong>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>intervals = [[1, 3], [2, 6], [8, 10], [15 ,18]]</code><br><strong>输出：</strong> <code>[[1, 6], [8, 10], [15, 18]]</code><br><strong>解释：</strong> 区间 <code>[1, 3]</code> 和 <code>[2, 6]</code> 重叠, 将它们合并为 <code>[1, 6]</code>。</p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>intervals = [[1, 4], [4, 5]]</code><br><strong>输出：</strong> <code>[[1, 5]]</code><br><strong>解释：</strong> 区间 <code>[1, 4]</code> 和 <code>[4, 5]</code> 可被视为重叠区间。</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>假设区间的起点是无序的，在对比区间右端点和另一个区间的左端点时，可能会出现本应该合并的区间因为对比顺序的错误而导致矛盾，所以区间一定是要按照左端点或者右端点的其中一个值进行有序排列的。</p><p>如果按照区间的左端点升序排序，那么在排序完的列表中，可以合并的区间一定是连续的，如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220418231027/sort.png" alt="左端点排序"></div><div class="image-caption">左端点排序</div></figure><p><br></p><p>因此在合并区间之前应该优先进行排序，我们默认使用快排，时间复杂度是 <strong>$O(nlogn)$</strong>，空间复杂度为 <strong>$O(1)$</strong>。在排序后的基础上只需要进行一次线性遍历就可以完成合并的处理，代码如下：</p><pre><code class="lang-js">const merge = (intervals) =&gt; {
  const result = [];

  if (intervals.length &gt; 0) {
    intervals.sort((a, b) =&gt; a[0] - b[0]);
    let prev = intervals[0];

    for (let i = 1; i &lt; intervals.length; i++) {
      const cur = intervals[i];

      if (prev[1] &gt;= cur[0]) {
        prev[1] = Math.max(prev[1], cur[1]);
      } else {
        result.push(prev);
        prev = cur;
      }
    }

    result.push(prev);
  }

  return result;
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(nlogn) + O(n) = O(nlogn)$</strong></li><li>空间复杂度：<strong>$O(1) + O(1) = O(1)$</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 724, 1991 —— 寻找数组中心下标</title>
    <url>/20220418200850/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-pivot-index/</a></li><li><a href="https://leetcode-cn.com/problems/find-the-middle-index-in-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code>，请你找到 <strong>最左边</strong> 的中间位置 <code>middleIndex</code>（也就是所有可能中间位置下标最小的一个）。</p><a id="more"></a><p><strong>中间位置 <code>middleIndex</code> 的数组下标满足：</strong></p><blockquote class="pullquote warning"><p><strong>$nums[0]$ $+$ $nums[1]$ $+$ $…$ $+$ $nums[middleIndex - 1]$ $===$ $nums[middleIndex + 1]$ $+$ $nums[middleIndex + 2]$ $+$ $…$ $+$ $nums[nums.length - 1]$</strong></p></blockquote><p>如果 <code>middleIndex === 0</code>，左边部分的和定义为 <code>0</code>，如果 <code>middleIndex === nums.length - 1</code> ，右边部分的和定义为 <code>0</code>。</p><p>请你返回满足上述条件 <strong>最左边</strong> 的 <code>middleIndex</code>，如果不存在这样的中间位置，请你返回 <code>-1</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [2, 3, -1, 8, 4]</code><br><strong>输出：</strong> <code>3</code><br><strong>解释：</strong><br>下标 <code>3</code> 之前的数字和为：<code>2 + 3 + -1 = 4</code><br>下标 <code>3</code> 之后的数字和为：<code>4 = 4</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1, -1, 4]</code><br><strong>输出：</strong> <code>2</code><br><strong>解释：</strong><br>下标 <code>2</code> 之前的数字和为：<code>1 + -1 = 0</code><br>下标 <code>2</code> 之后的数字和为：<code>0</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [2, 5]</code><br><strong>输出：</strong> <code>-1</code><br><strong>解释：</strong><br>不存在符合要求的 <code>middleIndex</code>。</p></blockquote><p><strong>示例 4：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1]</code><br><strong>输出：</strong> <code>0</code><br><strong>解释：</strong><br>下标 <code>0</code> 之前的数字和为：<code>0</code><br>下标 <code>0</code> 之后的数字和为：<code>0</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>暴力破解就是一边遍历一边通过累加求左侧的和，此时右侧的和未知，再嵌套循环求右侧的总和，如果左右和相等则结束循环直接返回索引，全部遍历完没有找到 <code>middleIndex</code> 则返回 <code>-1</code>。</p><pre><code class="lang-js">const findMiddleIndex = (nums) =&gt; {
  let leftSum = 0;

  for (let i = 0; i &lt; nums.length; i++) {
    let rightSum = 0;

    for (let j = i + 1; j &lt; nums.length; j++) {
      rightSum += nums[j];
    }

    if (leftSum === rightSum) {
      return i;
    }

    leftSum += nums[i];
  }

  return -1;
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(n^2)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>在暴力破解时，之所以会在每一次循环中再次嵌套循环是因为右侧的和未知，如果已知总和为 <code>sum</code>，遍历到当前项的值为 <code>num</code>，遍历累加求出的左侧总和为 <code>leftSum</code>，则可以求出右侧总和 <code>rightSum</code> 得：</p><blockquote class="pullquote success"><p><strong>$rightSum = sum - leftSum - num$</strong></p></blockquote><p>若 <code>leftSum</code> 与 <code>rightSum</code> 相等，则：</p><blockquote class="pullquote info"><p><strong>由：$leftSum = sum - leftSum - num$</strong><br><strong>推出：$2 * leftSum + num = sum$</strong></p></blockquote><p>所以先求出 <code>sum</code>，就可以在遍历过程中通过公式计算的结果判断是否左侧和右侧的总和相等。</p><pre><code class="lang-js">const findMiddleIndex = (nums) =&gt; {
  const sum = nums.reduce((sum, cur) =&gt; sum + cur, 0);
  let leftSum = 0;

  for (let i = 0; i &lt; nums.length; i++) {
    if (2 * leftSum + nums[i] === sum) {
      return i;
    }

    leftSum += nums[i];
  }

  return -1;
}
</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(n)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 获取对象属性名的方法和区别</title>
    <url>/20190417112536/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择：</strong></p><ul><li><strong><code>for in</code></strong></li><li><strong><code>Object.keys</code></strong></li><li><strong><code>Object.getOwnPropertyNames</code></strong></li><li><strong><code>Object.getOwnPropertySymbols</code></strong></li><li><strong><code>Reflect.ownKeys</code></strong></li></ul></blockquote><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><a id="more"></a><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><pre><code class="lang-js">/* 父类，继承自 Object.prototype */
const parent = Object.create(Object.prototype, {
  a: {
    value: 1,
    writable: true,
    enumerable: true,
    configurable: true
  },
  b: {
    value: 2,
    writable: true,
    enumerable: false,
    configurable: true
  },
  [Symbol(&#39;symbolParent&#39;)]: {
    value: 3,
    writable: true,
    enumerable: true,
    configurable: true
  }
});
</code></pre><pre><code class="lang-js">/* 子类，继承自 parent */
const child = Object.create(parent, {
  c: {
    value: 4,
    writable: true,
    enumerable: true,
    configurable: true
  },
  d: {
    value: 5,
    writable: true,
    enumerable: false,
    configurable: true
  },
  [Symbol(&#39;symbolChild&#39;)]: {
    value: 6,
    writable: true,
    enumerable: true,
    configurable: true
  }
});
</code></pre><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><pre><code class="lang-js">for (let k in child) {
  console.log(k);
}

// c
// a
</code></pre><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><pre><code class="lang-js">Object.keys(child);

// [&quot;c&quot;]
</code></pre><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><pre><code class="lang-js">for (let k in child) {
  if (child.hasOwnProperty(k)) {
    console.log(k);
  }
}

// c
</code></pre><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><pre><code class="lang-js">Object.getOwnPropertyNames(child);

// [&quot;c&quot;, &quot;d&quot;]
</code></pre><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><pre><code class="lang-js">Object.getOwnPropertySymbols(child);

// [Symbol(symbolChild)]
</code></pre><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><pre><code class="lang-js">Reflect.ownKeys(child);

// [&quot;c&quot;, &quot;d&quot;, Symbol(symbolChild)]
</code></pre><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 实现一个提交自动检测的 Git Hook</title>
    <url>/20190409024640/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><strong><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</strong></p></blockquote><a id="more"></a><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><blockquote class="pullquote success"><p><strong>本次将使用 <code>Node.js</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</strong></p><ul><li><strong>检测是否为 <code>Git</code> 项目；</strong></li><li><strong>检测邮箱是否符合规格；</strong></li><li><strong>检测代码是否含有冲突；</strong></li><li><strong>自动执行 <code>Eslint</code>，并检测问题。</strong></li></ul></blockquote><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景可能都会对团队项目持续集成的历史 “树” 造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong></p><p>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，很可能邮箱配置错误进行了提交，而推代码到远端时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新推到远端。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>新入职员工刚刚领了新的笔记本或老员工电脑重做系统；</strong></li><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到 <code>rebase</code> 之前的公共 <code>commit</code> 节点。</strong></li></ul></blockquote><p><strong>代码冲突：</strong></p><p>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由对组件进行渲染，项目不会报错。</strong></li></ul></blockquote><p><strong><code>Eslint</code> 检查：</strong></p><p>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p><strong>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</strong></p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><pre class="language-treeview">
  <code class="language-treeview">
    git-hooks
      |- default-events.js
      |- default-rules.js
      |- git-checker.js
      |- pre-commit.js
  </code>
</pre><blockquote class="pullquote info"><ul><li><strong><code>default-events.js</code>：用来编写默认的检测事件；</strong></li><li><strong><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</strong></li><li><strong><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</strong></li><li><strong><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</strong></li></ul></blockquote><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><pre><code class="lang-bash">$ npm install husky
</code></pre><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p><strong>项目中的 <code>husky</code> 配置如下：</strong></p><pre><code class="lang-json">/* 使用 hook 项目的 package.json */
{
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot;
    }
  }
}
</code></pre><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件。</p><p><strong>我们希望使用者的用法如下：</strong></p><pre><code class="lang-js">/* ~git-hooks/pre-commit.js */
const GitChecker = require(&#39;./git-checker&#39;);

const commitChecker = new GitChecker(&#39;pre-commit&#39;, {
  // default event names
  defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;, &#39;conflict&#39;, &#39;eslint&#39;],
  rules: {
    // your costom rules
  },
  checkEvents: {
    // your custom check events
  }
});

commitChecker.checkStart();
</code></pre><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><pre><code class="lang-js">/* ~git-hooks/default-rules.js */
module.exports = {
  emailCheck: /\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/,
  conflictCheck: &#39;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s&#39;
};
</code></pre><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下：</p><pre><code class="lang-js">/* ~git-hooks/git-checker.js */
// 引入依赖
const EventEmitter = require(&#39;events&#39;);
const exec = require(&#39;child_process&#39;).execSync;
const chalk = require(&#39;chalk&#39;);
const defaultRules = require(&#39;./default-rules&#39;);
const defaultEvents = require(&#39;./default-events&#39;);

const { log } = console;

// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit
class GitChecker extends EventEmitter {
  constructor(type, options) {
    super();

    // 防止使用者 options 内部属性传错，进行初始化
    const {
      rules = {},
      defaultEventNames = [],
      checkEvents = {}
    } = options;

    // 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理
    this.rules = Object.assign(defaultRules, rules);

    // 合并用户选择使用的默认检测函数和自定义检测函数
    this.checkEvents = Object.assign(this.getDefaultEvents(defaultEventNames), checkEvents);
    this.type = type; // git 操作类型
    this.isCommit = true; // 当前是否可以被提交
    this.gitConfigEnvs = [&#39;local&#39;, &#39;global&#39;, &#39;system&#39;]; // 取邮箱时的环境

    // 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向
    this.forbiddenCommit = this.forbiddenCommit.bind(this);
    this.init(); // 初始化
  }

  init() {
    // 将检测函数常用方法挂载到实例上
    this.log = log;
    this.exec = exec;
    this.chalk = chalk;

    // 注册当前类型 git 操作对应的检测函数
    this.register(this.type);
  }

  getDefaultEvents(eventsNames) {
    return eventsNames.reduce((memo, eventName) =&gt; {
      memo[eventName + &#39;CheckTask&#39;] = defaultEvents[eventName + &#39;CheckTask&#39;];
      return memo;
    }, {});
  }

  register(type) {
    Object.keys(this.checkEvents).forEach((event) =&gt; {
      // 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法
      this.on(type, () =&gt; this.checkEvents[event](this));
    });
  }

  forbiddenCommit() {
    this.isCommit = false;
  }

  async checkStart() {
    log(chalk.green(&#39;开始代码检测&#39;));

    // 发布执行检测函数
    await this.emit(this.type);

    // 结束后结束当前 git 操作进程
    this.checkEnd();
  }

  checkEnd() {
    // 如果当前状态为不可提交，则退出进程号不为 0（git 规定）
    if (!this.isCommit) process.exit(1);
    log(chalk.green(&#39;检测通过&#39;));
    process.exit(0);
  }
}

module.exports = GitChecker;
</code></pre><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */
exports.isGitCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; {
  // 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目
  try {
    exec(&#39;git status&#39;);
  } catch (e) {
    log(chalk.red(&#39;错误：当前不是一个git项目目录&#39;));
    forbiddenCommit(); // 更改提交状态太为不能提交
  }
};
</code></pre><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p><strong>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</strong></p></blockquote><pre><code class="lang-js">/* ~git-hooks/default-events.js */
exports.emailCheckTask = (checker) =&gt; {
  const checkEmailEnvs = (i) =&gt; {
    // 取出正则和获取 git 邮箱的环境参数集合
    const gitConfigEnvs = checker.gitConfigEnvs;
    const rules = checker.rules;

    // 获取邮箱的 git 命令
    const command = &#39;git config --&#39; + gitConfigEnvs[i] + &#39; user.email&#39;;

    // 如果获取邮箱成功，则校验邮箱是否合规
    try {
      const userEmail = checker.exec(command).toString();
      const isValidate = rules.emailCheck.test(userEmail);

      if (!isValidate) {
        checker.log(checker.chalk.red(&#39;错误：请使用正确的邮箱提交代码&#39;));
        checker.log(checker.chalk.yellow(&#39;你当前的邮箱是：&#39; + userEmail));
        checker.forbiddenCommit();
      } else {
        checker.log(checker.chalk.green(&#39;邮箱校验通过&#39;));
      }
    } catch (e) {
      if (i === gitConfigEnvs.length) {
        checker.log(checker.chalk.red(&#39;错误：请设置git的提交邮箱&#39;));
        checker.forbiddenCommit();
      } else {
        checkEmailEnvs(i + 1);
      }
    }
  };
  checkEmailEnvs(0);
};
</code></pre><blockquote class="pullquote info"><p><strong>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</strong></p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */
exports.conflictCheckTask = (checker) =&gt; {
  // 对文件进行正则匹配的 git 命令
  const command = &#39;git grep -n -P -E &quot;&#39; + rules.conflictCheck + &#39;&quot;&#39;;

  // 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码
  try {
    const conflicts = checker.exec(command, { encoding: &#39;utf-8&#39; });
    if (conflicts) {
      checker.log(checker.chalk.red(&#39;错误：发现冲突，请解决后再提交&#39;));
      checker.log(checker.chalk.red(&#39;错误代码：&#39;));
      checker.log(checker.chalk.red(conflicts.trim()));
      checker.forbiddenCommit();
    }
  } catch (e) {
    checker.log(checker.chalk.green(&#39;未发现冲突&#39;));
  }
};
</code></pre><blockquote class="pullquote warning"><p><strong>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</strong></p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */
exports.eslintCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; {
  try {
    exec(&#39;lint-staged&#39;);
    log(chalk.green(&#39;Eslint 校验通过&#39;));
  } catch (e) {
    log(chalk.red(&#39;错误：Eslint 校验不通过&#39;));
    forbiddenCommit();
  }
};
</code></pre><blockquote class="pullquote default"><p><strong><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</strong></p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之前执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><pre><code class="lang-js">/* ~git-hooks/pre-push.js */
const GitChecker = require(&#39;./git-checker&#39;);

const pushChecker = new GitChecker(&#39;pre-push&#39;, {
  defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;], // default event names
  rules: {
    // your costom rules
  },
  checkEvents: {
    myHook: ({ log, chalk, forbiddenCommit }) =&gt; {
      log(chalk.red(&#39;check prev push&#39;));
      forbiddenCommit();
    }
  }
});

commitChecker.checkStart();
</code></pre><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下：</p><pre><code class="lang-json">/* 使用 hook 项目的 package.json */
{
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot;,
      &quot;pre-push&quot;: &quot;node git-hooks/pre-push&quot;
    }
  }
}
</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p><strong>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址</strong> <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">git-hooks</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Hooks</tag>
        <tag>Git</tag>
        <tag>代码管理/版本控制</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 系列之 Github 团队协作</title>
    <url>/20190327025116/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><strong>尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，基于 <code>Git</code> 的这个局限，<code>Github</code> 就这样诞生了。</strong></p></blockquote><a id="more"></a><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><blockquote class="pullquote success"><ul><li><strong><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</strong></li><li><strong><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</strong></li><li><strong><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</strong></li><li><strong><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</strong></li><li><strong><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</strong></li></ul></blockquote><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><blockquote class="pullquote info"><p><strong>创建组织步骤（如 <code>Github</code> 功能更新请搜索最新教程或自行探索）如下：</strong></p><ul><li><strong>个人信息 <code>setting</code>；</strong></li><li><strong>进入界面点击左侧 <code>Organizations</code>；</strong></li><li><strong>点击右上角 <code>new organization</code>；</strong></li><li><strong>填好组织信息后点击下方 <code>Create organization</code>。</strong></li></ul></blockquote><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中能搜索到的成员进行协同开发、在组织下新建仓库、创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/master-flow.png" alt="主分支开发工作流"></div><div class="image-caption">主分支开发工作流</div></figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/git-flow.png" alt="Git Flow 工作流"></div><div class="image-caption">Git Flow 工作流</div></figure><p><br></p><blockquote class="pullquote default"><ul><li><strong><code>master</code>：专门用来存储正式发布的历史；</strong></li><li><strong><code>develop</code>：作为功能的集成分支，可以多团队、跨迭代同时在 <code>develop</code> 分支集成；</strong></li><li><strong><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</strong></li><li><strong><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>、上线、与 <code>master</code> 进行合并，同时与 <code>develop</code> 进行合并；</strong></li><li><strong><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</strong></li></ul></blockquote><blockquote class="pullquote success"><p><strong>适用团队：对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></p></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后再重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/github-flow.png" alt="Github 工作流"></div><div class="image-caption">Github 工作流</div></figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></p></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/gitlab-flow.png" alt="Gitlab 工作流"></div><div class="image-caption">Gitlab 工作流</div></figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况（公共库）。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><blockquote class="pullquote success"><ul><li><strong><code>base</code>：目标分支；</strong></li><li><strong><code>compare</code>：合并的特性分支。</strong></li></ul></blockquote><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><blockquote class="pullquote warning"><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li><strong>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</strong></li><li><strong>点击 <code>New Issue</code>;</strong></li><li><strong>填写 <code>Issues</code> 的标题及内容；</strong></li><li><strong>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</strong></li></ul></blockquote><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><blockquote class="pullquote primary"><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li><strong>进入项目的 <code>Setting</code> 页面；</strong></li><li><strong>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</strong></li><li><strong>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</strong><ul><li><strong><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</strong></li><li><strong><code>Feature request</code>：用来提出新的需求和功能；</strong></li><li><strong><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</strong></li></ul></li><li><strong>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</strong></li><li><strong>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</strong></li><li><strong>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</strong></li><li><strong>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版；</strong></li><li><strong>点击模版对应的 <code>Get started</code> 快速生成对应的模版。</strong></li></ul></blockquote><blockquote class="pullquote default"><p><strong>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</strong></p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><blockquote class="pullquote success"><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li><strong>进入项目的 <code>Projects</code> 页面；</strong></li><li><strong>点击 <code>Create a project</code>；</strong></li><li><strong>填写项目的名称和描述并点击下方 <code>Create project</code>。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><strong><code>To do</code>：将要完成的任务；</strong></li><li><strong><code>In progress</code>：正在进行中的任务；</strong></li><li><strong><code>Needs review</code>：需要复盘的任务；</strong></li><li><strong><code>Reviewer approved</code>：已经审核通过的任务。</strong></li></ul></blockquote><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><blockquote class="pullquote danger"><p><strong>设置分支保护步骤：</strong></p><ul><li><strong>进入项目的 <code>Setting</code> 页面；</strong></li><li><strong>选中左侧的 <code>Branches</code> 选项；</strong></li><li><strong>点击 <code>Add rule</code> 来添加保护规则；</strong></li><li><strong><code>Branch name pattern</code> 内制定要保护的分支名字；</strong></li><li><strong><code>Rule settings</code> 中可以设置分支保护规则。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>可选规则（可根据项目需求和要保护分支的安全级别多选）如下：</strong></p><ul><li><strong><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</strong><ul><li><strong><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</strong></li><li><strong><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</strong></li><li><strong><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</strong></li></ul></li><li><strong><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</strong><ul><li><strong><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</strong></li></ul></li><li><strong><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</strong></li><li><strong><code>Include administrators</code>：加入管理员执行所有限制的配置。</strong></li></ul></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过文档页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更流行，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件。</strong></p></blockquote>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>代码管理/版本控制</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 系列之实战技及巧注意事项总结</title>
    <url>/20190315115008/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项</strong>。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><pre><code class="lang-git">$ git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2
</code></pre><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><pre><code class="lang-git">$ git add .
$ git commit -m &#39;分离头指针测试&#39;
$ git log
</code></pre><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><strong>分离头指针优缺点：</strong></p><ul><li><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></li><li><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></li></ul></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><pre><code class="lang-git">$ git branch 分支名 分离头指针状态的提交（哈希值）
</code></pre><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><pre><code class="lang-git">$ git commit --amend
</code></pre><blockquote class="pullquote primary"><p><strong><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</strong></p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><pre><code class="lang-git">$ git rebase -i a4d56bb
</code></pre><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">pick 52f3935 add css file
- pick 91bd053 change css
+ reword 91bd053 change css

# Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# ...
</code></pre><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><p><strong>第二个交互界面：</strong></p><pre><code class="lang-diff">- css content
+ add css content

# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
#
# Date:      Tue Mar 19 14:48:22 2019 +0800
#
# interactive rebase in progress; onto a4d56bb
# Last command done (1 command done):
#    reword 9e4f711 add css content
# Next command to do (1 remaining command):
#    pick c220cf2 change css
# You are currently editing a commit while rebasing branch &#39;test&#39; on &#39;a4d56bb&#39;.
#
# Changes to be committed:
#       new file:   index.css
</code></pre><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><p><strong>修改 commit 后的提示信息：</strong></p><pre><code class="lang-bash">[detached HEAD de48b04] add css content
 Date: Tue Mar 19 14:48:22 2019 +0800
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 index.css
Successfully rebased and updated refs/heads/test.
</code></pre><blockquote class="pullquote success"><p><strong>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</strong></p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><p><strong>查看历史：</strong></p><pre><code class="lang-git">$ git log --oneline
</code></pre><pre><code class="lang-bash"># edd2400 (HEAD -&gt; test) add content to readme
# 50a015c add background css
# 15237d2 change css
# 4a8fd80 add css content
# 5149bad new READ.md
# 7f73a76 new html
</code></pre><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">pick 4a8fd80 add css content
- pick 15237d2 change css
- pick 50a015c add background css
+ squash 15237d2 change css
+ squash 50a015c add background css
pick edd2400 add content to readme

# Rebase 5149bad..edd2400 onto 5149bad (4 commands)
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# ...
</code></pre><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><p><strong>第二个交互界面：</strong></p><pre><code class="lang-diff"># This is a combination of 3 commits.
+
+ css changes
+
# This is the 1st commit message:

add css content

# This is the commit message #2:

change css

# This is the commit message #3:

add background css

# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
#
# Date:      Tue Mar 19 14:48:22 2019 +0800
#
# interactive rebase in progress; onto 5149bad
# Last commands done (3 commands done):
#    squash 15237d2 change css
#    squash 50a015c add background css
# Next command to do (1 remaining command):
#    pick edd2400 add content to readme
# You are currently rebasing branch &#39;test&#39; on &#39;5149bad&#39;.
#
# Changes to be committed:
#       new file:   index.css
</code></pre><p><strong>查看合并提交后的历史：</strong></p><pre><code class="lang-git">$ git log --oneline
</code></pre><pre><code class="lang-bash"># 2c84584 (HEAD -&gt; test) add content to readme
# ac001bc css changes
# 5149bad new READ.md
# 7f73a76 new html
</code></pre><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><p><strong>查看历史：</strong></p><pre><code class="lang-git">$ git log --oneline
</code></pre><pre><code class="lang-bash"># 23d6939 (HEAD -&gt; test) append content into readme
# 178ea29 link css in html
# 2c84584 add content to readme
# ac001bc css changes
# 5149bad new READ.md
# 7f73a76 new html
</code></pre><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><p><strong>执行命令：</strong></p><pre><code class="lang-git">$ git rebase -i 7f73a76
</code></pre><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">+ pick 7f73a76
+ squash 178ea29 link css in html
pick 4a8fd80 add css content
pick 5149bad new READ.md
pick ac001bc css changes
pick 2c84584 add content to readme
- pick 178ea29 link css in html
pick 23d6939 append content into readme

# Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# ...
</code></pre><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><p><strong>提示信息：</strong></p><pre><code class="lang-bash">The previous cherry-pick is now empty, possibly due to conflict resolution.
If you wish to commit it anyway, use:

    git commit --allow-empty

Otherwise, please use &#39;git reset&#39;
interactive rebase in progress; onto 7f73a76
Last command done (1 command done):
   pick 7f73a76
Next commands to do (5 remaining commands):
   squash 178ea29 link css in html
   pick 5149bad new READ.md
You are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;.

nothing to commit, working tree clean
Could not apply 7f73a76...
</code></pre><p><strong>执行 <code>git status</code> 提示信息：</strong></p><pre><code class="lang-bash">Last command done (1 command done):
   pick 7f73a76
Next commands to do (5 remaining commands):
   squash 178ea29 link css in html
   pick 5149bad new READ.md
  (use &quot;git rebase --edit-todo&quot; to view and edit)
You are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;.
  (all conflicts fixed: run &quot;git rebase --continue&quot;)

nothing to commit, working tree clean
</code></pre><p><strong>想继续合并：</strong></p><pre><code class="lang-git">$ git rebase --continue
</code></pre><p><strong>想还原回合并之前：</strong></p><pre><code class="lang-git">$ git rebase --abort
</code></pre><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><p><strong>查看合并后的历史：</strong></p><pre><code class="lang-git">$ git log --oneline
</code></pre><pre><code class="lang-bash"># 4d4f771 (HEAD -&gt; test) append content into readme
# a83f526 add content to readme
# 463fd85 css changes
# 7e44e19 new READ.md
# 753ebcd about html changes
</code></pre><blockquote class="pullquote warning"><p><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><pre><code class="lang-git">$ git reset --hard 版本号
</code></pre><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><pre><code class="lang-git">$ git reflog
$ git reset --hard 已删除的版本号
</code></pre><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置忽略上传的文件。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><p><strong>先将要忽略的文件添加到 <code>.gitignore</code>，然后执行下面命令对之前添加的文件进行删除操作。</strong></p><pre><code class="lang-git">$ git rm --cached 文件名/文件夹
</code></pre><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><blockquote class="pullquote success"><p><strong>当前代码跟要修复代码在同一条分支：</strong></p><ul><li><strong>将当前代码暂存；</strong></li><li><strong>修复代码后合并到 dev 发布测试环境验证，通过后发布；</strong></li><li><strong>恢复暂存代码继续开发；</strong></li></ul><pre><code class="lang-git">$ git stash
$ git stash pop
</code></pre></blockquote><blockquote class="pullquote info"><p><strong>当前代码跟要修复的代码不在同一条分支：</strong></p><ul><li><strong>提交当前分支代码；</strong></li><li><strong>切换到 <code>master</code> 分支创建一条新分支；</strong></li><li><strong>修复问题并提测；</strong></li><li><strong>验证通过后合并到 <code>master</code> 或 <code>dev</code> 分支发布；</strong></li><li><strong>回到开发新功能 <code>feature</code> 分支将修复代码（<code>hotfix</code>）集成进来并继续开发。</strong></li></ul><pre><code class="lang-git">$ git add .
$ git commit -m &#39;message&#39;

$ git checkout master
$ git checkout -b 修复问题分支

$ git checkout 测试分支
$ git merge 修复问题分支

$ git checkout 开发分支
$ git rebase 测试分支
</code></pre></blockquote><p>当然上面的思路仅供参考，因为不同的团队规范有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><p><strong>推送代码时的错误信息：</strong></p><pre><code class="lang-bash">error: failed to push some refs to &#39;git@github.yourRepository.git&#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code>（因为有些团队比较喜欢线性的提交记录以便追溯）操作，而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote default"><p><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></p></blockquote><p><strong>合并不相关的树：</strong></p><pre><code class="lang-git">$ git merge 本地分支 --allow-unrelated-histories 远端分支
</code></pre><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><p><strong>同步新分支信息：</strong></p><pre><code class="lang-git">$ git fetch 地址别名
</code></pre><p><strong>查看新分支：</strong></p><pre><code class="lang-git">$ git branch -av
</code></pre><p><strong>拉取新分支到本地：</strong></p><pre><code class="lang-git">$ git checkout -b 新分支名 地址别名/新分支名
</code></pre><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目贡献代码或修复 <code>Issue</code> 时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><p><strong>撤销本地新的提交：</strong></p><pre><code class="lang-git">$ git reset 与远端相同的提交
</code></pre><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><p><strong>合并后报错：</strong></p><pre><code class="lang-bash">...
Auto-merging yourfile
CONFLICT (content): Merge conflict in yourfile
Automatic merge failed; fix conflicts and then commit the result.
</code></pre><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></li><li><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><p><strong>撤销合并：</strong></p><pre><code class="lang-git">$ git merge --abort
</code></pre><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><pre><code class="lang-git">$ git rm oldfilename
$ git add newfilename
$ git commit -m &#39;merge message&#39;
$ git push
</code></pre><blockquote class="pullquote success"><p><strong>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过</strong> <a href="/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> <strong>对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</strong></p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p><strong>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</strong></p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p><strong>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</strong></p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令：</p><pre><code class="lang-git">$ git pull --rebase
</code></pre><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下：</p><pre><code class="lang-git">$ git fetch
$ git rebase 地址别名/分支名
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p><strong>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读</strong> <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>代码管理/版本控制</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 系列之 .git 内部刨析</title>
    <url>/20190310233856/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><p><strong><code>HEAD</code> 文件内容：</strong></p><pre><code class="lang-vim">ref: refs/heads/master
</code></pre><blockquote class="pullquote info"><p><strong><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支操作时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</strong></p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><p><strong><code>config</code> 文件基本内容：</strong></p><pre><code class="lang-vim">[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[user]
    name = yourname
    email = youremail
</code></pre><blockquote class="pullquote warning"><p><strong><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</strong></p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><p><strong>查看 <code>heads</code> 文件夹：</strong></p><pre><code class="lang-bash">$ ls -al .git/refs/heads
# drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .
# drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..
# -rw-r--r--  1 systemname  staff   41  2 24 17:31 master
</code></pre><p><strong>查看分支文件：</strong></p><pre><code class="lang-bash">$ cat .git/refs/tags/master
# ef5aaed0707989ebc069efcd842424f6315ab4e2
</code></pre><pre><code class="lang-git">$ git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2
# commit
</code></pre><blockquote class="pullquote primary"><p><strong>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</strong></p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><p><strong>查看 <code>tags</code> 文件夹：</strong></p><pre><code class="lang-bash">$ ls -al .git/refs/tags
# drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .
# drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..
# -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0
</code></pre><p><strong>查看标签文件：</strong></p><pre><code class="lang-bash">$ cat .git/refs/tags/1.0.0
# ef5aaed0707989ebc069efcd842424f6315ab4e2
</code></pre><pre><code class="lang-git">$ git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2
# object bcadbfea5e937e9b5eaed113dd8149c86124d72a
# type commit
# tag 1.0.0
# tagger yourusername &lt;youruseremail&gt; 1550212832 +0800

$ git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a
# commit
</code></pre><blockquote class="pullquote success"><p><strong>可以使用 <code>git cat-file</code> 命令查看文件对象类型。</strong></p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><pre><code class="lang-bash">$ ls -al .git/objects
# drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .
# drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..
# drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00
# ...
# drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9
# drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info
# drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack
</code></pre><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><strong><code>Git</code> 对象：</strong></p><ul><li><strong><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</strong></li><li><strong><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</strong></li><li><strong><code>commit</code>：存储提交的相关信息。</strong></li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象以及它们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190310233856/git-objects.png" alt="tree、commit、blob 关系图"></div><div class="image-caption">tree、commit、blob 关系图</div></figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><strong><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</strong></p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个生命周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><p><strong>例如下面文件：</strong></p><pre><code class="lang-bash"># ...
pre-commit.sample # 提交前执行
pre-push.sample # 推送前执行
pre-rebase.sample # 变基前执行
# ...
</code></pre><blockquote class="pullquote danger"><p><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></p></blockquote>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>代码管理/版本控制</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack4 —— 应用篇</title>
    <url>/20181115105656/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181115105656/webpack-use.jpg" title="webpack use"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181002041434/" target="_blank">Webpack4 —— 基础篇</a></li><li><a href="/20181110203121/" target="_blank">Webpack4 —— 优化篇</a></li></ul></blockquote><h2 id="多页面打包通用方案"><a href="#多页面打包通用方案" class="headerlink" title="多页面打包通用方案"></a>多页面打包通用方案</h2><h3 id="多页面应用简介"><a href="#多页面应用简介" class="headerlink" title="多页面应用简介"></a>多页面应用简介</h3><blockquote class="pullquote info"><p><strong>多页面（<code>MPA</code>）和单页面（<code>SPA</code>）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 <code>.html</code> 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote danger"><p><strong>多页面的优势是页面与页面之间是相互解耦的，对 <code>SEO</code> 更加友好，缺点是每次新增或删除页面都需要更改构建的配置。</strong></p></blockquote><h3 id="基础的多页面配置"><a href="#基础的多页面配置" class="headerlink" title="基础的多页面配置"></a>基础的多页面配置</h3><pre><code class="lang-js">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
  entry: {
    admin: path.resolve(__dirname. &#39;src/pages/admin/index.js&#39;),
    search: path.resolve(__dirname. &#39;src/pages/search/index.js&#39;)
  },
  output: {
    filename: &#39;[name][chunkhash:8].js&#39;,
    path: &#39;./dist&#39;
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: &#39;./src/index.html&#39;, // 模板文件路径
      filename: &#39;index.html&#39;, // 输出文件名称
      // ...
    }),
    new HtmlWebpackPlugin({
      template: &#39;./src/search.html&#39;,
      filename: &#39;search.html&#39;,
      // ...
    }),
  ]
  // ...
}
</code></pre><p>上面是一个基础的多页面配置，如果开发过程成页面的增加非常快速，且多人同时开发，这样每增加一个页面都需要在 <code>entry</code> 中增加一个入口，在 <code>plugins</code> 中增加一个 <code>HtmlWebpackPlugin</code> 插件的实例，这样的维护方式并不优雅。</p><p>我们更希望增加页面时不需要更改 <code>Webpack</code> 配置文件，而是可以动态的向 <code>entry</code> 和 <code>plugins</code> 中添加配置。</p><h3 id="动态的多页面配置"><a href="#动态的多页面配置" class="headerlink" title="动态的多页面配置"></a>动态的多页面配置</h3><p>按照上面的优化思路，我们需要在 <code>Webpack</code> 配置中读取本地某一个固定目录的文件，以知道有哪些页面需要配置，当然我们可以使用 <code>fs</code> 模块自己实现，在这里更推荐使用 <code>glob</code> 模块，<code>glob</code> 模块可以通过通配符的方式按照定义的规则去匹配文件目录。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install glob html-webpack-plugin -D
</code></pre><p><strong>动态生成页面配置：</strong></p><pre><code class="lang-js">const path = require(&#39;path&#39;);
const glob = require(&#39;glob&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

const setMPA = () =&gt; {
  const entry = {};
  const htmlPlugins = [];

  const pathMatch = path.resolve(__dirname, &#39;./src/pages/*/index.js&#39;)
  const entryFiles = glob.sync(pathMatch);

  entryFiles.map((pagePath) =&gt; {
    const pageName = pagePath.match(/.*\/(.*)\/index.js/)[1];
    entry[pageName] = pagePath;

    htmlPlugins.push(new HtmlWebpackPlugin({
      template: &#39;./src/pages/&#39; + pageName + &#39;/index.html&#39;, // 模板文件路径
      filename: pageName + &#39;.html&#39;, // 输出文件名称
      chunks: [pageName], // 使用的 chunk 名称
      inject: true, // 将 js 资源放在 body 底部
      minify: {
        collapseWhitespace: true, // 是否删除空白符与换行符
        removeAttributeQuotes: true, // 是否移除引号
        minifyCSS: true, // 压缩 CSS
        minifyJS: true, // 压缩 JS
        removeComments: true // 是否移除 HTML 中的注释
      }
    }));
  });

  return {
    entry,
    htmlPlugins
  };
}

module.exports = setMPA();
</code></pre><p>首先我们创建一个模块，模块中创建 <code>setMPA</code> 函数专门用来对页面进行动态化处理，函数返回 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的实例，首先通过 <code>glob</code> 的 <code>sync</code> 同步读取本地目录 <code>pages</code> 下的文件，获取页面文件的绝对路径（数组），循环的过程中匹配页面名称，并根据页面名称动态的创建 <code>entry</code> 和 <code>HtmlWebpackPlugin</code>。</p><p><strong>动态化配置示例：</strong></p><pre><code class="lang-js">const path = require(&#39;path&#39;);
const {entry, htmlPlugins} = require(&#39;./setMPA&#39;);

module.exports = {
  entry,
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;[name][chunkhash:8].js&#39;
  },
  plugins: [
    ...htmlPlugins
  ]
}
</code></pre><p>在 <code>Webpack</code> 配置中只需要引入 <code>setMPA</code> 模块，解构出 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的集合，并写在对应的配置上，这样就化解了有人新增页面就要增加对应页面配置的尴尬。</p><h2 id="集成-ESlint"><a href="#集成-ESlint" class="headerlink" title="集成 ESlint"></a>集成 ESlint</h2><h3 id="ESlint-介绍"><a href="#ESlint-介绍" class="headerlink" title="ESlint 介绍"></a>ESlint 介绍</h3><p><code>ESlint</code> 的作用是对项目的 <code>JS</code> 代码进行规范检查和风格统一，可以减少代码中的隐患和潜在问题，团队越大开发人员越多体现越明显，团队也可以根据实际情况制定规范。</p><p><code>ESlint</code> 可以与 <code>lint-staged</code> 和 <code>husky</code> 等模块在代码提交阶段进行检测，可以与 <code>Gitlab</code> 和 <code>Github</code> 等代码管理平台中的 <code>CI/CD</code> 进行集成，也可以在发布平台云构建过程中进行规范检查。</p><pre><code class="lang-json">/* package.json */
{
  &quot;script&quot;: {
    &quot;precommit&quot;: &quot;lint-staged&quot;
  },
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;lint-staged&quot;
    }
  },
  &quot;lint-staged&quot;: {
    &quot;linters&quot;: {
      &quot;*.{js,scss}&quot;: [
        &quot;eslint --fix&quot;,
        &quot;git add&quot;
      ]
    }
  }
}
</code></pre><p>也有些优秀的 <code>ESlint</code> 规范模块可以使用，如腾讯的 <code>eslint-config-airbnb</code>、<code>eslint-config-airbnb-base</code> 等。</p><h3 id="Webpack-中使用-ESlint"><a href="#Webpack-中使用-ESlint" class="headerlink" title="Webpack 中使用 ESlint"></a>Webpack 中使用 ESlint</h3><p>也可以在 <code>Webpack</code> 构建中集成 <code>ESlint</code> 规范检查，需要借助 <code>eslint-loader</code>，如果代码不符合 <code>ESlint</code> 规范，构建会中断。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader eslint-loader -D
</code></pre><p><strong><code>Webpack</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  module: {
    rules: [
      // ...
      {
        test: /.js$/,
        exclude: /node_modules/, // 排除项
        use: [
          &#39;babel-loader&#39;,
          &#39;eslint-loader&#39;
        ]
      }
      // ...
    ]
  }
}
</code></pre><p><strong><code>ESlint</code> 配置示例：</strong></p><pre><code class="lang-js">/* .eslint.js */
module.exports = {
  parser: &#39;babel-eslint&#39;, // 使用的 eslint 规范
  extends: [&#39;airbnb&#39;], // 继承的 eslint 规犯
  // 启用的环境
  env: {
    browser: true,
    node: true
  }
  // 自定义规则
  rules: {
    // 规则名称
    indent: [
      &#39;error&#39;, // 错误级别
      2 // 配置项的值
    ]
  }
}
</code></pre><blockquote class="pullquote success"><p><strong>自定义 <code>ESlint</code> 规则或想要根据成熟的 <code>ESlint</code> 规则做定制化修改，可以在 <code>.eslintrc</code> 、<code>.eslint.js</code> 或 <code>.eslint.yml</code> 文件中进行配置。</strong></p></blockquote><h2 id="通过-Webpack-构建组件和基础库"><a href="#通过-Webpack-构建组件和基础库" class="headerlink" title="通过 Webpack 构建组件和基础库"></a>通过 Webpack 构建组件和基础库</h2><h3 id="构建描述"><a href="#构建描述" class="headerlink" title="构建描述"></a>构建描述</h3><p>这里所说的打包组件和基础库其实就是 “造轮子” 时，对于自己封装的模块进行构建，在做这个事情的时候使用 <code>rollup</code> 其实更适合，因为 <code>rollup</code> 更纯粹，也更简单一些，<code>Webpack</code> 功能比较强大，除了对于平时开发的业务项目进行构建，对于打包组件和基础库也完全胜任。</p><blockquote class="pullquote warning"><p><strong>开发组件或基础库通常需要满足下面两个要求：</strong></p><ul><li><strong>输出的文件要构建成压缩版本和非压缩版本，非压缩版本用于开发阶段，压缩版本用于线上；</strong></li><li><strong>要支持多种模块化方式，如 <code>AMD</code>、<code>CommonJS</code>、<code>ES-Module</code> 以及 <code>script</code> 标签引入。</strong></li></ul></blockquote><p><strong>各种引入方式：</strong></p><pre><code class="lang-js">/* AMD */
require([&#39;large-number&#39;], function (largeNumber) {
  largeNumber.add(&#39;999&#39;, &#39;1&#39;);
})
</code></pre><pre><code class="lang-js">/* CommonJS */
const largeNumber = require(&#39;large-number&#39;);

largeNumber.add(&#39;999&#39;, &#39;1&#39;);
</code></pre><pre><code class="lang-js">/* ES-Module */
import * as largeNumber from &#39;large-number&#39;;

largeNumber.add(&#39;999&#39;, &#39;1&#39;);
</code></pre><pre><code class="lang-html">&lt;!-- script --&gt;
&lt;script src=&quot;//xxcnd/large-number.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  largeNumber.add(&#39;999&#39;, &#39;1&#39;);
&lt;/script&gt;
</code></pre><h3 id="构建一个基础库"><a href="#构建一个基础库" class="headerlink" title="构建一个基础库"></a>构建一个基础库</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>下面我们封装一个计算大数字加法的库，并把这个库作为第三方模块使用 <code>Webpack</code> 进行构建，项目目录结构如下：</p><pre class="language-treeview">
  <code class="language-treeview">
    large-number
      |- dist
      | |- large-number.js
      | |- large-number.min.js
      |- src
      | |- index.js
      |- index.js
      |- package.json
      |- webpack.config.js
  </code>
</pre><blockquote class="pullquote primary"><ul><li><strong><code>dist</code> 是我们希望输出的目录，<code>large-number.js</code> 为非压缩版，<code>large-number.min.js</code> 为非压缩版；</strong></li><li><strong><code>src</code> 是构建的目录，<code>index.js</code> 是大整数加法功能函数所在文件；</strong></li><li><strong><code>index.js</code>：入口文件；</strong></li><li><strong><code>package.josn</code>：依赖配置文件；</strong></li><li><strong><code>webpack.config.js</code>：<code>Webpack</code> 配置文件。</strong></li></ul></blockquote><h4 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h4><pre><code class="lang-js">/* ~src/index.js */
export default function add(a, b) {
  // 相加两数的当前位的指针
  let i = a.length - 1;
  let j = b.length - 1;

  let carry = 0; // 是否进位
  let ret = &#39;&#39;; // 最后输出结果

  // 循环，个位个位相加，十位十位相加...
  while (i &gt;= 0 || j &gt;= 0) {
    let x = 0; // a 的当前位
    let y = 0; // b 的当前位
    let sum; // 当前位数的和

    // 如果存在当前位数将 a 的数字转化为数字，并将指针指向上一位
    if (i &gt;= 0) {
      x = a[i] - &#39;0&#39;;
      i--;
    }

    // 如果存在当前位数将 b 的数字转化为数字，并将指针指向上一位
    if (j &gt;= 0) {
      y = b[j] - &#39;0&#39;;
      j--;
    }

    sum = x + y + carry; // 求总和

    // 如果总和大于 10 进位，并修正当前位数
    if (sum &gt;= 10) {
      carry = 1;
      sum -= 10;
    } else {
      carry = 0;
    }

    ret = sum + ret; // 将求和数子转换字符串
  }

  // 循环结束，如果仍然存在进位，则将进位的值与之前结果拼接
  if (carry) {
    ret = carry + ret;
  }

  return ret; // 返回最终结果
}
</code></pre><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><pre><code class="lang-json">{
  &quot;name&quot;: &quot;large-number&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;大整数加法&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;prepublish&quot;: &quot;npm run build&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;terser-webpack-plugin&quot;: &quot;^2.1.3&quot;,
    &quot;webpack&quot;: &quot;^4.41.2&quot;,
    &quot;webpack-cli&quot;: &quot;^3.3.9&quot;
  }
}
</code></pre><p>其中 <code>main</code> 是模块指定执行的文件，指向根目录的主文件。</p><h4 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h4><pre><code class="lang-js">/* index.js */
if (process.env.NODE_ENV === &#39;production&#39;) {
  module.exports = require(&#39;./dist/large-number.min.js&#39;);
} else {
  module.exports = require(&#39;./dist/large-number.js&#39;);
}
</code></pre><p>主文件中根据当前的引用环境区分提供压缩版和非压缩文件版。</p><h4 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h4><p>下面是整个模块构建最重要的，就是 <code>Webpack</code> 的配置文件。</p><pre><code class="lang-js">/* webpack.config.js */
const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);

module.exports = {
  mode: &#39;none&#39;,
  entry: {
    &#39;large-number&#39;: &#39;./src/index.js&#39;,
    &#39;large-number.min&#39;: &#39;./src/index.js&#39;
  },
  output: {
    filename: &#39;[name].js&#39;,
    library: &#39;largeNumber&#39;,
    libraryExport: &#39;default&#39;,
    libraryTarget: &#39;umd&#39;
  },
  optimization: {
    minimize: true,
    minimizer: [
      // 压缩的同时转换 ES6 语法，基于 uglifyPlugin 改造
      new TerserWebpackPlugin({
        include: /\.min\.js$/
      })
    ]
  }
}
</code></pre><blockquote class="pullquote success"><p><strong>配置文件参数解析：</strong></p><ul><li><strong><code>entry</code>：</strong><ul><li><strong><code>large-number</code>：压缩版入口文件路径；</strong></li><li><strong><code>large-number.min</code>：非压缩版入口文件路径。</strong></li></ul></li><li><strong><code>output</code>：</strong><ul><li><strong><code>filename</code>：出口文件名；</strong></li><li><strong><code>library</code>：导出的文件所提供的全局变量名；</strong></li><li><strong><code>libraryExport</code>：默认值为 <code>default</code>，如不配置访问导出对象的<code>default</code> 属性才可以获取对应的方法；</strong></li><li><strong><code>libraryTarget</code>：打包的模块规则，如 <code>CommonJS</code>，<code>ES-Module</code> 等，详情见</strong> <a href="https://webpack.js.org/configuration/output/#outputlibrarytarget" target="_blank">Webpack 官网</a><strong>。</strong></li></ul></li><li><strong><code>TerserWebpackPlugin</code>：基于 <code>UglifyPlugin</code> 插件实现的，相较于 <code>UglifyPlugin</code>，压缩的同时可以转换 <code>ES6</code> 语法。</strong><ul><li><strong><code>include</code>：属性的值为正则，默认匹配了 <code>large-number.min.js</code> 文件。</strong></li></ul></li></ul></blockquote><h2 id="构建-SSR-应用"><a href="#构建-SSR-应用" class="headerlink" title="构建 SSR 应用"></a>构建 SSR 应用</h2><h3 id="为什么要有-SSR-应用"><a href="#为什么要有-SSR-应用" class="headerlink" title="为什么要有 SSR 应用"></a>为什么要有 SSR 应用</h3><blockquote class="pullquote default"><p><strong>通常的客户端渲染流程如下：</strong></p><ul><li><strong>开始加载（白屏）；</strong></li><li><strong><code>HTML</code> 加载成功（提供 <code>loading</code>）;</strong></li><li><strong>请求 <code>CSS</code>、<code>JS</code> 等资源；</strong></li><li><strong>解析 <code>CSS</code>、<code>JS</code> 等资源；</strong></li><li><strong>页面渲染样式、执行 <code>JS</code> 逻辑；</strong></li><li><strong>如发送数据、图片请求；</strong></li><li><strong>页面达到可交互状态。</strong></li></ul></blockquote><p>从客户端的渲染流程看，我们可以发现从请求 <code>HTML</code> 到达到可交互状态中的请求是串行执行的，会导致白屏时间长，并且刚刚请求回的 <code>.html</code> 文件上的动态数据是空的，不利于搜索引擎的爬虫分析页面（不利于 <code>SEO</code>）。</p><h3 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h3><p><code>SSR</code>（<code>Server Side Rendering</code>） 又称为服务端渲染，将渲染后的 <code>.html</code> 整个返回给客户端，可以让客户端在加载 <code>.html</code> 后直接看到页面。</p><blockquote class="pullquote warning"><p><strong>服务端渲染流程：</strong></p><ul><li><strong>开始加载（白屏）；</strong></li><li><strong>服务端同构，将 <code>HTML</code>、<code>Data</code>、<code>CSS</code> 等进行组合；</strong></li><li><strong>返回给客户端解析并渲染；</strong></li><li><strong>页面达到可交互状态。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>跟客户端渲染的流程对比，可以发现服务端渲染的优势：</strong></p><ul><li><strong>串行的请求在服务端，内网拉取资源更快；</strong></li><li><strong>服务端渲染把客户端渲染的多个串行的请求优化成了一个请求（减少请求数）；</strong></li><li><strong>返回页面就能直接渲染出内容，减少了白屏的时间；</strong></li><li><strong>页面返回首屏所有数据，对 <code>SEO</code> 更友好。</strong></li></ul></blockquote><p><strong>客户端渲染和服务端渲染的差别对比：</strong></p><table><thead><tr><th style="width:20%"></th><th style="width:40%">客户端渲染</th><th>服务端渲染</th></tr></thead><tbody><tr><td>请求</td><td>多个请求（HTML，数据等）</td><td>1 个请求</td></tr><tr><td>加载过程</td><td>HTML 与数据串行加载</td><td>1 个请求返回 HTML 和数据</td></tr><tr><td>渲染</td><td>前端渲染</td><td>服务端渲染（如 Node.js）</td></tr><tr><td>可交互</td><td colspan="2">图片等静态资源加载完成，JS 逻辑执行完成可交互</td></tr></tbody></table><p><br></p><h3 id="构建服务端和客户端"><a href="#构建服务端和客户端" class="headerlink" title="构建服务端和客户端"></a>构建服务端和客户端</h3><p>假设负责服务端渲染的服务是由 <code>Express</code> 实现的，前端是使用 <code>React</code> 实现的，代码如下：</p><pre><code class="lang-bash">$ npm install express -D
</code></pre><pre><code class="lang-js">/* ~server/index.js 服务端 */
const express = require(&#39;express&#39;);
const fs = require(&#39;fs&#39;);
const axios = require(&#39;axios&#39;);

// React 内部提供的方法，用于将 JSX 转换成 HTML 字符
const { renderToString } = require(&#39;react-dom/server&#39;);
// 引入需要转换的 JSX
const SSR = require(&#39;./dist/index-server&#39;);
// 引入构建后的模板
const html = fs.readFile(&#39;./dist/index.html&#39;, &#39;utf-8&#39;);

// 增加 hask，防止属于浏览器的对象在服务端报错
if (window === undefined) {
  global.window = {};
}

const server = (port) =&gt; {
  const app = express();

  app.use(express.static(&#39;dist&#39;));

  app.get(&#39;/&#39;, (req, res) =&gt; {
    const html = renderMarkup(renderToString(SSR));
    res.status(200).send(html);
  });

  app.listen(port, () =&gt; {
    console.log(`server start ${port}`);
  });
}

const renderMarkup = async (str) =&gt; {
  const data = await axios.get(&#39;/xxx/xxx&#39;);
  return html.replace(&#39;&lt;!-- HTML_PLACEHOLDER --&gt;&#39;, str).replace(
    &#39;&lt;!-- INITAIL_DATA_PLACEHOLDER --&gt;&#39;，
    &#39;&lt;script&gt;window.__inital_data = &#39; + data + &#39;&lt;/script&gt;&#39;
  );
}

server(process.env.PORT || 3000);
</code></pre><pre><code class="lang-html">&lt;!-- ~dist/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Search&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 占位符，用于插入 HTML --&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;!-- HTML_PLACEHOLDER --&gt;&lt;/div&gt;
  &lt;!-- 数据占位符，用于插入数据 --&gt;
  &lt;!-- INITAIL_DATA_PLACEHOLDER --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-jsx">/* ~dist/index-server.js 客户端 */
const React = require(&#39;react&#39;);

class App extends React.Component {
  render() {
    return &lt;h1&gt;Hello world!&lt;/h1&gt;
  }
}

module.exports = &lt;App /&gt;;
</code></pre><blockquote class="pullquote danger"><p><strong>注意：由于 <code>React</code> 组件的 <code>JSX</code> 要通过服务端进行转换、渲染，所以不能使用 <code>ReactDom.render</code> 进行渲染，需要使用 <code>require</code> 引入， <code>module.exports</code> 导出。</strong></p></blockquote><h3 id="构建配置-1"><a href="#构建配置-1" class="headerlink" title="构建配置"></a>构建配置</h3><pre><code class="lang-js">const path = require(&#39;path&#39;);

module.exports = {
  // ...
  output: {
    path: path.join(__dirname, &#39;dist&#39;),
    filename: &#39;[name]-server.js&#39;
    libararyTarget: &#39;umd&#39;
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          &#39;ignore-loader&#39; // 使用构建后 `dist` 目录的 CSS
        ]
      }
    ]
  }
  // ...
}
</code></pre><h3 id="Webpack-SSR-注意的问题"><a href="#Webpack-SSR-注意的问题" class="headerlink" title="Webpack SSR 注意的问题"></a>Webpack SSR 注意的问题</h3><blockquote class="pullquote warning"><ul><li><strong>需要兼容浏览器的全局变量，如 <code>window</code>、<code>document</code> 等；</strong></li><li><strong>组件适配：将不兼容的组件根据打包环境适配，如服务端为 <code>CommonJS</code> 模块化规范；</strong></li><li><strong>请求适配：将 <code>fetch</code> 或者 <code>ajax</code> 请求的写法改写成 <code>isomorphic-fetch</code> 或者 <code>axios</code>（对于服务端做过适配）；</strong></li><li><strong>样式无法解析，服务端打包通过 <code>ignore-loader</code> 忽略掉 <code>CSS</code> 解析，或者将 <code>style-loader</code> 替换成 <code>isomorphic-style-loader</code>（使用 <code>CSS-Module</code> 的编码方式）。</strong></li></ul></blockquote><h2 id="定制构建命令行的显示日志"><a href="#定制构建命令行的显示日志" class="headerlink" title="定制构建命令行的显示日志"></a>定制构建命令行的显示日志</h2><p>在每一次构建时，默认在命令行都会打印一堆的日志信息，但是对于一个关注业务的开发者来说，更希望在构建错误时才去关注日志，并且快速定位错误，在 <code>Webpack</code> 中提供了 <code>stat</code> 配置用来控制日志内容的显示。</p><p><strong>生产环境配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  stat: &#39;errors-only&#39;
  // ...
}
</code></pre><p><strong>开发环境配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  devServer: {
    // ...
    stat: &#39;errors-only&#39;
    // ...
  }
  // ...
}
</code></pre><blockquote class="pullquote default"><p><strong>生产环境控制执行构建命令时的日志显示，如 <code>npm run build</code>，而开发环境控制代码热更新重新构建时的日志显示。</strong></p></blockquote><p><strong><code>stat</code> 可选值如下：</strong></p><table><thead><tr><th style="width:30%">可选值</th><th>描述</th></tr></thead><tbody><tr><td>errors-only</td><td>只在发生错误时输出</td></tr><tr><td>errors-warnings</td><td>只在发生错误或有新的编译时输出</td></tr><tr><td>minimal</td><td>只在发生错误或有新的编译时输出</td></tr><tr><td>none</td><td>没有输出</td></tr><tr><td>normal</td><td>标准输出</td></tr><tr><td>verbose</td><td>全部输出</td></tr><tr><td>detailed</td><td>全部输出除了 chunkModules 和 chunkRootModules</td></tr></tbody></table><p>目前存在一个问题是成功、警告以及失败的日志信息不够明显，使用 <code>FriendlyErrorsWebpackPlugin</code> 插件，可以通过颜色区分更明显的标注日志信息。</p><p><strong>插件安装：</strong></p><pre><code class="lang-bash">$ npm install friendly-errors-webpack-plugin -D
</code></pre><p><strong>插件配置示例：</strong></p><pre><code class="lang-js">const FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    new FriendlyErrorsWebpackPlugin()
  ]
  // ...
}
</code></pre><h2 id="构建异常和中断处理"><a href="#构建异常和中断处理" class="headerlink" title="构建异常和中断处理"></a>构建异常和中断处理</h2><p>在执行构建时，如果构建成功，接下来可能会执行发布操作，如果构建失败，可能会做错误上报的操作，这就需要我们的 <code>Webpack</code> 配置中能构处理构建异常和中断，其实在 <code>Webpack4</code> 中每次进程执行构建后都会抛出结束的状态码，<code>0</code> 为构建成功，其他只为构建失败。</p><pre><code class="lang-bash"># 查看状态码
echo $?
</code></pre><p>但我们的目的并不是通过命令拿到错误码，而是在构建过程刚结束时，可以针对状态码去做不同的处理，其实根据 <code>Webpack</code> 的底层对象 <code>Compiler</code> 的特性去实现一个插件就可以实现构建异常和中断处理，在插件中通过 <code>process.exit</code> 抛出状态码。</p><blockquote class="pullquote info"><p><strong><code>process.exit</code> 方法：</strong></p><ul><li><strong>状态码为 <code>0</code>，构建成功，回调函数中 <code>err</code> 参数为 <code>null</code>；</strong></li><li><strong>状态码为其他值，构建失败或中断，回调函数中 <code>err</code> 为错误对象，<code>err.code</code> 就是状态码。</strong></li></ul></blockquote><p><strong>插件简易实现和配置：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  plugins: [
    // ...
    function () {
      const interceptor = (stats) =&gt; {
        if (stats.complation.errors &amp;&amp; process.argv.includes(&#39;--watch&#39;)) {
          // 处理错误，上报
          process.exit(1);
        }
      }

      if (this.hooks) {
        this.hooks.done.tap(&#39;done&#39;, interceptor); // Webpack4
      } else {
        this.plugin(&#39;done&#39;, interceptor); // Webpack3
      }
    }
    // ...
  ]
  // ...
}
</code></pre><p><code>plugins</code> 不一定是类 <code>new</code> 出的插件实例对象，也可以是函数，上面的函数就可以作为插件被执行，在 <code>Webpack</code> 构建结束后会自动执行 <code>done</code> 事件，可以在 <code>done</code> 事件的回调函数中获取状态码和错误信息，做进一步的处理。</p><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack4 —— 优化篇</title>
    <url>/20181110203121/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181110203121/webpack-optimization.png" title="webpack optimization"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181002041434/" target="_blank">Webpack4 —— 基础篇</a></li><li><a href="/20181115105656/" target="_blank">Webpack4 —— 应用篇</a></li></ul></blockquote><h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><blockquote class="pullquote info"><p><strong>“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：</strong></p><ul><li><strong>版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；</strong></li><li><strong>没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。</strong></li></ul></blockquote><a id="more"></a><blockquote class="pullquote success"><p><strong>“文件指纹” 的种类：</strong></p><ul><li><strong><code>Hash</code>：和整个项目的构建有关，只要项目中有文件发生变化，使用该配置的文件名的 “指纹” 就会发生变化；</strong></li><li><strong><code>ChunkHash</code>：和 <code>Webpack</code> 打包的 <code>chunk</code> 有关，不同的 <code>entry</code>（多页应用时）会生成不同的 “指纹”，页面对应的文件发生变化才会影响该页面的 “指纹”；</strong></li><li><strong><code>ContentHash</code>：根据具体文件的内容生成 “指纹”，在具体某一个页面下引用的多个文件中，如果使用 <code>ChunkHash</code> 会导致一个文件变化其他的文件 “指纹” 也发生变化，使用 <code>ContentHash</code> 可以保证文件内容不变不会 “指纹” 不会发生变化。</strong></li></ul></blockquote><p><strong>合理使用 “文件指纹”：</strong></p><pre><code class="lang-js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = {
  entry: {
    app: &#39;./pages/app.js&#39;,
    appAdmin: &#39;./pages/appAdmin.js&#39;
  },
  output: {
    // 不同页面出口文件使用 chunkhash
    filename: &#39;[name][chunkhash:8].js&#39;,
    path: __dirname + &#39;dist&#39;
  },
  module: {
    rules: [
      // ...
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          &#39;css-loader&#39;,
        ],
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: &#39;url-loader&#39;,
        options: {
          limit: 10000,
          // MD5 根据文件内容生成，字体文件同理
          name: &#39;[name].[hash:8].[ext]&#39;
        }
      }
      // ...
    ]
  }
  plugins: [
    // 使用该插件将 CSS 文件单独提取
    new MiniCssExtractPlugin({
      // 该 contenthash 同图片的 hash
      filename: &#39;[name][contenthash:8].css&#39;
    })
  ]
  // ...
}
</code></pre><blockquote class="pullquote danger"><p><strong>“指纹” 配置不能和热更新插件 <code>HotModuleReplacementPlugin</code> 同时使用，因此也突出了 <code>Webpack</code> 配置根据环境（<code>mode</code>）区分的重要性。</strong></p></blockquote><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>在项目正式上线时，代码压缩是非常必要的，因为代码压缩后资源的字节会更少，文件大小会更小，这样在文件传输过程中也会节约带宽进而加快文件的访问速度。</p><h3 id="JS-压缩"><a href="#JS-压缩" class="headerlink" title="JS 压缩"></a>JS 压缩</h3><p>在 <code>Webpack4</code> 中内置了 <code>uglifyjs-webpacl-plugin</code> 插件，在 <code>mode</code> 配置为 <code>production</code> 时会默认实现 <code>.js</code> 文件的压缩，也可以手动安装该插件去配置关于压缩的其他参数，如并行压缩等（非必要）。</p><h3 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h3><p>在 <code>Webpack</code> 旧版本中可以通过 <code>css-loader</code> 中配置参数来实现压缩，但是后来 <code>css-loader</code> 去掉了这个配置，所以在 <code>Webpack4</code> 中可以通过 <code>OptimizeCssAssetsWebpackPlugin</code> 插件来实现对 <code>.css</code> 文件的压缩。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install cssnano optimize-css-assets-webpack-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 在 plugins 中配置 */
const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);

// 用于匹配 CSS 文件的处理器（默认）
const Cssnano = require(&#39;cssnano&#39;);

module.exports = {
  // ...
  plugins: [
    new OptimizeCssPlugin({
      assetNameRegExp: /\.css$/g,
      cssProcessor: Cssnano,
      cssProcessorOptions: {
        // 注释处理
        discardComments: {
          removeAll: true // 移除所有注释
        },
        normalizeUnicode: false // 防止 unicode-range 时产生乱码
      }
    })
  ]
}
</code></pre><pre><code class="lang-js">/* 在 optimization 中配置 */
const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);

// 用于匹配 CSS 文件的处理器（默认）
const Cssnano = require(&#39;cssnano&#39;);

module.exports = {
  // ...
  optimization: {
    // ...
    minimizer: [
      new OptimizeCssPlugin({
        assetNameRegExp: /\.css$/g,
        cssProcessor: Cssnano,
        cssProcessorOptions: {
          // 注释处理
          discardComments: {
            removeAll: true // 移除所有注释
          },
          normalizeUnicode: false // 防止 unicode-range 时产生乱码
        }
      })
    ]
    // ...
  }
}
</code></pre><h3 id="Html-压缩"><a href="#Html-压缩" class="headerlink" title="Html 压缩"></a>Html 压缩</h3><p>压缩 <code>.html</code> 文件主要还是依靠 <code>HtmlWebpackPlugin</code> 插件，通过生产环境构建时配置一些参数来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      template: &#39;./src/index.html&#39;, // 模板文件路径
      filename: &#39;index.html&#39;, // 输出文件名称
      inject: true, // 将 js 资源放在 body 底部
      minify: {
        collapseWhitespace: true, // 是否删除空白符与换行符
        removeAttributeQuotes: true, // 是否移除引号
        minifyCSS: true, // 压缩 CSS
        minifyJS: true, // 压缩 JS
        removeComments: true // 是否移除 HTML 中的注释
      }
    })
  ]
  // ...
}
</code></pre><h2 id="资源内联"><a href="#资源内联" class="headerlink" title="资源内联"></a>资源内联</h2><blockquote class="pullquote default"><p><strong>资源内联就是将资源的代码放在 <code>.html</code> 文件中一起请求回来，资源内联优化的意义大致可以分为两个层面，代码层面和网络层面。</strong></p><ul><li><strong>在代码层面可以内联一些 <code>meta</code> 标签，便于维护管理文件，可以内联一些页面框架的初始化脚本、上报埋点相关的脚本，也可以将首屏使用的 <code>CSS</code> 内联，防止网络不好的情况下页面闪动；</strong></li><li><strong>从网络层面，对一些小图片和字体资源进行内联可以减少请求次数，增加页面的响应速度。</strong></li></ul></blockquote><h3 id="Html-和-JS-的内联"><a href="#Html-和-JS-的内联" class="headerlink" title="Html 和 JS 的内联"></a>Html 和 JS 的内联</h3><p>内联 <code>Html</code> 和 <code>JS</code> 文件需要依赖 <code>raw-loader</code> 加载器，<code>raw-loader</code> 的功能其实就是读取一个文件，然后把文件读取的内容以字符串形式返回并插入到对应的位置。</p><p><strong>安装依赖（0.5.1 版本比较稳定）：</strong></p><pre><code class="lang-bash">$ npm install raw-loader@0.5.1 -D
</code></pre><p><strong>使用示例：</strong></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;!-- html 内联可以直接放在对应位置 --&gt;
  ${ require(&#39;raw-loader!./meta.html&#39;) }
  &lt;!-- js 内联需要包裹在 script 标签中，防止存在 ES6 代码需要添加 babel-loader --&gt;
  &lt;script&gt;${ require(&#39;raw-loader!babel-loader!./xxx.js&#39;) }&lt;/script&gt;
  &lt;title&gt;注入 Html 和 JS&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote class="pullquote info"><p><strong>由于 <code>Webpack</code> 使用编译模板的插件是 <code>HtmlWebpackPlugin</code>，默认模板使用的是 <code>ejs</code>，所以支持上面 <code>${}</code> 的模板语法。</strong></p></blockquote><h3 id="CSS-内联"><a href="#CSS-内联" class="headerlink" title="CSS 内联"></a>CSS 内联</h3><blockquote class="pullquote primary"><p><strong><code>CSS</code> 内联需要两个步骤：</strong></p><ul><li><strong>如果直接使用 <code>style-loader</code> 会把所有打包后的 <code>CSS</code> 样式都动态的注入 <code>.html</code> 文件中，所以需要使用 <code>MiniCssExtractPlugin</code> 插件优先对 <code>CSS</code> 进行抽离；</strong></li><li><strong>将抽离后首屏的 <code>.css</code> 文件注入到 <code>.html</code> 文件中，借助 <code>HtmlInlineCssWebpackPlugin</code> 插件来实现。</strong></li></ul></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install mini-css-extract-plugin html-webpack-plugin html-inline-css-webpack-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const HtmlInlineCssWebpackPlugin = require(&#39;html-inline-css-webpack-plugin&#39;);

module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          &#39;css-loader&#39;
        ]
      }
      // ...
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: &#39;[name][contenthash:8].css&#39;
    }),
    new HtmlWebpackPlugin({
      template: &#39;./src/index.html&#39;,
      filename: &#39;index.html&#39;
    }),
    new HtmlInlineCssWebpackPlugin()
    // ...
  ]
  // ...
}
</code></pre><blockquote class="pullquote warning"><p><strong>需要注意的是 <code>HtmlWebpackPlugin</code> 插件应该在 <code>HtmlInlineCssWebpackPlugin</code> 之前，因为这两个插件的执行顺序有所依赖，必须先产生 <code>index.html</code> 文件后才能对 <code>CSS</code> 进行注入。</strong></p></blockquote><h3 id="图片、字体的内联"><a href="#图片、字体的内联" class="headerlink" title="图片、字体的内联"></a>图片、字体的内联</h3><p>一些小图标和字体如果体积非常小的情况下发出多个请求是没有必要的，所以最好是转换成 <code>Base64</code> 直接内联在 <code>.html</code> 和 <code>.css</code> 文件中，可以通过 <code>url-loader</code> 在构建中实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install url-loader -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.(png|svg|gif|jpe?g)$/,
        use: [
          {
            loader: &#39;url-loader&#39;,
            options: {
              limit: 10240 // 图片小于 10k 转为 Base64
            }
          }
        ]
      },
      {
        test: /\.(woff2?|eot|ttf|otf)$/,
        use: [
          {
            loader: &#39;url-loader&#39;, // 字体小于 10k 转为 Base64
            options: {
              limit: 10240
            }
          }
        ]
      }
      // ...
    ]
  }
  // ...
}
</code></pre><blockquote class="pullquote default"><p><strong>这样的方式最大的问题是只能根据图片大小控制所有满足条件的图片和字体资源，而不能单独控制某一个资源，想要单独控制某一个资源可以使用自己编写 <code>Webpack</code> 插件或类似功能的第三方插件。</strong></p></blockquote><h2 id="抽取公共依赖"><a href="#抽取公共依赖" class="headerlink" title="抽取公共依赖"></a>抽取公共依赖</h2><p>在开发中的很多页面使用了相同的基础库，或者这些基础库之间引用了相同的依赖，或不同的组件中使用了相同的模块，以及 <code>node_modules</code> 中有些模块使用相同的依赖，这样直接打包会对公共部分重复打包，造成打包后的文件体积非常的大，这也是一个可以优化的点，可以将公共的部分按照优先级、权重、同步异步加载的方式进行抽取，进而对文件进行拆分，减小打包后文件的体积。</p><h3 id="基础库分离"><a href="#基础库分离" class="headerlink" title="基础库分离"></a>基础库分离</h3><p>假如我们是做 <code>React</code> 开发，默认情况下是会对 <code>react</code> 和 <code>react-dom</code> 构建并打包到 <code>bundle</code> 中去，可以通过 <code>CDN</code> 的方式进行引入，在打包的时候每一次都忽略 <code>react</code> 和 <code>react-dom</code> 文件，以减小 <code>bundle</code> 的体积，我们可以通过 <code>HtmlWebpackExternalsPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-externals-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackExternalsPlugin = require(&#39;html-webpack-externals-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    // ...
    new HtmlWebpackExternalsPlugin({
      externals: [
        {
          module: &#39;react&#39;, // 模块名称
          entry: &#39;//xxcnd.com/boudle/react.min.js&#39;, // cdn 地址
          global: &#39;React&#39; // 全局变量名
        },
        {
          module: &#39;react-dom&#39;,
          entry: &#39;//xxcnd.com/boudle/react-dom.min.js&#39;,
          global: &#39;ReactDom&#39;
        }
      ]
    })
    // ...
  ]
  // ...
}
</code></pre><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在 <code>Webpack4</code> 中内置了代码分割的功能插件，非常强大，可以通过将公共依赖抽离成单独文件的方式减小 <code>bundle</code> 的体积，这也是官方建议使用的方式。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 默认参数 */
module.exports = {
  // ...
  optimization: {
    // ...
    splitChunks: {
      chunks: &#39;all&#39;,
      minSize: 30000,
      maxSize: 0,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitalRequests: 3,
      automaticNameDelimiter: &#39;~&#39;,
      name: true
    }
    // ...
  }
  // ...
}
</code></pre><blockquote class="pullquote success"><p><strong><code>splitChunks</code> 参数详解：</strong></p><ul><li><strong><code>chunks</code>：</strong><ul><li><strong><code>async</code>：异步引入的库进行分离（默认）；</strong></li><li><strong><code>inital</code>：同步引入的库进行分离；</strong></li><li><strong><code>all</code>：所有引入的库进行分离（推荐）。</strong></li></ul></li><li><strong><code>minSize</code>：抽离公共包最小字节数；</strong></li><li><strong><code>maxSize</code>：抽离公共包最大字节数；</strong></li><li><strong><code>minChunks</code>：抽离公共包最小使用次数；</strong></li><li><strong><code>maxAsyncRequests</code>：浏览器同时请求同步资源的个数；</strong></li><li><strong><code>maxInitalRequests</code>：浏览器同时请求异步资源的个数；</strong></li><li><strong><code>automaticNameDelimiter</code>：抽离插件的文件名间隔符；</strong></li><li><strong><code>name</code>：值为 <code>true</code> 根据模块名称和缓存组（<code>cacheGroups</code>）的键自动选择名称。</strong></li></ul></blockquote><p><strong>使用自定义缓存组 <code>cacheGroups</code> 配置示例：</strong></p><pre><code class="lang-js">/* 自定义缓存组拆分同步异步模块 */
module.exports = {
  // ...
  optimization: {
    // ...
    splitChunks: {
      chunks: &#39;all&#39;,
      cacheGroups: {
        &#39;commons&#39;: {
          chunks: &#39;initial&#39;,
          name: &#39;commons&#39;,
          minChunks: 2,
          minSize: 0,
          reuseExistingChunk: true,
          priority: -5
        },
        &#39;async-commons&#39;: {
          chunks: &#39;async&#39;,
          name: &#39;async-commons&#39;,
          minChunks: 2,
          minSize: 0,
          reuseExistingChunk: true,
          priority: 5
        },
        &#39;vendors&#39;: {
          test: /[\\/]node_modules[\\/]/,
          name: &#39;vendors&#39;,
          chunks: &#39;initial&#39;,
          minChunks: 2,
          priority: 10,
          enforce: true,
          reuseExistingChunk: true
        },
        &#39;async-vendors&#39;: {
          test: /[\\/]node_modules[\\/]/,
          minChunks: 2,
          chunks: &#39;async&#39;,
          name: &#39;async-vendors&#39;,
          priority: 15,
          enforce: true,
          reuseExistingChunk: true
        }
      }
    }
    // ...
  }
  // ...
}
</code></pre><blockquote class="pullquote info"><p><strong><code>cacheGroups</code> 参数详解：</strong></p><ul><li><strong><code>commons</code>：所有代码中的公共依赖（同步）；</strong><ul><li><strong><code>test</code>：匹配依赖代码的文件夹，通常匹配 <code>node_modules</code>；</strong></li><li><strong><code>reuseExistingChunk</code>：允许重用现有模块，而不是在模块完全匹配时创建新模块；</strong></li><li><strong><code>priority</code>：权重，当被多个规则重用时会根据权重打包到对应策略的文件中；</strong></li><li><strong><code>enforce</code>：设置为 <code>true</code> 强制按照该规则拆分出一个文件，忽略文件大小；</strong></li></ul></li><li><strong><code>async-commons</code>：所有代码中的公共依赖（异步）；</strong></li><li><strong><code>vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（同步）；</strong></li><li><strong><code>async-vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（异步）；</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>注意：在使用 <code>cacheGroups</code> 属性进行代码分割后，产生的新 <code>chunks</code> 名称必须在页面 <code>HtmlWebpackPlugin</code> 实例的 <code>chunks</code> 属性中进行一一对应的配置。</strong></p></blockquote><p><strong><code>HtmlWebpackPlugin</code> 配置：</strong></p><pre><code class="lang-js">/* HtmlWebpackPlugin 使用前需安装 */
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    // ...
    new HtmlWebPackPlugin({
      template: &#39;./src/index.html&#39;,
      filename: &#39;index.html&#39;,
      // 包含 splitChunks.cacheGroups 中 key 值和页面的出口文件名称
      chunks: [
        &#39;commons&#39;,
        &#39;async-commons&#39;,
        &#39;vendors&#39;,
        &#39;async-vendors&#39;,
        &#39;index&#39;
      ]
      // ...
    })
    // ...
  ]
  // ...
}
</code></pre><h2 id="tree-shaking-优化"><a href="#tree-shaking-优化" class="headerlink" title="tree-shaking 优化"></a>tree-shaking 优化</h2><h3 id="配置-tree-shaking"><a href="#配置-tree-shaking" class="headerlink" title="配置 tree-shaking"></a>配置 tree-shaking</h3><p>这个优化的名字是非常形象的，像摇晃树一样，把多余的枯叶都晃掉，其实指的就是一个模块中有多个方法，在打包的 <code>uglify</code> 阶段擦除掉没有使用（被标记）的方法，通过不打包无用代码的方式来减小 <code>bundle</code> 的体积，进而减小资源的加载时间。</p><p>这个优化的思想借鉴了 <code>rollup</code>，并在 <code>Webpack2</code> 中进行了实现，通过插件配置，目前 <code>Webpack4</code> 版本已经内置了 <code>tree-shaking</code> 优化，在 <code>mode</code> 被配置为 <code>production</code>（生产环境）时默认生效，如果需要在开发环境中使用配置如下。</p><pre><code class="lang-json">/* .babelrc */
{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
  ]
}
</code></pre><blockquote class="pullquote success"><p><strong>想要使 <code>tree-shaking</code> 生效的注意点：</strong></p><ul><li><strong>引入模块必须使用 <code>ES6</code> 的模块化语法，因为 <code>tree-shaking</code> 的实现依赖于 <code>ES6</code> 模块化的静态特性；</strong></li><li><strong>导出的函数不能存在 “副作用”，即导出的函数需要是纯函数，否则默认的 <code>tree-shaking</code> 也会失效。</strong></li></ul></blockquote><h3 id="tree-shaking-原理简介"><a href="#tree-shaking-原理简介" class="headerlink" title="tree-shaking 原理简介"></a>tree-shaking 原理简介</h3><p>说到 <code>tree-shaking</code> 的原理是应该先了解 <code>DCE</code>（<code>dead code elimination</code>）的概念，就是指 “死” 代码消除。</p><blockquote class="pullquote default"><p><strong><code>DCE</code> 有以下情况：</strong></p><ul><li><strong>代码不会被执行，不可到达；</strong></li><li><strong>代码只会影响死变量，只写不读；</strong></li><li><strong>代码执行的结果不会被用到。</strong></li></ul></blockquote><pre><code class="lang-js">/* 代码不会被执行，不可到达 */
if (false) {
  console.log(&#39;dead code&#39;);
}
</code></pre><pre><code class="lang-js">/* 代码只会影响死变量，只写不读 */
let hello = &#39;nihao&#39;;
</code></pre><pre><code class="lang-js">/* 代码执行的结果不会被用到 */
// tool.js
export const fn1 = () =&gt; {
  return &#39;hello&#39;;
}

fn1();

export const fn2 = () =&gt; {
  return &#39;world&#39;;
}

// main.js
import { fn2 } from &#39;./tool.js&#39;;

fn2();
</code></pre><p><code>tree-shaking</code> 就是通过检查具有上面特性的代码并做相应处理来达到擦除多余代码的目的，并且依赖 <code>ES6</code> 模块化的静态特性，原因是哪些代码是多余的哪些代码是有用的在编译阶段就需要确定下来，<code>ES6</code> 模块的静态特性正好符合编译阶段对代码的分析，<code>CommonJS</code> 的模块化规范就明显不适合，因为模块的引入是动态的，由运行时决定。</p><blockquote class="pullquote primary"><p><strong>依赖模块静态化特性的原因：</strong></p><ul><li><strong>只能在顶层使用 <code>import</code> 引用模块；</strong></li><li><strong>引用的变量都是常量；</strong></li><li><strong>引入的模块对象的不可更改（<code>immutable</code>）特性。</strong></li></ul></blockquote><h3 id="深度-tree-shaking"><a href="#深度-tree-shaking" class="headerlink" title="深度 tree-shaking"></a>深度 tree-shaking</h3><p>如果函数中存在副作用，默认的 <code>tree-shaking</code> 之所以失效了是因为只能够在编译阶段做词法分析，而不能做作用域（<code>scope</code>）分析，如下面代码。</p><pre><code class="lang-js">// tool.js
import lodash from &#39;lodash-es&#39;;

export const fn1 = () =&gt; {
  console.log(&#39;hello&#39;);
}

export const fn2 = (arg) =&gt; {
  console.log(lodash.isArray(arg));
}

// main.js
import { fn1 } from &#39;./tool.js&#39;;

fn1();
</code></pre><p>在上面案例中并没有使用 <code>fn2</code>，但是由于 <code>fn2</code> 函数中有副作用，即引用了 <code>lodash</code>，所以还是对 <code>lodash</code> 和 <code>fn2</code> 进行了打包，这种情况下如果想要继续实现 <code>tree-shaking</code>，需要借助 <code>WebpackDeepScopePlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install webpack-deep-scope-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const WebpackDeepScopePlugin = require(&#39;webpack-deep-scope-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    // ...
    new WebpackDeepScopePlugin()
    // ...
  ]
  // ...
}
</code></pre><h2 id="Scope-Hoisting-优化"><a href="#Scope-Hoisting-优化" class="headerlink" title="Scope Hoisting 优化"></a>Scope Hoisting 优化</h2><p>由于浏览器对模块化语法支持依然不好，为了保证代码可以在各个浏览器中可执行，所以使用 <code>Webpack</code> 进行构建。</p><pre><code class="lang-js">/* 构建前 */
// a.js
export default &#39;xxx&#39;;

// b.js
import index from &#39;./a.js&#39;;
console.log(index);
</code></pre><pre><code class="lang-js">/* 构建后 */
(function (module, __webpack_exports__, __webpack_require__) {
  &quot;use strict&quot;
  // 模块 b 构建内容，省略...
})

(function (module, __webpack_exports__, __webpack_require__) {
  &quot;use strict&quot;
  // 模块 a 构建内容，省略...
})
</code></pre><p>被 <code>Webpack</code> 转换后的模块会包裹一层自执行函数，构建后的代码会存在大量的闭包，其中 <code>import</code> 会被转换成 <code>__webpack_require__</code> 的调用，<code>export</code> 会被转换成 <code>__webpack_exports__</code> 对象属性的的赋值。</p><blockquote class="pullquote warning"><p><strong>会导致的问题：</strong></p><ul><li><strong>大量函数闭包包裹的代码会导致体积增大，模块越多越明显；</strong></li><li><strong>运行代码时创建的函数作用域变多，内存开销变大。</strong></li></ul></blockquote><p><code>Scope Hoisting</code> 又被称为作用域提升，借鉴于 <code>rollup</code>，在 <code>Webpack3</code> 中被提出，将所有模块的代码按照引用顺序存放在一个函数作用域里，然后适当的重命名来防止变量命名冲突，用来减少函数声明代码，减小内存开销。</p><p>在 <code>Webpack4</code> 中当 <code>mode</code> 为 <code>production</code>（生产环境）时会默认开启 <code>Scope Hoisting</code>，当想在开发环境或 <code>Webpack3</code> 中配置开启，需要依赖 <code>Webpack</code> 的内置插件 <code>ModuleConcatenationPlugin</code> 来实现。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">const Webpack = require(&#39;webpack&#39;);

module.exports = {
  // ...
  plugins: [
    // ...
    new Webpack.optimize.ModuleConcatenationPlugin()
    // ...
  ]
  // ...
}
</code></pre><blockquote class="pullquote info"><p><strong>开启 <code>Scope Hoisting</code> 后，在多个模块中都会引用的模块会单独提取出来形成闭包函数，否则会将多个引用的模块按照引用顺序放在同一个闭包函数中。</strong></p></blockquote><h2 id="资源懒加载"><a href="#资源懒加载" class="headerlink" title="资源懒加载"></a>资源懒加载</h2><p><code>Webpack</code> 所特有的 <code>require.ensure()</code> 可以实现懒加载，符合 <code>CommonJS</code> 规范，目前已经被 <code>ES6+</code> 的动态 <code>import()</code> 取代，属于代码分割的一部分，对于大型 <code>Web</code> 单页面应用来讲，将所有代码都放在一个 <code>bundle</code> 文件中是没有必要的，特别是某些代码块不是经常被用到，大大降低了首屏的加载速度，使用动态 <code>import</code> 优化可以使类似这样的代码在使用时才去加载，使得初始化的时候代码体积更小。</p><p>在 <code>Webpack</code> 中要解析动态 <code>import()</code> 语法需要依赖 <code>babel</code> 中的 <code>@babel/plugin-syntax-dynamic-import</code> 插件。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install @babel/preset-env @babel/plugin-syntax-dynamic-import -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-json">/* .babelrc */
{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;
  ],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-syntax-dynamic-import&quot;
  ]
}
</code></pre><blockquote class="pullquote default"><p><strong>只要使用了动态 <code>import()</code> 语法加载的模块，在 <code>Webpack</code> 构建时都会打包出单独的 <code>chunk</code>，构建的代码内当需要加载模块时是通过 <code>JSONP</code> 的方式去加载的。</strong></p></blockquote><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
        <tag>构建</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 策略模式</title>
    <url>/20181006014812/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181006014812/strategy.jpg" title="策略模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote primary"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li></ul></blockquote><h2 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h2><p>“策略模式” 是将定义的一组算法封装起来，使其可以相互替换，封装的算法具有一定的独立性，让算法独立于客户端而变化，可以大大减少 <code>if...else</code> 和 <code>switch...case</code> 等判断。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181006014812/strategy-uml.jpg" alt="策略模式 UML 图"></div><div class="image-caption">策略模式 UML 图</div></figure><p><br></p><h2 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h2><p>下面是一个关于会员打折的逻辑，根据顾客身份不同输出不同的支付金额，是未使用 “策略模式” 的实现。</p><pre><code class="lang-js">/* 未使用策略模式 */
class Customer {
  constructor(type) {
    this.type = type;
  }
  pay(amount) {
    if (this.type === &#39;member&#39;) {
      return amount * 0.9;
    } else if (this.type === &#39;vip&#39;) {
      return amount * 0.8;
    } else {
      return amount;
    }
  }
}

const c1 = new Customer(&#39;normal&#39;);
const c2 = new Customer(&#39;member&#39;);
const c3 = new Customer(&#39;vip&#39;);

console.log(c1.pay(100)); // 100
console.log(c2.pay(100)); // 90
console.log(c3.pay(100)); // 80
</code></pre><p>上面的代码与 <a href="/20181005161213/" target="_blank">状态模式</a> 一节中的问题类似，违反开放封闭原则和单一职责原则，代码冗余且判断条件过多，“状态模式” 虽然可以解决状态不同时不同复杂逻辑的抽离和解耦，但是并不能解决过多条件判断的问题，下面就是用 “策略模式” 来对这个点进行优化。</p><pre><code class="lang-js">/* 使用策略模式优化 —— 策略类 */
class Customer {
  constructor(kind) {
    this.kind = kind;
  }
  pay(amount) {
    return this.kind.pay(amount);
  }
}

// 策略类
class Normal {
  pay(amount) {
    return amount;
  }
}

class Member {
  pay(amount) {
    return amount * 0.9;
  }
}

class VIP {
  pay(amount) {
    return amount * 0.8;
  }
}

const c1 = new Customer(new Normal());
const c2 = new Customer(new Member());
const c3 = new Customer(new VIP());

console.log(c1.pay(100)); // 100
console.log(c2.pay(100)); // 90
console.log(c3.pay(100)); // 80
</code></pre><p>上面是使用策略类对复杂判断逻辑的内容进行了抽象，并将原本 <code>if...else</code> 中的逻辑分别放在了不同的策略类中维护，如果每一个策略类中要维护的逻辑并不是很复杂，也可以使用第二种方案，即使用策略对象维护不同的逻辑。</p><pre><code class="lang-js">/* 使用策略模式优化 —— 策略对象 */
class Customer {
  constructor() {
    // 策略对象
    this.kinds = {
      normal(amount) {
        return amount;
      },
      member(amount) {
        return amount * 0.9;
      },
      vip(amount) {
        return amount * 0.8;
      }
    };
  }
  pay(kind, amount) {
    return this.kinds[kind](amount);
  }
}

const c1 = new Customer();
const c2 = new Customer();
const c3 = new Customer();

console.log(c1.pay(&#39;normal&#39;, 100)); // 100
console.log(c2.pay(&#39;member&#39;, 100)); // 90
console.log(c3.pay(&#39;vip&#39;, 100)); // 80
</code></pre><h2 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h2><h3 id="jQuery-的-animate-动画"><a href="#jQuery-的-animate-动画" class="headerlink" title="jQuery 的 animate 动画"></a>jQuery 的 animate 动画</h3><p>在 <code>jQuery</code> 的源码实现中，<code>animate</code> 方法就用到了 “策略模式”，通过不同的状态定义了动画不同的行为，使用代码如下：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;jQuery-animate&lt;/title&gt;
  &lt;style&gt;
    #content{
      width: 100px;
      height: 100px;
      background-color: pink;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id=&quot;bigger&quot;&gt;变大&lt;/button&gt;
  &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
  &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    $(&#39;#bigger&#39;).on(&#39;click&#39;, function () {
      $(&#39;#content&#39;).animate({
        width: &#39;200px&#39;,
        height: &#39;200px&#39;
      }, 1000, &#39;linear&#39;); // linear 参数为动画策略的一种类型
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>在 <a href="/20180928030105/" target="_blank">装饰器模式</a> 一节中也有表单校验的应用，代码如下：</p><pre><code class="lang-html">&lt;!-- 表单校验应用装饰器模式 --&gt;
&lt;form&gt;
  用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
  密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;
  &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt;
&lt;form&gt;
&lt;script&gt;
  const submitBtn = document.getElementById(&#39;submit-btn&#39;);

  // 添加切面函数
  Function.prototype.before = function (beforeFn) {
    const _this = this;
    return function () {
      let result = beforeFn.apply(this, arguments);
      result &amp;&amp; _this.apply(this, arguments);
    }
  }

  // 表单提交事件
  function submit() {
    console.log(&#39;提交表单&#39;);
  }

  // 验证用户名
  submit = submit.before(function () {
    const username = document.getElementById(&#39;username&#39;).value;
    if (!username) {
      return alert(&#39;请输入用户名&#39;);
    }
    return true;
  });

  // 验证
  submit = submit.before(function () {
    const password = document.getElementById(&#39;password&#39;).value;
    if (!password) {
      return alert(&#39;请输入密码&#39;);
    }
    return true;
  });

  submitBtn.addEventListener(&#39;click&#39;, submit);
&lt;/script&gt;
</code></pre><p>“装饰器模式” 是将对每个表单校验逻辑，通过增加切面（<code>AOP</code>）的方式插入在了 <code>submit</code> 事件之前，如果有一个校验不通过则不会执行下一个切面的校验操作或提交表单，但是这样的表单校验有局限性，如果页面表单校验非常多需要对校验逻辑进行统一管理，并且大多数场景下是所有的表单都校验后对所有的表单进行错误提示，这是就需要 “策略模式” 的策略对象来管理所有的校验逻辑。</p><pre><code class="lang-html">&lt;!-- 表单校验应用策略模式 --&gt;
&lt;form id=&quot;userform&quot;&gt;
  用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
  密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;
  手机号：&lt;input type=&quot;text&quot; name=&quot;mobile&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;script&gt;
  const form = document.getElementById(&#39;userform&#39;);
  const validator = (function () {
    const rules = {
      noEmpty(val, msg) {
        if (val === &#39;&#39;) return msg;
      },
      minLength(val, min, msg){
        if (val === &#39;&#39; || val.length &lt; min) return msg;
      },
      isMobile(val, msg) {
        if (!/1\d{10}/.test(val)) return msg;
      }
    };

    // 存储
    const checks = [];

    // 增加校验的项目
    function add(element, rule) {
      checks.push(function () {
        // [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;]
        const name = rule.shift();

        // [val, 6, &#39;密码长度不能少于 6 位&#39;]
        rule.unshift(element.value);
        return rules[name] &amp;&amp; rules[name].apply(element, rule);
      });
    }

    // 给策略对象增加新的功能
    function addRule(name, rule){
      rules[name] = rule;
    }

    // 开始校验
    function start() {
      for (let i = 0; i &lt; checks.length; i++) {
        const msg = checks[i]();
        if (msg) return msg;
      }
    }

    return { add, addRule, start };
  })();

  // 添加自定义规则
  validator.addRule(&#39;maxLength&#39;, function (val, max, msg) {
    if (val === &#39;&#39; || val.length &gt; max) return msg;
  });

  form.onsubmit = function () {
    validator.add(form.username, [&#39;noEmpty&#39;, &#39;用户名不能为空&#39;]);
    validator.add(form.password, [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;]);
    validator.add(form.password, [&#39;maxLength&#39;, 12, &#39;密码长度不能大于 12 位&#39;]);
    validator.add(form.mobile, [&#39;isMobile&#39;, &#39;必须输入合法的手机号&#39;]);

    const msg = validator.start();
    alert(msg || &#39;校验通过&#39;);
    return !msg;
  }
&lt;/script&gt;
</code></pre><p>通过对比两段代码可以显而易见的看出 “策略模式” 在对于表单校验的功能上比 “装饰器模式” 更加健壮，可以在保证可维护性的基础上支持更多复杂的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“策略模式” 和 “状态模式” 都有上下文、策略和状态类，上下文把这些请求委托给这些类来执行，“策略模式” 中，各个类是平等的，没有关系，客户端需要知道算法主动切换，“状态模式” 中，状态的切换和行为被封装好了，客户端不需要了解细节，所以 “策略模式” 真正意义的解决了状态过多时条件判断过多的问题，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/10.strategy" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 状态模式</title>
    <url>/20181005161213/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181005161213/state.jpg" title="状态模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote danger"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="状态模式简介"><a href="#状态模式简介" class="headerlink" title="状态模式简介"></a>状态模式简介</h2><p>有些情况下一个对象的行为取决于一个或者多个动态变化的属性，这样的属性叫做状态，这个对象叫做有状态的对象，这种情况下通常有很多的判断来处理状态不同时代码的执行逻辑，执行逻辑可能会非常复杂，让代码变得难以维护，“状态模式” 就是将这些逻辑委托给外面的对象或类来单独维护，来减少状态对象的逻辑，增强代码的维护性。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181005161213/state-uml.jpg" alt="状态模式 UML 图"></div><div class="image-caption">状态模式 UML 图</div></figure><p><br></p><h2 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h2><p>下面是一个类，功能为根据电池不同状态打印当前不同的颜色，下面是正常的实现方式。</p><pre><code class="lang-js">class Battery {
  constructor() {
    this.amount = &#39;high&#39;; // 电量高
  }
  show() {
    if (this.amount === &#39;high&#39;) {
      console.log(&#39;显示绿色&#39;);
      this.amount = &#39;middle&#39;; // 电量中等
    } else if (this.amount === &#39;middle&#39;) {
      console.log(&#39;显示黄色&#39;);
      this.amount = &#39;low&#39;; // 电量低
    } else if (this.amount === &#39;low&#39;) {
      console.log(&#39;显示红色&#39;);
    }
  }
}

const battery = new Battery();

battery.show(); // 显示绿色
battery.show(); // 显示黄色
battery.show(); // 显示红色
</code></pre><p>上面的代码虽然实现了我们想要的功能，但是代码中 <code>show</code> 方法违反了开放封闭原则和单一职责原则，状态切换逻辑不明显，判断条件太多，维护性和扩展性差，下面使用状态模式进行优化。</p><pre><code class="lang-js">class Battery {
  constructor() {
    this.amount = &#39;high&#39;; // 电量高
    this.state = new SuccessState(); // 绿色状态
  }
  show() {
    // 把显示逻辑委托给状态对象
    this.state.show();
    if (this.amount === &#39;high&#39;) {
      this.amount = &#39;middle&#39;; // 电量中等
      this.state = new WarningState(); // 黄色状态
    } else if (this.amount === &#39;middle&#39;) {
      this.amount = &#39;low&#39;; // 电量低
      this.state = new ErrorState(); // 红色状态
    }
  }
}

class SuccessState {
  show() {
    console.log(&#39;显示绿色&#39;);
  }
}

class WarningState {
  show() {
    console.log(&#39;显示黄色&#39;);
  }
}

class ErrorState {
  show() {
    console.log(&#39;显示红色&#39;);
  }
}

const battery = new Battery();

battery.show(); // 显示绿色
battery.show(); // 显示黄色
battery.show(); // 显示红色
</code></pre><p>经过 “状态模式” 的优化，我们将状态拆分成三个类，无论关于状态操作的多复杂的逻辑都在拆分出的类中实现，而不再需要在状态对象 <code>Battery</code> 中。</p><h2 id="状态模式的应用"><a href="#状态模式的应用" class="headerlink" title="状态模式的应用"></a>状态模式的应用</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>点赞是我们在项目开发中经常见到的功能，点赞后也可以取消点赞，这就出现了按钮关于点赞状态的切换和按钮文案的切换，下面是使用 “状态模式” 来实现的点赞功能。</p><pre><code class="lang-html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  // 维护点赞渲染逻辑的对象
  const likeState = {
    render(element) {
      element.innerHTML = &#39;赞&#39;;
    }
  };

  // 维护取消点赞渲染逻辑的对象
  const likedState = {
    render(element) {
      element.innerHTML = &#39;取消&#39;
    }
  }

  class Button {
    constructor(container) {
      this.liked = false; // 默认为未点赞状态
      this.state = likeState; // 设置当前的状态为未点赞

      this.element = document.createElement(&#39;button&#39;);
      container.appendChild(this.element);
      this.render(); // 初始化渲染
    }
    setState(state) {
      this.state = state; // 修改渲染状态
      button.liked = !button.liked; // 修改状态属性
      this.render(); // 重新渲染
    }
    render() {
      this.state.render(this.element);
    }
  }

  // 获取按钮对象并添加点击事件
  const button = new Button(document.getElementById(&#39;root&#39;));
  button.element.addEventListener(&#39;click&#39;, () =&gt; {
    button.setState(button.liked ? likeState : likedState);
  });
&lt;/script&gt;
</code></pre><p>上面代码使用 “状态模式” 统一封装了按钮的类 <code>Button</code>，传入的参数为渲染按钮的容器元素，按钮类的内部创建按钮并添加到容器元素中，统一管理了点赞状态，点赞渲染对象，如果想要切换状态只需要执行 <code>button</code> 对象提供的 <code>setState</code> 方法通过传入的不同状态对象进行状态切换和页面渲染。</p><h3 id="React-组件显示隐藏"><a href="#React-组件显示隐藏" class="headerlink" title="React 组件显示隐藏"></a>React 组件显示隐藏</h3><p>在 <code>React</code> 中，经常会出现通过事件切换组件的显示隐藏，最简单的方式是通过类组件状态来控制，但其实也可以使用 “状态模式” 在组件外编写对状态更改的逻辑，这样可以使组件的逻辑更清晰，代码更精简。</p><pre><code class="lang-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 状态管理对象
const States = {
  show() {
    console.log(&#39;显示 Banner&#39;);
    this.setState({ isShow: true });
  },
  hide() {
    console.log(&#39;隐藏 Banner&#39;);
    this.setState({ isShow: false });
  }
};

class Banner extends React.Component {
  state = { isShow: true }
  toggle = () =&gt; {
    const currentState = this.state.isShow ? &#39;hide&#39; : &#39;show&#39;;
    States[currentState] &amp;&amp; States[currentState].apply(this);
  }
  render() {
    return (
      &lt;div&gt;
        {
          isShow &amp;&amp; (
            &lt;nav&gt;导航&lt;/nav&gt;
          )
        }
        &lt;button&gt;toggle&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Banner /&gt;, document.getElementById(&#39;root&#39;));
</code></pre><p>在上面代码中组件外部的 <code>States</code> 就是管理切换状态逻辑的对象，就是说 “状态模式” 也可以在框架中单独使用。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>其实 “状态模式” 来源一个有限状态机的概念，有限状态机是指一个事物拥有多种状态，但是同一时间只会处于一种状态，可以通过动作来改变当前的状态，在 <code>JavaScript</code> 中拥有第三方模块 <code>javascript-state-machine</code> 专门帮我们来做这件事。</p><h3 id="javascript-state-machine-使用"><a href="#javascript-state-machine-使用" class="headerlink" title="javascript-state-machine 使用"></a>javascript-state-machine 使用</h3><p><code>javascript-state-machine</code> 提供一个类，创建实例时传入的参数为一个 <code>options</code> 对象，属性 <code>init</code> 用来定义初始状态值，属性 <code>transitions</code> 用来定义属性变化，<code>methods</code> 用来定义属性发生变化时所触发的钩子。</p><pre><code class="lang-js">// 有限状态机对象
const StateMachine = require(&#39;javascript-state-machine&#39;);

const fsm = new StateMachine({
  init: &#39;solid&#39;, // 初始状态（固态）
  transitions: [
    { from: &#39;solid&#39;, to: &#39;liquid&#39;, name: &#39;melt&#39; },
    { from: &#39;liquid&#39;, to: &#39;solid&#39;, name: &#39;freeze&#39; },
    { from: &#39;liquid&#39;, to: &#39;gas&#39;, name: &#39;vaporize&#39; },
    { from: &#39;gas&#39;, to: &#39;liquid&#39;, name: &#39;condense&#39; }
  ],
  methods: {
    onMelt() {
      console.log(&#39;melt&#39;);
    },
    onFreeze() {
      console.log(&#39;freeze&#39;);
    },
    onVaporize() {
      console.log(&#39;vaporize&#39;);
    },
    onCondense() {
      console.log(&#39;condense&#39;);
    }
  }
});

console.log(fsm.state); // solid
console.log(fsm.can(&#39;gas&#39;)); // false
console.log(fsm.cannot(&#39;gas&#39;)); // true
console.log(fsm.transitions()); // [ &#39;melt&#39; ]

console.log(fsm.allTransitions());
// [ &#39;init&#39;, &#39;melt&#39;, &#39;freeze&#39;, &#39;vaporize&#39;, &#39;condense&#39; ]

console.log(fsm.allStates()); // [ &#39;none&#39;, &#39;solid&#39;, &#39;liquid&#39;, &#39;gas&#39; ]

fsm.melt(); // melt
console.log(fsm.state); // liquid
console.log(fsm.transitions()); // [ &#39;freeze&#39;, &#39;vaporize&#39; ]
</code></pre><blockquote class="pullquote warning"><ul><li><strong><code>fsm.state</code>：当前状态；</strong></li><li><strong><code>fsm.can</code>：查看是否可直接转换到某个状态，参数为要转换的状态值；</strong></li><li><strong><code>fsm.cannot</code>：查看是否不能直接转换到某个状态，参数为要转换的状态值；</strong></li><li><strong><code>fsm.transitions</code>：返回可转换状态的方法列表；</strong></li><li><strong><code>fsm.allTransitions</code>：返回所有状态转换方法列表；</strong></li><li><strong><code>fsm.allStates</code>：返回定义的所有状态。</strong></li></ul></blockquote><h3 id="javascript-state-machine-原理"><a href="#javascript-state-machine-原理" class="headerlink" title="javascript-state-machine 原理"></a>javascript-state-machine 原理</h3><p>根据 <code>javascript-state-machine</code> 的用法我们模拟实现最基本的逻辑，构建一个有限状态机，代码如下：</p><pre><code class="lang-js">class StateMachine {
  constructor(options) {
    const {
      init = &#39;none&#39;,
      transitions = [],
      methods = {}
    } = options;

    this.state = init;

    transitions.forEach(transition =&gt; {
      const { from, to, name } = transition;
      this[name] = function () {
        if (this.state === from) {
          this.state = to;
          const method = &#39;on&#39; + name.slice(0, 1).toUpperCase() + name.slice(1);
          methods[method] &amp;&amp; methods[method]();
        }
      }
    });
  }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“状态模式” 实现的有限状态机可以更大限度的让状态变化与状态对象进行解耦，更减少了大量的判断逻辑，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/9.state" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 发布/订阅和观察者模式</title>
    <url>/20181004114907/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181004114907/observer.jpg" title="观察者模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote primary"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote warning"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><h3 id="发布-订阅模式实现"><a href="#发布-订阅模式实现" class="headerlink" title="发布/订阅模式实现"></a>发布/订阅模式实现</h3><p>在说 “观察者模式” 之前一定要说一下 “发布/订阅模式”，因为这两个模式非常相似又有些不同，最重要的是在设计模式中使用频繁。</p><pre><code class="lang-js">/* 发布/订阅的类 */
class Event {
  constructor() {
    this.events = {};
  }
  on(type, fn) {
    (this.events[type] || (this.events[type] = [])).push(fn)
  }
  emit(type) {
    if (this.events[type]) {
      this.events[type].forEach(fn =&gt; fn());
    }
  }
}
</code></pre><p>上面的类有一个基本属性 <code>events</code>，值为对象，用来存储不同类型的事件集合，原型方法 <code>on</code> 是用来订阅事件，第一个参数 <code>type</code> 为订阅事件的类型，<code>fn</code> 是要被执行的事件，<code>emit</code> 方法用来执行某个类型所有的事件。</p><pre><code class="lang-js">/* 发布/订阅的使用 */
const event = new Event();

// 订阅事件
event.on(&#39;say&#39;, () =&gt; console.log(&#39;hello&#39;));
event.on(&#39;say&#39;, () =&gt; console.log(&#39;world&#39;));

// 发布事件
event.emit(&#39;say&#39;);

// hello
// world
</code></pre><h3 id="发布-订阅模式的应用"><a href="#发布-订阅模式的应用" class="headerlink" title="发布/订阅模式的应用"></a>发布/订阅模式的应用</h3><p><strong>浏览器事件监听：</strong></p><pre><code class="lang-html">&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;
&lt;script&gt;
  const btn = document.getElementById(&#39;btn&#39;);

  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(1));
  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(2));
  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(3));
&lt;/script&gt;
</code></pre><p>当点击按钮触发事件时，三个回调函数会按照添加的顺序依次执行。</p><p><strong><code>Promise</code> 的异步调用的回调管理：</strong></p><pre><code class="lang-js">const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(&#39;res&#39;), 3000);
});

promise.then(data =&gt; console.log(1, data));
promise.then(data =&gt; console.log(2, data));
</code></pre><p>上面给同一个 <code>Promise</code> 实例的 <code>then</code> 方法中添加了两个回调函数，因为在创建 <code>Promise</code> 实例时内部使用了定时器，所以状态的变化延后了 <code>3s</code>，其实在 <code>Promise</code> 内部也是通过队列来对 <code>then</code> 的回调进行统一管理，在状态发生变化后立即循环执行。</p><blockquote class="pullquote danger"><p><strong>在 <code>Node.js</code> 中，有一个核心模块 <code>events</code> 提供的类 <code>EventEmitter</code>，几乎所有的事件都是基于这个模块实现的，如流的 <code>data</code> 和 <code>end</code> 事件、<code>http</code> 的 <code>request</code> 事件，而 <code>EventEmitter</code> 的内部原理就是 “发布/订阅模式”。</strong></p></blockquote><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="观察者模式的简单实现"><a href="#观察者模式的简单实现" class="headerlink" title="观察者模式的简单实现"></a>观察者模式的简单实现</h3><p>下面我们是 “观察者模式” 的案例，通过上面 “发布/订阅模式” 的实现来对比一下异同。</p><pre><code class="lang-js">/* 观察者模式 */
// 被观察者类
class Star {
  constructor(name) {
    this.name = name;
    this.state = &#39;&#39;;
    this.observers = [];
  }
  getState() {
    return this.state;
  }
  setState(state) {
    this.state = state;
    this.notify(); // 更新状态后通知
  }
  attach(observer) {
    this.observers.push(observer); // 添加观察者
  }
  notify() {
    // 订阅状态的观察者更新修改后的状态
    this.observers.forEach(observer =&gt; observer.update());
  }
}

// 观察者类
class Fan {
  constructor(name, star) {
    this.name = name;
    this.star = star;
    this.star.attach(this);
  }
  update() {
    console.log(&#39;我喜欢的明星喜欢&#39; + this.star.getState() + &#39;，我也喜欢。&#39;);
  }
}
</code></pre><p>在 “观察者模式” 中有两个基本的类，观察者和被观察者，被观察者提供状态 <code>state</code>，观察者去使用这个状态，当被观察者更新状态时会主动发布到订阅了状态的观察中，实现同步更新。</p><pre><code class="lang-js">const star = new Star(&#39;Super Star&#39;);
const fan = new Fan(&#39;张三&#39;, star);

star.setState(&#39;绿色&#39;);

// 我喜欢的明星喜欢绿色，我也喜欢。
</code></pre><h3 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h3><p><strong><code>Vue</code> 框架的数据响应式原理及 <code>watch</code> 方法：</strong></p><pre><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;p&gt;FullName: {{fullName}}&lt;/p&gt;
  &lt;p&gt;
    FirstName:
    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt;
  &lt;/p&gt;
  &lt;p&gt;
    LastName:
    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt;
  &lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  new Vue({
    el: &#39;#root&#39;,
    data: {
      firstName: &#39;张&#39;,
      lastName: &#39;三&#39;,
      fullName: &#39;张三&#39;
    },
    watch: {
      firstName(newName, oldName) {
        this.fullName = newName + this.lastName;
      }
    }
  });
&lt;/script&gt;
</code></pre><p>在 <code>Vue 2.x</code> 版本的数据响应式和 <code>watch</code> 监听的底层，就使用了 “观察者模式”，在模板解析过程中为变量添加观察者（<code>watcher</code>），在使用 <code>Object.defineProperty</code> 的 <code>getter</code> 和 <code>setter</code> 进行劫持数据，数据获取和更改会触发 <code>get</code> 和 <code>set</code> 方法，进而执行订阅和通知的逻辑，而通知的过程中调用了被统一管理的观察者的 <code>update</code> 方法，实现了视图层与数据层的同步。</p><p><strong><code>redux</code> 的 <code>createStore</code> 方法：</strong></p><pre><code class="lang-js">function createStore(reducer) {
  let state;
  let listeners = [];

  // 获取 store
  const getState = () =&gt; JSON.parse(JSON.stringify(state));

  // 订阅方法
  const subscribe = fn =&gt; {
    listeners.push(fn);

    // 取消订阅方法
    return () =&gt; {
      listeners = listeners.filter(listener =&gt; listener !== fn);
    };
  }

  // 派发动作
  const dispatch = action =&gt; {
    state = reducer(state, action);
    listeners.forEach(listener =&gt; listener());
  }

  dispatch({ type: &#39;@INIT&#39; });

  return {
    getState,
    subscribe,
    dispatch
  };
}
</code></pre><p>在 <code>redux</code> 的实现思想中也包含了 “观察者模式”，例如在 <code>redux</code> 与 <code>React</code> 的配合使用，<code>redux</code> 提供了订阅的方法 <code>subscribe</code> 和派发动作更新 <code>store</code> 的方法 <code>dispatch</code>，<code>React</code> 组件会使用 <code>store</code> 中提供的状态数据，这个 <code>store</code> 就是被观察者，而观察者就是 <code>React</code> 的各个组件，当使用 <code>dispatch</code> 派发动作更新数据时，会执行所有的观察者中的监听函数，实现组件数据与 <code>store</code> 的同步。</p><h2 id="发布-订阅模式和观察者模式"><a href="#发布-订阅模式和观察者模式" class="headerlink" title="发布/订阅模式和观察者模式"></a>发布/订阅模式和观察者模式</h2><p>观察者模式是由 “发布/订阅模式” 演变过来的，都存在订阅、通知的事件机制，“发布/订阅模式” 是对订阅的事件进行统一管理，主动触发通知，依次执行订阅的事件，而 “观察者模式” 是通过一个单独类去订阅观察者，当状态发生变化时通知到各个 “观察者” 实现状态的更新同步。</p><blockquote class="pullquote info"><p><strong>“发布/订阅模式” 与 “观察者模式” 的区别：</strong></p><ul><li><strong>“发布/订阅模式” 事件是统一由调度中心调度，订阅发布不存在依赖；</strong></li><li><strong>“观察者模式” 事件是被观察者调度，订阅与发布是存在依赖的；</strong></li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“观察者模式” 的意义就在于可以使多个对象数据重合的部分进行复用，同时还可以对各个对象之间解耦，最重要的是数据更新可以及时通知所有数据的使用者进行数据同步，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/8.observe" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack4 —— 基础篇</title>
    <url>/20181002041434/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181002041434/webpack-basic.png" title="webpack basic"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181115105656/" target="_blank">Webpack4 —— 应用篇</a></li><li><a href="/20181110203121/" target="_blank">Webpack4 —— 优化篇</a></li></ul></blockquote><h2 id="为什么需要构建工具？"><a href="#为什么需要构建工具？" class="headerlink" title="为什么需要构建工具？"></a>为什么需要构建工具？</h2><blockquote class="pullquote info"><ul><li><strong>转换 <code>ES6+</code> 语法；</strong></li><li><strong>转换 <code>JSX</code> 语法 / <code>Vue</code> 指令；</strong></li><li><strong><code>CSS</code> 私有前缀补全 / 预处理器（<code>less</code>，<code>sass</code>）；</strong></li><li><strong>压缩混淆 / 图片压缩；</strong></li></ul></blockquote><a id="more"></a><h2 id="为什么选择-Webpack？"><a href="#为什么选择-Webpack？" class="headerlink" title="为什么选择 Webpack？"></a>为什么选择 Webpack？</h2><p>早期的打包工具有 <code>Grount</code>，把打包构建分成一个一个的任务，队列式的处理每一个任务，如解析 <code>html</code> 任务、解析 <code>CSS</code> 任务、解析 <code>JS</code> 任务、图片压缩任务、代码压缩任务等等，每一个任务处理完成之后会将任务结果存放在本地磁盘的 <code>.temp</code> 目录，由于产生了 <code>IO</code> 操作，会导致打包速度比较慢。</p><p>后来产生了 <code>Glup</code>，原理与 <code>Grount</code> 类似，管道式的处理打包任务，不同的是 <code>Gulp</code> 有文件流的概念，每一个任务构建后的结果不会存放磁盘，而是存在内存中，在下一个步骤中可以直接使用上一个步骤内存中的结果，提高了打包速度。</p><p>目前最火爆的打包工具是 <code>Webpack</code>，在打包性能优于上面工具的基础上，更归功于丰富的生态社区、配置灵活的 <code>loader</code> 和 <code>plugin</code>，可以通过很灵活的配置完成团队项目个性化的打包需求，并且拥有强大的官方团队进行更新迭代，维护了众多稳定的 <code>loader</code> 和 <code>plugin</code>，更新速度非常快。</p><h2 id="安装-Webpack-及打包命令"><a href="#安装-Webpack-及打包命令" class="headerlink" title="安装 Webpack 及打包命令"></a>安装 Webpack 及打包命令</h2><p><strong>安装：</strong></p><pre><code class="lang-bash">$ npm install webpack webpack-cli -D
</code></pre><p>使用 <code>Webpack</code> 进行打包执行的其实是 <code>./node_modules/.bin</code> 目录的 <code>webpack</code> 文件。</p><pre><code class="lang-bash"># 打包命令
$ ./node_modules/.bin/webpack
</code></pre><p>为了方便项目中通常将打包命令配置在 <code>package.json</code> 的 <code>scripts</code> 中。</p><pre><code class="lang-json">/* 打包命令配置 */
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;
  }
}
</code></pre><p><strong>执行配置后的打包命令：</strong></p><pre><code class="lang-bash">$ npm run build
</code></pre><h2 id="Webpack-基础配置"><a href="#Webpack-基础配置" class="headerlink" title="Webpack 基础配置"></a>Webpack 基础配置</h2><h3 id="零配置"><a href="#零配置" class="headerlink" title="零配置"></a>零配置</h3><p>在 <code>Webpack4</code> 中，在不编写配置文件也可以进行打包，这就是 <code>4.x</code> 版本号称的 “零配置”，其实内部默认对入口文件（<code>entry</code>）和出口文件（<code>output</code>）进行了配置。</p><pre><code class="lang-js">/* 零配置默认值 */
module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: &#39;./dist/main.js&#39;
}
</code></pre><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p><code>mode</code> 是 <code>Webpack4</code> 新提出的概念，用来指定当前构建环境是开发环境（<code>production</code>）、生产环境（<code>development</code>）或 <code>none</code>，默认为 <code>production</code>，设置 <code>mode</code> 可以使用 <code>Webpack</code> 的一些参数值和内置的函数，也可以在打包时针对不同的环境配置不同的打包和优化策略。</p><p><strong><code>mode</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  mode: &#39;development&#39;
  // ...
}
</code></pre><blockquote class="pullquote warning"><p><strong>设置为 <code>development</code> 开启的参数如下：</strong></p><ul><li><strong>设置 <code>process.env.NODE_ENV</code> 值为 <code>development</code>；</strong></li><li><strong>开启 <code>NamedChunksPlugin</code>、<code>NamedModulesPlugin</code>，在代码热更新阶段标识更新的 <code>chunk</code> 和具体模块。</strong></li></ul><p><strong>设置为 <code>production</code> 开启的参数如下：</strong></p><ul><li><strong>设置 <code>process.env.NODE_ENV</code> 值为 <code>production</code>；</strong></li><li><strong>开启 <code>FlagDependencyUsagePlugin</code>、<code>FlagIncludedChunksPlugin</code>、<code>NoEmitOnErrorsPlugin</code>、<code>ModuleConcatenationPlugin</code>、<code>OccurrenceOrderPlugin</code>、<code>SideEffectsFlagPlugin</code>、<code>TerserPlugin</code>，开启这些插件 <code>Webpack</code> 会对 <code>JS</code> 压缩，识别 <code>package.json</code> 文件中标识代码是否存在副作用的参数等。</strong></li></ul><p><strong>将 <code>mode</code> 设置为 <code>none</code> 不开启任何优化选项。</strong></p></blockquote><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p><code>entry</code> 用于配置打包文件的入口，这个文件中会存在一些依赖关系，依赖的模块又存在依赖关系，最后形成一棵依赖树，<code>Webpack</code> 则将这些模块根据依赖关系，最后打包成多个静态资源，<code>entry</code> 主要有两种应用场景（单页应用和多页应用），配置如下。</p><pre><code class="lang-js">/* 单入口（SPA） */
module.exports = {
  entry: &#39;./src/index.js&#39;
}
</code></pre><pre><code class="lang-js">/* 多入口（多页应用） */
module.exports = {
  entry: {
    app: &#39;./src/pages/app.js&#39;,
    adminApp: &#39;./src/pages/adminApp.js&#39;
  }
}
</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>entry</code> 配置是用于指定的是源代码，那 <code>output</code> 就是用于指定 <code>Webpack</code> 打包后的结果代码，即用来告诉 <code>Webpack</code> 如何将编译后的文件输出到磁盘。</p><pre><code class="lang-js">module.exports = {
  // ...
  output: {
    filename: &#39;bundle.js&#39;,
    path: __dirname + &#39;/dist&#39;
  }
}
</code></pre><p><code>output</code> 属性值为对象，其中 <code>filename</code> 属性用于指定打包输出后的文件名，<code>path</code> 用于指定打包输出的目录，如果是多页应用，可以使用占位符保证打包后输出多个出口文件名字的唯一性。</p><pre><code class="lang-js">/* 多页应用 */
module.exports = {
  entry: {
    app: &#39;./src/pages/app.js&#39;,
    adminApp: &#39;./src/pages/adminApp.js&#39;
  },
  output: {
    filename: &#39;[name].js&#39;,
    path: __dirname + &#39;/dist&#39;
  }
}
</code></pre><p>上面的 <code>[name]</code> 打包后最后输出的出口文件与入口配置的文件名对应，即 <code>app.js</code> 和 <code>adminApp.js</code>。</p><h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p><code>Webpack</code> 默认情况下只支持 <code>js</code> 和 <code>json</code> 两种文件类型，<code>loader</code> （加载器）是专门用来支持其他文件类型并把其他文件转换成有效的模块添加到依赖树中，每一个 <code>loader</code> 都默认导出一个函数，接受源文件作为参数，并返回转换的结果，<code>loaders</code> 选项是专门用来配置这些加载器的。</p><p><strong>常见 loader 表：</strong></p><table><thead><tr><th style="width:30%">名称</th><th>描述</th></tr></thead><tbody><tr><td>babel-loader</td><td>转化 ES6、ES7 等 JS 新特性</td></tr><tr><td>css-loader</td><td>支持 .css 文件的加载和解析</td></tr><tr><td>less-loader</td><td>将 less 文件转换成 css</td></tr><tr><td>ts-loader</td><td>将 TS 转换成 JS</td></tr><tr><td>file-loader</td><td>对图片、字体等文件的打包</td></tr><tr><td>raw-loader</td><td>将文件以字符串的形式导入</td></tr><tr><td>thread-loader</td><td>多进程打包 JS 和 CSS</td></tr></tbody></table><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.txt$/, // 指定匹配规则（文件后缀名）
        use: &#39;raw-loader&#39; // 指定使用的 loader 名称
      }
    ]
  }
}
</code></pre><h4 id="解析-ES6-语法"><a href="#解析-ES6-语法" class="headerlink" title="解析 ES6+ 语法"></a>解析 ES6+ 语法</h4><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader @babel/preset-env -D
</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        use: &#39;babel-loader&#39;
      }
      // ...
    ]
  }
  // ...
}
</code></pre><blockquote class="pullquote success"><p><strong>在工程中添加 <code>.babelrc</code> 文件来对解析的 <code>ES6+</code> 语法进行配置。</strong></p></blockquote><p><strong><code>.babelrc</code> 配置示例：</strong></p><pre><code class="lang-json">/* 以 babel7 为例 */
{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;
  ],
  &quot;plugins&quot;: [
    &quot;@babel/proposal-class-properties&quot;
    // ...
  ]
}
</code></pre><blockquote class="pullquote primary"><p><strong><code>babel</code> 配置主要包含两部分，<code>presets</code> 和 <code>plugins</code>，<code>plugins</code> 中配置的每一项都是为了解析某一个语法，而 <code>presets</code> 配置的是这些功能的集合。</strong></p></blockquote><h4 id="解析-React-的-JSX-语法"><a href="#解析-React-的-JSX-语法" class="headerlink" title="解析 React 的 JSX 语法"></a>解析 React 的 JSX 语法</h4><p>由于 <code>React</code> 是在 <code>.js</code> 或 <code>.jsx</code> 的文件中使用 <code>JSX</code> 语法，所以解析 <code>JSX</code> 语法也是解析 <code>JS</code> 工作的一部分，同样需要 <code>babel-loader</code>，需要在 <code>Webpack</code> 配置文件的 <code>loader</code> 配置中增加识别 <code>.jsx</code> 文件以及在 <code>.babelrc</code> 配置文件的 <code>presets</code> 中专门增加解析 <code>JSX</code> 功能的集合。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader @babel/preset-env @babel/preset-react -D
</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.(jsx?)$/,
        use: &#39;babel-loader&#39;
      }
      // ...
    ]
  }
  // ...
}
</code></pre><p><strong><code>.babelrc</code> 配置示例：</strong></p><pre><code class="lang-json">{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-react&quot;
  ],
  &quot;plugins&quot;: [
    &quot;@babel/proposal-class-properties&quot;
    // ...
  ]
}
</code></pre><h4 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h4><blockquote class="pullquote default"><p><strong>解析 <code>CSS</code> 主要靠 <code>css-loader</code> 和 <code>style-loader</code>：</strong></p><ul><li><strong><code>css-loader</code>：用于加载 <code>.css</code> 文件，并转换成 <code>CommonJS</code> 对象；</strong></li><li><strong><code>style-loader</code>：将样式通过 <code>&lt;style&gt;&lt;/style&gt;</code> 标签插入到 <code>html</code> 文件的 <code>head</code> 中。</strong></li></ul></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader -D
</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.css$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
      }
      // ...
    ]
  }
  // ...
}
</code></pre><blockquote class="pullquote warning"><p><strong>值得注意的是，在处理同一个类型文件使用多个 <code>loader</code> 时，是链式调用的，<code>loader</code> 的执行顺序是从右向左的，所以在编写解析 <code>CSS</code> 加载器配置时应该 <code>style-loader</code> 在前，<code>css-loader</code> 在后，即先通过 <code>css-loader</code> 解析 <code>.css</code> 文件，将解析好的结果传递给 <code>style-loader</code> 处理并插入到页面的 <code>head</code> 中。</strong></p></blockquote><h4 id="解析-Less-和-Sass"><a href="#解析-Less-和-Sass" class="headerlink" title="解析 Less 和 Sass"></a>解析 Less 和 Sass</h4><p><code>Less</code> 和 <code>Sass</code> 作为 <code>CSS</code> 的预编译语言，加入了很多编程的特性，功能更强，对样式的组织也更加的灵活，但是浏览器依然不识别，所以也需要 <code>Webpack</code> 进行编译转换。</p><p><strong>安装依赖（<code>Less</code>）：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader less-loader less -D
</code></pre><p><strong>安装依赖（<code>Sass</code>）：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader sass-loader node-sass -D
</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">/* less 配置 */
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.less$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]
      }
      // ...
    ]
  }
  // ...
}
</code></pre><pre><code class="lang-js">/* sass 配置 */
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.scss$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
      }
      // ...
    ]
  }
  // ...
}
</code></pre><h4 id="解析图片和字体资源"><a href="#解析图片和字体资源" class="headerlink" title="解析图片和字体资源"></a>解析图片和字体资源</h4><p><code>Webpack</code> 对其他类型的文件进行打包编译需要依赖 <code>file-loader</code>（专门用于处理文件）。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install file-loader -D
</code></pre><p><strong><code>file-loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.(png|svg|gif|jpe?g)$/, // 解析图片
        use: &#39;file-loader&#39;
      },
      {
        test: /\.(woff2?|eot|ttf|otf)$/, // 解析字体
        use: &#39;file-loader&#39;
      }
      // ...
    ]
  }
  // ...
}
</code></pre><blockquote class="pullquote default"><p><strong>也可以使用 <code>url-loader</code> 来实现对图片和字体资源的解析，<code>url-loader</code> 相比 <code>file-loader</code> 而言，支持更颗粒化的解析方式，可以配置解析后出口文件的具体目录，也可以根据资源大小设置将资源转换成 <code>base64</code>。</strong></p></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install url-loader -D
</code></pre><p><strong><code>url-loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.(png|svg|gif|jpe?g)$/, // 解析图片
        use: [
          {
            loader: &#39;url-loader&#39;,
            options: {
              limit: 10240, // 资源小于该数值转为 base64
              name: &#39;img/[name].[ext]&#39; // 打包后的输出路径
            }
          }
        ]
      }
      // 字体资源同理...
    ]
  }
  // ...
}
</code></pre><h4 id="PostCSS-对-CSS-的增强"><a href="#PostCSS-对-CSS-的增强" class="headerlink" title="PostCSS 对 CSS 的增强"></a>PostCSS 对 CSS 的增强</h4><p>在开发 <code>CSS</code> 时，存在着很多让我们头疼的的问题，比如有些 <code>CSS3</code> 的属性由于各浏览器的实现标准不同要加上不同的私有前缀，也比如为了在移动端进行页面适配使用的 <code>rem</code>、<code>vw</code> 单位与 <code>px</code> 的转换问题等等，其中的一部分问题其实是可以在 <code>Webpack</code> 构建的过程中直接解决的。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install postcss-loader autoprefixer postcss-px2rem -D
</code></pre><p>可以通过 <code>Webpack</code> 配置文件中直接配置，也可以 <code>PostCSS</code> 配置文件中进行配置。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 配置在 Webpack 配置文件 */
module.exports = {
  module: {
    rules: [
      // ...
      {
        test: /\.css/,
        use: [
          &#39;style-loader&#39;,
          &#39;css-loader&#39;,
          {
            loader: &#39;postcss-loader&#39;, // 使用 postcss-loader
            options: {
              plugins: [
                // 添加私有前缀
                require(&#39;autoprefixer&#39;)({
                  // 兼容浏览器版本（最后两个版本、使用率大于 1%，ios 7 以上）
                  browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;]
                }),
                // px 自动转换 rem
                require(&#39;postcss-px2rem&#39;)({
                  remUnit: 75, // 75 px 等于 1 rem
                  remPrecision: 8 // 换算结果小数点后面保留几位小数
                })
                // ...
              ]
            }
          }
        ]
      }
      // ...
    ]
  }
}
</code></pre><pre><code class="lang-js">/* 在 postcss.config.js 中配置 */
module.exports = {
  plugins: [
    require(&#39;autoprefixer&#39;)({
      browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;]
    }),
    require(&#39;postcss-px2rem&#39;)({
      remUnit: 75,
      remPrecision: 8
    })
    // ...
  ]
}
</code></pre><p>如果使用其他 <code>PostCSS</code> 的功能也是类似的，需要先下载对应的 <code>PostCSS</code> 插件，然后在配置文件中进行配置。</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p><code>plugins</code> 通常用来对 <code>Webpack</code> 打包功能的增强，对打包过程和出口文件大小的优化、资源管理和环境变量的注入，可以作用域整个构建过程。</p><p><strong>常见 plugin 表：</strong></p><table><thead><tr><th style="width:35%">名称</th><th>描述</th></tr></thead><tbody><tr><td>CommonsChunkPlugin</td><td>将 chunks 相同的模块代码提取成公共 js</td></tr><tr><td>CleanWebpackPlugin</td><td>清理构建目录</td></tr><tr><td>ExtracTextWebpackPlugin</td><td>将 CSS 从 bundle 文件里提取成一个独立的 .css 文件</td></tr><tr><td>CopyWebpackPlugin</td><td>将文件或者文件夹拷贝到构建的输出目录</td></tr><tr><td>HtmlWebpackPlugin</td><td>创建 html 文件并注入 bundle 文件</td></tr><tr><td>UglifyjsWebpackPlugin</td><td>压缩 .js 文件</td></tr><tr><td>ZipWebpackPlugin</td><td>将打包出的资源生成一个 .zip 包</td></tr></tbody></table><p><br></p><h4 id="自动生成-index-html"><a href="#自动生成-index-html" class="headerlink" title="自动生成 index.html"></a>自动生成 index.html</h4><p>自动生成 <code>index.html</code> 文件主要通过 <code>HtmlWebpackPlugin</code> 插件实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">// 引入插件
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = {
  // ...
  plugins: [
    // 创建插件的实例
    new HtmlWebpackPlugin({
      template: &#39;./src/index.html&#39;, // 模板文件路径
      filename: &#39;index.html&#39; // 输出文件名称
    })
    // ...
  ]
}
</code></pre><h4 id="抽取-CSS-文件"><a href="#抽取-CSS-文件" class="headerlink" title="抽取 CSS 文件"></a>抽取 CSS 文件</h4><p><code>Webpack</code> 在上面对 <code>CSS</code> 的解析中，使用了 <code>css-loader</code> 和 <code>style-loader</code>，通过构建后的结果发现 <code>.css</code> 文件被注入到了 <code>.js</code> 文件中，在生产环境通常会为了减小出口文件的体积对 <code>.css</code> 文件进行抽离，在 <code>Webpack4</code> 中使用 <code>MiniCssExtractPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install mini-css-extract-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader, // 用于将 CSS 抽离的加载器
          &#39;css-loader&#39;,
        ]
      }
      // ...
    ]
  },
  plugins: [
    // ...
    new MiniCssExtractPlugin({
      filename: &#39;[name].css&#39; // 抽离的文件名
    })
    // ...
  ]
  // ...
}
</code></pre><blockquote class="pullquote info"><p><strong>解析 <code>.css</code> 文件无论哪种方式需要使用 <code>css-loader</code>，但 <code>MiniCssExtractPlugin</code> 提供的 <code>loader</code> 与 <code>style-loader</code> 的功能是互斥的，<code>style-loader</code> 用于将解析的 <code>CSS</code> 注入，而 <code>MiniCssExtractPlugin.loader</code> 意在单独抽离。</strong></p></blockquote><h4 id="自动清理构建目录"><a href="#自动清理构建目录" class="headerlink" title="自动清理构建目录"></a>自动清理构建目录</h4><p>如果输出的文件配置了 <code>hash</code> 且在每次构建时没有及时删除指定的输出目录（如 <code>dist</code>），会导致输出目录中的文件越来越多，不容易区分哪些是新构建出来的文件，所以应该让 <code>Webpack</code> 在每次构建之前清除输出的目录。</p><p>当然清除的方式可以多种，比如手动删除，或者在 <code>package.json</code> 中配置的构建命令中增加前置命令如下。</p><pre><code class="lang-json">/* 不优雅的方式 */
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rm -rf ./dist &amp;&amp; webpack&quot;
  }
}
</code></pre><p>这种方式并不优雅，完全可以通过 <code>Webpack</code> 配置中增加 <code>CleanWebpackPlugin</code> 插件来解决这个问题，这样在每次构建之前就会自动清除输出目录。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install clean-webpack-plugin -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);

module.exports = {
  // ...
  output: {
    filename: &#39;[name][chunkhash:8].js&#39;,
    path: __dirname + &#39;dist&#39;
  }
  plugins: [
    new CleanWebpackPlugin()
  ]
  // ...
}
</code></pre><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>Webpack</code> 中，文件监听是指发现源文件发生变化时，自动重新构建出新的输出文件。</p><blockquote class="pullquote success"><p><strong><code>Webpack</code> 开启监听模式有两种方式：</strong></p><ul><li><strong>启动 <code>Webpack</code> 命令时带上 <code>--watch</code> 参数，可以在 <code>package.json</code> 中进行配置；</strong></li><li><strong>在 <code>Webpack</code> 配置文件中进行设置。</strong></li></ul></blockquote><p><strong>添加参数：</strong></p><pre><code class="lang-json">/* 配置命令 */
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;watch&quot;: &quot;webpack --watch&quot;
  }
}
</code></pre><p><strong>执行命令：</strong></p><pre><code class="lang-bash">$ npm run watch
</code></pre><p><strong><code>Webpack</code> 配置文件：</strong></p><pre><code class="lang-js">/* webpack 配置文件 */
module.exports = {
  // ...
  watch: true, // 开启监听
  watchOptions: {
    // 忽略监听的文件目录
    ignored: /node_modules/,
    // 监听到发生变化会等待 300ms 去重新构建（防止多次保存），默认 300ms
    aggregateTimeout: 300，
    // 每秒检查 1000 次
    poll: 1000
  }
  // ...
}
</code></pre><p><strong><code>watch</code> 监听原理分析：</strong></p><blockquote class="pullquote warning"><p><strong><code>Webpack</code> 会轮询的判断文件的最后编辑时间是否发生变化，如果某个文件发生变化不会立即重新构建，而是会将变化缓存起来，等待 <code>aggregateTimeout</code> 配置的时间后重新构建，这样做是为了防止短时间的多次变化或产生了新的变化文件，在该时间到达时将变化的文件列表进行统一构建，以提高性能，这样的监听方式的缺陷是浏览器不会自动刷新，需要手动刷新查看文件修改后的效果。</strong></p></blockquote><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p><code>webpack-dev-server</code> 是在本地启动服务来监听文件的变化，不是以输出文件的形式更新，而是即时将重新构建的结果放在内存中。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install webpack-dev-server -D
</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  mode: &#39;development&#39;, // 由于 webpack-dev-server 在开发环境中使用
  devServer: {
    host: &#39;localhost&#39;, // 本地服务的域名
    contentBase: &#39;./dist&#39;, // server 作用的目录
    port: 8080, // 端口号
    compress: true // 是否启动服务器压缩
  }
  // ...
}
</code></pre><p><strong>配置服务启动命令：</strong></p><pre><code class="lang-json">{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;
  }
}
</code></pre><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>在 <code>Webpack</code> 构建后的代码中，经过了压缩、混淆等，会出现一个新的问题，就是代码执行出错后不容定位错误是在源代码中哪一个位置产生的，而 <code>devtool</code> 的配置的作用就是让我们更容易定位错误的位置。</p><p><strong><code>devtool</code> 的关键词：</strong></p><table><thead><tr><th style="width:30%">关键词</th><th>作用</th></tr></thead><tbody><tr><td>evel</td><td>使用 evel 函数包裹代码</td></tr><tr><td>source-map</td><td>产生 .map 文件</td></tr><tr><td>cheap</td><td>不含列信息</td></tr><tr><td>inline</td><td>将 .map 内容作为 DataURI 嵌入，不单独生成 .map 文件</td></tr><tr><td>module</td><td>包含 loader 的 source-map</td></tr></tbody></table><p><code>devtool</code> 属性的值就是由上面的关键词组成的，不同的名字会使用不同的调试策略，而名字中的关键词则包含了上面特性，下面是 <code>Webpcak</code> 官网给出的不同构建策略对应的信息。</p><table><thead><tr><th style="width:36%">devtool</th><th style="width:8%">首次构建</th><th style="width:8%">二次构建</th><th style="width:14%">是否适合生产环境</th><th>可以定位的代码</th></tr></thead><tbody><tr><td>none</td><td>+++</td><td>+++</td><td>yes</td><td>最终输出的代码</td></tr><tr><td>eval</td><td>+++</td><td>+++</td><td>no</td><td>Webpack 生成的代码（一个个的模块）</td></tr><tr><td>cheap-eval-source-map</td><td>+</td><td>++</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>cheap-module-eval-source-map</td><td>o</td><td>++</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>eval-source-map</td><td>--</td><td>+</td><td>no</td><td>源代码</td></tr><tr><td>cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>inline-cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>inline-cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>source-map</td><td>--</td><td>--</td><td>yes</td><td>源代码</td></tr><tr><td>inline-source-map</td><td>--</td><td>--</td><td>no</td><td>源代码</td></tr><tr><td>hidden-source-map</td><td>--</td><td>--</td><td>yes</td><td>源代码</td></tr><tr><td>nosources-source-map</td><td>--</td><td>--</td><td>yes</td><td>无源代码</td></tr></tbody></table><blockquote class="pullquote info"><p><strong><code>+++</code> 非常快速，<code>++</code> 快速，<code>+</code> 比较快，<code>o</code> 中等，<code>-</code> 比较慢，<code>--</code> 慢</strong></p></blockquote><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {
  // ...
  devtool: &#39;evel&#39;
  // ...
}
</code></pre><p>使用不同的 <code>devtool</code> 会带来不同的效果，使用 <code>evel</code> 不安全，使用 <code>inline</code> 注入会增加打包文件的大小、线上环境生成 <code>.map</code> 文件会容易被人反编译进而暴露业务逻辑等等，所以在 <code>devtool</code> 使用时还是根据自己的需要和安全考虑来权衡。</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><h3 id="配置热更新的方式"><a href="#配置热更新的方式" class="headerlink" title="配置热更新的方式"></a>配置热更新的方式</h3><p><code>webpack-dev-server</code> 可以配合自带的插件实现热更新，即文件修改后，不刷新浏览器的情况下自动构建并在浏览器中响应渲染。</p><pre><code class="lang-js">/* 使用 webpack-dev-server */
const webpack = require(&#39;webpack&#39;);

module.exports = {
  // ...
  mode: &#39;development&#39;,
  devServer: {
    host: &#39;localhost&#39;,
    contentBase: &#39;./dist&#39;,
    port: 8080,
    compress: true
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
  // ...
}
</code></pre><p>想要颗粒度更细致的控制 <code>Webpack</code> 的热更新，也可以使用另一种方式，即借助 <code>Express</code> 或 <code>Koa</code> 自己创建一个服务，并借助 <code>webpack-dev-middleware</code> 来实现热更新，这种方式更适合灵活的定制化场景。</p><pre><code class="lang-js">/* 使用 webpack-dev-middleware */
const express = require(&#39;express&#39;);
const webpack = require(&#39;webpack&#39;);
const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;);
const config = require(&#39;./webpack.config.js&#39;);

const app = express();
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

app.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><h3 id="热更新原理简介"><a href="#热更新原理简介" class="headerlink" title="热更新原理简介"></a>热更新原理简介</h3><blockquote class="pullquote primary"><p><strong>热更新的实现分为服务端和浏览器两个部分：</strong></p><ul><li><strong>Webpack Dev Server</strong><ul><li><strong><code>Webpack Compile</code>：<code>Webpack</code> 的编译器，作用是将 <code>JS</code> 编译成 <code>Bundle</code>；</strong></li><li><strong><code>HMR Server</code>：将热更新的文件输出给 <code>HMR Runtime</code>；</strong></li><li><strong><code>Bundle Server</code>：提供文件在浏览器以服务器的方式访问。</strong></li></ul></li><li><strong>Browser</strong><ul><li><strong><code>HMR Runtime</code>：开发阶段打包过程中，会被注入到浏览器，使浏览器的 <code>bundle.js</code> 和服务器建立 <code>websocket</code> 链接，以更新文件的变化；</strong></li><li><strong><code>bundle.js</code>：构建输出的文件。</strong></li></ul></li></ul></blockquote><blockquote class="pullquote success"><p><strong><code>Webpack</code> 在将本地文件显示在浏览器其实有两个阶段：</strong></p><ul><li><strong>第一个阶段为启动阶段通过 <code>Webpack Compile</code> 将文件系统中的文件进行构建，然后将文件传递给 <code>Bundle Server</code>，<code>Bundle Server</code> 将 <code>bundle.js</code> 响应给浏览器；</strong></li><li><strong>第二个阶段为热更新阶段，依然通过 <code>Webpack Compile</code> 对文件系统中修改的文件进行构建，将构建后的结果传递给 <code>HMR Server</code>，<code>HMR Server</code> 通过 <code>Websocket</code> 协议将文件变化的结果通知浏览器端的 <code>HMR Runtime</code>，执行代码并刷新页面。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>未完待续…</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Webpack</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 外观模式</title>
    <url>/20181001165125/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181001165125/facade.jpg" title="外观模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote warning"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="外观模式简介"><a href="#外观模式简介" class="headerlink" title="外观模式简介"></a>外观模式简介</h2><p>“外观模式” 就是把一些复杂的流程封装成一个接口，提供给外部更简单的使用。</p><blockquote class="pullquote info"><p><strong>在外观模式中存在三种角色如下：</strong></p><ul><li><strong>门面角色（<code>Facade</code>）：是 “外观模式” 的核心，它熟悉子系统的功能，并被客户角色调用，内部实现了客户角色需求功能的组合；</strong></li><li><strong>子系统角色（<code>System</code>）：实现了子系统的功能（多个），对于客户角色是未知的；</strong></li><li><strong>客户角色（<code>Client</code>）：通过调用 <code>Facede</code> 来完成要实现的功能。</strong></li></ul></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181001165125/facade-uml.jpg" alt="外观模式 UML 图"></div><div class="image-caption">外观模式 UML 图</div></figure><p><br></p><h2 id="外观模式的实现"><a href="#外观模式的实现" class="headerlink" title="外观模式的实现"></a>外观模式的实现</h2><p>上面已经介绍了 “外观模式” 的各个角色，下面是简单的代码实现。</p><pre><code class="lang-js">// 子系统角色 Sum
class Sum {
  sum(a, b) {
    return a + b;
  }
}

// 子系统角色 Minus
class Minus {
  minus(a, b) {
    return a - b;
  }
}

// 子系统角色 Multipy
class Multipy {
  multipy(a, b) {
    return a * b;
  }
}

// 子系统角色 Divide
class Divide {
  divide(a, b) {
    return a / b;
  }
}

// 门面角色 Calculator
class Calculator {
  constructor() {
    this.sumObj = new Sum();
    this.minusObj = new Minus();
    this.multipyObj = new Multipy();
    this.divideObj = new Divide();
  }
  sum(...args) {
    return this.sumObj.sum(...args);
  }
  minus(...args) {
    return this.minusObj.minus(...args);
  }
  multipy(...args) {
    return this.multipyObj.multipy(...args);
  }
  divide(...args) {
    return this.divideObj.divide(...args);
  }
}

// 客户角色
const calculator = new Calculator();

console.log(calculator.sum(1, 2)); // 3
console.log(calculator.minus(1, 2)); // -1
console.log(calculator.multipy(1, 2)); // 2
console.log(calculator.divide(1, 2)); // 0.5
</code></pre><p>我们在上面代码中实现了一个计算器功能，计算器具备的功能为加、减、乘、除，我们把这四个功能分别拆分成为四个子系统，用门面类 <code>Calculator</code> 来进行连接，这样只需要调用 <code>Calculator</code> 的实例（客户角色）就可以调用四个子系统模块分别提供的功能，但是上面的代码实现功能比较简洁，并没达到 “外观模式” 的真正作用，就是可以随意组合各个子系统的功能。</p><pre><code class="lang-js">/* 组合子系统功能 */
// 子系统角色 CPU
class CPU {
  start() {
    console.log(&#39;CPU 启动&#39;);
  }
}

// 子系统角色 Memory
class Memory {
  start() {
    console.log(&#39;内存启动&#39;);
  }
}

// 子系统角色 Disk
class Disk {
  start() {
    console.log(&#39;硬盘启动&#39;);
  }
}

// 门面角色 Computer
class Computer {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.disk = new Disk();
  }
  start() {
    // 组合子系统功能
    this.cpu.start();
    this.memory.start();
    this.disk.start();
  }
}

// 客户角色
const computer = new Computer();

computer.start();
// CPU 启动
// 内存启动
// 硬盘启动
</code></pre><p>上面代码打印了一个计算机的启动过程，功能来自于各个子系统，也可以通过门面角色实现子系统功能的多种组合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“外观模式” 的作用是可以对复杂功能解耦合，分散到各个子系统，使子系统与子系统互相独立，并对各个子系统提供外界访问的功能组合模块，这样既提高了子系统的维护性，又增加了外界访问功能的扩展性，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/7.facade" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 代理模式</title>
    <url>/20180929025641/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180929025641/proxy.jpg" title="代理模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h2><p>由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180929025641/proxy-uml.jpg" alt="代理模式 UML 图"></div><div class="image-caption">代理模式 UML 图</div></figure><p><br></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><pre><code class="lang-js">// 假设无法客户端无法直接使用这个类
class Google {
  get(url) {
    return url + &#39; is google&#39;;
  }
}

// 只能通过代理操作 Google 类
class Proxy {
  constructor() {
    this.google = new Google();
  }
  get(url) {
    return this.google.get(url);
  }
}

const proxy = new Proxy();
const result = proxy.get(&#39;http://www.google.com&#39;);
console.log(result); // http://www.google.com is google
</code></pre><p>假设 <code>Google</code> 类我们无法直接使用，只有 <code>Proxy</code> 可以使用 <code>Google</code>，我们可以通过 <code>Proxy</code> 类去操作使用 <code>Google</code> 类，此时 <code>Proxy</code> 类就是一个代理。</p><h2 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h2><p>在 <code>ES6</code> 标准以后，<code>JavaScript</code> 提供了原生的代理模式 <code>Proxy</code> 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。</p><pre><code class="lang-js">/* ES6 Proxy 的使用 */
const lucy = {
  name: &#39;lucy&#39;,
  age: 20,
  height: 165
};

const lucyMother = new Proxy(lucy, {
  get(target, key) {
    if (key === &#39;age&#39;) {
      return target.age - 2;
    } else if (key === &#39;height&#39;) {
      return target.height + 5;
    } else {
      return target[key];
    }
  },
  set(target, key, val) {
    if (key === &#39;boyfriend&#39;) {
      if (val.age &gt; 40) {
        console.log(&#39;太老了&#39;);
      } else if (val.salary &lt; 20000) {
        console.log(&#39;太穷了&#39;);
      } else {
        target[key] = val;
      }
    }
  }
});

console.log(lucyMother.name); // lucy
console.log(lucyMother.age); // 18
console.log(lucyMother.height); // 170

lucyMother.boyfriend = {
  age: 42,
  salary: 25000
}
// 太老了

lucyMother.boyfriend = {
  age: 36,
  salary: 18000
}
// 太穷了
</code></pre><p>上面是一个接地气的案例，创建一个对象存储 <code>lucy</code> 的基本信息，使用代理创建 <code>lucyMother</code> 为 <code>lucy</code> 找男朋友，通过代理对象获取 <code>lucy</code> 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。</p><h2 id="代理模式、适配器模式和装饰器模式"><a href="#代理模式、适配器模式和装饰器模式" class="headerlink" title="代理模式、适配器模式和装饰器模式"></a>代理模式、适配器模式和装饰器模式</h2><p>从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。</p><blockquote class="pullquote info"><ul><li><strong>代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；</strong></li><li><strong>代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来接口的功能；</strong></li><li><strong>适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。</strong></li></ul></blockquote><h2 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;事件委托&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul id=&quot;list&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
  &lt;/ul&gt;
  &lt;script&gt;
    const ulList = document.getElementById(&#39;list&#39;);

    ulList.addEventListener(&#39;click&#39;, function (event) {
      console.log(event.target.innerHTML);
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 <code>target</code> 获取到具体触发事件的子元素。</p><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 <code>loading</code> 图片来过渡，这就是图片加载的基本需求。</p><pre><code class="lang-js">/* node 服务器 */
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

const app = express();

app.get(&#39;/loading.gif&#39;, function (req, res) {
  res.sendFile(path.resolve(&#39;img&#39;, &#39;loading.gif&#39;));
});

app.get(&#39;/img/:name&#39;, function (req, res) {
  setTimeout(function () {
    res.sendFile(path.join(__dirname, req.path));
  }, 3000);
});

app.use(express.static(__dirname));

app.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>上面服务器模拟了加载图片响应慢的场景，<code>loading</code> 图片立即响应，其他图片则延迟 <code>3s</code> 响应。</p><pre><code class="lang-html">&lt;!-- Dom 结构 --&gt;
&lt;ul id=&quot;menu&quot;&gt;
  &lt;li data-src=&quot;/img/bg1.jpg&quot;&gt;图片1&lt;/li&gt;
  &lt;li data-src=&quot;/img/bg2.jpg&quot;&gt;图片2&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&quot;bgimg&quot;&gt;&lt;/div&gt;
</code></pre><pre><code class="lang-js">/* 没有实现 loading */
const menu = document.getElementById(&#39;menu&#39;);
const bgimg = document.getElementById(&#39;bgimg&#39;);

const background = (function () {
  const img = new Image();
  bgimg.appendChild(img)
  return {
    setSrc(src) {
      img.src = src;
    }
  }
})();

menu.addEventListener(&#39;click&#39;, function (event) {
  const src = event.target.dataset.src;
  background.setSrc(src);
});
</code></pre><p>上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 <code>loading</code> 图片过渡，之所以说图片加载应用了 “代理模式” 并不是指加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在事件监听的函数中增加 <code>loading</code> 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。</p><pre><code class="lang-js">/* 使用代理对象实现 loading 过渡 */
const menu = document.getElementById(&#39;menu&#39;);
const bgimg = document.getElementById(&#39;bgimg&#39;);

// 请求图片的对象
const background = (function () {
  const img = new Image();
  bgimg.appendChild(img)
  return {
    setSrc(src) {
      img.src = src;
    }
  }
})();

// 增加 loading 过度的代理对象
const proxyBackground = (function () {
  const img = new Image();
  img.onload = function () {
    background.setSrc(this.src);
  }
  return {
    setSrc(src) {
      background.setSrc(&#39;./img/loading.gif&#39;);
      img.src = src;
    }
  }
})();

// 监听获取图片的事件中使用的是代理对象 proxyBackground
menu.addEventListener(&#39;click&#39;, function (event) {
  const src = event.target.dataset.src;

  // 防止缓存
  proxyBackground.setSrc(src + &#39;?time=&#39; + Date.now());
});
</code></pre><p>上面的实现方式就符合 “代理模式”，<code>background</code> 对象是提供基本功能，而<code>proxyBackground</code>（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 <code>setSrc</code> 方法去请求图片。</p><h3 id="防抖代理"><a href="#防抖代理" class="headerlink" title="防抖代理"></a>防抖代理</h3><p>防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。</p><pre><code class="lang-html">&lt;!-- 未使用防抖代理处理 --&gt;
&lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;
&lt;script&gt;
  const ipt = document.getElementById(&#39;ipt&#39;);

  function post() {
    console.log(&#39;发送请求了&#39;);
  }

  ipt.addEventListener(&#39;input&#39;, post);
&lt;/script&gt;
</code></pre><p>上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。</p><pre><code class="lang-html">&lt;!-- 使用防抖代理优化 --&gt;
&lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;
&lt;script&gt;
  const ipt = document.getElementById(&#39;ipt&#39;);

  function post() {
    console.log(&#39;发送请求了&#39;);
  }

  // 代理函数去执行 post
  const debouncePost = (function () {
    let timer = null;
    return function () {
      clearInterval(timer);
      timer = setTimeout(function () {
        post();
      }, 500);
    }
  })();

  ipt.addEventListener(&#39;input&#39;, debouncePost);
&lt;/script&gt;
</code></pre><p>使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 <code>500ms</code> 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>使用 “代理模式” 的场景在后端会更多，比如代理跨域，<code>Nginx</code> 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/6.proxy" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 装饰器模式</title>
    <url>/20180928030105/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180928030105/decorator.jpg" title="装饰器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="装饰器模式概念"><a href="#装饰器模式概念" class="headerlink" title="装饰器模式概念"></a>装饰器模式概念</h2><p>“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180928030105/decorator-uml.jpg" alt="装饰器模式 UML 图"></div><div class="image-caption">装饰器模式 UML 图</div></figure><p><br></p><h2 id="装饰器模式和适配器模式"><a href="#装饰器模式和适配器模式" class="headerlink" title="装饰器模式和适配器模式"></a>装饰器模式和适配器模式</h2><pre><code class="lang-js">/* 装饰器模式案例 */
// 类 Duck
class Duck {
  constructor(name) {
    this.name = name;
  }
  eat(food) {
    console.log(this.name + &#39;吃&#39; + food);
  }
}

// 装饰器类 TangDuck，装饰 Duck 类
class TangDuck {
  constructor(name) {
    this.duck = new Duck(name);
  }
  eat(food) {
    this.duck.eat(food);
    console.log(&#39;说谢谢&#39;);
  }
}

const tangDuck = new TangDuck(&#39;唐老鸭&#39;);
tangDuck.eat(&#39;苹果&#39;);
// 唐老鸭吃苹果
// 说谢谢
</code></pre><pre><code class="lang-js">/* 适配器模式案例 */
// 类 Power
class Power {
  charge() {
    return &#39;220V&#39;;
  }
}

// 适配器
class Adaptor {
  constructor(Power) {
    this.power = new Power();
  }
  chargeTransform() {
    return this.power.charge() + &#39; =&gt; 22v&#39;;
  }
}

// 类 Power 的使用者
class Notepad {
  constructor(Power) {
    this.adaptor = new Adaptor(Power);
  }
  use() {
    console.log(this.adaptor.chargeTransform());
  }
}
</code></pre><p>上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。</p><h2 id="装饰器模式和继承"><a href="#装饰器模式和继承" class="headerlink" title="装饰器模式和继承"></a>装饰器模式和继承</h2><p>通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 <code>Coffee</code>，组成是咖啡加水，这个基础上可以加奶、糖、冰，需求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。</p><pre><code class="lang-js">/* 继承的实现方式 */
// 水 + 咖啡
class Coffee {
  make(water) {
    return water + &#39; + 咖啡&#39;
  }
  cost() {
    return 10;
  }
}

// 水 + 奶 + 咖啡
class MilkCoffee extends Coffee {
  constructor() {
    super();
  }
  make(water) {
    return super.make(water) + &#39; + 奶&#39;;
  }
  cost() {
    return super.cost() + 3;
  }
}

// 水 + 糖 + 咖啡
class SugarCoffee extends Coffee {
  constructor() {
    super();
  }
  make(water) {
    return super.make(water) + &#39; + 糖&#39;;
  }
  cost() {
    return super.cost() + 2;
  }
}

// 水 + 糖 + 奶 + 咖啡
class SugarMilkCoffee extends SugarCoffee {
  constructor() {
    super();
  }
  make(water) {
    return super.make(water) + &#39; + 奶&#39;;
  }
  cost() {
    return super.cost() + 3;
  }
}

// 水 + 奶 + 糖 + 咖啡
class MilkSugarCoffee extends MilkCoffee {
  constructor() {
    super();
  }
  make(water) {
    return super.make(water) + &#39; + 糖&#39;;
  }
  cost() {
    return super.cost() + 2;
  }
}
</code></pre><p>从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。</p><pre><code class="lang-js">/* 装饰器模式的实现方式 */
class Coffee {
  make(water) {
    return water + &#39; + 咖啡&#39;;
  }
  cost() {
    return 10;
  }
}

class MilkCoffee {
  constructor(parent) {
    this.parent = parent;
  }
  make(water) {
    return this.parent.make(water) + &#39; + 奶&#39;;
  }
  cost() {
    return this.parent.cost() + 3;
  }
}

class SugarCoffee {
  constructor(parent) {
    this.parent = parent;
  }
  make(water) {
    return this.parent.make(water) + &#39; + 糖&#39;;
  }
  cost() {
    return this.parent.cost() + 2;
  }
}

class IceCoffee {
  constructor(parent) {
    this.parent = parent;
  }
  make(water) {
    return this.parent.make(water) + &#39; + 冰&#39;;
  }
  cost() {
    return this.parent.cost() + 1;
  }
}

const coffee = new Coffee();
const milkCoffee = new MilkCoffee(coffee);
const sugarCoffee = new SugarCoffee(milkCoffee);
const iceCoffee = new IceCoffee(sugarCoffee);

console.log(milkCoffee.make(&#39;水&#39;), milkCoffee.cost());
console.log(sugarCoffee.make(&#39;水&#39;), sugarCoffee.cost());
console.log(iceCoffee.make(&#39;水&#39;), iceCoffee.cost());

// 水 + 咖啡 + 奶 13
// 水 + 咖啡 + 奶 + 糖 15
// 水 + 咖啡 + 奶 + 冰 16
</code></pre><p>从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。</p><blockquote class="pullquote info"><p><strong>装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。</strong></p></blockquote><h2 id="装饰器模式和-AOP-编程"><a href="#装饰器模式和-AOP-编程" class="headerlink" title="装饰器模式和 AOP 编程"></a>装饰器模式和 AOP 编程</h2><p>在软件业，<code>AOP</code> 为 <code>Aspect Oriented Programming</code> 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。</p><p>在 <code>JavaScript</code> 中的 <code>AOP</code> 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。</p><pre><code class="lang-js">/* AOP 编程的案例 */
// 给函数扩展 before 方法
Function.prototype.before = function (beforeFn) {
  let _this = this;
  return function () {
    beforeFn.apply(this, arguments);
    _this.apply(this, arguments);
  }
}

// 给函数扩展 after 方法
Function.prototype.after = function (afterFn) {
  let _this = this;
  return function () {
    _this.apply(this, arguments);
    afterFn.apply(this, arguments);
  }
}

// 原函数
function buy(money, goods) {
  console.log(&#39;花&#39; + money + &#39;元钱买&#39; + goods);
}

// 使用 before 方法给函数增加前切面
buy = buy.before(function () {
  console.log(&#39;向媳妇要1元钱&#39;);
});

// 使用 before 方法给函数增加后切面
buy = buy.after(function () {
  console.log(&#39;还给媳妇0.2元钱&#39;);
})

buy(0.8, &#39;盐&#39;);
// 向媳妇要1元钱
// 花0.8元钱买盐
// 还给媳妇0.2元钱
</code></pre><blockquote class="pullquote default"><p><strong><code>AOP</code> 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 <code>AOP</code> 编程的一种。</strong></p></blockquote><h2 id="装饰器模式的应用"><a href="#装饰器模式的应用" class="headerlink" title="装饰器模式的应用"></a>装饰器模式的应用</h2><h3 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。</p><pre><code class="lang-html">&lt;!-- 一个埋点的简单案例 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;埋点&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button data-name=&quot;wetermelon&quot; id=&quot;wetermelon&quot;&gt;西瓜&lt;/button&gt;
  &lt;button data-name=&quot;apple&quot; id=&quot;apple&quot;&gt;苹果&lt;/button&gt;
  &lt;script&gt;
    const wetermelon = document.getElementById(&#39;wetermelon&#39;);
    const apple = document.getElementById(&#39;apple&#39;);

    // 添加切面
    Function.prototype.after = function (afterFn) {
      let _this = this;
      return function () {
        _this.apply(this, arguments);
        afterFn.apply(this, arguments);
      }
    }

    // 事件处理函数
    function click() {
      console.log(&#39;你点击了&#39; + this.dataset.name);
    }

    click = click.after(function () {
      // 向服务器发送统计数据
      const img = new Image();
      img.src = &#39;http://localhost:3000/report?name=&#39; + this.dataset.name;
    });

    // 给所有的
    Array.from(document.querySelectorAll(&#39;button&#39;)).forEach(button =&gt; {
      button.addEventListener(&#39;click&#39;, click);
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-js">/* 负责统计点击次数的服务 */
const express = require(&#39;express&#39;);
const app = express();

// 存储按钮的点击次数
const goods = {};

app.get(&#39;/report&#39;, function (req, res) {
  const name = req.query.name;
  if (goods[name]) {
    goods[name]++;
  } else {
    goods[name] = 1;
  }

  res.json(goods);
});

app.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>上面的埋点就是通过 <code>AOP</code> 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 <code>report</code> 接口来获取当前各个按钮的点击次数。</p><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 <code>submit</code> 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 <code>AOP</code> 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。</p><pre><code class="lang-html">&lt;!-- 应用于表单校验 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;表单校验&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
  密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;
  &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt;
  &lt;script&gt;
    const submitBtn = document.getElementById(&#39;submit-btn&#39;);

    // 添加切面函数
    Function.prototype.before = function (beforeFn) {
      let _this = this;
      return function () {
        let result = beforeFn.apply(this, arguments);
        result &amp;&amp; _this.apply(this, arguments);
      }
    }

    // 表单提交事件
    function submit() {
      console.log(&#39;提交表单&#39;);
    }

    // 验证用户名
    submit = submit.before(function () {
      const username = document.getElementById(&#39;username&#39;).value;
      if (!username) {
        return alert(&#39;请输入用户名&#39;);
      }
      return true;
    });

    // 验证
    submit = submit.before(function () {
      const password = document.getElementById(&#39;password&#39;).value;
      if (!password) {
        return alert(&#39;请输入密码&#39;);
      }
      return true;
    });

    submitBtn.addEventListener(&#39;click&#39;, submit);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>JavaScript</code> 中 “装饰器模式” 和 <code>AOP</code> 编程非常相似，应用也非常多，如 <code>axios</code> 中对请求、响应的拦截方法，<code>Koa</code> 中间件，都包含这样的编程思想，而在 <code>ES6</code> 之后 <code>JavaScript</code> 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/5.decorator" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 适配器模式</title>
    <url>/20180927230432/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180927230432/adapter.jpg" title="适配器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote primary"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="适配器模式的概念"><a href="#适配器模式的概念" class="headerlink" title="适配器模式的概念"></a>适配器模式的概念</h2><p>“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180927230432/adapter-uml.jpg" alt="适配器模式 UML 图"></div><div class="image-caption">适配器模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">// 类 Power
class Power {
  charge() {
    return &#39;220V&#39;;
  }
}

// 适配器
class Adaptor {
  constructor(Power) {
    this.power = new Power();
  }
  chargeTransform() {
    return this.power.charge() + &#39; =&gt; 22V&#39;;
  }
}

// 类 Power 的使用者
class Notepad {
  constructor(Power) {
    this.adaptor = new Adaptor(Power);
  }
  use() {
    console.log(this.adaptor.chargeTransform());
  }
}

const notepad = new Notepad(Power);
notepad.use(); // 220V =&gt; 22V
</code></pre><p>上面代码中有三个类，<code>Power</code> 类为电源，提供 <code>220V</code> 电压，<code>Notepad</code> 为我们的电子设备，使用电压 <code>22V</code>，明显两个类是不匹配的，此时的 <code>Adaptor</code> 就是一个适配器，作用是连接 <code>Power</code> 与 <code>Notepad</code>，将 <code>220V</code> 转换为 <code>22V</code>。</p><blockquote class="pullquote warning"><p><strong>适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。</strong></p></blockquote><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配参数和返回数据"><a href="#适配参数和返回数据" class="headerlink" title="适配参数和返回数据"></a>适配参数和返回数据</h3><p>在浏览器通过 <code>Ajax</code> 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。</p><p>在请求响应后，后端会返回给我们 <code>JSON</code> 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。</p><pre><code class="lang-js">// 请求方法
function ajax(options) {
  const defaultOptions = {
    method: &#39;GET&#39;,
    dataType: &#39;JSON&#39;
  };

  initParams(options, defaultOptions); // 适配参数
}

// 参数适配器
function initParams(options, defaultOptions) {
  for (let attr in options) {
    defaultOptions[attr] = options[attr] || defaultOptions[attr];
  }

  return defaultOptions;
}

// 数据适配器
function tranformData(data) {
  return JSON.parse(data);
}

// 使用适配器
ajax({
  url: &#39;www.pandashen.com&#39;,
  method: &#39;POST&#39;,
  success(json) {
    const result = tranformData(json); // 适配返回数据
    console.log(result);
  }
});
</code></pre><h3 id="适配转换-Promise"><a href="#适配转换-Promise" class="headerlink" title="适配转换 Promise"></a>适配转换 Promise</h3><p>在 <code>Node.js</code> 的 <code>fs</code> 模块中有很多异步的方法，比如 <code>readFile</code>，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 <code>Promise</code> 实例。</p><pre><code class="lang-js">const fs = require(&#39;fs&#39;);

// 适配成 Promise
function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) =&gt; {
      fn.call(null, ...args, (err, data) =&gt; {
        err ? reject(err) : resolve(data);
      });
    });
  }
}

// 使用适配后的方法
const readFile = promisify(fs.readFile);
readFile(&#39;index.txt&#39;, &#39;utf-8&#39;).then(data =&gt; {
  console.log(data); // Hello world
});
</code></pre><h3 id="适配技术栈变更后的旧代码"><a href="#适配技术栈变更后的旧代码" class="headerlink" title="适配技术栈变更后的旧代码"></a>适配技术栈变更后的旧代码</h3><p>在一些老项目是 <code>jQuery</code> 的技术栈，请求也使用的是自带的 <code>$.ajax</code>，如果一天项目中决定移除 <code>jQuery</code>，请求方法 <code>$.ajax</code> 自然也跟着移除了，假设我们想使用 <code>fetch</code> 来代替 <code>$.ajax</code>，则要修改大量的代码，这时 “适配器模式” 可以对 <code>fetch</code> 进行适配，让我们继续沿用 <code>$.ajax</code> 的写法。</p><pre><code class="lang-js">// 适配器
window.$ = {
  ajax(options) {
    return fetch(options.url, {
      method: options.type || &#39;GET&#39;,
      body: JSON.stringifily(options.data || {})
    }).then(res =&gt; res.json());
  }
};

// $.ajax 的旧代码
$.ajax({
  url: &#39;pandashen.com/info&#39;,
  type: &#39;POST&#39;,
  dataType: &#39;json&#39;,
  data: { id: 1 }
}).then(function (data) {
  console.log(data);
});
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“适配器模式” 是很常用的设计模式之一，<code>Vue</code> 的 <code>computed</code> 计算属性、<code>Koa</code> 兼容 <code>1.x</code> 和 <code>2.x</code> 版本的转换中间件 <code>koa-convert</code> 都应用了 “适配器模式”，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/4.adapter" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 单例模式</title>
    <url>/20180926201447/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180926201447/single.jpg" title="单例模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h2><p>“单例模式” 就是通过类创建实例后，每次创建和获取都返回同一个实例，下面是 “单例模式” 最基本的实现。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180926201447/singleton-uml.jpg" alt="单例模式 UML 图"></div><div class="image-caption">单例模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">/* ES6 写法 */
class Person {
  constructor(name) {
    this.name = name;
  }
  static getInstance(name) {
    if (!this.instance) {
      this.instance = new Person(name);
    }
    return this.instance;
  }
}

const w1 = Person.getInstance(&#39;hello&#39;);
const w2 = Person.getInstance(&#39;world&#39;);

console.log(w1 === w2); // true
</code></pre><pre><code class="lang-js">/* ES5 写法 */
function Person(name) {
  this.name = name;
}

Person.getInstance = (function () {
  let instance;
  return function (name) {
    if (!instance) {
      instance = new Person(name);
    }
    return instance;
  }
})();

const w1 = Person.getInstance(&#39;hello&#39;);
const w2 = Person.getInstance(&#39;world&#39;);

console.log(w1 === w2); // true
</code></pre><p>上面分别用 <code>ES6</code> 和 <code>ES5</code> 的方式实现了一个基本的单例模式，创建 <code>Person</code> 的实例时需要通过 <code>getInstance</code> 静态方法，这样第一次会创建一个实例，再次调用时会将之前创建的实例返回，达到单例的目的。</p><blockquote class="pullquote danger"><p><strong>上面单例模式的缺点：</strong></p><ul><li><strong>类的使用者必须要知道这是一个单例的类，创建和获取实例必须通过调用 <code>getInstance</code> 方法；</strong></li><li><strong>并不能真正阻止类的使用者通过 <code>new</code> 关键字创建出新的实例。</strong></li></ul></blockquote><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p>“透明单例模式” 可以解决上面普通 “单例模式” 的不足，希望可以直接使用 <code>new</code> 关键字来创建类的实例，如果已经创建，再次通过 <code>new</code> 创建，则会返回之前创建的实例。</p><pre><code class="lang-js">/* 透明单例模式 */
const Person = (function () {
  let instance;

  return function (name) {
    if (instance) {
      return instance;
    } else {
      this.name = name;
      instance = this;
    }
  }
})();

const w1 = new Person(&#39;hello&#39;);
const w2 = new Person(&#39;world&#39;);

console.log(w1 === w2); // true
</code></pre><p>“透明单例模式” 的原理是创建一个自执行函数，内部创建一个私有变量 <code>instance</code> 用来存储创建的实例，并通过闭包返回一个构造函数，用变量 <code>Person</code> 接收，当使用 <code>new</code> 创建实例时，先检测私有变量 <code>instance</code> 是否有值，如果没值则创建实例，如果有值则直接返回 <code>instance</code>（利用 <code>new</code> 关键字和构造创建实例的原理实现）。</p><blockquote class="pullquote default"><p><strong>缺点：违反了单一职责原则（一个函数只做一件事），自执行函数返回的构造函数已经不止单纯用作构建实例，同时处理了单例的判断逻辑。</strong></p></blockquote><h2 id="单例与构建分离"><a href="#单例与构建分离" class="headerlink" title="单例与构建分离"></a>单例与构建分离</h2><p>针对上面 “透明单例模式” 的缺点，下面将构造函数单例处理与构建逻辑进行分离。</p><pre><code class="lang-js">/* 单例逻辑与构建逻辑分离 */
// 真正的构造函数
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function () {
  console.log(this.name);
}

// 新的构造函数
const CreatePerson = (function () {
  let instance;

  return function (name) {
    if (!instance) {
      instance = new Person(name);
    }
    return instance;
  }
})();

const w1 = new CreatePerson(&#39;hello&#39;);
const w2 = new CreatePerson(&#39;world&#39;);

console.log(w1 === w2); // true
</code></pre><p>上面代码将单例的逻辑与构造函数的逻辑进行了分离，真正用于构造实例的类是 <code>Person</code>，用于处理单例逻辑的是自执行函数返回的函数，使用 <code>CreatePerson</code> 变量接收，这个函数也同时约定好被当做构造函数使用（通过 <code>new</code> 关键字调用和直接执行效果相同）。</p><blockquote class="pullquote primary"><p><strong>缺点：生成的新构造函数名字（<code>CreatePerson</code>）是固定的，用来创建实例的这个类（<code>Person</code>）也是固定的，不够灵活。</strong></p></blockquote><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>下面支持不同的构造函数创建实例，并且可以使用原本构造函数的对应方法，就是把上面案例不灵活的地方变得灵活。</p><pre><code class="lang-js">/* 封装变化 */
const CreateSingle = function (Constructor) {
  let instance;

  const SingleConstructor = function () {
    if (!instance) {
      Constructor.apply(this, arguments);
      instance = this;
    }
    return instance;
  }

  // 实现原型继承
  SingleConstructor.prototype = Object.create(Constructor.prototype);
  return SingleConstructor;
}
</code></pre><pre><code class="lang-js">/* 使用方式 */
// 构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}

function Dailog(name) {
  this.name = name
}

// 原型方法
Person.prototype.sayHi = function () {
  console.log(this.name + &#39;：&#39; + this.age);
}

Dailog.prototype.getName = function () {
  console.log(this.name);
}

// 创建新的构造函数并生成实例
const CreatePerson = CreateSingle(Person);
const w1 = new CreatePerson(&#39;hello&#39;, 18);
const w2 = new CreatePerson(&#39;world&#39;, 20);

const CreateDailog = CreateSingle(Dailog);
const s1 = new CreateDailog(&#39;model&#39;);
const s2 = new CreateDailog(&#39;view&#39;);

console.log(w1 === w2); // true
console.log(s1 === s2); // true
</code></pre><p>上面我们把创建单例的逻辑进行了封装变成了一个通用的逻辑，对于不同构造函数所创建实例，只需要传入这个构造函数并生成新的构造函数，需要注意的是，新的构造函数无法继承原构造函数的原型方法，所以通过继承实现的。</p><h2 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在编写代码时，我们有时候需要人为的创建命名空间，以防止变量的相互污染，这是可以使用 “单例模式” 来实现。</p><pre><code class="lang-js">/* 创建命名空间的方法 */
// 存储工具方法
const utils = {};

// 定义命名空间
utils.define = function (namespace, fn) {
  // 获取命名空间的数组
  const namespaces = namespace.split(&#39;.&#39;);

  // 最后一项为设定方法的属性名
  const methodName = namespaces.pop();

  // 定义变量存储当前命名空间的引用，默认为 utils（根命名空间）
  let current = utils;

  for (let i = 0; i &lt; namespaces.length; i++) {
    const currentNamespace = namespaces[i];

    // 当某一个命名空间没有时，则创建这个命名空间（单例模式）
    if (!current[currentNamespace]) {
      current[currentNamespace] = {};
    }

    // 否则让当前命名空间指向已有的命名空间
    current = current[currentNamespace];
  }

  // 将传入的函数设定给最后一级命名空间的属性上
  current[methodName] = fn;
}
</code></pre><pre><code class="lang-js">/* 命名空间的创建和使用 */
// 通过命名空间定义方法
utils.define(&#39;dom.class.addClass&#39;, function () {
  console.log(&#39;dom.class.addClass&#39;);
});

utils.define(&#39;string.trim&#39;, function () {
  console.log(&#39;string.trim&#39;);
});

utils.define(&#39;event.prevent&#39;, function () {
  console.log(&#39;event.prevent&#39;);
});

// 使用方法
utils.dom.class.addClass(&#39;title&#39;); // dom.class.addClass
utils.string.trim(&#39; hello &#39;); // string.trim
utils.event.prevent(); // event.prevent
</code></pre><p>上面代码的设计希望通过 <code>utils</code> 对象的 <code>define</code> 方法按照传入的表示命名空间的字符串去创建方法，基本实现思路和逻辑是，当一个属性是第一次出现时，创建一个对象作为该命名空间，当再次出现时则不会重复创建命名空间（因为会出现覆盖的问题），而是沿用之前创建的命名空间。</p><h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p><code>LRU</code> 全称为 <code>Least Recently Used</code>，为最近使用的意思，缓存的方式为访问一个元素时，则将其标记为活跃，当存储时，如果超出容量则删除最不常用的元素。</p><pre><code class="lang-js">/* 创建 LRU 缓存类 */
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.members = [];
  }
  put(key, val) {
    let oldestIndex = -1; // 最不活跃项的索引
    let oldestAge = -1; // 最不活跃项的活跃数值
    let found = false;

    for (let i = 0; i &lt; this.members.length; i++) {
      const member = this.members[i];

      // 如果找到当前最不活跃的项，将 oldestAge 和 oldestIndex 更新为该项对应值
      if (member.age &gt; oldestAge) {
        oldestAge = member.age;
        oldestIndex = i;
      }

      // 如果添加项在原本 members 中已经存在，则更新 age 的值为 0
      if (member.key === key) {
        this.members[i] = { key, val, age: 0 };
        found = true; // 为了跳过 push 新增的环节
      } else {
        // 否则其他所有项 age 自增
        member.age++;
      }
    }

    if (!found) {
      if (this.members.length &gt;= this.capacity) {
        this.members.splice(oldestIndex, 1);
      }
      this.members.push({ key, val, age: 0 });
    }
  }
  get(key) {
    for (let i = 0; i &lt; this.members.length; i++) {
      const member = this.members[i];

      if (member.key === key) {
        member.age = 0;
        return member.val;
      }
    }
    return -1;
  }
}
</code></pre><p>上面是一个创建 <code>LRU</code> 缓存的类，用数组管理成员，<code>put</code> 方法用于新增成员，<code>get</code> 方法用于访问成员，当访问成员时，成员的 <code>age</code> 清零，代表最近活跃，当新增元素时，如果该元素已存在，则做覆盖操作，如果不存在，则推入数组中，<code>age</code> 设置为零，其他成员 <code>age</code> 自增，若数组超出容量时，先找到 <code>age</code> 最大的元素删除，再将新的元素推入数组，上面是一个直观但性能较差的实现，如果有兴趣可以使用链表进行优化。</p><pre><code class="lang-js">/* 使用 LRU 缓存 */
const cache = new LRUCache(2);

cache.put(&#39;1&#39;, 1);
console.log(cache.members);
// [ { key: &#39;1&#39;, val: 1, age: 0 } ]

cache.put(&#39;2&#39;, 2);
console.log(cache.members);
// [ { key: &#39;1&#39;, val: 1, age: 1 }, { key: &#39;2&#39;, val: 2, age: 0 } ]

cache.put(&#39;3&#39;, 3);
console.log(cache.members);
// [ { key: &#39;2&#39;, val: 2, age: 1 }, { key: &#39;3&#39;, val: 3, age: 0 } ]

cache.put(&#39;2&#39;, &#39;hello&#39;);
console.log(cache.members);
// [ { key: &#39;2&#39;, val: &#39;hello&#39;, age: 0 }, { key: &#39;3&#39;, val: 3, age: 1 } ]
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“单例模式” 是设计模式中非常好理解的一个，使用还是非常广泛的，在 <code>Redux</code> 等众多的第三方库中也有所体现，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/3.single" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 JS 表现 —— 工厂模式</title>
    <url>/20180925190503/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180925190503/factory.jpg" title="工厂模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote success"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>“简单工厂模式” 是由一个工厂对象决定创建出哪一种产品类的实例。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180925190503/simple-factory-uml.jpg" alt="简单工厂模式 UML 图"></div><div class="image-caption">简单工厂模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">/* 直接创建子类实例 */
// 父类
class Plant {
  constructor(name) {
    this.name = name;
  }
  grow() {
    console.log(&#39;I am growing!&#39;);
  }
}

// 子类 —— Apple
class Apple extends Plant {
  constructor(name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 子类 —— Orange
class Orange extends Plant {
  constructor(name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 直接创建子类的实例
const apple = new Apple(&#39;苹果&#39;, &#39;甜&#39;);
const orange = new Orange(&#39;橘子&#39;, &#39;酸&#39;);

console.log(apple.flavour); // 甜
console.log(orange.flavour); // 酸
</code></pre><p>上面创建子类实例的方式是使用 <code>new</code> 关键字直接创建，这种创建方式使产生的实例和具体的类紧紧的耦合在一起，并依赖于类的具体实现，如果在子类可能随时发生变化的代码中，将对维护造成麻烦，使用 “简单工厂模式” 可以对产生的实例和具体的类进行解耦，且不必关心子类的具体实现和在未来是否发生变化。</p><pre><code class="lang-js">/* 使用简单工厂模式创建子类的实例 */
// 父类
class Plant {
  constructor(name) {
    this.name = name;
  }
  grow() {
    console.log(&#39;I am growing!&#39;);
  }
}

// 子类 —— Apple
class Apple extends Plant {
  constructor(name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 子类 —— Orange
class Orange extends Plant {
  constructor(name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 工厂类
class Factory {
  static create(type) {
    switch (type) {
      case &#39;apple&#39;:
        return new Apple(&#39;苹果&#39;, &#39;甜&#39;);
      case &#39;orange&#39;:
        return new Orange(&#39;桔子&#39;, &#39;酸&#39;);
      default:
        throw new Error(&#39;no constructor!&#39;);
    }
  }
}

// 使用简单工厂创建子类实例
const apple = Factory.create(&#39;apple&#39;);
const orange = Factory.create(&#39;orange&#39;);

console.log(apple.flavour); // 甜
console.log(orange.flavour); // 酸
</code></pre><p>从上面代码看，我们只需要通过类型就可以得到某一个子类的实例，不需要知道子类是谁，以及具体实现，并在工厂 <code>Factory</code> 中做了错误处理，可以不必担心未来某一个子类发生变化或者被删除的问题。</p><pre><code class="lang-js">/* 简单工厂经典案例 —— jQuery */
// jQuery 的构造函数
class JQuery {
  constructor (selector) {
    this.selector = selector;
    const elements = document.querySelectorAll(selector);
    this.length = elements.length;

    for (let i = 0; i &lt; this.length; i++) {
      this[i] = elements[i];
    }
  }
  html() {
    return this[0].innerHTML;
  }
}

// 简单工厂函数
window.$ = function (selector) {
  return new JQuery(selector);
}

// 获取 li 标签并调用 html 方法
const html = $(&#39;li&#39;).html();
</code></pre><pre><code class="lang-js">/* 简单工厂经典案例 —— React 虚拟 DOM */
// 创建虚拟 DOM 的构造函数
class VNode {
  constructor(tagName, attrs, children) {
    this.tagName = tagName;
    this.attrs = attrs;
    this.children = children;
  }
}

// 挂在 React 对象上的简单工厂函数
React.createElement = function (tagName, attrs, children) {
  return new VNode(tagName, attrs, children);
}
</code></pre><blockquote class="pullquote warning"><p><strong>简单工厂模式的缺点：不满足开放封闭原则，内部可以随意修改，新增、修改子类都需要修改工厂类内部代码，在扩展的过程中工厂类的代码将会越来越臃肿。</strong></p></blockquote><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>“工厂方法模式” 可以规避 “简单工厂模式” 的缺点，又称为 “多态性工厂模式”，核心的工厂类不再负责创建出哪一种产品类的实例，而是将具体创建的工作交给子类去做。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180925190503/factory-method-uml.jpg" alt="工厂方法模式 UML 图"></div><div class="image-caption">工厂方法模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">/* 基本的工厂方法模式使用 */
// 父类
class Plant {
  constructor(name) {
    this.name = name;
  }
}

// 子类 —— Apple
class Apple extends Plant {
  constructor (name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 子类 —— Orange
class Orange extends Plant {
  constructor (name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）
class Factory {
  create () {}
}

// 子类工厂 —— AppleFactory
class AppleFactory extends Factory {
  static create() {
    return new Apple(&#39;苹果&#39;, &#39;甜&#39;);
  }
}

// 子类工厂 —— OrangeFactory
class OrangeFactory extends Factory {
  static create() {
    return new Orange(&#39;桔子&#39;, &#39;酸&#39;);
  }
}

// 创建实例
const apple = AppleFactory.create();
const orange = OrangeFactory.create();

console.log(apple.flavour); // 甜
console.log(orange.flavour); // 酸
</code></pre><p>上面是一个基础的 “工厂方法模式” 使用，解决了 “简单工厂模式” 扩展的问题（遵循开放封闭原则），创建实例虽然不耦合具体的类，但是耦合工厂的子类，下面可以通过文件拆分进行解耦。</p><pre><code class="lang-js">/* plant.js */
// 父类
class Plant {
  constructor(name) {
    this.name = name;
  }
}

module.exports = Plant;
</code></pre><pre><code class="lang-js">/* factory.js */
// 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现）
class Factory {
  create () {}
}

module.exports = Factory;
</code></pre><pre><code class="lang-js">/* apple.js */
const Plant = require(&#39;./plant&#39;);
const Factory = require(&#39;./factory&#39;);

// 子类 —— Apple
class Apple extends Plant {
  constructor (name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 子类工厂 —— AppleFactory
class AppleFactory extends Factory {
  static create() {
    return new Apple(&#39;苹果&#39;, &#39;甜&#39;);
  }
}

module.exports = AppleFactory;
</code></pre><pre><code class="lang-js">/* orange.js */
const Plant = require(&#39;./plant&#39;);
const Factory = require(&#39;./factory&#39;);

// 子类 —— Orange
class Orange extends Plant {
  constructor (name, flavour) {
    super(name);
    this.flavour = flavour;
  }
}

// 子类工厂 —— OrangeFactory
class OrangeFactory extends Factory {
  static create() {
    return new Orange(&#39;桔子&#39;, &#39;酸&#39;);
  }
}

module.exports = OrangeFactory;
</code></pre><pre><code class="lang-js">/* setting.js */
// 配置文件，将要创建实例的类型与对应的工厂关联起来
const setting = {
  apple: &#39;./apple&#39;,
  orange: &#39;./orange&#39;,
};

module.exports = setting;
</code></pre><pre><code class="lang-js">/* use.js */
const setting = require(&#39;./setting&#39;);

const apple = require(setting[&#39;apple&#39;]).create();
const orange = require(setting[&#39;orange&#39;]).create();

console.log(apple.flavour); // 甜
console.log(orange.flavour); // 酸
</code></pre><p>使用上面这样的 “工厂方法模式”，扩展时只需要新增一个文件，在文件中定义具体创建实例的类和工厂类就可以了，一般会有一个配置文件将要创建实例的类型和对应的工厂关联起来，创建对应的实例只需通过类型和配置文件找到对应的工厂执行 <code>create</code> 方法即可。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>“抽象工厂模式” 是指当有多个抽象角色时，可以提供一个接口，不必指定 “产品” 具体的情况下，创建多个产品族中的产品对象。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180925190503/abatract-factory-uml.jpg" alt="抽象工厂模式 UML 图"></div><div class="image-caption">抽象工厂模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">// 父类 —— Icon
class Icon {
  render() {}
}

// 父类 —— Button
class Button {
  render() {}
}

// 子类 —— AppleIcon 苹果图标
class AppleIcon extends Icon {
  render() {
    console.log(&#39;绘制 Mac 的图标&#39;);
  }
}

// 子类 —— AppleButton 苹果按钮
class AppleButton extends Button {
  render() {
    console.log(&#39;绘制 Mac 的按钮&#39;);
  }
}

// 子类 —— WindowsIcon Windows 图标
class WindowsIcon extends Icon {
  render() {
    console.log(&#39;绘制 Windows 的图标&#39;);
  }
}

// 子类 —— WindowsButton Windows 按钮
class WindowsButton extends Button {
  render() {
    console.log(&#39;绘制 Windows 的按钮&#39;);
  }
}

// 父类工厂
class Factory {
  createIcon() {} // 创建图标
  createButton() {} // 创建按钮
}

// 子类工厂 —— AppleFactory 用于创建苹果族产品实例
class AppleFactory extends Factory {
  createIcon() {
    return new AppleIcon();
  }
  createButton() {
    return new AppleButton();
  }
}

// 子类工厂 —— WindowsFactory 用于创建 Windows 族产品实例
class WindowsFactory extends Factory {
  createIcon() {
    return new WindowsIcon();
  }
  createButton() {
    return new WindowsButton();
  }
}

// 创建苹果工厂实例
const appleFactory = new AppleFactory();

// 创建苹果族产品
appleFactory.createIcon().render(); // 绘制 Mac 的图标
appleFactory.createButton().render(); // 绘制 Mac 的按钮

// 创建 Windows 工厂实例
const wondowsFactory = new WindowsFactory();

// 创建 Windows 族产品
wondowsFactory.createIcon().render(); // 绘制 Windows 的图标
wondowsFactory.createButton().render(); // 绘制 Windows 的按钮
</code></pre><p>在上面案例中，按照 “抽象工厂模式” 的说法，多个抽象角色指的是 <code>Apple</code> 和 <code>Windows</code>，<code>Icon</code> 和 <code>Button</code>，工厂分为 <code>AppleFactory</code> 和 <code>WindowsFactory</code> 两类，可以分别创建对应产品的 <code>Icon</code> 和 <code>Button</code> 实例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>上面几种工厂模式中，“简单工厂模式” 在框架开发中使用居多，“工厂方法模式” 更多在一些比较老的且复杂的项目中用作业务模块封装和抽象，“抽象工厂模式” 在前端并不常用，应用于后端偏多，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/2.factory" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基础篇 —— Router 4.0 的基本使用</title>
    <url>/20180921182754/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20180921182754/react-router.png" title="React Router"><p><br></p><h2 id="React-路由简介"><a href="#React-路由简介" class="headerlink" title="React 路由简介"></a>React 路由简介</h2><blockquote class="pullquote info"><p><strong>在 <code>Web</code> 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 <code>URL</code> 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，<code>React</code> 全家桶中也有配套的路由系统，在路由 <code>2.0</code> 版本时叫做 <code>react-router</code>，在路由 <code>4.0</code> 时更名为 <code>react-router-dom</code>，我们本次就针对较新版本的 <code>Router</code> 系统进行介绍。</strong></p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>为了方便演示如何 <code>Router</code>，我们使用 <code>create-react-app</code> 创建一个 <code>React</code> 项目，并删除 <code>src</code> 文件夹内多余文件，创建我们需要的文件 <code>index.js</code>，目录结构如下：</p><pre class="language-treeview">
  <code class="language-treeview">
    react-router
      |- public
      | |- favicon.ico
      | |- index.html
      | |- manifest.json
      |- src
      | |- pages
      | | |- Add.js
      | | |- Detail.js
      | | |- Home.js
      | | |- Index.js
      | | |- List.js
      | | |- Login.js
      | | |- Logo.js
      | | |- MenuLink.js
      | | |- Profile.js
      | | |- Protected.js
      | | |- User.js
      | |- App.js
      | |- index.css
      | |- index.js
      |- .gitignore
      |- package.json
      |- README.md
      |- yarn.lock
  </code>
</pre><p>其中主组件为 <code>App</code>，在 <code>index.js</code> 中渲染，<code>index.js</code> 代码如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/index.js */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App&#39;;

ReactDOM.render(&lt;App /&gt;, window.root);
</code></pre><p>而 <code>App</code> 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。</p><h2 id="HashRouter-和-BrowserRouter"><a href="#HashRouter-和-BrowserRouter" class="headerlink" title="HashRouter 和 BrowserRouter"></a>HashRouter 和 BrowserRouter</h2><p>在 <code>React Router</code> 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 <code>HashRouter</code> 和 <code>BrowserRouter</code>，我们知道浏览器的 <code>hash</code> 值发生变化会阻止页面的跳转，而 <code>HashRouter</code> 就是利用这个特性实现的，通过监听 <code>onhanshchange</code> 事件在 <code>hash</code> 值改变的时候做出响应，<code>BrowserRouter</code> 则是利用 <code>H5</code> 的新 <code>History API</code> 的 <code>pushState</code> 方法构造的的历史记录集合来实现的。</p><p>通常情况下，在开发的时候使用 <code>HashRouter</code> 更多，而在真正上线时替换成 <code>BrowserRouter</code>，两种 <code>Router</code> 在地址栏上的表现上区别只是是否含有 <code>#</code>，两种 <code>Router</code> 的使用如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— HashRouter */
import React, { Component } from &#39;react&#39;;
import { HashRouter } from &#39;react-router-dom&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
      {/* 路由相关代码 */}
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— BrowserRouter */
import React, { Component } from &#39;react&#39;;
import { BrowserRouter } from &#39;react-router-dom&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;BrowserRouter&gt;
      {/* 路由相关代码 */}
      &lt;/BrowserRouter&gt;
    )
  }
}
</code></pre><p>其实就是使用 <code>React Router</code> 中提供的这两种类型的路由组件对路由相关的 <code>JSX</code> 进行包裹。</p><h2 id="Route-和-Link-组件"><a href="#Route-和-Link-组件" class="headerlink" title="Route 和 Link 组件"></a>Route 和 Link 组件</h2><p><code>Route</code> 组件是用来定义路由跳转切换组件的区域，通过 <code>path</code> 属性定义匹配的路由，<code>component</code> 属性来定义渲染的组件，渲染后就是一个 <code>div</code> 标签，<code>Link</code> 是用来点击跳转路由的，通常用来定义导航栏内容，通过 <code>to</code> 属性设置匹配的路由，需要与 <code>Route</code> 的 <code>path</code> 一一对应，点击后可切换到对应的路由组件，渲染后为一个 <code>a</code> 标签。</p><h3 id="创建路由跳转的组件"><a href="#创建路由跳转的组件" class="headerlink" title="创建路由跳转的组件"></a>创建路由跳转的组件</h3><p>下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 <code>Home.js</code>、<code>User.js</code>、<code>Profile.js</code></p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Home.js */
import React, { Component } from &#39;react&#39;;

export default class Home extends Component {
  render() {
    return (
      &lt;div&gt;主页&lt;/div&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/User.js */
import React, { Component } from &#39;react&#39;;

export default class User extends Component {
  render() {
    return (
      &lt;div&gt;用户&lt;/div&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Profile.js */
import React, { Component } from &#39;react&#39;;

export default class Profile extends Component {
  render() {
    return (
      &lt;div&gt;个人中心&lt;/div&gt;
    )
  }
}
</code></pre><h3 id="配合使用-Route-和-Link"><a href="#配合使用-Route-和-Link" class="headerlink" title="配合使用 Route 和 Link"></a>配合使用 Route 和 Link</h3><p>使用 <code>Link</code> 和 <code>Route</code> 配合使用如下，点击 <code>Link</code> 会在类名 <code>container</code> 的元素种加载路由路径对应的组件。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Link } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;div&gt;
          &lt;ul className=&quot;nav&quot;&gt;
            &lt;li&gt;
              &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;div className=&quot;container&quot;&gt;
            &lt;Route path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route path=&quot;/user&quot; component={User} /&gt;
            &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><p>启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 <code>Link</code> 和 <code>Route</code> 组件混在一起，我们其实可以将 <code>App</code> 拆分成两个组件，一个用来存放 <code>Link</code> 部分，一个用来存放 <code>Route</code> 部分，创建 <code>Index</code> 组件，将 <code>Link</code> 的部分抽取出去，代码修改如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 修改后 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Route path=&quot;/home&quot; component={Home} /&gt;
          &lt;Route path=&quot;/user&quot; component={User} /&gt;
          &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Index.js */
import React, { Component } from &#39;react&#39;;
import { Link } from &#39;react-router-dom&#39;;

export default class Index extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;a className=&quot;navbar-brand&quot;&gt;管理系统&lt;/a&gt;
      &lt;/div&gt;
      &lt;ul className=&quot;nav&quot;&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div className=&quot;container&quot;&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
}
</code></pre><p>经过修改之后 <code>Index</code> 组件专门用来维护导航组件 <code>Link</code>，<code>App</code> 组件专门用来维护路由组件 <code>Route</code>，这样代码看起来就不那么混乱了。</p><h3 id="Route-组件的-exact-属性"><a href="#Route-组件的-exact-属性" class="headerlink" title="Route 组件的 exact 属性"></a>Route 组件的 exact 属性</h3><p>上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 <code>/user</code> 为例，假设添加一个新的路由 <code>/user/add</code>，那么 <code>React</code> 会由上到下依次匹配，<code>/user/add</code> 中包含 <code>/user</code>，因此会同时渲染两个组件，这不是我们希望的。</p><p>在 <code>React Router</code> 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 <code>/user</code> 对应的 <code>Route</code> 组件添加 <code>exact</code> 属性，并将值设置为 <code>true</code> 即可，所以匹配 <code>/user/add</code> 时就不会出现 <code>/user</code> 对应的路由组件也被渲染的情况，当然也可以将 <code>exact</code> 简写到 <code>Route</code> 组件上省略赋值为 <code>true</code> 的过程。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 添加 exact */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Route path=&quot;/home&quot; component={Home} /&gt;
          &lt;Route path=&quot;/user&quot; exact component={User} /&gt;
          &lt;Route path=&quot;/user/add&quot; component={User} /&gt;
          &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><h2 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h2><p>因为 <code>React</code> 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，<code>React Router</code> 的 <code>Switch</code> 组件就是来做这件事的，只需要将多个 <code>Route</code> 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 添加 Switch 组件 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Switch } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route path=&quot;/user&quot; exact component={User} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={User} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={User} /&gt; {/* 同名路由 */}
            &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
          &lt;/Switch&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><p>使用 <code>Switch</code> 组件优化后，启动项目就可以发现只渲染了一个 <code>User</code> 组件。</p><h2 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h2><p>在 <code>React</code> 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 <code>404</code> 页面，第二种方式是将页面路由重定向到主页，而 <code>React Router</code> 提供的 <code>Redirect</code> 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 <code>Route</code> 组件的下面用来 “兜底”，使用 <code>to</code> 属性来定义重定向的路由。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 添加 Redirect 组件 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt;
            &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
            &lt;Redirect to=&quot;/home&quot; /&gt; {/* 无法匹配路由时重定向 */}
          &lt;/Switch&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><blockquote class="pullquote warning"><p><strong>注意：<code>Redirect</code> 不能放在 <code>Route</code> 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。</strong></p></blockquote><p>对于路由都没有匹配而返回 <code>404</code> 页面我们这里也简单说一下，但是这样的用法非常少，使用 <code>Redirect</code> 重定向到指定页面的方式会更多一些。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 匹配失败跳转 404 页面 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Switch } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt;
            &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
            &lt;Route path=&quot;/&quot; component={Error} /&gt; {/* Error 组件代表 404 */}
          &lt;/Switch&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><p>由于其他的路由都匹配失败，最后会和 <code>/</code> 匹配，所以会显示 <code>Error</code> 组件，这里处理 <code>404</code> 的 <code>Route</code> 的组件也必须放在最下面来 “兜底”。</p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><h3 id="实现二级路由"><a href="#实现二级路由" class="headerlink" title="实现二级路由"></a>实现二级路由</h3><p>在了解 <code>React Router</code> 的基本使用后，我们用同样的知识点来给 <code>User</code> 组件写一个二级路由，<code>User</code> 中有一个子导航，分别对应用户列表 <code>List</code> 组件和添加用户 <code>Add</code> 组件，代码的套路与之前相同。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/User.js */
import React, { Component } from &#39;react&#39;;
import { Link, Route, Switch } from &#39;react-router-dom&#39;;
import Add from &#39;./Add&#39;;
import List from &#39;./List&#39;;

export default class User extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;ul className=&quot;sub-nav&quot;&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div className=&quot;sub-container&quot;&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/user/list&quot; component={List} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={Add} /&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><h3 id="解决默认路径不匹配的问题"><a href="#解决默认路径不匹配的问题" class="headerlink" title="解决默认路径不匹配的问题"></a>解决默认路径不匹配的问题</h3><p>当通过 <code>React Router</code> 访问 <code>/user</code> 的时候，会先加载 <code>User</code> 组件，再加载 <code>User</code> 内部的组件包括子导航，但是 <code>/user</code> 的路径既没有和 <code>/user/add</code> 匹配，也没有和 <code>/user/list</code> 匹配，这样渲染了一个空的类名为 <code>sub-containe</code> 的 <code>div</code> 标签，我们应该让 <code>User</code> 组件加载时子路由默认可以匹配一个路由组件，解决方式如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/User.js —— Redirect 组件重定向的方式 */
import React, { Component } from &#39;react&#39;;
import { Link, Route, Switch, Redirect } from &#39;react-router-dom&#39;;
import Add from &#39;./Add&#39;;
import List from &#39;./List&#39;;

export default class User extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;ul className=&quot;sub-nav&quot;&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div className=&quot;sub-container&quot;&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/user/list&quot; component={List} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={Add} /&gt;
            &lt;Redirect to=&quot;/user/list&quot; /&gt; {/* 重定向到 List 组件 */}
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>上面的方式是使用 <code>Redirect</code> 组件重定向的方式实现的，但是这样访问的 <code>/user</code>，路径会自动改变为 <code>/user/list</code>，感觉上有一些奇怪，当然还有另外的解决方式。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/User.js —— Route 组件严格匹配 */
import React, { Component } from &#39;react&#39;;
import { Link, Route, Switch } from &#39;react-router-dom&#39;;
import Add from &#39;./Add&#39;;
import List from &#39;./List&#39;;

export default class User extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;ul className=&quot;sub-nav&quot;&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div className=&quot;sub-container&quot;&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/user&quot; exact component={List} /&gt;
            &lt;Route path=&quot;/user/list&quot; component={List} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={Add} /&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>上面的方式是当匹配到了 <code>/user</code> 的路由也加载默认要渲染的 <code>List</code> 组件实现的，但是为了防止向下继续匹配，可以添加 <code>exact</code> 设置严格匹配，进一步优化可以使用 <code>Switch</code> 组件，让路由成功匹配一次后不再向下匹配。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 <code>React</code> 搭建的单页面应用来说就是路由切换，在 <code>React</code> 中都最初是通过 <code>Link</code> 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 <code>React Router</code> 的 <code>Route</code> 组件会给内部渲染的组件传递路由相关的三个参数 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><blockquote class="pullquote warning"><p><strong><code>history</code> 上存储了 <code>length</code> 属性代表当前支持存入历史记录的数量，也同样存储了 <code>location</code>，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 <code>go</code>（传入数字代表前进或后退几页）、<code>goBack</code>（后退）、<code>goForward</code>（前进）、<code>replace</code>（用其他路由替换当前历史）、<code>push</code>，其中最常用的就是 <code>push</code> 方法，下面会着重介绍，<code>match</code> 中存储了一些路由匹配的相关信息，如 <code>url</code>，即浏览器输入的路径，真正匹配的路径 <code>path</code> 属性以及是代表否严格匹配的 <code>isExact</code> 属性，在 <code>match</code> 中最重要的是 <code>params</code> 属性，值为对象，用来存储路由参数，这个我们放在后面来说。</strong></p></blockquote><p>下面在 <code>Add</code> 组件中添加一输入框和按钮，当点击按钮时将输入框的数据存入 <code>localStorage</code> 中，并自动将路由跳转到 <code>/user/list</code>，即渲染 <code>List</code> 组件，然后将数据取出渲染到 <code>List</code> 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 <code>Add</code> 组件中的实现。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Add.js */
import React, { Component } from &#39;react&#39;;

export default class Add extends Component {
  input = React.createRef() // 非受控组件取值

  // 表单提交事件
  handleSubmit = (e) =&gt; {
    e.preventDefault(); // 取消默认的页面跳转事件

    // 先从 localStorage 获取已有数据
    const lists = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || [];

    // 添加新数据
    lists.push({
      id: lists.length + 1,
      username: this.input.current.value
    });

    // 存入 localStorage
    localStorage.setItem(&#39;lists&#39;, JSON.stringify(lists));

    // 编程式导航，自动跳转到 List
    this.props.history.push(&#39;/user/list&#39;);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;form className=&quot;form&quot; onSubmit={this.handleSubmit}&gt;
          &lt;label htmlFor=&quot;username&quot; className=&quot;control-label&quot;&gt;用户名&lt;/label&gt;
          &lt;input
            className=&quot;form-control&quot;
            type=&quot;text&quot;
            id=&quot;username&quot;
            ref={this.input}
          /&gt;
          &lt;br /&gt;
          &lt;input type=&quot;submit&quot; className=&quot;btn btn-success&quot; /&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>在上面我们通过 <code>Route</code> 传递给渲染组件的 <code>history</code> 的 <code>push</code> 方法实现了路由的自动跳转，<code>push</code> 方法接收的参数就是将要跳转的路径字符串，<code>List</code> 组件代码如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/List.js */
import React, { Component } from &#39;react&#39;;

export default class List extends Component {
  state = { users: [] }

  componentWillMount() {
    // 取出 localStorage 数据并更新状态
    const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || [];
    this.setState({ users });
  }

  render() {
    return (
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;用户 ID&lt;/th&gt;
            &lt;th&gt;用户名&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {
            this.state.users.map(({ id, username }) =&gt; {
              return (
                &lt;tr key={id}&gt;
                  &lt;td&gt;{id}&lt;/td&gt;
                  &lt;td&gt;{username}&lt;/td&gt;
                &lt;/tr&gt;
              )
            })
          }
        &lt;/tbody&gt;
      &lt;/table&gt;
    )
  }
}
</code></pre><p>取出 <code>localStorage</code> 中的数据在 <code>List</code> 中渲染时有两点注意，第一是取出数据和设置状态应该在 <code>render</code> 渲染 <code>JSX</code> 之前，这样在没有执行 <code>render</code> 时会合并状态并只渲染一次，也就是说 <code>componentWillMount</code> “钩子” 和 <code>render</code> “钩子” 的 <code>return</code> 语句前更新状态都是可以的，如果在 <code>componentDidMount</code> “钩子” 中更新会导致组件渲染两次，在 <code>React</code> 开发中如果获取数据的过程是同步的（<code>localStorage</code> 取值是同步的），不需要渲染两次。</p><p>第二点是在使用表格元素 <code>table</code> 渲染时，必须要含有 <code>thead</code> 和 <code>tbody</code>，这是 <code>React</code> 规定的，不可以省略。</p><h2 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h2><p>现在在我们的 <code>List</code> 组件表格中，点击每一行都可以跳转到学生 <code>ID</code> 对应的详情 <code>Detail</code> 组件中，由于每一个学生的 <code>ID</code> 不同渲染的详情也不相同，此时需要将学生 <code>ID</code> 作为路由参数进行传递，并在 <code>Detail</code> 内渲染对应的内容，由于 <code>Detail</code> 组件的渲染与 <code>List</code> 组件是同一区域，所以仍然是二级路由，我们需要在 <code>User</code> 组件中进行添加。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/User.js —— 增加 Detail 二级路由 */
import React, { Component } from &#39;react&#39;;
import { Link, Route, Switch } from &#39;react-router-dom&#39;;
import Add from &#39;./Add&#39;;
import List from &#39;./List&#39;;
import Detail from &#39;./Detail&#39;;

export default class User extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;ul className=&quot;sub-nav&quot;&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div className=&quot;sub-container&quot;&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/user&quot; exact component={List} /&gt;
            &lt;Route path=&quot;/user/list&quot; component={List} /&gt;
            &lt;Route path=&quot;/user/add&quot; component={Add} /&gt;
            &lt;Route path=&quot;/user/detail/:id&quot; component={Detail} /&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>在 <code>React Router</code> 中，我们通过给路由后面添加 <code>/:paramname</code> 的方式添加参数，也可以通过 <code>/:paramname/:paramname</code> 传递多个参数（形参），由于在 <code>List</code> 中点击表格的的某行的单元格跳转路由，所以 <code>List</code> 组件修改如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数 */
import React, { Component } from &#39;react&#39;;
import { Link } from &#39;react-router-dom&#39;;

export default class List extends Component {
  state = { users: [] }

  componentWillMount() {
    // 取出 localStorage 数据并更新状态
    const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || [];
    this.setState({ users });
  }

  render() {
    return (
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;用户 ID&lt;/th&gt;
            &lt;th&gt;用户名&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            {
              this.state.users.map(({ id, username }) =&gt; {
                return (
                  &lt;tr key={id}&gt;
                    &lt;td&gt;{id}&lt;/td&gt;
                    &lt;td&gt;
                      &lt;Link to={`/user/detail/${id}`}&gt;{username}&lt;/Link&gt;
                    &lt;/td&gt;
                  &lt;/tr&gt;
                )
              })
            }
        &lt;/tbody&gt;
      &lt;/table&gt;
    )
  }
}
</code></pre><p>在 <code>List</code> 组件中，同样使用 <code>Link</code> 组件对要点击切换路由的节点进行包裹，并用 <code>to</code> 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 <code>List</code> 组件到 <code>Detail</code> 组件的切换，如果我们有些 <code>List</code> 的数据想在跳转到 <code>Detail</code> 组件时直接带过去，则可以使用另一种写法如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据 */
import React, { Component } from &#39;react&#39;;
import { Link } from &#39;react-router-dom&#39;;

export default class List extends Component {
  state = { users: [] }

  componentWillMount() {
      // 取出 localStorage 数据并更新状态
      const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || [];
      this.setState({ users });
  }

  render() {
    return (
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;用户 ID&lt;/th&gt;
            &lt;th&gt;用户名&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {
            this.state.users.map(({ id, username }) =&gt; {
              return (
                &lt;tr key={id}&gt;
                  &lt;td&gt;{id}&lt;/td&gt;
                  &lt;td&gt;
                    &lt;Link
                      to={{
                        pathname: `/user/detail/${id}`,
                        state: username
                      }}
                    &gt;
                      {username}
                    &lt;/Link&gt;
                  &lt;/td&gt;
                &lt;/tr&gt;
              )
            })
          }
        &lt;/tbody&gt;
      &lt;/table&gt;
    )
  }
}
</code></pre><p>不同的是给 <code>to</code> 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 <code>pathname</code> 属性的值，<code>state</code> 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 <code>Route</code> 组件包裹的，会传入 <code>history</code>、<code>loacltion</code> 和 <code>match</code> 三个属性，同样的，通过点击 <code>Link</code> 传递的路由参数和数据都可以在 <code>props</code> 上获取到，前者通过 <code>location.state</code> 或者 <code>history.location.state</code> 上获取到，后者可以通过 <code>match.params</code> 上获取到，那么 <code>Detail</code> 组件将传递过来的参数渲染，代码如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Detail.js */
import React, { Component } from &#39;react&#39;;

export default class Detail extends Component {
  state = { user: {} }

  componentWillMount() {
    // 有值说明是点击过来的，否则是地址栏输入的
    const data = this.props.location.state;

    // 获取路由参数
    const id = parseInt(this.props.match.params.id);

    // 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state
    if (data) {
      this.setState({ user: { id, username: data }});
    } else {
      const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || [];
      const user = users.find(item =&gt; item.id === id);

      this.setState({ user: { id, username: user.username }});
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;span&gt;{this.state.user.id}&lt;/span&gt;
        &lt;span&gt; ------- &lt;/span&gt;
        &lt;span&gt;{this.state.user.username}&lt;/span&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><blockquote class="pullquote warning"><p><strong>这里有两点注意点：</strong></p><ul><li><strong>首先通过组件 <code>props.match.params</code> 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型；</strong></li><li><strong>其次是传递的数据，也就是组件通过 <code>props.location.state</code> 获取的数据，只有在通过 <code>Link</code>组件点击过去才会存在，在地址栏输入为 <code>undefined</code>，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。</strong></li></ul></blockquote><h2 id="withRouter-函数"><a href="#withRouter-函数" class="headerlink" title="withRouter 函数"></a>withRouter 函数</h2><p>在之前的编程式导航中我们使用了 <code>Route</code> 传递给渲染组件的 <code>props.history.push</code> 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 <code>history</code>、<code>location</code> 和 <code>match</code> 属性，并使用 <code>history</code> 上的路由设置方法进行跳转路由，这应该如何实现呢？</p><p>其实 <code>React Route</code> 给我们提供了一个函数 <code>withRouter</code> 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，<code>withRouter</code> 方法内部帮我们在传入的组件外层包装了一层 <code>Route</code> 组件，并传入了 <code>history</code>、<code>location</code> 和 <code>match</code> 属性作为参数，所以当我们使用返回的组件时可以通过 <code>props</code> 属性获取 <code>history</code>、<code>location</code> 和 <code>match</code>。</p><p>下面针对我们之前的 <code>Index</code> 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 <code>Login</code> 组件的功能，<code>Login</code> 组件为一级路由，所以我们应该修改 <code>App</code> 组件，添加一个 <code>/login</code> 的路由，<code>Login</code> 和修改后的 <code>App</code> 组件如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 添加 Login 组件路由 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;
import Login from &#39;./pages/Login&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/home&quot; component={Home }/&gt;
            &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt;
            &lt;Route path=&quot;/profile&quot; component={Profile} /&gt;
            &lt;Route path=&quot;/login&quot; component={Login}/&gt; {/* 添加登录页路由 */}
            &lt;Redirect to=&quot;/home&quot; /&gt; {/* 无法匹配路由时重定向 */}
          &lt;/Switch&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Login.js —— 添加登录和退出功能 */
import React, { Component } from &#39;react&#39;;

export default class Login extends Component {
  login = () =&gt; {
    localStorage.setItem(&#39;login&#39;, &#39;ok&#39;);
  }

  exit = () =&gt; {
    localStorage.removeItem(&#39;login&#39;);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.login}&gt;登录&lt;/button&gt;
        &lt;button onClick={this.exit}&gt;退出&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>在 <code>Login</code> 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 <code>localStorage</code> 中添加 <code>login</code> 属性，在退出时清除这个属性，以模拟登录状态。</p><p>抽取出 <code>Logo</code> 后的 <code>Index</code> 组件也应该添加一个新的导航为 “登录”，<code>Login</code> 组件和修改后的 <code>Index</code> 组件如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航 */
import React, { Component } from &#39;react&#39;;
import { Link } from &#39;react-router-dom&#39;;
import Logo from &#39;./Logo&#39;;

export default class Index extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;Logo /&gt;
      &lt;/div&gt;
      &lt;ul className=&quot;nav&quot;&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/login&quot;&gt;登录&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div className=&quot;container&quot;&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
}
</code></pre><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Logo.js */
import React, { Component } from &#39;react&#39;;
import { withRouter } from &#39;react-router-dom&#39;;

class Logo extends Component {
  change = () =&gt; {
    console.log(this.props);
    this.props.history.push(&#39;/login&#39;);
  }

  render() {
    return (
      &lt;div className=&quot;navbar-brand&quot; onClick={this.change}&gt;管理系统&lt;/div&gt;
    )
  }
}

export default withRouter(Logo);
</code></pre><p>通过 <code>Logo</code> 案例的代码我们可以看出，其实最后导出的并不是 <code>Logo</code> 组件，而是使用 <code>withRouter</code> 函数包装后返回的高阶组件，<code>withRouter</code> 方法内部帮我们搞定了 <code>Logo</code> 组件的 <code>props</code> 没有 <code>history</code>、<code>location</code> 和 <code>match</code> 属性的问题。</p><h2 id="受保护的路由"><a href="#受保护的路由" class="headerlink" title="受保护的路由"></a>受保护的路由</h2><p>以前在点击个人中心时会直接渲染 <code>Profile</code> 组件，在给 <code>Login</code> 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 <code>localStorage</code> 中存在 <code>login</code> 属性，则渲染 <code>Profile</code> 的 <code>Route</code> 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。</p><p>这就需要我对 <code>App</code> 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 <code>React Router</code> 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/App.js —— 添加受保护的路由 */
import React, { Component } from &#39;react&#39;;
import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;;
import Home from &#39;./pages/Home&#39;;
import User from &#39;./pages/User&#39;;
import Profile from &#39;./pages/Profile&#39;;
import Index from &#39;./pages/Index&#39;;
import Login from &#39;./pages/Login&#39;;
import Protected from &#39;./pages/Protected&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;HashRouter&gt;
        &lt;Index&gt;
          &lt;Switch&gt;
            &lt;Route path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route path=&quot;/user&quot; exact component={User} /&gt;
            {/* 添加受保护的路由 */}
            &lt;Protected path=&quot;/profile&quot; component={Profile} /&gt;
            &lt;Route path=&quot;/login&quot; component={Login} /&gt;
            {/* 无法匹配路由时重定向 */}
            &lt;Redirect to=&quot;/home&quot; /&gt;
          &lt;/Switch&gt;
        &lt;/Index&gt;
      &lt;/HashRouter&gt;
    )
  }
}
</code></pre><p>我们重写了 <code>App</code> 组件中个人中心对应的路由，将原来的 <code>Route</code> 组件用高阶组件 <code>Protected</code> 代替，也就等于是将原本传入的参数 <code>path</code> 和 <code>component</code> 传入了高阶组件 <code>Protected</code>，下面来看一下高阶组件 <code>Protected</code> 的实现。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Protected.js —— 添加受保护的路由 */
import React, { Component } from &#39;react&#39;;
import { Route, Redirect } from &#39;react-router-dom&#39;;

export default class Protected extends Component {
  render() {
    const login = localStorage.getItem(&#39;login&#39;);
    return login ? (
      &lt;Route {...this.props} /&gt;
    ) : (
      &lt;Redirect to={{ pathname: '/login', state: { 'from': '/profile' }}} /&gt;
    )
  }
}
</code></pre><p>在 <code>Protected</code> 获取登录状态，存在时直接渲染了 <code>Route</code> 组件，并将 <code>path</code> 和 <code>component</code> 参数传入，如果不存在则渲染 <code>Redirect</code> 组件重定向到登录页，传入的参数同 <code>Link</code> 组件的规则相同，<code>pathname</code> 代表重定向的路径，<code>state</code> 代表带过去的数据，我们这里添加了一个 <code>from</code> 属性，用来记录渲染登录页的来源，即个人中心。</p><p>接下来就是 <code>Login</code> 组件中在点击登录后验证是否存在 <code>state</code>，如果存在则返回存储的 <code>from</code> 对应的路由，即个人中心，不存在则跳回首页，<code>Login</code> 修改如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Login.js —— 完善登录功能 */
import React, { Component } from &#39;react&#39;;

export default class Login extends Component {
  login = () =&gt; {
    localStorage.setItem(&#39;login&#39;, &#39;ok&#39;);

    // 获取上一个路由传递的 state
    const prevPathDate = this.props.location.state;

    // 存在 state 则返回来源对应的页面，否则回主页
    if (prevPathDate) {
      this.props.history.push(prevPathDate.from);
    } else {
      this.props.history.push(&#39;/home&#39;);
    }
  }

  exit = () =&gt; {
    localStorage.removeItem(&#39;login&#39;);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.login}&gt;登录&lt;/button&gt;
        &lt;button onClick={this.exit}&gt;退出&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 <code>React</code> 中会频繁使用，还是比较重要的。</p><h2 id="NavLink-组件"><a href="#NavLink-组件" class="headerlink" title="NavLink 组件"></a>NavLink 组件</h2><p>在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，<code>React Router</code> 已经给我们提供了 <code>NavLink</code> 组件用于实现这个功能，<code>NavLink</code> 组件具备 <code>Link</code> 组件所有的功能，唯一不同的就是 <code>NavLink</code> 组件在被选中时不止发生路由跳转，还会给渲染后的 <code>a</code> 标签添加一个名为 <code>active</code> 的 <code>class</code> 属性，而我们只需要通过 <code>css</code> 去给类名 <code>active</code> 设置样式即可。</p><pre><code class="lang-css">/* 路径：~react-router/src/index.css —— 激活样式 */
a.active {
  color: skyblue !important;
}
</code></pre><p>设置好激活样式以后，我们只需要在 <code>Index</code> 组件中引入激活样式的 <code>css</code> 文件并将 <code>Link</code> 组件替换成 <code>NavLink</code> 组件即可。</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Index.js —— 将 Link 修改为 NavLink */
import React, { Component } from &#39;react&#39;;
import { NavLink } from &#39;react-router-dom&#39;;
import Logo from &#39;./Logo&#39;;

// 引入激活样式
import &#39;../index.css&#39;;

export default class Index extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;Logo /&gt;
      &lt;/div&gt;
      &lt;ul className=&quot;nav&quot;&gt;
        &lt;li&gt;
          &lt;NavLink to=&quot;/home&quot;&gt;首页&lt;/NavLink&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;NavLink to=&quot;/user&quot;&gt;用户&lt;/NavLink&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;NavLink to=&quot;/profile&quot;&gt;个人中心&lt;/NavLink&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;NavLink to=&quot;/login&quot;&gt;登录&lt;/NavLink&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div className=&quot;container&quot;&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
}
</code></pre><h2 id="自定义导航组件实现激活"><a href="#自定义导航组件实现激活" class="headerlink" title="自定义导航组件实现激活"></a>自定义导航组件实现激活</h2><p><code>React Router</code> 在给我们提供的导航组件 <code>NavLink</code> 功能有限，只会给内部的 <code>a</code> 标签在选中时添加 <code>active</code> 类名，如果我们想实现给一个 <code>li</code> 标签添加 <code>active</code> 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 <code>MenuLink</code>，将 <code>Index</code> 组件中的 <code>li</code> 标签和 <code>NavLink</code> 组件统一替换成 <code>MenuLink</code> 组件，代码如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/Index.js —— 将 Link 修改为 NavLink */
import React, { Component } from &#39;react&#39;;
import { NavLink } from &#39;react-router-dom&#39;;
import Logo from &#39;./Logo&#39;;
import MenuLink from &#39;./MenuLink&#39;

export default class Index extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;Logo /&gt;
      &lt;/div&gt;
      &lt;ul className=&quot;nav&quot;&gt;
        &lt;MenuLink to=&quot;/home&quot;&gt;首页&lt;/MenuLink&gt;
        &lt;MenuLink to=&quot;/user&quot;&gt;用户&lt;/MenuLink&gt;
        &lt;MenuLink to=&quot;/profile&quot;&gt;个人中心&lt;/MenuLink&gt;
        &lt;MenuLink to=&quot;/login&quot;&gt;登录&lt;/MenuLink&gt;
      &lt;/ul&gt;
      &lt;div className=&quot;container&quot;&gt;
        {this.props.children}
      &lt;/div&gt;
    )
  }
}
</code></pre><p>在实现 <code>MenuLink</code> 组件之前我们分析一下实现思路，首先我们依然模拟 <code>NavLink</code> 的方式给 <code>MenuLink</code> 传入了 <code>to</code> 属性，值为将要跳转的路由，所以我们应该在 <code>MenuLink</code> 组件中来接收这个路由，而 <code>MenuLink</code> 内部一定是包含 <code>li</code> 和 <code>Link</code> 组件的，我们可以将这个 <code>to</code> 属性传递给 <code>Link</code> 组件，如果想要通过激活状态给外层的 <code>li</code> 标签设置状态我们需要知道是否匹配了路由，并可以通过 <code>match</code> 属性获得，所以在 <code>li</code> 的外层应该有 <code>Route</code> 组件配合，因为只有 <code>Route</code> 组件才会将 <code>history</code>、<code>location</code> 和 <code>match</code> 作为参数传递给其内部渲染的组件。</p><p>这就要说到 <code>Route</code> 组件的渲染模式，在传入 <code>component</code> 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 <code>li</code> 和 <code>Link</code>，并通过点击 <code>Link</code> 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 <code>children</code> 属性指定时刻需要渲染的组件，实现代码如下：</p><pre><code class="lang-jsx">/* 路径：~react-router/src/pages/MenuLink.js */
import React, { Component } from &#39;react&#39;;
import { Route, Link } from &#39;react-router-dom&#39;;
import &#39;../index.css&#39;;

export default class MenuLink extends Component {
  render() {
    return (
      &lt;Route
        path={this.props.to}
        children={({ match }) =&gt; (
          &lt;li className={match ? &#39;active&#39; : &#39;&#39;}&gt;
            &lt;Link to={this.props.to}&gt;{this.props.children}&lt;/Link&gt;
          &lt;/li&gt;
        )}
      /&gt;
    )
  }
}
</code></pre><p>上面代码中由于 <code>children</code> 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 <code>active</code> 类名添加给了 <code>li</code>，所以我们需要在 <code>MenuLink</code> 组件中引入样式文件 <code>index.css</code> 并将修改，代码如下：</p><pre><code class="lang-css">/* 路径：~react-router/src/index.css —— 激活样式修改后 */
li.active a {
  color: skyblue !important;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>本篇通过一个简单的案例使用了由 <code>React Router</code> 所提供的、开发中常用的功能，但美中不足的是并没有使用一些 <code>UI</code> 库或者 <code>CSS</code> 样式来美化，为了更明显的看到 <code>React Router</code> 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 <code>CSS</code> 样式。</strong></p></blockquote>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基础篇 —— 组件间的参数传递</title>
    <url>/20180919002629/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20180919002629/react-props-transmit.png" title="React 组件间参数传递"><p><br></p><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><blockquote class="pullquote default"><p><strong>支持组件化开发的前端框架如 <code>React</code>、<code>Vue</code>，组件间的参数传递都是很重要的，而 <code>React</code> 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 <code>props</code> 属性渲染即可，如果顶层组件的某个属性的值改变了，<code>React</code> 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。</strong></p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建 <code>React</code> 项目，项目生成后删除 <code>src</code> 文件目录下的多余文件，留下 <code>index.js</code>，命令如下：</p><pre><code class="lang-bash"># 安装脚手架
$ npm install -g create-react-app
# 创建项目
$ create-react-app transfer-props
</code></pre><p><strong>该项目最后的目录结构如下：</strong></p><pre class="language-treeview">
  <code class="language-treeview">
    transfer-props
      |- public
      | |- favicon.ico
      | |- index.html
      | |- manifest.json
      |- src
      | |- components
      | | |- App.js
      | | |- Child.js
      | | |- Parent.js
      | |- context.js
      | |- index.js
      |- .gitignore
      |- package.json
      |- README.md
      |- yarn.lock
  </code>
</pre><h2 id="父组件传参给子组件"><a href="#父组件传参给子组件" class="headerlink" title="父组件传参给子组件"></a>父组件传参给子组件</h2><p>创建一个最外层组件 <code>App</code>，并在 <code>index.js</code> 中进行渲染。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/index.js */
import React from &#39;react&#39;;
import ReactDOM from &#39;react&#39;;
import App from &#39;./components/App&#39;;

ReactDOM.render(&lt;App /&gt;, window.root);
</code></pre><p><code>App</code> 组件内部状态中含有 <code>users</code> 属性，值为数组，含有 <code>title</code> 属性，现在要将这两个参数传递给 <code>Parent</code> 组件，传参方式如下：</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/App.js */
import React, { Component } from &#39;react&#39;;
import Parent from &#39;./Parent&#39;;

export default class App extends Component {
  // 状态
  state = {
    users: [
      { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; },
      { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; }
    ],
    title: &#39;学生信息&#39;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Parent {...this.state} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p><code>Parent</code> 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 <code>Child</code>，<code>Child</code> 组件中需要使用父组件 <code>users</code> 数组的学生 <code>id</code>，传参如下：</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Parent.js */
import React, { Component } from &#39;react&#39;;
import Child from &#39;./Child&#39;;

export default class App extends Component {
  render() {
    const { users, title } = this.props;

    return (
      &lt;div&gt;
        &lt;h1&gt;{title}&lt;/h1&gt; {/* 显示标题 */}
        &lt;ul&gt;
          {
            // 循环创建 Child 组件
            users.map(item =&gt; {
              return (
                &lt;Child key={item.id} {...item} /&gt;
              )
            })
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>最后是 <code>Child</code> 组件，用来渲染学生的基本信息，在 <code>Parent</code> 中我们已经将参数传递，最后看看在 <code>Child</code> 中的接收。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Child.js */
import React, { Component } from &#39;react&#39;;

export default class App extends Component {
  render() {
    const { id, name, age } = this.props;
    return (
      &lt;li&gt;
        &lt;span&gt;{id}&lt;/span&gt;
        &lt;span&gt;{name}&lt;/span&gt;
        &lt;span&gt;{age}&lt;/span&gt;
      &lt;/li&gt;
    )
  }
}
</code></pre><blockquote class="pullquote danger"><p><strong>注意：子组件接收父组件的 <code>props</code> 属性是只读的，不可以修改，修改会报错。</strong></p></blockquote><p>其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 <code>React</code> 单向数据流的特点，但是子组件是不可以直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。</p><h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>在 <code>React</code> 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。</p><p>我们创建一个与 <code>Parent</code> 组件平行的 <code>Input</code> 组件，两个组件都是 <code>App</code> 的直接子组件，在 <code>Input</code> 组件内通过某些操作给父组件的状态中的 <code>users</code> 属性新增一条数据。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Input.js */
import React, { Component } from &#39;react&#39;;

export default class Input extends Component {
  name = React.createRef();
  age = React.createRef();

  handleSubmit = e =&gt; {
    // 取消默认事件
    e.preventDefault();

    // 执行父组件方法，取出输入框的值构造成对象作为参数传入
    this.props.addStudent({
      name: this.name.current.value,
      age: this.age.current.value
    });
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt;
        &lt;br /&gt;
        年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt;
        &lt;br /&gt;
        &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre><p>上面是 <code>Input</code> 组件，在修改时没有直接使用按钮的点击事件，而是添加了 <code>form</code> 标签并使用 <code>submit</code> 事件，是因为可以使用 <code>H5</code> 的自带的校验功能，但是使用 <code>form</code> 会自动提交页面，所以在执行 <code>submit</code> 事件时应取消默认事件，然后调用父组件传来的方法 <code>addStudent</code>，并传入输入框获取的值（非受控组件的取值方式），父组件 <code>App</code> 修改如下：</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/App.js —— 修改后 */
import React, { Component } from &#39;react&#39;;
import Parent from &#39;./Parent&#39;;
import Input from &#39;./Input&#39;;

export default class App extends Component {
  // 状态
  state = {
    users: [
      { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; },
      { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; }
    ],
    title: &#39;学生信息&#39;
  }

  // 添加学生信息事件
  addStudent = val =&gt; {
    // 使用 push 添加
    // this.state.users.push({ id: this.state.users.length + 1, ...val });
    // this.setState({});

    // 使用 setState 添加
    this.setState({
      users: [
        ...this.state.users,
        { id: this.state.users.length + 1, ...val }
      ]
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Parent {...this.state} /&gt;
        &lt;Input addStudent={this.addStudent} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>首先父组件 <code>App</code> 应该创建 <code>addStudent</code> 方法作为参数传递给子组件 <code>Input</code>，而在 <code>addStudent</code> 方法内部通过 <code>push</code> 和 <code>setState</code> 两种方式进行添加，发现都可以更新状态和视图，区别是 <code>push</code> 操作的原来的引用，而 <code>setState</code> 创建了新的引用空间。</p><blockquote class="pullquote info"><p><strong>在 <code>React</code> 所有状态的更改都不建议操作原来的引用，通常做法都是通过 <code>setState</code> 返回一个新的 <code>state</code>（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 <code>React</code> 类组件种有一个 <code>PureComponent</code> 纯组件类型，对 <code>shouldComponentUpdate</code> 生命周期 “钩子” 做了优化，使用了 <code>props</code> 和 <code>state</code> 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。</strong></p></blockquote><h2 id="context-实现跨组件传参"><a href="#context-实现跨组件传参" class="headerlink" title="context 实现跨组件传参"></a>context 实现跨组件传参</h2><p>在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。</p><p>跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。</p><p>在 <code>React</code> 中给我们提供了 <code>context</code> <code>API</code> 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。</p><h3 id="旧版-context"><a href="#旧版-context" class="headerlink" title="旧版 context"></a>旧版 context</h3><p>在旧版的 <code>context</code> 需要配合属性类型检测的 <code>prop-types</code> 模块共同使用，需要在共同的父组件上定义一个方法 <code>getChildContext</code>，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 <code>childContextTypes</code>，值为一个对象，属性的值与 <code>getChildContext</code> 方法内返回的对象的属性一一对应，并用 <code>prop-types</code> 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 <code>contextTypes</code> 对所使用的属性的数据类型进行校验，需要父组件与 <code>childContextTypes</code> 内的定义一致，然后可以通过子组件实例的 <code>context</code> 属性获取，我们可以使用 <code>context</code> 将上面的案例修改如下：</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/App.js —— 旧版 context */
import React, { Component } from &#39;react&#39;;
import Parent from &#39;./Parent&#39;;
import Input from &#39;./Input&#39;;
import PropTypes from &#39;prop-types&#39;; // 引入参数类型检测模块

export default class App extends Component {
  // 状态
  state = {
    users: [
      { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; },
      { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; }
    ],
    title: &#39;学生信息&#39;
  }

  // 定义参数类型
  static childContextTypes = {
    state: PropTypes.object,
    addStudent: PropTypes.func
  }

  // 上下文对象传给子组件的参数
  getChildContext() {
    return {
      state: this.state,
      addStudent: this.addStudent
    }
  }

  // 添加学生信息事件
  addStudent = val =&gt; {
    // 使用 setState 添加
    this.setState({
      users: [
        ...this.state.users,
        { id: this.state.users.length + 1, ...val }
      ]
    });
  }

  render() {
    return (
      &lt;div&gt;
        {/* 不再需要传参 */}
        &lt;Parent /&gt;
        &lt;Input /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>上面只是将 <code>APP</code> 组件中原本传给子组件的参数去掉，按照要求添加了 <code>getChildContext</code> 方法和 <code>childContextTypes</code> 静态属性。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Input.js —— 旧版 context */
import React, { Component } from &#39;react&#39;;

export default class Input extends Component {
  name = React.createRef();
  age = React.createRef();

  // 类型检测与父组件定义的类型对应
  static contextTypes = {
    addStudent: PropTypes.func
  }

  handleSubmit = e =&gt; {
    // 取消默认事件
    e.preventDefault();

    // 从上下文对象上获取父组件的方法并执行
    this.context.addStudent({
      name: this.name.current.value,
      age: this.age.current.value
    });
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt;
        &lt;br/&gt;
        年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt;
        &lt;br/&gt;
        &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre><p>在 <code>Input</code> 组件中定义 <code>contextTypes</code> 属性，将 <code>addStudent</code> 方法从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Parent.js —— 旧版 context */
import React, { Component } from &#39;react&#39;;
import Child from &#39;./Child&#39;;

export default class Parent extends Component {
  // 类型检测与父组件定义的类型对应
  static contextTypes = {
    state: PropTypes.object
  }

  render() {
    // 从 context 对象上获取 state 并解构
    const { users, title } = this.context.state;
    return (
      &lt;div&gt;
        &lt;h1&gt;{title}&lt;/h1&gt; {/* 显示标题 */}
        &lt;ul&gt;
          {
            // 循环创建 Child 组件
            users.map(item =&gt; {
              return (
                &lt;Child key={item.id} {...item} /&gt;
              )
            })
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre><p>在 <code>Parent</code> 组件中同样定义 <code>contextTypes</code> 属性，将 <code>state</code> 属性从原来的 <code>props</code> 获取改为了从 <code>context</code> 上获取。</p><h3 id="新版-context"><a href="#新版-context" class="headerlink" title="新版 context"></a>新版 context</h3><p>新版 <code>context</code> 其实是 <code>React</code> 对象提供给我们的方法 <code>createContext</code> 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 <code>Provider</code>（提供者）和 <code>Consumer</code>（消费者），由于两个配合使用的组件必须由同一次调用 <code>createContext</code> 时创建，所以我们单独创建文件 <code>context.js</code> 代码如下：</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/context.js —— 新版 context */
import React from &#39;react&#39;;

// 创建上下文对象
const { Provider, Consumer } = React.createContext();

// 到处上下文对象的组件
export { Provider, Consumer };
</code></pre><p>还是之前的案例，我们可以使用新版 <code>context</code> 修改如下：</p><pre><code class="lang-jsx">// 路径：~transfer-props/src/components/App.js —— 新版 context
import React, { Component } from &#39;react&#39;;
import Parent from &#39;./Parent&#39;;
import Input from &#39;./Input&#39;;
import { Provider } from &#39;../context&#39;;

export default class App extends Component {
  // 状态
  state = {
    users: [
      { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; },
      { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; }
    ],
    title: &#39;学生信息&#39;
  }

  // 添加学生信息事件
  addStudent = val =&gt; {
    // 使用 setState 添加
    this.setState({
      users: [
        ...this.state.users,
        { id: this.state.users.length + 1, ...val }
      ]
    });
  }

  render() {
    return (
      &lt;Provider value={{
        addStudent: this.addStudent,
        state: this.state
      }}&gt;
        &lt;div&gt;
          &lt;Parent {...this.state} /&gt;
          &lt;Input addStudent={this.addStudent} /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    )
  }
}
</code></pre><p>提供参数的父组件 <code>App</code> 应该使用 <code>Provider</code> 进行包裹，将传入的参数以 <code>value</code> 为参数名（规定），传入 <code>context</code> 对象中。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Input.js —— 新版 context */
import React, { Component } from &#39;react&#39;;
import { Consumer } from &#39;../context.js&#39;;

export default class Input extends Component {
  name = React.createRef();
  age = React.createRef();

  handleSubmit = (e, addStudent) =&gt; {
    // 取消默认事件
    e.preventDefault();

    // 执行父组件方法，取出输入框的值构造成对象作为参数传入
    addStudent({
      name: this.name.current.value,
      age: this.age.current.value
    });
  }

  render() {
    return (
      &lt;Consumer&gt;
        {
          ({ addStudent }) =&gt; (
            &lt;form onSubmit={e =&gt; handleSubmit(e, addStudent)}&gt;
              姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt;
              &lt;br/&gt;
              年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt;
              &lt;br/&gt;
              &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt;
            &lt;/form&gt;
          )
        }
      &lt;/Consumer&gt;
    )
  }
}
</code></pre><p>在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 <code>Provider</code> 对应的 <code>Consumer</code> 组件，用 <code>Consumer</code> 组件替换原本组件返回的 <code>JSX</code>，内部传入一个函数，函数的形参即为 <code>context</code> 对象，函数内部返回值为原本子组件返回的 <code>JSX</code>，子组件使用父组件的属性可直接从函数的形参获取或解构。</p><pre><code class="lang-jsx">/* 路径：~transfer-props/src/components/Parent.js —— 新版 context */
import React, { Component } from &#39;react&#39;;
import Child from &#39;./Child&#39;;
import { Consumer } from &#39;../context.js&#39;;

export default class App extends Component {
  render() {
    return (
      &lt;Consumer&gt;
        {
          ({ states }) =&gt; (
            &lt;div&gt;
              &lt;h1&gt;{states.title}&lt;/h1&gt; {/* 显示标题 */}
              &lt;ul&gt;
                {
                  // 循环创建 Child 组件
                  states.users.map(item =&gt; (
                    &lt;Child {...item} key={item.id}&gt;&lt;/Child&gt;
                  ))
                }
              &lt;/ul&gt;
            &lt;/div&gt;
          )
        }
      &lt;/Consumer&gt;
    )
  }
}
</code></pre><p><code>Parent</code> 作为 <code>App</code> 的子组件，修改的方式同 <code>Input</code> 组件相同，如上面代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>关于 <code>React</code> 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 <code>context</code> 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 <code>Redux</code>、<code>Mobx</code> 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取。</strong></p></blockquote>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基础篇 —— 生命周期详解</title>
    <url>/20180915194439/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20180915194439/react-life-cycle.png" title="React 生命周期"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>本篇文章主要内容针对 <code>React</code> 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 <code>React</code> 的同学建议先学习一下 <code>React</code> 比较基础的内容</strong> <a href="/20180910025959/" target="_blank">React 基础篇 —— 带你走进 React 世界</a><strong>。</strong></p></blockquote><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先使用 <code>create-react-app</code> 脚手架创建一个 <code>React</code> 项目，脚手架工具的安装和项目创建命令如下：</p><pre><code class="lang-bash"># 安装脚手架
$ npm install -g create-react-app
# 创建项目
$ create-react-app life-cycle
</code></pre><p>创建项目后删除 <code>src</code> 目录中的无用文件，只留下 <code>index.js</code> 入口文件即可。</p><h2 id="类组件的生命周期"><a href="#类组件的生命周期" class="headerlink" title="类组件的生命周期"></a>类组件的生命周期</h2><h3 id="静态属性-defaultProps"><a href="#静态属性-defaultProps" class="headerlink" title="静态属性 defaultProps"></a>静态属性 defaultProps</h3><p><code>defaultProps</code> 是用来给 <code>React</code> 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 <code>React 15.x</code> 版本的时候可以用 <code>React.createClass</code> 创建类组件，组件中有与 <code>defaultProps</code> 静态属性作用相同的生命周期 “钩子” <code>getDefaultProps</code>，随着 <code>React 16.x</code> 版本废弃了 <code>React.createClass</code>，也就使用 <code>defaultProps</code> 属性替代了 <code>getDefaultProps</code>。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  static defaultProps = {
    num: 0
  }

  render() {
    return &lt;div&gt;{this.props.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p>启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor</code> 是 <code>ES6</code> 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 <code>defaultProps</code> 静态属性执行顺序的代码。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    console.log(props.number); // 0
  }
  static defaultProps = {
    num: 0
  }

  render() {
    return &lt;div&gt;{this.props.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p>从上面案例中可以看到当执行 <code>constructor</code> 时，<code>props</code> 对象中的 <code>num</code> 属性已经有值了，这也充分说明了说明 <code>constructor</code> 是晚于 <code>defaultProps</code> 执行的。</p><h3 id="状态对象-state"><a href="#状态对象-state" class="headerlink" title="状态对象 state"></a>状态对象 state</h3><p>在 <code>React</code> 中，每一个类组件都有一个属于自己的状态，可以使用 <code>setState</code> 方法更新状态，在 <code>React 15.x</code> 中，通过 <code>React.createClass</code> 创建类组件，使用对应的生命周期 “钩子” <code>getInitialState</code> 来创建，同样的，<code>React 16.x</code> 废弃了 <code>React.createClass</code>，创建 <code>state</code> 的过程自然由新的方式代替。</p><p>创建 <code>state</code> 的方式大概有两种，分别是在 <code>constructor</code> 中创建或者直接创建 <code>state</code> 属性，代码如下：</p><pre><code class="lang-jsx">/* 第一种创建 state 的方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    this.state = { num: 0 };
  }

  render() {
    return &lt;div&gt;{this.state.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><pre><code class="lang-jsx">/* 第二种创建 state 的方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    console.log(this.state.num); // 0
  }

  // 创建 state
  state = { num: 0 }

  render() {
    return &lt;div&gt;{this.state.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p>从上面可以看出直接创建 <code>state</code> 属性的方式与创建静态属性 <code>defaultProps</code> 类似，执行要早于 <code>constructor</code>。</p><h3 id="componentWillMount-钩子"><a href="#componentWillMount-钩子" class="headerlink" title="componentWillMount 钩子"></a>componentWillMount 钩子</h3><p><code>componentWillMount</code> 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 <code>componentWillMount</code>，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 <code>Ajax</code> 请求获取数据。</p><p>在 <code>React 16.3</code> 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 <code>componentWillMount</code> 的可以迁移到 <code>constructor</code>，但不能包含 <code>setState</code> 操作，因为 <code>constructor</code> 中无法调用 <code>setState</code>。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    console.log(&#39;constructor&#39;);
  }

  state = { num: 0 }

  componentWillMount() {
    console.log(&#39;componentWillMount&#39;);
    this.setState({ num: 3 });
  }

  render() {
    return &lt;div&gt;{this.state.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// constructor
// componentWillMount
</code></pre><p>从上面的打印结果可以看出 <code>componentWillMount</code> “钩子” 的执行是晚于 <code>constructor</code> 的，从页面渲染 <code>3</code> 的结果来看，在 <code>componentWillMount</code> “钩子” 中已经可以使用 <code>setState</code> 更改状态了。</p><h3 id="render-钩子"><a href="#render-钩子" class="headerlink" title="render 钩子"></a>render 钩子</h3><p><code>render</code> 钩子的主要作用是返回组件内部要被渲染的 <code>JSX</code>，即所谓的挂载过程，将上面例子简单修改一下。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    console.log(&#39;constructor&#39;);
  }

  state = { num: 0 }

  componentWillMount() {
    console.log(&#39;componentWillMount&#39;);
  }

  render() {
    console.log(&#39;render&#39;);
    return &lt;div&gt;{this.state.num}&lt;/div&gt;;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// constructor
// componentWillMount
// render
</code></pre><p>从打印结果可以看出 <code>constructor</code> 最先执行，其次是 <code>componentWillMount</code>，最后是 <code>render</code>，由于状态或属性的更新可能导致组件重新渲染，所以 <code>render</code> 可能会被执行多次。</p><h3 id="componentDidMount-钩子"><a href="#componentDidMount-钩子" class="headerlink" title="componentDidMount 钩子"></a>componentDidMount 钩子</h3><p><code>componentDidMount</code> 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 <code>DOM</code> 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  constructor(props) {
    super();
    console.log(&#39;constructor&#39;);
  }

  state = { num: 0 }

  componentWillMount() {
    console.log(&#39;componentWillMount&#39;);
  }

  componentDidMount() {
    console.log(&#39;componentDidMount&#39;);
  }

  render() {
    console.log(&#39;render&#39;);
    return &lt;div&gt;{this.state.num}&lt;/div&gt;
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// constructor
// componentWillMount
// render
// componentDidMount
</code></pre><p>执行顺序：<code>constructor</code> → <code>componentWillMount</code> → <code>render</code> → <code>componentDidMount</code>。</p><h3 id="componentWillUpdate-钩子"><a href="#componentWillUpdate-钩子" class="headerlink" title="componentWillUpdate 钩子"></a>componentWillUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后会触发 <code>render</code> 钩子对组件重新渲染，在执行 <code>render</code> 前会调用 <code>componentWillUpdate</code> 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 <code>nextProps</code>、<code>nextState</code> 和 <code>nextContext</code>，即更新后的属性对象、状态对象和上下文对象。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;componentWillUpdate&#39;);
    console.log(&#39;nowState&#39;, this.state);
    console.log(&#39;nextProps&#39;, nextProps);
    console.log(&#39;nextState&#39;, nextState);
    console.log(&#39;nextContext&#39;, nextContext);
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// componentWillUpdate
// nowState { num: 0 }
// nextProps {}
// nextState { num: 1 }
// nextContext {}
// render
</code></pre><p>从执行点击事件后的结果来看，在重新渲染之前 <code>componentWillUpdate</code> 早于 <code>render</code> 执行，而在 <code>componentWillUpdate</code> 执行时 <code>state</code> 的状态还未更新。</p><h3 id="componentDidUpdate-钩子"><a href="#componentDidUpdate-钩子" class="headerlink" title="componentDidUpdate 钩子"></a>componentDidUpdate 钩子</h3><p>在调用 <code>setState</code> 更新数据后执行 <code>render</code> 钩子对组件重新渲染，渲染后会立即调用 <code>componentDidUpdate</code> 钩子，此时 <code>state</code> 状态和页面都已经更新，钩子默认有三个参数，分别为 <code>prevProps</code>、<code>prevState</code> 和 <code>prevContext</code>，即更新前的属性对象、状态对象和上下文对象。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;componentDidUpdate&#39;);
    console.log(&#39;nowState&#39;, this.state);
    console.log(&#39;prevProps&#39;, prevProps);
    console.log(&#39;prevState&#39;, prevState);
    console.log(&#39;prevContext&#39;, prevContext);
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// componentWillUpdate
// render
// componentDidUpdate
// nowState { num: 1 }
// prevProps {}
// prevState { num: 0 }
// prevContext {}
</code></pre><p>触发点击事件后的执行顺序为：<code>componentWillUpdate</code> → <code>render</code> → <code>componentDidUpdate</code>。</p><h3 id="shouldComponentUpdate-钩子"><a href="#shouldComponentUpdate-钩子" class="headerlink" title="shouldComponentUpdate 钩子"></a>shouldComponentUpdate 钩子</h3><p>在使用 <code>setState</code> 更改状态时，其实还会默默的执行 <code>shouldComponentUpdate</code> “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 <code>true</code>，若使用该 “钩子” 必须指定布尔类型的返回值 <code>true</code> 或 <code>false</code>，当返回值为 <code>true</code> 时代表更新状态和视图，否则不更新，只要使用 <code>setState</code> 就会触发该 “钩子”，该钩子有三个参数，与 <code>componentWillUpdate</code> “钩子” 相同。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;componentDidUpdate&#39;);
  }

  shouldComponentUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;shouldComponentUpdate&#39;);
    console.log(&#39;nowState&#39;, this.state);
    console.log(&#39;nextProps&#39;, nextProps);
    console.log(&#39;nextState&#39;, nextState);
    console.log(&#39;nextContext&#39;, nextContext);
    return true;
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// shouldComponentUpdate
// nowState { num: 0 }
// nextProps {}
// nextState { num: 1 }
// nextContext {}
// componentWillUpdate
// render
// componentDidUpdate
</code></pre><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>true</code> 时，触发点击事件后的执行顺序为：<code>shouldComponentUpdate</code> → <code>componentWillUpdate</code> → <code>render</code> → <code>componentDidUpdate</code>。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;componentDidUpdate&#39;);
  }

  shouldComponentUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;shouldComponentUpdate&#39;);
    console.log(&#39;nextState&#39;, nextState);
    return false;
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// shouldComponentUpdate
// nextState { num: 1 } 不断更新
</code></pre><p>当 <code>shouldComponentUpdate</code> “钩子” 返回值为 <code>false</code> 时，触发点击事件后只有 <code>shouldComponentUpdate</code> 执行了，并且随着触发点击事件的次数增加，<code>nextState</code> 参数的状态不断变化，但是 <code>state</code> 和页面都不更新。</p><h3 id="componentWillUnmount-钩子"><a href="#componentWillUnmount-钩子" class="headerlink" title="componentWillUnmount 钩子"></a>componentWillUnmount 钩子</h3><p><code>componentWillUnmount</code> “钩子” 会在组件卸载之前触发，卸载组件需调用 <code>ReactDOM</code> 的 <code>unmountComponentAtNode</code> 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    // 卸载组件
    ReactDOM.unmountComponentAtNode(window.root);
  }

  componentWillUnmount () {
    console.log(&#39;componentWillUnmount&#39;);
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;Kill&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// componentWillUnmount
</code></pre><p><code>componentWillUnmount</code> 钩子一般用来在卸载组件之前清除可能会调用 <code>setState</code> 的异步操作，为了防止在卸载组件后继续更新状态而报错。</p><h2 id="复合组件的生命周期"><a href="#复合组件的生命周期" class="headerlink" title="复合组件的生命周期"></a>复合组件的生命周期</h2><blockquote class="pullquote info"><p><strong>上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。</strong></p></blockquote><h3 id="复合组件渲染生命周期的执行顺序"><a href="#复合组件渲染生命周期的执行顺序" class="headerlink" title="复合组件渲染生命周期的执行顺序"></a>复合组件渲染生命周期的执行顺序</h3><p>在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 子组件
class ChildCounter extends Component {
  state = { num: 0 }

  componentWillMount() {
    console.log(&#39;child-componentWillMount&#39;);
  }

  componentDidMount() {
    console.log(&#39;child-componentDidMount&#39;);
  }

  render() {
    console.log(&#39;child-render&#39;);
    return &lt;div&gt;{this.state.num}&lt;/div&gt;
  }
}

// 父组件
class Counter extends Component {
  componentWillMount() {
    console.log(&#39;parent-componentWillMount&#39;);
  }

  componentDidMount() {
    console.log(&#39;parent-componentDidMount&#39;);
  }

  render() {
    console.log(&#39;parent-render&#39;);
    return (
      &lt;div&gt;
        &lt;ChildCounter /&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// parent-componentWillMount
// parent-render
// child-componentWillMount
// child-render
// child-componentDidMount
// parent-componentDidMount
</code></pre><p>从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 <code>render</code> 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 子组件
class ChildCounter extends Component {
  state = { num: 0 }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;child-componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;child-componentDidUpdate&#39;);
  }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num - 1 });
  }

  render() {
    console.log(&#39;child-render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;update-child&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 父组件
class Counter extends Component {

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;parent-componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;parent-componentDidUpdate&#39;);
  }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  render() {
    console.log(&#39;parent-render&#39;);
    return (
      &lt;div&gt;
        &lt;ChildCounter /&gt;
        &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// 点击子组件更新按钮
// child-componentWillUpdate
// clild-render
// child-componentDidUpdate

// 点击父组件更新按钮
// parent-componentWillUpdate
// parent-render
// child-componentWillUpdate
// clild-render
// child-componentDidUpdate
// parent-componentDidUpdate
</code></pre><p>当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 <code>render</code> 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。</p><p>点击父组件更新按钮生命周期的执行顺序：<code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>点击子组件更新按钮生命周期的执行顺序：<code>child-componentWillUpdate</code> → <code>clild-render</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote warning"><p><strong>如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 <code>shouldComponentUpdate</code> “钩子” 将返回值设置为 <code>false</code> 的方式来控制。</strong></p></blockquote><h3 id="componentWillReceiveProps-钩子"><a href="#componentWillReceiveProps-钩子" class="headerlink" title="componentWillReceiveProps 钩子"></a>componentWillReceiveProps 钩子</h3><p>当传入组件的参数，即 <code>props</code> 发生变化时，<code>componentWillReceiveProps</code> “钩子” 执行，该钩子有一个参数，代表下一次更新的 <code>props</code> 对象，执行该 “钩子” 时，<code>props</code> 并没有更新，也就是说是在 <code>props</code> 变化之前执行。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 子组件
class ChildCounter extends Component {
  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;child-componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;child-componentDidUpdate&#39;);
  }

  shouldComponentUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;child-shouldComponentUpdate&#39;);
    return true;
  }

  componentWillReceiveProps(nextProps) {
    console.log(&#39;child-componentWillReceiveProps&#39;);
    console.log(&#39;nowProps&#39;, this.props);
    console.log(&#39;nextProps&#39;, nextProps);
  }

  render() {
    console.log(&#39;child-render&#39;);
    return &lt;div&gt;{this.props.n}&lt;/div&gt;
  }
}

// 父组件
class Counter extends Component {
  state = { num: 0 }

  componentWillUpdate(nextProps, nextState, nextContext) {
    console.log(&#39;parent-componentWillUpdate&#39;);
  }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;parent-componentDidUpdate&#39;);
  }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  render() {
    console.log(&#39;parent-render&#39;);
    return (
      &lt;div&gt;
        &lt;ChildCounter n={this.state.num} /&gt;
        &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// parent-componentWillUpdate
// parent-render
// child-componentWillReceiveProps
// nowProps { n: 0 }
// nextProps { n: 1 }
// child-shouldComponentUpdate
// child-componentWillUpdate
// child-render
// child-componentDidUpdate
// parent-componentDidUpdate
</code></pre><p>点击父组件更新按钮后，父子组件生命周期的执行顺序如下：</p><p><code>parent-componentWillUpdate</code> → <code>parent-render</code> → <code>child-componentWillReceiveProps</code> → <code>child-shouldComponentUpdate</code> → <code>child-componentWillUpdate</code> → <code>child-render</code> → <code>child-componentDidUpdate</code> → <code>parent-componentDidUpdate</code>。</p><p>由此可以说明 <code>componentWillReceiveProps</code> 钩子在 <code>shouldComponentUpdate</code> 之前执行。</p><blockquote class="pullquote danger"><p><strong><code>componentWillReceiveProps</code> “钩子” 在第一次渲染父子组件时不执行，在 <code>React 16.x</code> 版本中被标记为 “已废弃”。</strong></p></blockquote><h2 id="关于-setState-在生命周期中的使用"><a href="#关于-setState-在生命周期中的使用" class="headerlink" title="关于 setState 在生命周期中的使用"></a>关于 setState 在生命周期中的使用</h2><p>在 <code>React</code> 生命周期 “钩子” 中，只有 <code>componentWillMount</code>、<code>componentDidMount</code> 和 <code>componentWillReceiveProps</code> 中可以调用 <code>setState</code>。</p><p>原因是 <code>setState</code> 方法会触发 <code>render</code> “钩子” 执行，而 <code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 是在 <code>render</code> 后触发，包括在 <code>render</code> 中调用 <code>setState</code>，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 <code>componentWillUnmount</code> “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。</p><blockquote class="pullquote warning"><p><strong>在 <code>componentWillReceiveProps</code> 中使用 <code>setState</code>，其目的是为了将新更改的属性更新为该组件的状态，但 <code>React</code> 官方不建议这样使用。</strong></p></blockquote><h2 id="React-生命周期流程图"><a href="#React-生命周期流程图" class="headerlink" title="React 生命周期流程图"></a>React 生命周期流程图</h2><p>下面是一张关于目前版本比较常用的 <code>React</code> 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 <code>React</code> 生命周期中各个钩子函数的执行过程。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180915194439/react-lifecycle-raw.png" alt="React 生命周期流程图"></div><div class="image-caption">React 生命周期流程图</div></figure><p><br></p><h2 id="React-16-3-新增生命周期"><a href="#React-16-3-新增生命周期" class="headerlink" title="React 16.3 新增生命周期"></a>React 16.3 新增生命周期</h2><h3 id="getDerivedStateFromProps-静态方法"><a href="#getDerivedStateFromProps-静态方法" class="headerlink" title="getDerivedStateFromProps 静态方法"></a>getDerivedStateFromProps 静态方法</h3><p><code>getDerivedStateFromProps</code> 是一个类组件的静态方法，用来替代 <code>componentWillReceiveProps</code> “钩子”，在传入的属性变化之前执行，方法的参数与 <code>componentWillReceiveProps</code> 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 <code>state</code>，不能和 <code>componentWillMount</code> “钩子” 同时使用。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 子组件
class ChildCounter extends Component {
  state = { num: 0 }

  componentDidUpdate(prevProps, prevState, prevContext) {
    console.log(&#39;child-componentDidUpdate&#39;);
    console.log(&#39;nowState&#39;, this.state);
  }

  static getDerivedStateFromProps(nextProps) {
    console.log(&#39;child-getDerivedStateFromProps&#39;);
    console.log(&#39;nextProps&#39;, nextProps);
    return { num: nextProps.n };
  }

  render() {
    console.log(&#39;child-render&#39;);
    return &lt;div&gt;{this.props.n}&lt;/div&gt;
  }
}

// 父组件
class Counter extends Component {
  state = { num: 0 }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  render() {
    console.log(&#39;parent-render&#39;);
    return (
      &lt;div&gt;
        &lt;ChildCounter n={this.state.num} /&gt;
        &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// parent-render
// child-render
// child-getDerivedStateFromProps
// nextProps { n: 1 }
// child-componentDidUpdate
// nowState { num: 1 }
</code></pre><p>点击父组件的更新按钮钩子的执行顺序如下：<code>parent-render</code> → <code>child-render</code> → <code>child-getDerivedStateFromProps</code> → <code>child-componentDidUpdate</code>。</p><blockquote class="pullquote primary"><p><strong><code>getDerivedStateFromProps</code> 除了上面叙述的用法的注意事项，与 <code>componentWillReceiveProps</code> 相比还有两个优势：</strong></p><ul><li><strong>第一点是默认第一次渲染时也会执行该 “钩子”；</strong></li><li><strong>第二点是不需要再通过调用 <code>setState</code> 将新的 <code>props</code> 转换成组件的状态，可以直接通过返回值设置状态。</strong></li></ul></blockquote><h3 id="getSnapshotBeforeUpdate-钩子"><a href="#getSnapshotBeforeUpdate-钩子" class="headerlink" title="getSnapshotBeforeUpdate 钩子"></a>getSnapshotBeforeUpdate 钩子</h3><p><code>getSnapshotBeforeUpdate</code> “钩子” 用于替代 <code>componentWillUpdate</code> “钩子”，不能与 <code>componentWillMount</code> “钩子” 同时使用，必须与 <code>componentDidUpdate</code> “钩子” 同时使用，需返回一个值或者 <code>null</code>，该值会传给 <code>componentDidUpdate</code> “钩子” 的第三个参数。</p><pre><code class="lang-jsx">import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  // 点击事件
  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
  }

  getSnapshotBeforeUpdate() {
    console.log(&#39;getSnapshotBeforeUpdate&#39;);
    return 123;
  }

  componentDidUpdate(prevProps, prevState, prop) {
    console.log(&#39;componentDidUpdate&#39;);
    console.log(&#39;prop&#39;, prop);
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);

// render
// getSnapshotBeforeUpdate
// componentDidUpdate
// prop 123
</code></pre><p>点击更新按钮执行顺序为：<code>render</code> → <code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>以上就是关于 <code>React</code> 生命周期的内容，涵盖了在 <code>React</code> 开发中对生命周期大部分的应用，也是 <code>React</code> 知识体系中非常重要的部分，<code>React</code> 生命周期和 <code>Vue</code> 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。</strong></p></blockquote>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>React 基础篇 —— 带你走进 React 世界</title>
    <url>/20180910025959/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/react.png" title="React 16"><p><br></p><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><blockquote class="pullquote default"><p><strong><code>React</code> 是前端最流行的框架之一，由 <code>Facebook</code> 产出，由于其独特的 <code>JSX</code> 语法与组件化开发模式，将原本前端基于 <code>DOM</code> 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 <code>DOM</code> 操作是 “昂贵” 的，<code>React</code> 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 <code>React</code> 已经成为前端工程师之必备技术栈。</strong></p></blockquote><a id="more"></a><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>在创建 <code>React</code> 项目时，可以使用当下最流行的脚手架 <code>create-react-app</code> 和 <code>generator-react-webpack</code>，前者是由 <code>Facebook</code> 官方出品，后者是社区提供。</p><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p><code>create-react-app</code> 适用于大部分项目，集成了对 <code>React</code>、<code>JSX</code>、<code>ES6</code> 和 <code>Flow</code> 的支持，支持热更新，默认情况下无需对 <code>Webpack</code> 进行配置，如果要单独配置 <code>Webpack</code>，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。</p><pre><code class="lang-bash"># 安装脚手架
$ npm install -g create-react-app
# 创建项目
$ create-react-app project-name
# 弹射 Webpack 配置文件
$ npm run eject
</code></pre><blockquote class="pullquote warning"><p><strong>注意：创建 <code>React</code> 项目时，项目名称不能含大写字母，使用 <code>eject</code> 命令弹出配置项的过程不可逆。</strong></p></blockquote><h3 id="generator-react-webpack"><a href="#generator-react-webpack" class="headerlink" title="generator-react-webpack"></a>generator-react-webpack</h3><p><code>generator-react-webpack</code> 适用于构建大型项目，它是需要 <code>yeoman</code> 的支持，几乎具备了 <code>create-react-app</code> 的全部功能，不同的是默认可以对 <code>Webpack</code> 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下：</p><pre><code class="lang-bash"># 安装脚手架及依赖
$ npm install -g yo generator-react-webpack
# 创建项目根目录
$ mkdir project-name
# 进入项目目录
$ cd project-name
# 创建项目
$ yo react-webpack
</code></pre><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>我们本次使用 <code>create-react-app</code> 来构建一个项目，并弹出配置项，<code>src</code> 目录为我们主要的开发文件，必须含有一个入口文件 <code>index.js</code>，所以我们在构建项目后删除 <code>src</code> 中的无用文件，目录结构如下（可以通过 <code>npm run start</code> 启动项目）。</p><pre class="language-treeview">
  <code class="language-treeview">
    react-demo
      |- config
      | |- jest
      | | |- cssTransform.js
      | | |- fileTransform.js
      | |- env.js.js
      | |- paths.js
      | |- webpack.config.dev.js
      | |- webpack.config.prod.js
      | |- webpackDevServer.config.js
      |- public
      | |- favicon.ico
      | |- index.html
      | |- manifest.json
      |- scripts
      | |- build.js
      | |- start.js
      | |- test.js
      |- src
      | |- index.js
      |- .gitignore
      |- package.json
      |- README.md
      |- yarn.lock
  </code>
</pre><h2 id="探索-React"><a href="#探索-React" class="headerlink" title="探索 React"></a>探索 React</h2><h3 id="引入-React-变量必须大写"><a href="#引入-React-变量必须大写" class="headerlink" title="引入 React 变量必须大写"></a>引入 React 变量必须大写</h3><p><code>React</code> 的核心模块分为两个，分别为 <code>react</code> 和 <code>react-dom</code>，前者为 <code>React</code> 的核心逻辑，后者为 <code>React</code> 的渲染逻辑，在 <code>React</code> 中规定引入 <code>react</code> 模块的变量名必须大写。</p><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
import react from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建一个 JSX
const h1 = (
  &lt;h1&gt;hello world&lt;/h1&gt;
)

// 渲染到页面
ReactDOM.render(h1, window.root);
</code></pre><p>如果向上面代码中将引入 <code>react</code> 的变量小写，报错信息如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error1.png" alt="React 变量错写报错"></div><div class="image-caption">React 变量错写报错</div></figure><p><br></p><p>该报错信息的意思是当前使用了 <code>JSX</code>，必须要有一个大写的 <code>React</code>，从而可以看出这是 <code>React</code> 所规定的，当将接收 <code>react</code> 的变量改成大写后，页面正常渲染。</p><h3 id="React-必须有-createElement-方法"><a href="#React-必须有-createElement-方法" class="headerlink" title="React 必须有 createElement 方法"></a>React 必须有 createElement 方法</h3><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
// 创建一个大写的 React 对象
const React = {};

// 创建一个 JSX
const h1 = (
  &lt;h1&gt;hello world&lt;/h1&gt;
)
</code></pre><p>为了进一步验证，上面代码中创建一个名为 <code>React</code> 的对象，报错信息如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error2.png" alt="React 没有 createElement 方法报错"></div><div class="image-caption">React 没有 createElement 方法报错</div></figure><p><br></p><p>这个报错非常明显的在告诉我们，<code>React</code> 对象中缺少了 <code>createElement</code> 方法，我们将代码修改如下后发现报错信息消失。</p><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
// 创建一个大写的 React 对象
const React = {
  createElement() {}
};

// 创建一个 JSX
const h1 = (
  &lt;h1&gt;hello world&lt;/h1&gt;
)
</code></pre><p>页面 “白屏” 是因为并没有使用 <code>react-dom</code> 进行渲染，我们定义的 <code>h1</code> 是一个组件，同时也是 <code>JSX</code>，所以会调用 <code>createElement</code> 对 <code>JSX</code> 进行解析。</p><h3 id="解析后的-JSX-长什么样"><a href="#解析后的-JSX-长什么样" class="headerlink" title="解析后的 JSX 长什么样"></a>解析后的 JSX 长什么样</h3><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
import React from &#39;react&#39;;

// 创建一个 JSX
const h1 = (
  &lt;h1&gt;hello world&lt;/h1&gt;
)

// 查看 JSX 解析后的结果
console.log(h1);
</code></pre><p>打开 <code>Chorme</code> 浏览器控制台查看打印结果如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/virtualDOM.png" alt="JSX 解析后的虚拟 DOM 结构"></div><div class="image-caption">JSX 解析后的虚拟 DOM 结构</div></figure><p><br></p><p>从结果可以看出 <code>createElement</code> 方法最终将 <code>JSX</code> 解析成了一个对象结构，其中 <code>props</code> 带表属性对象，其中的 <code>children</code> 代表子元素，也就是文本节点 <code>hello world</code>，<code>type</code> 代表标签类型为 <code>h1</code>，这样用来表述 <code>DOM</code> 结构的对象被称为虚拟 <code>DOM</code>。</p><h3 id="模拟解析和渲染过程"><a href="#模拟解析和渲染过程" class="headerlink" title="模拟解析和渲染过程"></a>模拟解析和渲染过程</h3><p>在上面我们知道了 <code>React</code> 可以自动将 <code>JSX</code> 转换成虚拟 <code>DOM</code>，而 <code>ReactDOM</code> 的 <code>render</code> 方法将虚拟 <code>DOM</code> 渲染成了真实的 <code>DOM</code>，用法如下：</p><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建 JSX
const el = (
  &lt;h1 name=&quot;hi&quot;&gt;
    hello
    &lt;span&gt;world&lt;/span&gt;
  &lt;/h1&gt;
)

// 渲染到页面
ReactDOM.render(el, window.root);
</code></pre><p>查看页面可以看到正常渲染了，现在就用前面对 <code>React</code> 的了解来简单模拟解析与渲染的过程，代码如下：</p><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
// 创建 React 对象和 createElement 方法
const React = {
  createElement(type, props, ...children) {
    return { type, props, children };
  }
};

// 创建 JSX
const el = (
  &lt;h1 name=&quot;hi&quot;&gt;
    hello
    &lt;span&gt;world&lt;/span&gt;
  &lt;/h1&gt;
)

// 渲染的 render 方法
function render(vnode, container) {
  // 如果是字符串说明是文本节点，创建文本节点并插入到父元素中
  if (typeof vnode === &#39;string&#39;) {
    return container.appendChild(document.createTextNode(vnode));
  }

  // 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组
  const { type, props, children } = vnode;

  // 创建元素
  const tag = document.createElement(type);

  // 循环添加属性
  for (let key in props) {
    tag.setAttribute(key, props[key]);
  }

  // 循环子元素，并递归创建子元素
  children.forEach(child =&gt; {
    render(child, tag);
  });

  // 将元素插入到容器中，root
  container.appendChild(tag);
}

// 渲染虚拟 DOM
render(el, window.root);
</code></pre><p>通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，<code>React</code> 内部的实现更为复杂，兼容了多种组件类型和复杂的 <code>DOM</code> 结构。</p><h3 id="JSX-最外层只能有一个元素"><a href="#JSX-最外层只能有一个元素" class="headerlink" title="JSX 最外层只能有一个元素"></a>JSX 最外层只能有一个元素</h3><pre><code class="lang-jsx">/* 文件位置：~react-demo/src/index.js */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建 JSX
const el = (
  &lt;h1 name=&quot;hi&quot;&gt;hello&lt;/h1&gt;
  &lt;div&gt;world&lt;/div&gt;
)

ReactDOM.render(el, window.root);
</code></pre><p>在对上面代码中的 <code>JSX</code> 进行渲染时会有如下报错信息。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error3.png" alt="JSX 没有唯一父元素包裹报错"></div><div class="image-caption">JSX 没有唯一父元素包裹报错</div></figure><p><br></p><p>上面的报错信息告诉我们 <code>JSX</code> 元素必须包裹在一个闭合的标签内，所以说在写 <code>JSX</code> 语法的时候我们必须保证最外层只有一个元素节点。</p><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><blockquote class="pullquote info"><p><strong>在 <code>JSX</code> 全称为 <code>JavaScript XML</code>，但是和普通的 <code>HTML</code> 相比，有一些不同的用法，如元素属性 <code>class</code>、<code>for</code>、<code>style</code>、<code>dangerouslyInnerHTML</code> 以及注释写法等等。</strong></p></blockquote><h3 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h3><p>在 <code>JSX</code> 语法中，在标签中应使用 <code>className</code> 替代 <code>HTML</code> 中的 <code>class</code> 属性，因为在 <code>JavaScript</code> 中 <code>class</code> 为关键字。</p><pre><code class="lang-jsx">/* class 属性在 JSX 中的写法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(&lt;h1 className=&quot;active&quot;&gt;hello&lt;/h1&gt;, window.root);
</code></pre><h3 id="htmlFor-属性"><a href="#htmlFor-属性" class="headerlink" title="htmlFor 属性"></a>htmlFor 属性</h3><p>在 <code>HTML</code> 中，通过点击 <code>label</code> 标签让 <code>input</code> 输入框获取焦点是很常见的，只需要让 <code>label</code> 标签 <code>for</code> 属性的值与 <code>input</code> 标签的 <code>id</code> 值相等即可，但是在 <code>JSX</code> 中这这样的写法会报错，必须将 <code>label</code> 标签的 <code>for</code> 属性使用 <code>htmlFor</code> 替代，代码如下：</p><pre><code class="lang-jsx">/* for 属性在 JSX 中的写法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const el = (
  &lt;div&gt;
    &lt;h1&gt;hello&lt;/h1&gt;
    &lt;label htmlFor=&quot;username&quot;&gt;用户名&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;
  &lt;/div&gt;
)

ReactDOM.render(el, window.root);
</code></pre><h3 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h3><pre><code class="lang-jsx">/* style 属性错误的写法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const el = (
  &lt;h1 style=&quot;color: red;&quot;&gt;hello&lt;/h1&gt;
)

ReactDOM.render(el, window.root);
</code></pre><p>在 <code>JSX</code> 中关于 <code>style</code> 属性的写法发生了变化，如果用 <code>HTML</code> 中的写法会报错，错误信息如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error4.png" alt="JSX 中 style 属性错误写法报错"></div><div class="image-caption">JSX 中 style 属性错误写法报错</div></figure><p><br></p><p>报错信息中明确的告诉我们 <code>style</code> 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下：</p><pre><code class="lang-jsx">/* style 属性在 JSX 中的写法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const el = (
  &lt;h1 style={{color: 'red'}}&gt;hello&lt;/h1&gt;
)

ReactDOM.render(el, window.root);
</code></pre><blockquote class="pullquote warning"><p><strong>注意：在解析 <code>JSX</code> 的过程中，<code>&lt;</code> 和 <code>&gt;</code> 包裹 <code>JSX</code> 元素，元素属性中最外层的 <code>{</code> 和 <code>}</code> 包裹 <code>JS</code> 代码，而内层的 <code>{</code> 和 <code>}</code> 则代表一个 <code>JS</code> 对象，所以 <code>style</code> 是被两层 “花括号” 所包裹，并不是 <code>mustache</code> 语法。</strong></p></blockquote><h3 id="取值表达式"><a href="#取值表达式" class="headerlink" title="取值表达式"></a>取值表达式</h3><p>在 <code>JSX</code> 中，所有的 <code>JS</code> 代码都可以写在 <code>JSX</code> 元素起始和闭合标签中间的 <code>{</code> 和 <code>}</code> 内，会将执行结果渲染到该元素上。</p><pre><code class="lang-jsx">/* 取值表达式的使用 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const str = &#39;world&#39;;
const obj = { hello: &#39;world&#39; };
const fn = () =&gt; &lt;p&gt;hello&lt;/p&gt;;

const el = (
  &lt;div&gt;
    &lt;h1&gt;{fn()}&lt;/h1&gt;
    &lt;div&gt;{str}&lt;/div&gt;
    &lt;div&gt;{JSON.stringify(obj)}&lt;/div&gt;
    &lt;div&gt;{true ? &lt;span&gt;nihao&lt;/span&gt; : null}&lt;/div&gt;
  &lt;/div&gt;
)

ReactDOM.render(el, window.root);
</code></pre><p>启动项目可以看到页面上已经成功的渲染了 <code>hello</code>、<code>world</code>、<code>{ hello: &#39;world&#39; }</code> 和 <code>nihao</code>，上面三元运算符结果如果为 <code>null</code> 则不会渲染这个节点，<code>viod 0</code> 与 <code>null</code> 作用相同。</p><h3 id="dangerouslySetInnerHTML-属性"><a href="#dangerouslySetInnerHTML-属性" class="headerlink" title="dangerouslySetInnerHTML 属性"></a>dangerouslySetInnerHTML 属性</h3><p>在 <code>JSX</code> 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 <code>dangerouslySetInnerHTML</code> 替代原生 <code>JS</code> 中的 <code>innerHTML</code>。</p><pre><code class="lang-jsx">/* dangerouslySetInnerHTML 的用法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const str = &#39;&lt;h1&gt;hello&lt;/h1&gt;&#39;;
const el = (
  &lt;h1 dangerouslySetInnerHTML={{__html: str}}&gt;&lt;/h1&gt;
)

ReactDOM.render(el, window.root);
</code></pre><p>在上面的代码中，<code>dangerouslySetInnerHTML</code> 属性的值为对象，将要插入的 <code>HTML</code> 字符串作为对象中 <code>__html</code> 属性的值即可，设置 <code>dangerouslySetInnerHTML</code> 属性的 <code>JSX</code> 元素中不能有任何的子元素。</p><blockquote class="pullquote danger"><p><strong>注意：<code>dangerouslySetInnerHTML</code> 属性非常危险，容易引发 <code>XSS</code> 攻击，轻易不要使用。</strong></p></blockquote><h3 id="JSX-中注释的写法"><a href="#JSX-中注释的写法" class="headerlink" title="JSX 中注释的写法"></a>JSX 中注释的写法</h3><p>在 <code>JSX</code> 的 <code>DOM</code> 结构中，如果需要对代码进行注释不能使用 <code>JS</code> 中的 <code>// 注释</code>，也不能使用 <code>HTML</code> 中的 <code>&lt;!-- 注释 --&gt;</code>，注释必须使用 <code>{ }</code> 包裹，写法如下：</p><pre><code class="lang-jsx">/* 注释在 JSX 中的写法 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const el = (
  &lt;div&gt;
    &lt;h1 name=&quot;hi&quot;&gt;hello&lt;/h1&gt;
    {/* 这是注释，支持多行 */}
    &lt;span&gt;world&lt;/span&gt;
  &lt;/div&gt;
)

ReactDOM.render(el, window.root);
</code></pre><h3 id="Fragment-组件"><a href="#Fragment-组件" class="headerlink" title="Fragment 组件"></a>Fragment 组件</h3><p>在 <code>React 16.3</code> 中提供了一个组件，类似于原生 <code>JS</code> 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下：</p><pre><code class="lang-jsx">/* Fragment 组件的使用 */
import React, { Fragment } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const el = (
  &lt;Fragment&gt;
    &lt;h1&gt;hello&lt;/h1&gt;
    &lt;div&gt;world&lt;/div&gt;
  &lt;/Fragment&gt;
)

ReactDOM.render(el, window.root);
</code></pre><h3 id="循环动态创建-JSX-结构"><a href="#循环动态创建-JSX-结构" class="headerlink" title="循环动态创建 JSX 结构"></a>循环动态创建 JSX 结构</h3><p>在 <code>React</code> 中不存在过多的 <code>API</code>，最大的特点就是 <code>JSX</code> 语法可以将 <code>JS</code> 与 <code>HTML</code> 混写（函数式编程），借助原生 <code>JS</code> 的方法实现功能，比如可以使用循环创建 <code>JSX</code> 结构。</p><pre><code class="lang-jsx">/* 循环在 JSX 中的应用 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const arr = [1, 2, 3];
const el = (
  arr.map((item, index) =&gt; {
    return (
      &lt;li key={index}&gt;{item}&lt;/li&gt;
    )
  })
)

ReactDOM.render(el, window.root);
</code></pre><blockquote class="pullquote danger"><p><strong>上面成功的渲染除了一个列表，但是有两点需要注意：</strong></p><ul><li><strong>第一点是循环一定要使用具有返回值的方法，如 <code>map</code>、<code>filter</code> 等；</strong></li><li><strong>第二点是每一个循环出来的 <code>JSX</code> 元素必须绑定一个 <code>key</code> 属性，可以使用数据的 <code>id</code>（优先），也可以使用数组的索引。</strong></li></ul></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote class="pullquote success"><p><strong>在上面所有代码中的 <code>JSX</code> 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 <code>JSX</code> 结构以及提高工作效率而存在的。</strong></p></blockquote><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>在 <code>React</code> 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 <code>JSX</code>，也可以为 <code>null</code>，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下：</p><pre><code class="lang-jsx">/* 函数组件 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建一个函数组件
function Build(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;{props.title}&lt;/h1&gt;
      &lt;div&gt;{props.content}&lt;/div&gt;
    &lt;/div&gt;
  )
}

// 渲染组件
ReactDOM.render((
  &lt;div&gt;
    &lt;Build title=&#39;1&#39; content=&#39;1xx&#39;&gt;&lt;/Build&gt; {/* 双闭合 */}
    &lt;Build title=&#39;2&#39; content=&#39;2xx&#39; /&gt; {/* 单闭合 */}
  &lt;/div&gt;
), window.root);
</code></pre><blockquote class="pullquote primary"><p><strong>函数组件缺点（<code>16.3</code> 以前）：</strong></p><ul><li><strong>在函数组件内部 <code>this</code> 为 <code>undefined</code>；</strong></li><li><strong>在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；</strong></li><li><strong>函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。</strong></li></ul></blockquote><p>由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 <code>React.render</code> 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。</p><pre><code class="lang-jsx">/* 函数组件多次渲染 */
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建函数组件
function Clock(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;当前时间&lt;/h1&gt;
      &lt;div&gt;{props.time}&lt;/div&gt;
    &lt;/div&gt;
  )
}

// 每秒渲染一次组件
setInterval(() =&gt; {
  ReactDOM.render(
    &lt;Clock time={new Date().toLocaleString()} /&gt;,
    window.root
  );
}, 1000);
</code></pre><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件解决了函数组件所有的缺陷，是通过类声明的。</p><pre><code class="lang-jsx">/* 类组件 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  // constructor(props) {
  //   super(props);
  //   this.state = {
  //     time: new Date().toLocaleString();
  //   }
  // }

  // 等价于 constructor 的写法，更简洁
  state = {
    time: new Date().toLocaleString()
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><p>在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 <code>this</code>，又能创建和更新状态，也可以通过生命周期进行一些操作。</p><p>所有的类组件都需要继承 <code>React.Component</code>，这样就可以使用 <code>React.Component</code> 的原型方法 <code>setState</code> 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 <code>DOM</code>，这是 <code>ReactDOM</code> 通过 <code>diff</code> 算法所做的优化。</p><h3 id="类组件中添加事件"><a href="#类组件中添加事件" class="headerlink" title="类组件中添加事件"></a>类组件中添加事件</h3><p>在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。</p><pre><code class="lang-jsx">/* 方式 1：使用箭头函数直接绑定事件 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  state = {
    time: new Date().toLocaleString()
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
        &lt;button onClick={() =&gt; {
          // 卸载组件的方法
          ReactDOM.unmountComponentAtNode(window.root);
        }}&gt;
          kill
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><pre><code class="lang-jsx">/* 方式 2：使用 bind 绑定函数 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  state = {
    time: new Date().toLocaleString()
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 点击事件
  handleClick() {
    ReactDOM.unmountComponentAtNode(window.root);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
        &lt;button onClick={this.handleClick.bind(this)}&gt;kill&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><p>上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 <code>render</code> 时都会创建新的箭头函数，而将函数作为原型方法，通过 <code>bind</code> 是为了修正方法内部的 <code>this</code> 指向，但是每次执行 <code>render</code> 时，<code>bind</code> 也会返回一个新的函数。</p><pre><code class="lang-jsx">/* 方式 3：在方式 2 的基础上提前生成函数 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  constructor(props) {
    super(props);
    this.state = {
      time: new Date().toLocaleString()
    };
    this.fn = this.handleClick.bind(this);
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 点击事件
  handleClick() {
    ReactDOM.unmountComponentAtNode(window.root);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
        &lt;button onClick={this.fn}&gt;kill&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><p>这样就解决了上面每次执行 <code>render</code> 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。</p><pre><code class="lang-jsx">/* 方式 4：使用 ES7 语法将原型方法使用箭头函数 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  state = {
    time: new Date().toLocaleString()
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 点击事件
  handleClick = () =&gt; {
    ReactDOM.unmountComponentAtNode(window.root);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
        &lt;button onClick={this.handleClick}&gt;kill&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><p>使用 <code>ES7</code> 的新语法，既解决了事件处理函数方法内部 <code>this</code> 指向问题，又解决了每次执行 <code>render</code> 创建新函数的问题，但需要依赖 <code>@babel/plugin-proposal-class-properties</code> 插件来解析。</p><h3 id="卸载组件后不能再更新状态"><a href="#卸载组件后不能再更新状态" class="headerlink" title="卸载组件后不能再更新状态"></a>卸载组件后不能再更新状态</h3><p>还是上面的时钟案例，我们知道卸载一个组件应该使用 <code>ReactDOM.unmountComponentAtNode</code> 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。</p><p>当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error5.png" alt="卸载组件后更新状态报错"></div><div class="image-caption">卸载组件后更新状态报错</div></figure><p><br></p><p>这个报错信息的意思是告诉我们在组件卸载后不能再通过 <code>setState</code> 更新状态，所以我们要在组件卸载之前先清空调用 <code>setState</code> 的定时器，代码修改如下：</p><pre><code class="lang-jsx">/* 完整的时钟组件 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 创建类组件
class Clock extends Component {
  state = {
    time: new Date().toLocaleString()
  }

  // 生命周期
  componentDidMount() {
    // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染
    this.timer = setInterval(() =&gt; {
      this.setState({ time: new Date().toLocaleString() });
    }, 1000);
  }

  // 组件将要卸载时清空定时器
  componentWillUnmount() {
    clearInterval(this.timer);
  }

  // 点击事件
  handleClick = () =&gt; {
    ReactDOM.unmountComponentAtNode(window.root);
  }

  // 渲染这个组件会调用 render 方法
  render() {
    return (
      &lt;div&gt;
        时间：&lt;span&gt;{this.state.time}&lt;/span&gt;
        &lt;button onClick={this.handleClick}&gt;kill&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 渲染组件
ReactDOM.render(&lt;Clock /&gt;, window.root);
</code></pre><p>在这个组件中用到了两个生命周期 “钩子”，<code>componentDidMount</code> 钩子在组件挂载后执行，类似于原生 <code>JS</code> 的 <code>window.onload</code>，<code>componentWillUnmount</code> 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 <code>React</code> 基础篇系列文章中一一说明。</p><h3 id="类组件的参数传递"><a href="#类组件的参数传递" class="headerlink" title="类组件的参数传递"></a>类组件的参数传递</h3><pre><code class="lang-jsx">/* 类组件传参第一种方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const p = { name: &#39;panda&#39;, age: 28 };

class Person extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;{this.props.name}&lt;/p&gt;
        &lt;p&gt;{this.props.age}&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

// 分别传入想要的属性
ReactDOM.render(&lt;Person name={p.name} age={p.age} /&gt;, window.root);
</code></pre><pre><code class="lang-jsx">/* 类组件传参第二种方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

const p = { name: &#39;panda&#39;, age: 28 };

class Person extends Component {
  render() {
    const { name, age } = this.props;

    return (
      &lt;div&gt;
        &lt;p&gt;{name}&lt;/p&gt;
        &lt;p&gt;{age}&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

// 传入整个对象
ReactDOM.render(&lt;Person {...p} /&gt;, window.root);
</code></pre><p>上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 <code>constructor</code> 中的第一个参数接收 <code>props</code>，也可以直接使用 <code>this.props</code>，因为 <code>React</code> 在组件创建实例调用 <code>super</code> 之前就已经将 <code>props</code> 作为了实例属性。</p><h3 id="组件参数的类型校验"><a href="#组件参数的类型校验" class="headerlink" title="组件参数的类型校验"></a>组件参数的类型校验</h3><p>在 <code>React</code> 组件传递参数时，是通过 <code>props</code> 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 <code>React</code> 生态中有一个第三方模块 <code>prop-types</code> 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。</p><pre><code class="lang-bash">$ npm install prop-types
</code></pre><pre><code class="lang-js">/* 使用 prop-types 校验传给组件的参数 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import PropTypes from &#39;prop-types&#39;;

const p = {
  name: &#39;panda&#39;,
  age: 28,
  gender: &#39;男&#39;,
  hobby: [&#39;basketball&#39;, &#39;swim&#39;],
  pos: { x: 433, y: 822 },
  salary: 5000
}

class Person extends Component {
  // 定义默认属性，React 自带
  static defaultProps = {
    name: &#39;shen&#39;
  }

  // 定义属性类型
  static propTypes = {
    name: PropTypes.string.isRequired, // 类型必须为字符串，必填项
    age: PropTypes.number, // 类型必须为数字
    gender: PropTypes.oneOf([&#39;男&#39;, &#39;女&#39;]), // 性别只能为男或女
    hobby: PropTypes.arrayOf(PropTypes.string), // 数组成员类型必须是字符串
    pos: PropTypes.shape({ // 限制模型内部类型
      x: PropTypes.number.isRequired,
      y: PropTypes.number.isRequired
    }),

    // 第一个参数为原对象，第二个参数为当前属性，第三个参数为类
    salary(obj, key, P) {
      // 自行校验
      if (obj[key] &lt; 3000) {
        throw new Error(&#39;工资太低&#39;);
      }
    }
  }

  render() {
    const { name, age } = this.props;

    return (
      &lt;div&gt;
        &lt;p&gt;{name}&lt;/p&gt;
        &lt;p&gt;{age}&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Person {...p} /&gt;, window.root);
</code></pre><p>使用 <code>prop-types</code> 必须在类组件上添加一个静态属性 <code>propTypes</code>，在内部定义属性的类型，其中 <code>isRequired</code> 为必填项，如果没有传参会报错，在检测是会优先检测 <code>React</code> 的静态属性 <code>defaultProps</code>，即默认属性，如果 <code>defaultProps</code> 存在则视为已经有该参数。</p><p><code>oneOf</code> 方法参数为一个数组，传给组件对应的参数值必须是传给 <code>oneOf</code> 数组中的其中一项，否则会报错，<code>arrayOf</code> 方法用于限制数组成员的类型，<code>shape</code> 方法用于限属性值为对象的内部属性类型，参数为对象。</p><p>在 <code>propTypes</code> 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。</p><h3 id="setState-更新状态"><a href="#setState-更新状态" class="headerlink" title="setState 更新状态"></a>setState 更新状态</h3><p>在前面的时钟组件中已经简单的使用过 <code>setState</code>，在这里我们会对 <code>setState</code> 的用法通过一个计数器案例来做详细说明。</p><pre><code class="lang-jsx">/* 计数器案例 1 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 });
    this.setState({ num: this.state.num + 1 });
  }

  render() {
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p>在上面的计数器中，当我们点击按钮时会执行 <code>handleClick</code>，而在 <code>handleClick</code> 内部调用了两次 <code>setState</code> 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，<code>setState</code> 是异步执行的，最后一次执行的会覆盖前一次，其实在 <code>setState</code> 方法调用时支持传入一个回调函数，代码如下：</p><pre><code class="lang-jsx">/* 计数器案例 2 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }

  handleClick = () =&gt; {
    this.setState({ num: this.state.num + 1 }, () =&gt; {
      this.setState({ num: this.state.num + 1 });
    });
  }

  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p><code>setState</code> 传入的回调会在更新状态成功后执行，所以将代码修改后两次 <code>setState</code> 都生效了，<code>render</code> 执行了两次，这样的写法如果调用 <code>setState</code> 次数多了就形成了 “回调地狱”，<code>setState</code> 还有另一种用法如下：</p><pre><code class="lang-jsx">/* 计数器案例 3 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Counter extends Component {
  state = { num: 0 }
  handleClick = () =&gt; {
    this.setState(prevState =&gt; ({ num: prevState.num + 1 }));
    this.setState(prevState =&gt; ({ num: prevState.num + 1 }));
  }
  render() {
    console.log(&#39;render&#39;);
    return (
      &lt;div&gt;
        {this.state.num}
        &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;Counter /&gt;, window.root);
</code></pre><p><code>setState</code> 方法可直接传入一个函数，函数的参数为上一次更新的 <code>state</code>，也就是 <code>this.state</code>，此时执行 <code>setState</code> 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次（也叫 <code>setState</code> 合并）。</p><blockquote class="pullquote info"><p><strong>触发组件重新渲染的两种方式：</strong></p><ul><li><strong><code>props</code> 发生变化，如调用 <code>render</code> 并传入新的属性值；</strong></li><li><strong>调用 <code>setState</code> 重新设置状态。</strong></li></ul></blockquote><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。</p><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>下面是一个受控组件的写法，输入框的初始值是通过 <code>value</code> 和 <code>defaultValue</code> 属性绑定的状态的值。</p><pre><code class="lang-jsx">/* 受控组件 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Control extends Component {
  state = {
    msg1: &#39;hello&#39;,
    msg2: &#39;world&#39;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; value={this.state.msg1} /&gt; {/* 报错 */}
        &lt;input type=&quot;text&quot; defaultValue={this.state.msg2} /&gt; {/* 不报错 */}
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Control /&gt;, window.root);
</code></pre><p>上面的代码中是两种绑定初始值的方式，使用 <code>defaultValue</code> 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 <code>value</code> 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20180910025959/error6.png" alt="受控组件赋初始值报错"></div><div class="image-caption">受控组件赋初始值报错</div></figure><p><br></p><p>输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 <code>onChange</code> 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下：</p><pre><code class="lang-jsx">/* 受控组件 —— 修改后 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Control extends Component {
  state = {
    msg: &#39;hello&#39;
  }

  changeHandler = e =&gt; {
    this.setState({ msg: e.target.value });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          value={this.state.msg}
          onChange={this.changeHandler}
        /&gt;
        {this.state.msg}
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Control /&gt;, window.root);
</code></pre><p>上面的代码中在 <code>onChange</code> 事件中调用了 <code>setState</code> 并更新了状态，但是如果有多个输入框，要保证 <code>onChange</code> 事件的复用，实现不同的输入框输入时 <code>onChange</code> 事件时更新不同的状态，实现如下：</p><pre><code class="lang-jsx">/* 受控组件 —— 多个输入框复用 onChange */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class Control extends Component {
  state = {
    msg1: &#39;hello&#39;,
    msg2: &#39;world&#39;
  }

  changeHandler = e =&gt; {
    const val = e.target.name;
    this.setState({ [val]: e.target.value });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          name=&quot;msg1&quot;
          value={this.state.msg1}
          onChange={this.changeHandler}
        /&gt;
        {this.state.msg1}
        &lt;br /&gt;
        &lt;input
          type=&quot;text&quot;
          name=&quot;msg2&quot;
          value={this.state.msg2}
          onChange={this.changeHandler}
        /&gt;
        {this.state.msg2}
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Control /&gt;, window.root);
</code></pre><p>上面通过给 <code>input</code> 标签添加和状态的变量名相同的 <code>name</code> 属性，在触发 <code>onChange</code> 事件时用 <code>name</code> 属性作为更新状态数据的键值。</p><blockquote class="pullquote default"><p><strong>受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。</strong></p></blockquote><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>非受控组件与受控组件相比就是直接操作 <code>DOM</code> 来操作表单元素，直接操作 <code>DOM</code> 可以在 <code>componentDidMount</code> 生命周期内（<code>DOM</code> 完全挂载），写法如下：</p><pre><code class="lang-jsx">/* 非受控组件 —— 直接操作 DOM（不建议） */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class UnControl extends Component {
  componentDidMount() {
    const username = document.getElementById(&#39;username&#39;);
    username.value = 123;
    console.log(username.value);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;UnControl /&gt;, window.root);
</code></pre><p>当然在 <code>React</code> 中并不会这么写，<code>React</code> 专门给我们提供了操作 <code>DOM</code> 属性 <code>ref</code>，用法如下：</p><pre><code class="lang-jsx">/* 非受控组件 —— ref 常用写法 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class UnControl extends Component {
  handleClick = () =&gt; {
    // 打印输入框的值
    console.log(this.userDom.value);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          id=&quot;username&quot;
          ref={dom =&gt; this.userDom = dom}
        /&gt;
        &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;UnControl /&gt;, window.root);
</code></pre><p>使用 <code>ref</code> 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 <code>DOM</code>，通常情况下会使用类组件的一个属性来存储这个 <code>DOM</code>，方便在其他的事件或生命周期 “钩子” 中使用。</p><p>在 <code>React 16.3</code> 中推出了操作非受控组件的新的 <code>API</code> <code>React.createRef</code> 方法，返回值是一个对象，将这个对象绑定在表单元素的 <code>ref</code> 上，则可以通过这个对象的 <code>current</code> 属性获取这个表单元素的 <code>DOM</code> 元素。</p><pre><code class="lang-jsx">/* 非受控组件 —— React 16.3 新 API */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

class UnControl extends Component {
  userDom = React.createRef();

  handleClick = () =&gt; {
    // 打印输入框的值
    console.log(this.userDom.current.value);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; ref={this.userDom} /&gt;
        &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;UnControl&gt;&lt;/UnControl&gt;, window.root);
</code></pre><p>我们其实把 <code>React.createRef</code> 的返回值存储为了类组件的一个属性，并将这个属性传入 <code>ref</code>，这样可以在其他的事件或生命周期 “钩子” 中操作 <code>DOM</code>，如果存在多个这样的表单元素，许多次调用 <code>React.createRef</code>，并分别将存储返回值的类组件属性传入各个表单的 <code>ref</code> 中。</p><blockquote class="pullquote warning"><p><strong>非受控组件的好处是，操作 <code>DOM</code> 方便，可以与更多基于 <code>DOM</code> 操作的第三方库结合。</strong></p></blockquote><h2 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h2><blockquote class="pullquote primary"><p><strong>复合组件指的就是存在父子关系的组件嵌套，在 <code>React</code> 中有三种形式的父子组件嵌套：</strong></p><ul><li><strong>父组件中返回 <code>JSX</code> 中直接包含子组件；</strong></li><li><strong><code>children</code> 的方式引入子组件；</strong></li><li><strong><code>render props</code> 的方式引入子组件。</strong></li></ul></blockquote><p>第一种是直接将子组件在父组件中引入，并放在父组件 <code>render</code> 方法返回的 <code>JSX</code> 中。</p><pre><code class="lang-jsx">/* 复合组件 —— 第一种方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 父组件
class Parent extends Component {
  render() {
    return (
      &lt;div&gt;
        这是父组件
        &lt;Child /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件
class Child extends Component {
  render() {
    return (
      &lt;div&gt;这是子组件&lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Parent /&gt;, window.root);
</code></pre><p>我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 <code>JSX</code> 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 <code>props</code> 的 <code>children</code> 属性进行接收，并放入对应的位置。</p><pre><code class="lang-jsx">/* 复合组件 —— 第二种方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 父组件
class Parent extends Component {
  render() {
    return (
      &lt;div&gt;
        这是父组件
        &lt;Child&gt;
          &lt;div&gt;父组件传递给子组件的 JSX&lt;/div&gt;
        &lt;/Child&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件
class Child extends Component {
  render() {
    return (
      &lt;div&gt;
        这是子组件
        {this.props.children}
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(&lt;Parent /&gt;, window.root);
</code></pre><p>第三种方式是将子组件作为一个函数的返回值，而函数作为父组件的 <code>props</code> 参数传入父组件，父组件返回的 <code>JSX</code> 中调用函数返回子组件，又叫 <code>render props</code>。</p><pre><code class="lang-jsx">/* 复合组件 —— 第三种方式 */
import React, { Component } from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// 父组件
class Parent extends Component {
  render() {
    return (
      &lt;div&gt;
        这是父组件
        {this.props.buildChild()}
      &lt;/div&gt;
    )
  }
}

// 子组件
class Child extends Component {
  render() {
    return (
      &lt;div&gt;
        这是子组件
        {this.props.children}
      &lt;/div&gt;
    )
  }
}

// render props 函数
const buildChildFn = () =&gt; {
  return &lt;Child /&gt;
}

ReactDOM.render(&lt;Parent buildChild={buildChildFn} /&gt;, window.root);
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>这是系列关于 <code>React</code> 基础的文章，本篇是关于 <code>React</code> 的一些基础知识，也包含了一些 <code>React 16</code> 版本的一些新增内容，比较适合不了解 <code>React</code> 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。</strong></p></blockquote>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>ES7</tag>
        <tag>React</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 中间件 body-parser 原理分析</title>
    <url>/20180828022147/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180828022147/express-middleware.png" title="Express 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>Express</code> 是基于 <code>Node.js</code> 平台的 <code>Web</code> 框架，应用广泛，在 <code>Express</code> 社区中有着大量的开发者通过 <code>Express</code> 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 <code>req</code>、响应对象 <code>res</code> 添加属性或方法，我们接下来就通过分析常用的 <code>body-parser</code> 中间件的原理来了解如何开发 <code>Express</code> 中间件。</strong></p></blockquote><a id="more"></a><h2 id="body-parser-的基本使用"><a href="#body-parser-的基本使用" class="headerlink" title="body-parser 的基本使用"></a>body-parser 的基本使用</h2><p>想分析一个中间件的原理，首先应该从使用入手，在足够了解用法的基础上去分析，现在搭建一个简易的 <code>Express</code> 服务，并使用 <code>body-parser</code> 中间件，使用前需安装。</p><pre><code class="lang-bash">$ npm install express body-parser
</code></pre><p><strong>使用 <code>body-parser</code> 代码如下：</strong></p><pre><code class="lang-js">/* 使用 body-parser 中间件 */
const express = require(&#39;express&#39;);
const bodyParser = require(&#39;body-parser&#39;);

// 创建服务
const app = express();

// 使用 body-parser 中间
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

// 创建路由
app.post(&#39;/login&#39;, function (req, res) {
  console.log(req.body);
  res.send(req.body);
});

// 监听服务
app.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>启动上面的服务器，通过 <code>postman</code> 工具分别通过表单提交和 <code>json</code> 的格式访问 <a href="javascript:;">http://localhost:3000/login</a>，查看服务器控制后台的打印结果和 <code>postman</code> 的返回结果。</p><h2 id="body-parser-的实现"><a href="#body-parser-的实现" class="headerlink" title="body-parser 的实现"></a>body-parser 的实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><blockquote class="pullquote default"><p><strong>从上面的使用案例我们可以分析出一下几点：</strong></p><ul><li><strong>首先，<code>body-parser</code> 中间件的作用是给 <code>req</code> 添加属性 <code>body</code>，值为对象，以键值对的形式存储请求体中的参数；</strong></li><li><strong>其次，<code>body-parser</code> 只处理 <code>POST</code> 请求；</strong></li><li><strong>最后，<code>body-parser</code> 模块导出一个对象，上面有两个方法 <code>urlencoded</code> 和 <code>json</code>，分别处理表单提交和 <code>json</code> 格式的请求体参数。</strong></li></ul></blockquote><h3 id="分析-urlencoded、json-公共逻辑"><a href="#分析-urlencoded、json-公共逻辑" class="headerlink" title="分析 urlencoded、json 公共逻辑"></a>分析 urlencoded、json 公共逻辑</h3><blockquote class="pullquote default"><p><strong>在实现之前我们先分析一下两个方法：</strong></p><ul><li><strong>首先都需要先读取请求体中的内容，数据传输的类型为 <code>Buffer</code>，转换成字符串后会根据提交方式不同而导致请求体中的内容是查询字符串或者是 <code>json</code> 字符串的区别；</strong></li><li><strong>当解析失败时都需要做错误处理；</strong></li><li><strong>当不是 <code>POST</code> 请求时都需要向下执行其他中间件；</strong></li><li><strong>而最核心的事就是把请求体中的数据转换成对象挂在 <code>req.body</code> 上。</strong></li></ul></blockquote><p>使用的转换数据的方法不同是唯一的区别，能区分两者的就是请求头 <code>Content-Type</code> 的值，因此我们可以把所有的公共逻辑抽取出来用一个 <code>acceptPost</code> 函数来执行。</p><h3 id="模块的创建"><a href="#模块的创建" class="headerlink" title="模块的创建"></a>模块的创建</h3><p>我们下面创建自己的 <code>body-parser</code> 模块，防止命名冲突，模块命名为 <code>my-body-parser</code>，处理参数需要使用 <code>querystring</code> 和 <code>qs</code> 两个模块，其中 <code>qs</code> 是第三方模块，使用前需安装。</p><pre><code class="lang-bash">$ npm install qs
</code></pre><p><code>qs</code> 和 <code>querystring</code> 作用基本相同，就是处理查询字符串格式的参数，但是也有一点小小的区别，<code>querystring</code> 只能处理一级，而 <code>qs</code> 可以处理多级。</p><pre><code class="lang-js">/* 文件：my-body-parser.js */
const querystring = require(&#39;querystring&#39;);
const qs = require(&#39;qs&#39;);

// urlencoded 和 json 公共逻辑
function acceptPost() {
  // ...
}

// 处理表单提交的方法
function urlencoded() {
  // ...
}

// 处理请求体 json 的方法
function json() {
  // ...
}

// 导出对象
module.exports = { urlencoded, json };
</code></pre><p>在把基本模块搭建好后，我们下面就实现 <code>body-parser</code> 模块内的公共逻辑函数 <code>acceptPost</code>。</p><h3 id="acceptPost-的实现"><a href="#acceptPost-的实现" class="headerlink" title="acceptPost 的实现"></a>acceptPost 的实现</h3><p>为了兼容 <code>urlencoded</code> 方法和 <code>json</code> 方法设计了两个参数，一个是区分当前调用方法的 <code>type</code>，一个是针对 <code>urlencoded</code> 方法的 <code>options</code>。</p><pre><code class="lang-js">/* acceptPost 的实现 */
// urlencoded 方法和 json 方法的公共逻辑函数
function acceptPost(type, options) {
  // 返回一个中间件函数
  return function (req, res, next) {
    // 获取请求头
    const contentType = req.headers[&#39;content-type&#39;];

    // 判断如果不符合两种提交的请求头直接交给其他中间件处理
    if (
      contentType === &#39;application/x-www-form-urlencoded&#39; ||
      contentType === &#39;application/json&#39;
    ) {
      // 存储数据的数组
      const buffers = [];

      req.on(&#39;data&#39;, function (data) {
        // 接收数据并存入数组中
        buffers.push(data);
      });

      req.on(&#39;end&#39;, function () {
        // 组合数据并转换成字符串
        const result = Buffer.concat(buffers).toString();

        // 处理数据并挂载 req.body 属性上
        // 如果是表单提交则使用 querystring 或 qs，否则使用 JSON.parse
        if (type === &#39;form&#39;) {
          // 如果配置 extended 值为 true 使用 qs，否则使用 querystring
          req.body = options.extended ? qs.parse(result) : querystring.parse(result);
        } else if (type === &#39;json&#39;) {
          req.body = JSON.parse(result);
        }

        next(); // 向下执行
      });

      // 错误处理
      req.on(&#39;err&#39;, function (err) {
        next(err);
      });
    } else {
      next();
    }
  }
}
</code></pre><h3 id="urlencoded-和-json-方法的实现"><a href="#urlencoded-和-json-方法的实现" class="headerlink" title="urlencoded 和 json 方法的实现"></a>urlencoded 和 json 方法的实现</h3><pre><code class="lang-js">// 处理表单提交的方法
function urlencoded(options) {
  // 定义 type 值
  const type = &#39;form&#39;;
  return acceptPost(type, options)
}

// 处理请求体 json 的方法
function json() {
  // 定义 type 值
  const type = &#39;json&#39;;
  return acceptPost(type);
}
</code></pre><p>当我们把所有的公共逻辑都抽取出去后发现，<code>urlencoded</code> 和 <code>json</code> 方法内部只需要定义不同的类型就可以执行自己的中间件逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>上面分析 <code>body-parse</code> 中间件的原理的目的在于理解 <code>Express</code> 中间件开发的模式，在此总结一下，<code>Express</code> 中间件返回的是一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，当功能无法处理某些情况时需要调用 <code>next</code>，当出现错误时调用 <code>next</code> 并传递错误，则交给 <code>Express</code> 内置的错误处理中间件，在中间件内部代码涉及异步操作时，须在异步完成的回调当中调用 <code>next</code>，这是不如 <code>Koa</code> 方便的一点，同时也是两者的区别，因为 <code>Koa</code> 中已经大量使用 <code>async/await</code>，在执行异步代码时可以等待。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>中间件</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 源码分析及简易封装</title>
    <url>/20180825162129/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180825162129/express.png" title="Express 源码解析"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><strong><code>Express</code> 是 <code>Node.js</code> 的 <code>Web</code> 框架，与 <code>Koa</code> 的轻量相比，功能要更多一些，依然是当前使用最广泛的 <code>Node.js</code> 框架，本篇参考 <code>Express</code> 的核心逻辑来实现一个简易版，<code>Express</code> 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 <code>Express</code>，又想快速的了解 <code>Express</code> 常用功能的原理，那读这篇文章算往前迈一小步，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 <code>Express</code> 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。</strong></p></blockquote><a id="more"></a><h2 id="搭建基本服务"><a href="#搭建基本服务" class="headerlink" title="搭建基本服务"></a>搭建基本服务</h2><p>下面我们使用 <code>Express</code> 来搭建一个最基本的服务，只有三行代码，只能访问不能响应。</p><pre><code class="lang-js">/* 三行代码搭建的最基本服务 */
// 引入 Express
const express = require(&#39;express&#39;);

// 创建服务
const app = express();

// 监听服务
app.listen(3000);
</code></pre><p>从上面我们可以分析出，<code>express</code> 模块给我们提供了一个函数，调用后返回了一个函数或对象给上面有 <code>listen</code> 方法给我们创建了一个 <code>http</code> 服务，我们就按照官方的设计返回一个函数 <code>app</code>。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {}

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p>我们创建一个模块 <code>express.js</code>，导出了 <code>createApplication</code> 函数并返回在内部创建 <code>app</code> 函数，<code>createApplication</code> 等于我们引入 <code>Express</code> 模块时所调用的那个函数，返回值就是我们接收的 <code>app</code>，在 <code>createApplication</code> 返回的 <code>app</code> 函数上挂载了静态方法 <code>listen</code>，用于帮助我们启动 <code>http</code> 服务。</p><p><code>createApplication</code> 函数内我们使用引入的 <code>http</code> 模块创建了服务，并调用了创建服务 <code>server</code> 的 <code>listen</code> 方法，将 <code>app.listen</code> 的所有参数传递进去，这就等于做了一层封装，将真正创建服务器的过程都包在了 <code>app.listen</code> 内部，我们自己封装的 <code>Express</code> 模块只有在调用导出函数并调用 <code>app.listen</code> 时才会真正的创建服务器和启动服务器，相当于将原生的两步合二为一。</p><h2 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h2><p>在 <code>Express</code> 框架中有多个路由方法，方法名分别对应不同的请求方式，可以帮助我们匹配路径和请求，在完全匹配时执行路由内部的回调函数，目的是在不同路由不同请求方法的情况下让服务器做出不同的响应，路由的使用方式如下。</p><pre><code class="lang-js">/* 路由的使用方式 */
// 引入 Express
const express = require(&#39;express&#39;);

// 创建服务
const app = express();

// 创建路由
app.get(&#39;/&#39;, function (req, res) {
  res.end(&#39;home&#39;);
});

app.post(&#39;/about&#39;, function (req, res) {
  res.end(&#39;about&#39;);
});

app.all(&#39;*&#39;, function (req, res) {
  res.end(&#39;Not Found&#39;);
});

// 监听服务
app.listen(3000);
</code></pre><p>如果启动上面的服务，通过浏览器访问定义的路由时可以匹配到 <code>app.get</code>、<code>app.post</code> 或 <code>app.all</code> 并执行回调，但其实我们可以发现这些方法的名字是与请求类型严格对应的，不仅仅这几个，下面来看看实现路由的核心逻辑（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// ************************** 以下为新增代码 **************************
// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
// ************************** 以上为新增代码 **************************

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
// ************************** 以下为新增代码 **************************
    // 获取方法名统一转换成小写
    const method = req.method.toLowerCase();

    // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
    const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

    // 循环匹配路径
    for (let i = 0; i &lt; app.routes.lenth; i++) {
      // 循环取得每一层
      const layer = app.routes[i];

      // 如果说路径和请求类型都能匹配，则执行该路由层的回调
      if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
        return layer.hanlder(req, res);
      }
    }

    // 如果都没有匹配上，则响应错误信息
    res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath);
// ************************** 以上为新增代码 **************************
  }

// ************************** 以下为新增代码 **************************
  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);
// ************************** 以上为新增代码 **************************

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p>我们的逻辑大体可以分为两个部分，路由方法的创建以及路由的匹配，首先是路由方法的创建阶段，每一个方法的内部所做的事情就是将路由的路径、请求方式和回调函数作为对象的属性，并将对象存入一个数组中统一管理，所以我们创建了 <code>app.routes</code> 数组用来存储这些路由对象。</p><p>方法名对应请求类型，请类型有很多，我们不会一一的创建每一个方法，所以选择引入专门存储请求类型名称的 <code>methods</code> 模块，其实路由方法逻辑相同，我们封装了 <code>createRouteMethod</code> 方法用来生成不同路由方法的函数体，之所以这样做是因为有个特殊的路由方法 <code>app.all</code>，导致请求类型有差别，其他的可以从 <code>methods</code> 中取，<code>app.all</code> 我们定义类型为 <code>all</code> 通过 <code>createRouteMethod</code> 函数的参数传入。</p><p>接着就是循环 <code>methods</code> 调用 <code>createRouteMethod</code> 函数创建路由方法，并单独创建 <code>app.all</code> 方法。</p><p>路由匹配阶段实在函数 <code>app</code> 内完成的，因为启动服务接收到请求时会执行 <code>createServer</code> 中的回调，即执行 <code>app</code>，先通过原生自带的 <code>req.method</code> 取出请求方式并处理成小写，通过 <code>req.path</code> 取出完整路径并分成路由名和查询字符串两个部分。</p><p>循环 <code>app.routes</code> 用取到请求的类型和路由名称匹配，两者都相等则执行对应路由对象上的回调函数，在判断条件中，请求方式兼容了我们之前定义的 <code>all</code>，为了所有的请求类型只要路由匹配都可以执行 <code>app.all</code> 的回调，请求路径兼容了 <code>*</code>，因为如果某个路由方法定义的路径为 <code>*</code>，则任意路由都可以执行这个路由对象上的回调。</p><h2 id="扩展请求对象属性"><a href="#扩展请求对象属性" class="headerlink" title="扩展请求对象属性"></a>扩展请求对象属性</h2><p>且在路由内部可以通过 <code>req</code> 访问一些原生没有的属性如 <code>req.path</code>、<code>req.query</code>、<code>req.host</code> 和 <code>req.params</code>，这说明 <code>Express</code> 在实现的过程中对 <code>req</code> 进行了处理。</p><pre><code class="lang-js">/* req 属性的使用 */
// 引入 Express
const express = require(&#39;express&#39;);

// 创建服务
const app = express();

// 创建路由
app.get(&#39;/&#39;, function (req, res) {
  console.log(req.path);
  console.log(req.query);
  console.log(req.host);
  res.end(&#39;home&#39;);
});

app.get(&#39;/about/:id/:name&#39;, function (req, res) {
  console.log(req.params);
  res.end(&#39;about&#39;);
});

// 监听服务
app.listen(3000);
</code></pre><p>在上面的使用中我们写了两个路由，分别打印了原生所不具备而 <code>Express</code> 帮我们处理并新增的属性，下面我们就来在之前自己实现的 <code>express.js</code> 的基础上增加这些属性（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);

// ************************** 以下为新增代码 **************************
const querystring = require(&#39;querystring&#39;);
// ************************** 以上为新增代码 **************************

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
    // 获取方法名统一转换成小写
    const method = req.method.toLowerCase();

    // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
    const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

// *************************** 以下为修改代码 **************************
    // 将路径名赋值给 req.path
    req.path = reqPath;
    // 将查询字符串转换成对象赋值给 req.query
    req.query = querystring.parse(query);
    // 将主机名赋值给 req.host
    req.host = req.headers.host.split(&#39;:&#39;)[0];

    // 循环匹配路径
    for (let i = 0; i &lt; app.routes.lenth; i++) {
      // 循环取得每一层
      const layer = app.routes[i];

      // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
      if (layer.regexp) {
        // 使用路径配置的正则匹配请求路径
        const result = pathname.match(layer.regexp);

        // 如果匹配到结果且请求方式匹配
        if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
          // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
          req.params = layer.paramNames.reduce(function (memo, key, index) {
            memo[key] = result[index + 1];
            return memo;
          }, {});

          // 执行对应的回调
          return layer.hanlder(req, res);
        }
      } else {
        // 如果说路径和请求类型都能匹配，则执行该路由层的回调
        if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
          return layer.hanlder(req, res);
        }
      }
// ************************** 以上为修改代码 **************************
    }

    // 如果都没有匹配上，则响应错误信息
    res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath);
  }

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

// ************************** 以下为新增代码 **************************
      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
      if (pathname.indexOf(&#39;:&#39;) !== -1) {
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }
// ************************** 以上为新增代码 **************************

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p>上面代码有些长，我们一点一点分析，首先是 <code>req.path</code>，就是我们浏览器地址栏里查询字符串前的路径，值其实就是我们之前从 <code>req.url</code> 中解构出来的 <code>pathname</code>，我们只需要将 <code>pathname</code> 赋值给 <code>req.path</code> 即可。</p><p><code>req.query</code> 是浏览器地址栏的查询字符串传递的参数，就是我们从 <code>req.url</code> 解构出来的查询字符串，借助 <code>querystring</code> 模块将查询字符串处理成对象赋值给 <code>req.query</code> 即可。</p><p><code>req.host</code> 是访问的主机名，请求头中的 <code>host</code> 包含了主机名和端口号，我们只要截取出前半部分赋值给 <code>req.host</code> 即可。</p><p>最复杂的是 <code>req.params</code> 的实现，大概分为两个步骤，首先是在路由方法创建时需要检查定义的路由是否含有路由参数，如果有则取出参数的键存入数组 <code>paramNames</code> 中，然后创建一个匹配路由参数的正则，通过 <code>replace</code> 实现正则字符串的创建，再通过 <code>RegExp</code> 构造函数来创建正则，并挂在路由对象上，之所以使用 <code>replace</code> 是因为创建的规则内的分组要和路由参数的个数是相同的，我们将这些逻辑完善进了 <code>createRouteMethod</code> 函数中。</p><h2 id="实现响应方法-send-和-sendFile"><a href="#实现响应方法-send-和-sendFile" class="headerlink" title="实现响应方法 send 和 sendFile"></a>实现响应方法 send 和 sendFile</h2><p>之前的例子中我们都是用原生的 <code>end</code> 方法响应浏览器，我们知道 <code>end</code> 方法只能接收字符串和 <code>Buffer</code> 作为响应的值，非常不方便，其实在 <code>Express</code> 中封装了一个 <code>send</code> 方法挂在 <code>res</code> 对象下，可以接收数组、对象、字符串、<code>Buffer</code>、数字处理后响应给浏览器，在 <code>Express</code> 内部同样封装了一个 <code>sendFile</code> 方法用于读取请求的文件。</p><pre><code class="lang-js">/* send 响应 */
// 引入 Express
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

// 创建服务
const app = express();

// 创建路由
app.get(&#39;/&#39;, function (req, res) {
  res.send({ name: &#39;panda&#39;, age: 28 });
});

app.get(&#39;/test.txt&#39;, function (req, res) {
  // 必须传入绝对路径
  res.sendFile(path.join(__dirname, req.path));
});

// 监听服务
app.listen(3000);
</code></pre><p>通过我们的分析，封装的 <code>send</code> 方法应该是将 <code>end</code> 不支持的类型数据转换成了字符串，在内部再次调用 <code>end</code>，而 <code>sendFile</code> 方法规定参数必须为绝对路径，内部实现应该是利用可读流读取文件内容相应给浏览器，下面是两个方法的实现（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
const querystring = require(&#39;querystring&#39;);

// ************************** 以下为新增代码 **************************
const util = require(&#39;util&#39;);
const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息
const fs = require(&#39;fs&#39;);
// ************************** 以上为新增代码 **************************

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
    // 获取方法名统一转换成小写
    const method = req.method.toLowerCase();

    // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
    const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

    // 将路径名赋值给 req.path
    req.path = reqPath;
    // 将查询字符串转换成对象赋值给 req.query
    req.query = querystring.parse(query);
    // 将主机名赋值给 req.host
    req.host = req.headers.host.split(&#39;:&#39;)[0];

// ************************** 以下为新增代码 **************************
    // 响应方法
    res.send = function (params) {
      // 设置响应头
      res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);

      // 检测传入值得数据类型
      switch (typeof params) {
        case &#39;object&#39;:
          res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);

          // 将任意类型的对象转换成字符串
          params = util.inspect(params);
          break;
        case &#39;number&#39;:
          // 数字则直接取出状态吗对应的名字返回
          params = httpServer.STATUS_CODES[params];
          break;
        default:
          break;
      }

      // 响应
      res.end(params);
    }

    // 响应文件方法
    res.sendFile = function (pathname) {
      fs.createReadStream(pathname).pipe(res);
    }
// ************************** 以上为新增代码 **************************

    // 循环匹配路径
    for (let i = 0; i &lt; app.routes.lenth; i++) {
      // 循环取得每一层
      const layer = app.routes[i];

      // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
      if (layer.regexp) {
        // 使用路径配置的正则匹配请求路径
        const result = reqPath.match(layer.regexp);

        // 如果匹配到结果且请求方式匹配
        if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
          // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
          req.params = layer.paramNames.reduce(function (memo, key, index) {
            memo[key] = result[index + 1];
            return memo;
          }, {});

          // 执行对应的回调
          return layer.hanlder(req, res);
        }
      } else {
        // 如果说路径和请求类型都能匹配，则执行该路由层的回调
        if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
          return layer.hanlder(req, res);
        }
      }
    }

      // 如果都没有匹配上，则响应错误信息
    res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath);
  }

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
      if (pathname.indexOf(&#39;:&#39;) !== -1) {
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p>有一点需要注意，在 <code>Node</code> 环境中想把任何对象类型转换成字符串应该使用 <code>util.inspect</code> 方法，而当 <code>send</code> 方法输入数字类型时，要返回对应状态码的名称，可通过 <code>_http_server</code> 模块的 <code>STATUS_CODES</code> 对象获取。</p><h2 id="内置中间件的实现"><a href="#内置中间件的实现" class="headerlink" title="内置中间件的实现"></a>内置中间件的实现</h2><p><code>Express</code> 最大的特点就是中间件机制，中间件就是用来处理请求的函数，用来完成不同场景的请求处理，一个中间件处理完请求后可以再传递给下一个中间件，具有回调函数 <code>next</code>，不执行 <code>next</code> 则会卡在一个位置，调用 <code>next</code> 则继续向下传递。</p><pre><code class="lang-js">/* use 的使用 */
// 引入 Express
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

// 创建服务
const app = express();

// 创建路由
app.use(function (req, res, next) {
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
  next();
});

// 创建路由
app.get(&#39;/&#39;, function (req, res) {
  res.send({ name: &#39;panda&#39;, age: 28 });
});

// 监听服务
app.listen(3000);
</code></pre><p>在上面代码中使用 <code>use</code> 方法执行了传入的回调函数，实现公共逻辑，起到了中间件的作用，调用回调参数的 <code>next</code> 方法向下继续执行，下面来实现 <code>use</code> 方法（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
const querystring = require(&#39;querystring&#39;);
const util = require(&#39;util&#39;);
const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息
const fs = require(&#39;fs&#39;);

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
// ************************** 以下为修改代码 **************************
    // 循环匹配路径
    let index = 0;

    function next(err) {
      // 获取第一个回调函数
      const layer = app.routes[index++];

      if (layer) {
        // 将当前中间件函数的属性解构出来
        const { method, pathname, handler } = layer;

        if (err) { // 如果存在错误将错误交给错误处理中间件，否则
          if (method === &#39;middle&#39;, handle.length === 4) {
            return hanlder(err, req, res, next);
          } else {
            next(err);
          }
        } else { // 如果不存在错误则继续向下执行
          // 判断是中间件还是路由
          if (method === &#39;middle&#39;) {
            // 匹配路径判断
            if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) {
              handler(req, res, next);
            } else {
              next();
            }
          } else {
            // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
            if (layer.regexp) {
              // 使用路径配置的正则匹配请求路径
              const result = req.path.match(layer.regexp);

              // 如果匹配到结果且请求方式匹配
              if (result &amp;&amp; ( method === layer.method || layer.method === &#39;all&#39;)) {
                // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
                req.params = layer.paramNames.reduce(function (memo, key, index ) {
                  memo[key] = result[index + 1];
                  return memo;
                }, {});

                // 执行对应的回调
                return layer.hanlder(req, res);
              } else {
                next();
              }
            } else {
              // 如果说路径和请求类型都能匹配，则执行该路由层的回调
              if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                return layer.hanlder(req, res);
              } else {
                next();
              }
            }
          }
        }
      } else {
        // 如果都没有匹配上，则响应错误信息
        res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; req.path);
      }
    }

    next();
// ************************** 以上为修改代码 **************************
  }

// ************************** 以下为新增代码 **************************
  function init() {
    return function (req, res, next) {
      // 获取方法名统一转换成小写
      const method = req.method.toLowerCase();

      // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
      const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

      // 将路径名赋值给 req.path
      req.path = reqPath;
      // 将查询字符串转换成对象赋值给 req.query
      req.query = querystring.parse(query);
      // 将主机名赋值给 req.host
      req.host = req.headers.host.split(&#39;:&#39;)[0];

      // 响应方法
      res.send = function (params) {
        // 设置响应头
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);

        // 检测传入值得数据类型
        switch (typeof params) {
          case &#39;object&#39;:
            res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);

            // 将任意类型的对象转换成字符串
            params = util.inspect(params);
            break;
          case &#39;number&#39;:
            // 数字则直接取出状态吗对应的名字返回
            params = httpServer.STATUS_CODES[params];
            break;
          default:
            break;
        }

        // 响应
        res.end(params);
      }

      // 响应文件方法
      res.sendFile = function (pathname) {
        fs.createReadStream(pathname).pipe(res);
      }

      // 向下执行
      next();
    }
  }
// ************************** 以上为新增代码 **************************

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

    // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
// ************************** 以下为修改代码 **************************
      if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) {
// ************************** 以上为修改代码 **************************
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

// ************************** 以下为新增代码 **************************
  // 添加中间件方法
  app.use = function (pathname, handler) {
    // 处理没有传入路径的情况
    if (typeof handler !== &#39;function&#39;) {
      handler = pathname;
      pathname = &#39;/&#39;;
    }

    // 生成函数并执行
    createRouteMethod(&#39;middle&#39;)(pathname, handler);
  }

  // 将初始逻辑作为中间件执行
  app.use(init());
// ************************** 以上为新增代码 **************************

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p><code>use</code> 方法第一个参数为路径，与路由相同，不传默认为 <code>/</code>，如果不传所有的路径都会经过该中间件，如果传入指定的值，则匹配后的请求才会通过该中间件。</p><p>中间件的执行可能存在异步的情况，但之前匹配路径使用的是 <code>for</code> 循环同步匹配，我们将其修改为异步并把路由匹配的逻辑与中间件路径匹配的逻辑进行了整合，并创建了 <code>use</code> 方法，对是否传了第一个参数做了一个兼容，其他将带有请求方式、路径和回调的逻辑统一使用 <code>createRouteMethod</code> 方法创建，并传入 <code>middle</code> 类型，<code>createRouteMethod</code> 中路由参数匹配的逻辑对 <code>middle</code> 类型做了一个排除。</p><p>使用 <code>Express</code> 中间件调用 <code>next</code> 方法时，不传递参数和参数为 <code>null</code> 代表执行成功，如果传入了其他的参数，表示执行出错，会跳过所有正常的中间件和路由，直接交给错误处理中间件处理，并将 <code>next</code> 传入的参数作为错误处理中间件回调函数的第一个参数 <code>err</code>，后面三个参数分别为 <code>req</code>、<code>res</code> 和 <code>next</code>。</p><p>代码种创建了 <code>index</code> 变量，默认调用了一次 <code>next</code> 方法，每次然后取出数组 <code>app.routes</code> 中的路由对象的回调函数执行，并在内部执行 <code>handler</code>，而 <code>handler</code> 回调中又调用了 <code>next</code> 方法，就这样将整个中间件和路由的回调串联起来。</p><p>我们发现在第一次调用 <code>next</code> 之前的所有逻辑，如给 <code>req</code> 添加属性，给 <code>res</code> 添加方法，都是公共逻辑，是任何中间件和路由在匹配之前都会执行的逻辑，我们既然有了中间件方法 <code>app.user</code>，可以将这些逻辑抽取出来作为一个单独的中间件回调函数执行，所以创建了 <code>init</code> 函数，内部返回了一个函数作为回调函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，并在<code>init</code> 调用返回的函数内部调用 <code>next</code> 向下执行。</p><h2 id="内置模板引擎的实现"><a href="#内置模板引擎的实现" class="headerlink" title="内置模板引擎的实现"></a>内置模板引擎的实现</h2><p>在 <code>Express</code> 框架中内置支持了 <code>ejs</code>、<code>jade</code> 等模板，使用方法 “三部曲” 如下。</p><pre><code class="lang-js">/* 模板的使用 */
// 引入 Express
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

// 创建服务
const app = express();

// 1、指定模板引擎，其实就是模板文件的后缀名
app.set(&#39;view engine&#39;, &#39;ejs&#39;);

// 2、指定模板的存放根目录
app.set(&#39;views&#39;, path.resolve(__dirname, &#39;views&#39;));

// 3、如果要自定义模板后缀和函数的关系
app.engine(&#39;.html&#39;, require(&#39;./ejs&#39;).__express);

// 创建路由
app.get(&#39;/user&#39;, function (req, res) {
  //使用指定的模板引擎渲染 user 模板
  res.render(&#39;user&#39;, { title: &#39;用户管理&#39; });
});

// 监听服务
app.listen(3000);
</code></pre><p>上面将模板根目录设置为 <code>views</code> 文件夹，并规定了模板类型为 <code>ejs</code>，可以同时给多种模板设置，并不冲突，如果需要将其他后缀名的模板按照另一种模板的渲染引擎渲染则使用 <code>app.engine</code> 进行设置，下面看一下实现代码（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
const querystring = require(&#39;querystring&#39;);
const util = require(&#39;util&#39;);
const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息
const fs = require(&#39;fs&#39;);

// ************************** 以下为新增代码 **************************
const path = require(&#39;path&#39;);
// ************************** 以上为新增代码 **************************

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
    // 循环匹配路径
    let index = 0;

    function next(err) {
      // 获取第一个回调函数
      const layer = app.routes[index++];

      if (layer) {
        // 将当前中间件函数的属性解构出来
        const { method, pathname, handler } = layer;

        if (err) { // 如果存在错误将错误交给错误处理中间件，否则
          if (method === &#39;middle&#39;, handle.length === 4) {
            return hanlder(err, req, res, next);
          } else {
            next(err);
          }
        } else { // 如果不存在错误则继续向下执行
          // 判断是中间件还是路由
          if (method === &#39;middle&#39;) {
              // 匹配路径判断
              if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) {
                handler(req, res, next);
              } else {
                next();
              }
          } else {
            // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
            if (layer.regexp) {
              // 使用路径配置的正则匹配请求路径
              const result = req.path.match(layer.regexp);

              // 如果匹配到结果且请求方式匹配
              if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
                req.params = layer.paramNames.reduce(function (memo, key, index) {
                  memo[key] = result[index + 1];
                  return memo;
                }, {});

                // 执行对应的回调
                return layer.hanlder(req, res);
              } else {
                next();
              }
            } else {
              // 如果说路径和请求类型都能匹配，则执行该路由层的回调
              if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                return layer.hanlder(req, res);
              } else {
                next();
              }
            }
          }
        }
      } else {
        // 如果都没有匹配上，则响应错误信息
        res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + req.path);
      }
    }

    next();
  }

  function init() {
    return function (req, res, next) {
      // 获取方法名统一转换成小写
      const method = req.method.toLowerCase();

      // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
      const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

      // 将路径名赋值给 req.path
      req.path = reqPath;
      // 将查询字符串转换成对象赋值给 req.query
      req.query = querystring.parse(query);
      // 将主机名赋值给 req.host
      req.host = req.headers.host.split(&#39;:&#39;)[0];

      // 响应方法
      res.send = function (params) {
        // 设置响应头
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);

        // 检测传入值得数据类型
        switch (typeof params) {
          case &#39;object&#39;:
            res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);

            // 将任意类型的对象转换成字符串
            params = util.inspect(params);
            break;
          case &#39;number&#39;:
            // 数字则直接取出状态吗对应的名字返回
            params = httpServer.STATUS_CODES[params];
            break;
          default:
            break;
        }

        // 响应
        res.end(params);
      }

      // 响应文件方法
      res.sendFile = function (pathname) {
        fs.createReadStream(pathname).pipe(res);
      }

// ************************** 以下为新增代码 **************************
      // 模板渲染方法
      res.render = function (filename, data) {
        // 将文件名和模板路径拼接
        let filepath = path.join(app.get(&#39;views&#39;), filename);

        // 获取扩展名
        let extname = path.extname(filename.split(path.sep).pop());

        // 如果没有扩展名，则使用默认的扩展名
        if (!extname) {
          extname = &#39;.&#39; + app.get(&#39;view engine&#39;)
          filepath += extname;
        }

        // 读取模板文件并使用渲染引擎相应给浏览器
        app.engines[extname](filepath, data, function (err, html) {
          res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
          res.end(html);
        });
      }
// ************************** 以上为新增代码 **************************

      // 向下执行
      next();
    }
  }

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
// ************************** 以下为修改代码 **************************
      // 满足条件说明是取值方法
      if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) {
        return app.settings[pathname];
      }
// ************************** 以上为修改代码 **************************

      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
      if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) {
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

  // 添加中间件方法
  app.use = function (pathname, handler) {
    // 处理没有传入路径的情况
    if (typeof handler !== &#39;function&#39;) {
      handler = pathname;
      pathname = &#39;/&#39;;
    }

    // 生成函数并执行
    createRouteMethod(&#39;middle&#39;)(pathname, handler);
  }

  // 将初始逻辑作为中间件执行
  app.use(init());

// ************************** 以下为新增代码 **************************
  // 存储设置的对象
  app.setting ={};

  // 存储模板渲染方法
  app.engines = {};

  // 添加设置的方法
  app.set = function (key, value) {
    app.use[key] = value;
  }

  // 添加渲染引擎的方法
  app.engine = function (ext, renderFile) {
    app.engines[ext] = renderFile;
  }
// ************************** 以上为新增代码 **************************

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

module.exports = createApplication;
</code></pre><p>在上面新增代码中设置了两个缓存 <code>settings</code> 和 <code>engines</code>，前者用来存储模板相关的设置，如渲染成什么类型的文件、读取模板文件的根目录，后者用来存储渲染引擎，即渲染模板的方法，这所以设置这两个缓存对象是为了实现 <code>Express</code> 多种不同模板共存的功能，可以根据需要进行设置和使用，而设置的方法分别为 <code>app.set</code> 和 <code>app.engine</code>，有设置值的方法就应该有取值的方法，但是 <code>app.get</code> 方法已经被设置为路由方法了，为了语义我们在 <code>app.get</code> 方法逻辑中进行了兼容，当参数为 <code>1</code> 个时，从 <code>settings</code> 中取值并返回，否则执行添加路由方法的逻辑。</p><p>之前都是准备工作，在使用时无论是中间件还是路由中都是靠调用 <code>res.render</code> 方法并传入模板路径和渲染数据来真正实现渲染和响应的，<code>render</code> 方法是在 <code>init</code> 函数初始化时就挂在了 <code>res</code> 上，核心逻辑是取出传入的模板文件后缀名，如果存在则使用后缀名，将文件名与默认读取模板的文件夹路径拼接传递给设置的渲染引擎的渲染方法，如果不存在后缀名则默认拼接 <code>.html</code> 当作后缀名，再与默认读取模板路径进行拼接，在渲染函数的回调中将渲染引擎渲染的模板字符串响应给浏览器。</p><h2 id="内置静态资源中间件的实现"><a href="#内置静态资源中间件的实现" class="headerlink" title="内置静态资源中间件的实现"></a>内置静态资源中间件的实现</h2><p>在 <code>Express</code> 内部可以通过路由处理静态文件，但是如果可能请求多个文件不可能一个文件对应一个路由，因此 <code>Express</code> 内部实现了静态文件中间件，使用如下。</p><pre><code class="lang-js">/* 静态文件中间件的使用 */
// 引入 Express
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

// 创建服务
const app = express();

// 使用处理静态文件中间件
app.use(express.static(path.resolve(__dirname, &#39;public&#39;)));

// 监听服务
app.listen(3000);
</code></pre><p>从上面使用可以看出，<code>express.static</code> 是一个函数，执行的时候传入了一个参数，为默认查找文件的根路径，而添加中间件的 <code>app.use</code> 方法传入的参数正好是回调函数，这说明 <code>express.static</code> 方法需要返回一个函数，形参为 <code>req</code>、<code>res</code> 和 <code>next</code>，通过调用方式我们能看出 <code>static</code> 是静态方法，挂在了模块返回的函数上，实现代码如下（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
const querystring = require(&#39;querystring&#39;);
const util = require(&#39;util&#39;);
const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// ************************** 以下为新增代码 **************************
const mime = require(&#39;mime&#39;);
// ************************** 以上为新增代码 **************************

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
    // 循环匹配路径
    let index = 0;

    function next(err) {
      // 获取第一个回调函数
      const layer = app.routes[index++];

      if (layer) {
        // 将当前中间件函数的属性解构出来
        const { method, pathname, handler } = layer;

        if (err) { // 如果存在错误将错误交给错误处理中间件，否则
          if (method === &#39;middle&#39;, handle.length === 4) {
            return hanlder(err, req, res, next);
          } else {
            next(err);
          }
        } else { // 如果不存在错误则继续向下执行
          // 判断是中间件还是路由
          if (method === &#39;middle&#39;) {
            // 匹配路径判断
            if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) {
              handler(req, res, next);
            } else {
              next();
            }
          } else {
            // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
            if (layer.regexp) {
              // 使用路径配置的正则匹配请求路径
              const result = req.path.match(layer.regexp);

              // 如果匹配到结果且请求方式匹配
              if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
                req.params = layer.paramNames.reduce(function (memo, key, index) {
                  memo[key] = result[index + 1];
                  return memo;
                }, {});

                // 执行对应的回调
                return layer.hanlder(req, res);
              } else {
                next();
              }
            } else {
              // 如果说路径和请求类型都能匹配，则执行该路由层的回调
              if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                return layer.hanlder(req, res);
              } else {
                next();
              }
            }
          }
        }
      } else {
        // 如果都没有匹配上，则响应错误信息
        res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + req.path);
      }
    }

    next();
  }

  function init() {
    return function (req, res, next) {
      // 获取方法名统一转换成小写
      const method = req.method.toLowerCase();

      // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
      const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

      // 将路径名赋值给 req.path
      req.path = reqPath;
      // 将查询字符串转换成对象赋值给 req.query
      req.query = querystring.parse(query);
      // 将主机名赋值给 req.host
      req.host = req.headers.host.split(&#39;:&#39;)[0];

      // 响应方法
      res.send = function (params) {
        // 设置响应头
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);

        // 检测传入值得数据类型
        switch (typeof params) {
          case &#39;object&#39;:
            res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);
            // 将任意类型的对象转换成字符串
            params = util.inspect(params);
            break;
          case &#39;number&#39;:
            // 数字则直接取出状态吗对应的名字返回
            params = httpServer.STATUS_CODES[params];
            break;
          default:
            break;
        }

        // 响应
        res.end(params);
      }

      // 响应文件方法
      res.sendFile = function (pathname) {
        fs.createReadStream(pathname).pipe(res);
      }

      // 模板渲染方法
      res.render = function (filename, data) {
        // 将文件名和模板路径拼接
        let filepath = path.join(app.get(&#39;views&#39;), filename);

        // 获取扩展名
        let extname = path.extname(filename.split(path.sep).pop());

        // 如果没有扩展名，则使用默认的扩展名
        if (!extname) {
          extname = &#39;.&#39; + app.get(&#39;view engine&#39;)}
          filepath += extname;
        }

        // 读取模板文件并使用渲染引擎相应给浏览器
        app.engines[extname](filepath, data, function (err, html) {
          res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
          res.end(html);
        });
      }

      // 向下执行
      next();
    }
  }

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      // 满足条件说明是取值方法
      if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) {
        return app.settings[pathname];
      }

      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
      if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) {
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

  // 添加中间件方法
  app.use = function (pathname, handler) {
    // 处理没有传入路径的情况
    if (typeof handler !== &#39;function&#39;) {
      handler = pathname;
      pathname = &#39;/&#39;;
    }

    // 生成函数并执行
    createRouteMethod(&#39;middle&#39;)(pathname, handler);
  }

  // 将初始逻辑作为中间件执行
  app.use(init());

  // 存储设置的对象
  app.setting ={};

  // 存储模板渲染方法
  app.engines = {};

  // 添加设置的方法
  app.set = function (key, value) {
    app.use[key] = value;
  }

  // 添加渲染引擎的方法
  app.engine = function (ext, renderFile) {
    app.engines[ext] = renderFile;
  }

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

// ************************** 以下为新增代码 **************************
createApplication.static = function (staticRoot) {
  return function (req, res, next) {
    // 获取文件的完整路径
    const filename = path.join(staticRoot, req.path);

    // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应
    fs.access(filename, function (err) {
      if (err) {
        next();
      } else {
        // 设置响应头类型和响应文件内容
        res.setHeader(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;);
        fs.createReadStream(filename).pipe(res);
      }
    });
  }
}
// ************************** 以上为新增代码 **************************

module.exports = createApplication;
</code></pre><p>这个方法的核心逻辑是获取文件的路径，检查文件的权限，如果没有权限，则调用 <code>next</code> 交给其他中间件，这里注意的是 <code>err</code> 错误对象不要传递给 <code>next</code>，因为后面的中间件还要执行，如果传递后会直接执行错误处理中间件，有权限的情况下就正常读取文件内容，给 <code>Content-Type</code> 响应头设置文件类型，并将文件的可读流通过 <code>pipe</code> 方法传递给可写流 <code>res</code>，即响应给浏览器。</p><h2 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h2><p>在 <code>Express</code> 中有一个功能在我们匹配到的某一个路由中调用可以直接跳转到另一个路由，即 <code>302</code> 重定向。</p><pre><code class="lang-js">/* 使用重定向 */
// 引入 Express
const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

// 创建服务
const app = express();

// 创建路由
app.get(&#39;/user&#39;, function (req, res, next) {
  res.end(&#39;user&#39;);
});

app.get(&#39;/detail&#39;, function (req, res, next) {
  // 访问 /detail 重定向到 /user
  res.redirect(&#39;/user&#39;);
});

// 监听服务
app.listen(3000);
</code></pre><p>看到上面的使用方式，我们根据前面的套路知道是 <code>Express</code> 在 <code>res</code> 对象上给挂载了一个 <code>redirect</code> 方法，参数为状态码（可选）和要跳转路由的路径，并且这个方法应该在 <code>init</code> 函数调用时挂在 <code>res</code> 上的，下面是实现的代码（直接找到星号提示新增或修改位置即可）。</p><pre><code class="lang-js">/* 文件：express.js */
const http = require(&#39;http&#39;);

// methods 模块返回存储所有请求方法名称的数组
const methods = require(&#39;methods&#39;);
const querystring = require(&#39;querystring&#39;);
const util = require(&#39;util&#39;);
const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const mime = require(&#39;mime&#39;);

function createApplication() {
  // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理
  const app = function (req, res) {
    // 循环匹配路径
    let index = 0;

    function next(err) {
      // 获取第一个回调函数
      const layer = app.routes[index++];

      if (layer) {
        // 将当前中间件函数的属性解构出来
        const { method, pathname, handler } = layer;

        if (err) { // 如果存在错误将错误交给错误处理中间件，否则
          if (method === &#39;middle&#39;, handle.length === 4) {
            return hanlder(err, req, res, next);
          } else {
            next(err);
          }
        } else { // 如果不存在错误则继续向下执行
          // 判断是中间件还是路由
          if (method === &#39;middle&#39;) {
            // 匹配路径判断
            if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) {
              handler(req, res, next);
            } else {
              next();
            }
          } else {
            // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型
            if (layer.regexp) {
              // 使用路径配置的正则匹配请求路径
              const result = req.path.match(layer.regexp);

              // 如果匹配到结果且请求方式匹配
              if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象
                req.params = layer.paramNames.reduce(function (memo, key, index) {
                  memo[key] = result[index + 1];
                  return memo;
                }, {});

                // 执行对应的回调
                return layer.hanlder(req, res);
              } else {
                next();
              }
            } else {
              // 如果说路径和请求类型都能匹配，则执行该路由层的回调
              if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) {
                return layer.hanlder(req, res);
              } else {
                next();
              }
            }
          }
        }
      } else {
        // 如果都没有匹配上，则响应错误信息
        res.end(&#39;CANNOT &#39; + req.method} + &#39;&#39; + req.path);
      }
    }

    next();
  }

  function init() {
    return function (req, res, next) {
      // 获取方法名统一转换成小写
      const method = req.method.toLowerCase();

      // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2
      const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;);

      // 将路径名赋值给 req.path
      req.path = reqPath;
      // 将查询字符串转换成对象赋值给 req.query
      req.query = querystring.parse(query);
      // 将主机名赋值给 req.host
      req.host = req.headers.host.split(&#39;:&#39;)[0];

      // 响应方法
      res.send = function (params) {
        // 设置响应头
        res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;);

        // 检测传入值得数据类型
        switch (typeof params) {
          case &#39;object&#39;:
            res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;);

            // 将任意类型的对象转换成字符串
            params = util.inspect(params);
            break;
          case &#39;number&#39;:
            // 数字则直接取出状态吗对应的名字返回
            params = httpServer.STATUS_CODES[params];
            break;
          default:
            break;
        }

        // 响应
        res.end(params);
      }

      // 响应文件方法
      res.sendFile = function (pathname) {
        fs.createReadStream(pathname).pipe(res);
      }

      // 模板渲染方法
      res.render = function (filename, data) {
        // 将文件名和模板路径拼接
        let filepath = path.join(app.get(&#39;views&#39;), filename);

        // 获取扩展名
        let extname = path.extname(filename.split(path.sep).pop());

        // 如果没有扩展名，则使用默认的扩展名
        if (!extname) {
          extname = &#39;.&#39; + app.get(&#39;view engine&#39;)
          filepath += extname;
        }

        // 读取模板文件并使用渲染引擎相应给浏览器
        app.engines[extname](filepath, data, function (err, html) {
          res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
          res.end(html);
        });
      }

// ************************** 以下为新增代码 **************************
      // 重定向方法
      res.redirect = function (status, target) {
        // 如果第一个参数是字符串类型说明没有传状态码
        if (typeof status === &#39;string&#39;) {
          // 将第二个参数（重定向的目标路径）设置给 target
          target = status;

          // 再把状态码设置成 302
          status = 302;
        }

        // 响应状态码，设置重定向响应头
        res.statusCode = status;
        res.setHeader(&#39;Location&#39;, target);
        res.end();
      }
// ************************** 以上为新增代码 **************************

      // 向下执行
      next();
    }
  }

  // 存储路由层的请求类型、路径和回调
  app.routes = [];

  // 返回一个函数体用于将路由层存入 app.routes 中
  function createRouteMethod(method) {
    return function (pathname, handler) {
      // 满足条件说明是取值方法
      if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) {
        return app.settings[pathname];
      }

      const layer = {
        method,
        pathname, // 不包含查询字符串
        handler
      };

      // 如果含有路由参数，如 /xxx/:aa/:bb
      // 取出路由参数的键 aa bb 存入数组并挂在路由对象上
      // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上
      if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) {
        const paramNames = []; // 存储路由参数

        // 将路由参数取出存入数组，并返回正则字符串
        const regStr = pathname.replace(/:(\w+)/g, function (matched, attr) {
          paramNames.push(attr);
          return &#39;(\\w+)&#39;;
        });

        const regexp = new RegExp(regStr); // 生成正则类型
        layer.regexp = regexp; // 将正则挂在路由对象上
        layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上
      }

      // 把这一层放入存储所有路由层信息的数组中
      app.routes.push(layer);
    }
  }

  // 循环构建所有路由方法，如 app.get app.post 等
  methods.forEach(function (method) {
    // 匹配路由的 get 方法
    app[method] = createRouteMethod(method);
  });

  // all 方法，通吃所有请求类型
  app.all = createRouteMethod(&#39;all&#39;);

  // 添加中间件方法
  app.use = function (pathname, handler) {
    // 处理没有传入路径的情况
    if (typeof handler !== &#39;function&#39;) {
      handler = pathname;
      pathname = &#39;/&#39;;
    }

    // 生成函数并执行
    createRouteMethod(&#39;middle&#39;)(pathname, handler);
  }

  // 将初始逻辑作为中间件执行
  app.use(init());

  // 存储设置的对象
  app.setting ={};

  // 存储模板渲染方法
  app.engines = {};

  // 添加设置的方法
  app.set = function (key, value) {
    app.use[key] = value;
  }

  // 添加渲染引擎的方法
  app.engine = function (ext, renderFile) {
    app.engines[ext] = renderFile;
  }

  // 启动服务的 listen 方法
  app.listen = function () {
    // 创建服务器
    const server = http.createServer(app);

    // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调
    server.listen(...arguments);
  }

  // 返回 app
  return app;
}

createApplication.static = function (staticRoot) {
  return function (req, res, next) {
    // 获取文件的完整路径
    const filename = path.join(staticRoot, req.path);

    // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应
    fs.access(filename, function (err) {
      if (err) {
        next();
      } else {
        // 设置响应头类型和响应文件内容
        res.setHeader(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;);
        fs.createReadStream(filename).pipe(res);
      }
    });
  }
}

module.exports = createApplication;
</code></pre><p>其实 <code>res.redirect</code> 方法的核心逻辑就是处理参数，如果没有传状态码的时候将参数设置给 <code>target</code>，将状态码设置为 <code>302</code>，并设置重定向响应头 <code>Location</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>到此为止 <code>Express</code> 的大部分内置功能就都简易的实现了，由于 <code>Express</code> 内部的封装思想，以及代码复杂、紧密的特点，各个功能代码很难单独拆分，总结一下就是很难表述清楚，只能通过大量代码来堆砌，好在每一部分实现我都标记了 “重点”，但看的时候还是要经历 “痛苦”，这已经将 <code>Express</code> 中的逻辑 “阉割” 到了一定的程度，读 <code>Express</code> 的源码一定比读这篇文章更需要耐心，当然如果你已经读到了这里证明困难都被克服了，继续加油。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>中间件</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2 中间件原理解析 —— 看了就会写</title>
    <url>/20180820200342/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180820200342/koa-middleware.png" title="Koa 中间件"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong><code>Koa 2.x</code> 版本是当下最流行的 <code>Node.js</code> 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 <code>Node.js</code> 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</strong></p></blockquote><a id="more"></a><h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 <code>API</code> 的使用方式及洋葱模型分析中间件是如何工作的。</p><pre><code class="lang-js">/* 洋葱模型特点 */
// 引入 Koa
const Koa = require(&#39;koa&#39;);

// 创建服务
const app = new Koa();

app.use(async (ctx, next) =&gt; {
  console.log(1);
  await next();
  console.log(2);
});

app.use(async (ctx, next) =&gt; {
  console.log(3);
  await next();
  console.log(4);
});

app.use(async (ctx, next) =&gt; {
  console.log(5);
  await next();
  console.log(6);
});

// 监听服务
app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p><h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p><pre><code class="lang-bash">$ npm install koa koa-bodyparser
</code></pre><p><strong>koa-bodyparser 具体用法如下：</strong></p><pre><code class="lang-js">/* koa-bodyparser 的用法 */
const Koa = require(&#39;koa&#39;);
const bodyParser = require(&#39;koa-bodyparser&#39;);

const app = new Koa();

// 使用中间件
app.use(bodyParser());

app.use(async (ctx, next) =&gt; {
  if (ctx.path === &#39;/&#39; &amp;&amp; ctx.method === &#39;POST&#39;) {
    // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据
    console.log(ctx.request.body);
  }
});

app.listen(3000);
</code></pre><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p><pre><code class="lang-js">/* 文件：my-koa-bodyparser.js */
const querystring = require(&#39;querystring&#39;);

module.exports = function bodyParser() {
  return async (ctx, next) =&gt; {
    await new Promise((resolve, reject) =&gt; {
      // 存储数据的数组
      const dataArr = [];

      // 接收数据
      ctx.req.on(&#39;data&#39;, data =&gt; dataArr.push(data));

      // 整合数据并使用 Promise 成功
      ctx.req.on(&#39;end&#39;, () =&gt; {
        // 获取请求数据的类型 json 或表单
        const contentType = ctx.get(&#39;Content-Type&#39;);

        // 获取数据 Buffer 格式
        const data = Buffer.concat(dataArr).toString();

        if (contentType === &#39;application/x-www-form-urlencoded&#39;) {
          // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
          ctx.request.body = querystring.parse(data);
        } else if (contentType === &#39;applaction/json&#39;) {
          // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
          ctx.request.body = JSON.parse(data);
        }

        // 执行成功的回调
        resolve();
      });
    });

    // 继续向下执行
    await next();
  }
}
</code></pre><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 <code>Promise</code> 中进行。</p><blockquote class="pullquote info"><ul><li><p><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续回到当前中间件，所以我们需要使用 <code>await</code> 进行等待。</strong></p></li><li><p><strong>其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 <code>Promise</code> 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 <code>Promise</code> 成功后再执行 <code>next</code>。</strong></p></li></ul></blockquote><h2 id="koa-better-body-中间件模拟"><a href="#koa-better-body-中间件模拟" class="headerlink" title="koa-better-body 中间件模拟"></a>koa-better-body 中间件模拟</h2><p><code>koa-bodyparser</code> 在处理表单提交时还是显得有一点弱，因为不支持文件上传，而 <code>koa-better-body</code> 则弥补了这个不足，但是 <code>koa-better-body</code> 为 <code>Koa 1.x</code> 版本的中间件，<code>Koa 1.x</code> 的中间件都是使用 <code>Generator</code> 函数实现的，我们需要使用 <code>koa-convert</code> 将 <code>koa-better-body</code> 转化成 <code>Koa 2.x</code> 的中间件。</p><pre><code class="lang-bash">$ npm install koa koa-better-body koa-convert path uuid
</code></pre><p><strong>koa-better-body 具体用法如下：</strong></p><pre><code class="lang-js">/* koa-better-body 的用法 */
const Koa = require(&#39;koa&#39;);
const betterBody = require(&#39;koa-better-body&#39;);
const convert = require(&#39;koa-convert&#39;); // 将  koa 1.0 中间转化成 koa 2.0 中间件
const path = require(&#39;path&#39;);
const fs = require(&#39;fs&#39;);
const uuid = require(&#39;uuid/v1&#39;); // 生成随机串

const app = new Koa();

// 将 koa-better-body 中间件从 koa 1.0 转化成 koa 2.0，并使用中间件
app.use(convert(betterBody({
  uploadDir: path.resolve(__dirname, &#39;upload&#39;)
})));

app.use(async (ctx, next) =&gt; {
  if (ctx.path === &#39;/&#39; &amp;&amp; ctx.method === &#39;POST&#39;) {
    // 使用中间件后 ctx.request.fields 属性自动加上了 post 请求的文件数据
    console.log(ctx.request.fields);

    // 将文件重命名
    const imgPath = ctx.request.fields.avatar[0].path;
    const newPath = path.resolve(__dirname, uuid());
    fs.rename(imgPath, newPath);
  }
});

app.listen(3000);
</code></pre><p>上面代码中 <code>koa-better-body</code> 的主要功能就是将表单上传的文件存入本地指定的文件夹下，并将文件流对象挂在了 <code>ctx.request.fields</code> 属性上，我们接下来就模拟 <code>koa-better-body</code> 的功能实现一版基于 <code>Koa 2.x</code> 处理文件上传的中间件。</p><pre><code class="lang-js">/* 文件：my-koa-better-body.js */
const fs = require(&#39;fs&#39;);
const uuid = require(&#39;uuid/v1&#39;);
const path = require(&#39;path&#39;);

// 给 Buffer 扩展 split 方法预备后面使用
Buffer.prototype.split = function (sep) {
  const len = Buffer.from(sep).length; // 分隔符所占的字节数
  const result = []; // 返回的数组
  let start = 0; // 查找 Buffer 的起始位置
  let offset = 0; // 偏移量

  // 循环查找分隔符
  while ((offset = this.indexOf(sep, start)) !== -1) {
    // 将分隔符之前的部分截取出来存入
    result.push(this.slice(start, offset));
    start = offset + len;
  }

  // 处理剩下的部分
  result.push(this.slice(start));

  // 返回结果
  return result;
}

module.exports = function (options) {
  return async (ctx, next) =&gt; {
    await new Promise((resolve, reject) =&gt; {
      let dataArr = []; // 存储读取的数据

      // 读取数据
      ctx.req.on(&#39;data&#39;, data =&gt; dataArr.push(data));

      ctx.req.on(&#39;end&#39;, () =&gt; {
        // 取到请求体每段的分割线字符串
        const bondery = &#39;--&#39; + ctx.get(&#39;content-Type&#39;).split(&#39;=&#39;)[1];

        // 获取不同系统的换行符
        const lineBreak = process.platform === &#39;win32&#39; ? &#39;\r\n&#39; : &#39;\n&#39;;

        // 非文件类型数据的最终返回结果
        const fields = {};

        // 分隔的 buffer 去掉没用的头和尾即开头的 &#39;&#39; 和末尾的 &#39;--&#39;
        dataArr = dataArr.split(bondery).slice(1, -1);

        // 循环处理 dataArr 中每一段 Buffer 的内容
        dataArr.forEach(lines =&gt; {
          // 对于普通值，信息由包含键名的行 + 两个换行 + 数据值 + 换行组成
          // 对于文件，信息由包含 filename 的行 + 两个换行 + 文件内容 + 换行组成
          const [head, tail] = lines.split(lineBreak + lineBreak});

          // 判断是否是文件，如果是文件则创建文件并写入，如果是普通值则存入 fields 对象中
          if (head.includes(&#39;filename&#39;)) {
            // 防止文件内容含有换行而被分割，应重新截取内容并去掉最后的换行
            let tail = lines.slice(head.length + 2 * lineBreak.length, -lineBreak.length);

            // 创建可写流并指定写入的路径：
            // 绝对路径 + 指定文件夹 + 随机文件名，最后写入文件
            fs.createWriteStream(path.join(__dirname, options.uploadDir, uuid())).end(tail);
          } else {
            // 是普通值取出键名
            const key = head.match(/name=&#39;(\w+)&#39;/)[1];

            // 将 key 设置给 fields tail 去掉末尾换行后的内容
            fields[key] = tail.toString(&#39;utf8&#39;).slice(0, -lineBreak.length);
          }
        });

        // 将处理好的 fields 对象挂在 ctx.request.fields 上，并完成 Promise
        ctx.request.fields = fields;
        resolve();
      });
    });

    // 向下执行
    await next();
  }
}
</code></pre><p>上面的内容逻辑可以通过代码注释来理解，就是模拟 <code>koa-better-body</code> 的功能逻辑，我们主要的关心点在于中间件实现的方式，上面功能实现的异步操作依然是读取数据，为了等待数据处理结束仍然在 <code>Promise</code> 中执行，并使用 <code>await</code> 等待，<code>Promise</code> 执行成功调用 <code>next</code>。</p><h2 id="koa-views-中间件模拟"><a href="#koa-views-中间件模拟" class="headerlink" title="koa-views 中间件模拟"></a>koa-views 中间件模拟</h2><p><code>Node.js</code> 模板是我们经常使用的工具，用来在服务端帮我们渲染页面，模板的种类繁多，因此出现了 <code>koa-view</code> 中间件，来兼容这些模板，先安装依赖的模块。</p><pre><code class="lang-bash">$ npm install koa koa-views ejs
</code></pre><p><strong>下面是一个 ejs 的模板文件：</strong></p><pre><code class="lang-ejs">&lt;!-- 文件：index.ejs --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&#39;en&#39;&gt;
&lt;head&gt;
  &lt;meta charset=&#39;UTF-8&#39;&gt;
  &lt;title&gt;ejs&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;%= name %&gt;
  &lt;%= age %&gt;

  &lt;% if (name == &#39;panda&#39;) { %&gt;
    panda
  &lt;% } else { %&gt;
    shen
  &lt;% } %&gt;

  &lt;% arr.forEach(item =&gt; { %&gt;
    &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;
  &lt;% }); %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>koa-views 具体用法如下：</strong></p><pre><code class="lang-js">/* koa-views 的用法 */
const Koa = require(&#39;koa&#39;);
const views = require(&#39;koa-views&#39;);
const path = require(&#39;path&#39;);

const app = new Koa();

// 使用中间件
app.use(views(path.resolve(__dirname, &#39;views&#39;), {
  extension: &#39;ejs&#39;
}));

app.use(async (ctx, next) =&gt; {
  await ctx.render(&#39;index&#39;, { name: &#39;panda&#39;, age: 20, arr: [1, 2, 3] });
});

app.listen(3000);
</code></pre><p>可以看出我们使用了 <code>koa-views</code> 中间件后，让 <code>ctx</code> 上多了 <code>render</code> 方法帮助我们实现对模板的渲染和响应页面，就和直接使用 <code>ejs</code> 自带的 <code>render</code> 方法一样，并且从用法可以看出 <code>render</code> 方法是异步执行的，所以需要使用 <code>await</code> 进行等待，接下来我们就来模拟实现一版简单的 <code>koa-views</code> 中间件。</p><pre><code class="lang-js">/* 文件：my-koa-views.js */
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const { promisify } = require(&#39;util&#39;);

// 将读取文件方法转换成 Promise
const readFile = promisify(fs.readFile);

// 到处中间件
module.exports = function (dir, options) {
  return async (ctx, next) =&gt; {
    // 动态引入模板依赖模块
    const view = require(options.extension);

    ctx.render = async (filename, data) =&gt; {
      // 异步读取文件内容
      const tmpl = await readFile(path.join(dir, filename + &#39;.&#39; + options.extension), &#39;utf8&#39;);

      // 将模板渲染并返回页面字符串
      const pageStr = view.render(tmpl, data);

      // 设置响应类型并响应页面
      ctx.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
      ctx.body = pageStr;
    }

    // 继续向下执行
    await next();
  }
}
</code></pre><p>挂在 <code>ctx</code> 上的 <code>render</code> 方法之所以是异步执行的是因为内部读取模板文件是异步执行的，需要等待，所以 <code>render</code> 方法为 <code>async</code> 函数，在中间件内部动态引入了我们使的用模板，如 <code>ejs</code>，并在 <code>ctx.render</code> 内部使用对应的 <code>render</code> 方法获取替换数据后的页面字符串，并以 <code>html</code> 的类型响应。</p><h2 id="koa-static-中间件模拟"><a href="#koa-static-中间件模拟" class="headerlink" title="koa-static 中间件模拟"></a>koa-static 中间件模拟</h2><p>下面是 <code>koa-static</code> 中间件的用法，代码使用的依赖如下，使用前需安装。</p><pre><code class="lang-bash">$ npm install koa koa-static mime
</code></pre><p><strong>koa-static 具体用法如下：</strong></p><pre><code class="lang-js">/* koa-static 的用法 */
const Koa = require(&#39;koa&#39;);
const static = require(&#39;koa-static&#39;);
const path = require(&#39;path&#39;);

const app = new Koa();

app.use(static(path.resolve(__dirname, &#39;public&#39;)));

app.use(async (ctx, next) =&gt; {
  ctx.body = &#39;hello world&#39;;
});

app.listen(3000);
</code></pre><p>通过使用和分析，我们知道了 <code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件，如果我们直接访问文件名的时候，会查找这个文件并直接响应，如果没有这个文件路径会当作文件夹，并查找文件夹下的 <code>index.html</code>，如果存在则直接响应，如果不存在则交给其他中间件处理。</p><pre><code class="lang-js">/* 文件：my-koa-static.js */
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const mime = require(&#39;mime&#39;);
const { promisify } = require(&#39;util&#39;);

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) {
  return async (ctx, next) =&gt; {
    // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
    const realPath = path.join(dir, ctx.path);

    try {
      // 获取 stat 对象
      const statObj = await stat(realPath);

      // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
      if (statObj.isFile()) {
        ctx.set(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;);
        ctx.body = fs.createReadStream(realPath);
      } else {
        const filename = path.join(realPath, &#39;index.html&#39;);

        // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
        await access(filename);

        // 存在设置文件类型并响应内容
        ctx.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
        ctx.body = fs.createReadStream(filename);
      }
    } catch (e) {
      await next();
    }
  }
}
</code></pre><p>上面的逻辑中需要检测路径是否存在，由于我们导出的函数都是 <code>async</code> 函数，所以我们将 <code>stat</code> 和 <code>access</code> 转化成了 <code>Promise</code>，并用 <code>try...catch</code> 进行捕获，在路径不合法时调用 <code>next</code> 交给其他中间件处理。</p><h2 id="koa-router-中间件模拟"><a href="#koa-router-中间件模拟" class="headerlink" title="koa-router 中间件模拟"></a>koa-router 中间件模拟</h2><p>在 <code>Express</code> 框架中，路由是被内置在了框架内部，而 <code>Koa</code> 中没有内置，是使用 <code>koa-router</code> 中间件来实现的，使用前需要安装。</p><pre><code class="lang-bash">$ npm install koa koa-router
</code></pre><p><code>koa-router</code> 功能非常强大，下面我们只是简单的使用，并且根据使用的功能进行模拟。</p><pre><code class="lang-js">/* koa-router 的简单用法 */
const Koa = require(&#39;Koa&#39;);
const Router = require(&#39;koa-router&#39;);

const app = new Koa();
const router = new Router();

router.get(&#39;/panda&#39;, (ctx, next) =&gt; {
  ctx.body = &#39;panda&#39;;
});

router.get(&#39;/pandashen&#39;, (ctx, next) =&gt; {
  ctx.body = &#39;pandashen&#39;;
});

router.get(&#39;/shen&#39;, (ctx, next) =&gt; {
  ctx.body = &#39;shen&#39;;
})

// 调用路由中间件
app.use(router.routes());

app.listen(3000);
</code></pre><p>从上面看出 <code>koa-router</code> 导出的是一个类，使用时需要创建一个实例，并且调用实例的 <code>routes</code> 方法将该方法返回的 <code>async</code> 函数进行连接，但是在匹配路由的时候，会根据路由 <code>get</code> 方法中的路径进行匹配，并串行执行内部的回调函数，当所有回调函数执行完毕之后会执行整个 <code>Koa</code> 串行的 <code>next</code>，原理同其他中间件，我下面来针对上面使用的功能简易实现。</p><pre><code class="lang-js">/* 文件：my-koa-router.js */
// 控制每一个路由层的类
class Layer {
  constructor(path, cb) {
    this.path = path;
    this.cb = cb;
  }
  match(path) {
    // 地址的路由和当前配置路由相等返回 true，否则返回 false
    return path === this.path;
  }
}

// 路由的类
class Router {
  constructor() {
    // 存放每个路由对象的数组，{ path: /xxx, fn: cb }
    this.layers = [];
  }
  get(path, cb) {
    // 将路由对象存入数组中
    this.layers.push(new Layer(path, cb));
  }
  compose(ctx, next, handlers) {
    // 将匹配的路由函数串联执行
    function dispatch(index) {
      // 如果当前 index 个数大于了存储路由对象的长度，则执行 Koa 的 next 方法
      if (index &gt;= handlers.length) return next();

      // 否则调用取出的路由对象的回调执行，并传入一个函数，在传入的函数中递归 dispatch(index + 1)
      // 目的是为了执行下一个路由对象上的回调函数
      handlers[index].cb(ctx, () =&gt; dispatch(index + 1));
    }

    // 第一次执行路由对象的回调函数
    dispatch(0);
  }
  routes() {
    return async (ctx, next) {
      // 当前 next 是 Koa 自己的 next，即 Koa 其他的中间件，筛选出路径相同的路由
      const handlers = this.layers.filter(layer =&gt; layer.match(ctx.path));
      this.compose(ctx, next, handlers);
    }
  }
}
</code></pre><p>在上面我们创建了一个 <code>Router</code> 类，定义了 <code>get</code> 方法，当然还有 <code>post</code> 等，我们只实现 <code>get</code> 意思一下，<code>get</code> 内为逻辑为将调用 <code>get</code> 方法的参数函数和路由字符串共同构建成对象存入了数组 <code>layers</code>，所以我们创建了专门构造路由对象的类 <code>Layer</code>（方便扩展），在路由匹配时我们可以根据 <code>ctx.path</code> 拿到路由字符串，并通过该路由过滤出 <code>layers</code> 数组中与路由相匹配的路由对象，调用 <code>compose</code> 方法将过滤后的数组作为参数 <code>handlers</code> 传入，串行执行路由对象上的回调函数。</p><blockquote class="pullquote warning"><p><strong><code>compose</code> 这个方法的实现思想非常的重要，在 <code>Koa</code> 源码中用于串联中间件，在 <code>redux</code> 源码中用于串行执行 <code>promise</code>、<code>thunk</code> 和 <code>logger</code> 等中间件，我们 <code>compose</code> 的实现是一个简版，并没有兼容异步，主要思想是递归 <code>dispatch</code> 函数，每次取出数组中下一个路由对象的回调函数执行，直到所有匹配的路由的回调函数都执行完，执行 <code>Koa</code> 的下一个中间件，即调用 <code>next</code>，注意此处的 <code>next</code> 不同于 <code>layers</code> 数组中回调函数的参数 <code>next</code>，<code>layers</code> 数组中路由对象回调函数的 <code>next</code> 代表下一个匹配路由的回调。</strong></p></blockquote><blockquote class="pullquote info"><p><strong><code>Koa</code> 相比 <code>Express</code> 框架关于中间件和使用上的一些优势：</strong></p><ul><li><strong><code>Express</code> 中很多功能都是集成在框架内部，而这些功能不一定都用得到，应用相对简单的情况下显得冗余，<code>Koa</code> 就更轻量，只集成最核心功能，上手快，文档少；</strong></li><li><strong><code>Koa</code> 的一切扩展功能都可以通过引入中间件来实现，大大增加灵活性，中间件可以自己开发，也可以来自社区，插拔随意，即插即用；</strong></li><li><strong><code>Koa</code> 中间件的实现原理明确，与自身的 “洋葱模型” 结合机制清晰，更多的促进关于 <code>Koa</code> 中间件生态的建设。</strong></li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>上面我们分析和模拟了一些中间件，发现 <code>Koa</code> 中间件的开发使用非常方便，需要的功能都可以用对应的中间件来实现，使用中间件可以给我们带来一些好处，比如能将我们处理好的数据和新方法挂载在 <code>ctx</code> 上，方便后面 <code>use</code> 传入的回调函数中使用，也可以帮我们处理一些公共逻辑，不至于在每一个 <code>use</code> 的回调中都去处理，大大减少了冗余代码，由此看来其实给 <code>Koa</code> 使用中间件的过程就是一个典型的 “装饰器” 模式，在通过上面的分析之后相信大家也了解了 <code>Koa</code> 的 “洋葱模型” 和异步特点，知道该如何开发自己的中间件了。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>async/await</tag>
        <tag>Koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 使用 cookie 和 session</title>
    <url>/20180817153635/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180817153635/cookie-session.png" title="cookie-session"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>由于浏览器无状态的特性，<code>cookie</code> 技术应运而生，<code>cookie</code> 是一个会话级的存储，大小 <code>4KB</code> 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不建议存放敏感信息，<code>session</code> 是专门用于存储最初设置给浏览器 <code>cookie</code> 数据的地方，我们本篇就来讨论一下 <code>cookie</code> 和 <code>session</code> 在 <code>Node.js</code> 中的使用方式。</strong></p></blockquote><a id="more"></a><h2 id="cookie-的基本使用"><a href="#cookie-的基本使用" class="headerlink" title="cookie 的基本使用"></a>cookie 的基本使用</h2><h3 id="Node-js-原生操作-cookie"><a href="#Node-js-原生操作-cookie" class="headerlink" title="Node.js 原生操作 cookie"></a>Node.js 原生操作 cookie</h3><p>下面是 <code>cookie</code> 在 Node 原生中的读取和写入方法。</p><pre><code class="lang-js">/* 原生中操作 cookie */
const http = require(&#39;http&#39;);

// 创建服务
http.createServer((req, res) =&gt; {
  if (req.url === &#39;/read&#39;) {
    // 读取 cookie
    console.log(req.headers.cookie);
    res.end(req.headers.cookie);
  } else if (req.url === &#39;/write&#39;) {
    // 设置 cookie
    res.setHeader(&#39;Set-Cookie&#39;, [
      &#39;name=panda; domain=panda.com; path=/write; httpOnly=true&#39;,
      &#39;age=28; Expires=&#39; + new Date(Date.now() + 1000 * 10).toGMTString(),
      &#39;address=&#39; + encodeURIComponent(&#39;回龙观&#39;) + &#39;; max-age=10&#39;
    ]);
    res.end(&#39;Write ok&#39;);
  } else {
    res.end(&#39;Not Found&#39;);
  }
}).listen(3000);
</code></pre><p>上面代码创建了一个 <code>http</code> 服务器，可以通过读取 <code>cookie</code> 请求头的值来获取浏览器发来的 <code>cookie</code>，服务器可以通过给浏览器设置响应头 <code>Set-Cookie</code> 实现对浏览器 <code>cookie</code> 的设置，多个 <code>cookie</code> 参数为数组，在数组内可以规定每一条 <code>cookie</code> 的规则，中间使用一个分号和一个空格隔开。</p><blockquote class="pullquote warning"><ul><li><strong><code>domain</code> 用来设置允许访问 <code>cookie</code> 的域；</strong></li><li><strong><code>path</code> 用来设置允许访问 <code>cookie</code> 的路径；</strong></li><li><strong><code>httpOnly</code> 用来设置是否允许浏览器中修改 <code>cookie</code>，如果通过浏览器修改设置过 <code>httpOnly=true</code> 的 <code>cookie</code>，则会增加一条同名 <code>cookie</code>，原来的 <code>cookie</code> 不会被修改；</strong></li><li><strong><code>Expires</code> 用来设置过期时间，绝对时间，值为一个 <code>GMT</code> 或 <code>UTC</code> 格式的时间；</strong></li><li><strong><code>max-age</code> 同样用来设置过期时间，相对时间，值为一个正整数，单位 <code>s</code>。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong><code>cookie</code> 默认不支持存储中文，如果存储中文需先使用 <code>encodeURIComponent</code> 方法进行转译，将转译后的结果存入 <code>cookie</code>，在浏览器获取 <code>cookie</code> 需使用 <code>decodeURIComponent</code> 方法转回中文。</strong></p></blockquote><h3 id="Koa-中操作-cookie"><a href="#Koa-中操作-cookie" class="headerlink" title="Koa 中操作 cookie"></a>Koa 中操作 cookie</h3><p><code>Koa</code> 是当下流行的 <code>Node.js</code> 框架，是对原生 <code>Node</code> 的一个轻量的封装，但是内部实现了快捷操作 <code>cookie</code> 的方法，下面是原生中对 <code>cookie</code> 的操作在 <code>Koa</code> 中的写法。</p><pre><code class="lang-js">/* Koa 中操作 cookie */
const Koa = require(&#39;koa&#39;);
const Router = require(&#39;koa-router&#39;);

// 创建服务和路由
const app = new Koa();
const router = new Router();

// 签名需要设置 key
app.keys = [&#39;shen&#39;];

router.get(&#39;/read&#39;, (ctx, next) =&gt; {
  // 获取 cookie
  const name = ctx.cookies.get(name) || &#39;No name&#39;;
  const age = ctx.cookies.get(age) || &#39;No age&#39;;
  ctx.body = name + &#39;-&#39; + age;
});

router.get(&#39;/write&#39;, (ctx, next) =&gt; {
  // 设置 cookie
  ctx.cookies.set(&#39;name&#39;, &#39;panda&#39;, { domain: &#39;panda.com&#39; });
  ctx.cookies.set(&#39;age&#39;, 28, { maxAge: 10 * 1000, signed: true });
});

// 使用路由
app.use(router.routes());
app.listen(3000);
</code></pre><p>在 <code>Koa</code> 中将获取和设置 <code>cookie</code> 的方法都挂在了 <code>ctx</code> 上下文对象的 <code>cookies</code> 属性上，分别为 <code>get</code> 和 <code>set</code>。</p><p><code>cookies.get</code> 的参数为获取 <code>cookie</code> 的键名，返回值为键对应的值，<code>cookies.set</code> 的第一个参数同样为 <code>cookie</code> 的键名，第二个参数为键对应的值，第三个参数为一个对象，用来配置该条 <code>cookie</code> 的规则，如 <code>domain</code>、<code>path</code> 和过期时间等，这里 <code>maxAge</code> 值为毫秒数。</p><blockquote class="pullquote warning"><p><strong>注意：<code>Koa</code> 中设置的 <code>cookie</code> 默认不允许浏览器端通过 <code>document.cookie</code> 获取，但是服务器也可以被欺骗，比如使用 <code>postman</code> 发送一个带 <code>Cookie</code> 请求头的请求，服务器可以通过设置签名来预防，即添加 <code>signed</code> 选项并将值设置为 <code>true</code>。</strong></p></blockquote><h3 id="Koa-操作-cookie-方法的原理"><a href="#Koa-操作-cookie-方法的原理" class="headerlink" title="Koa 操作 cookie 方法的原理"></a>Koa 操作 cookie 方法的原理</h3><p><code>cookies</code> 对象都是挂在 <code>ctx</code> 上来实现的，使用过 <code>Koa</code> 都知道如果要操作 <code>ctx</code> 就会用到中间件的思想，我们这就看看这两个方法使用原生封装的过程。</p><pre><code class="lang-js">/* Koa 中 ctx.cookies 对象 get 和 set 方法的原理 */
const Koa = require(&#39;koa&#39;);
const querystring = require(&#39;querystring&#39;);

const app = new Koa();

app.use(async (ctx, next) =&gt; {
  // 获取 cookie
  const get = key =&gt; {
    const cookies = ctx.get(&#39;cookie&#39;) || &#39;&#39;;
    return querystring.parse(result, &#39;; &#39;)[key];
  };

  // 设置 cookie，存储所有的 cookie，等于 setHeader 中的第二个参数
  const cookies = [];
  const set = (key, val, options = {}) =&gt; {
    // 用于构造单条 cookie 和权限等设置的数组，默认存放这条 cookie 的键和值
    const single = [key + &#39;=&#39; + encodeURIComponent(val)];

    // 下面是配置
    if (options.domain) {
      single.push(&#39;domain=&#39; + options.domain);
    }

    if (options.maxAge) {
      single.push(&#39;Max-Age=&#39; + options.maxAge);
    }

    if (options.path) {
      single.push(&#39;path=&#39; + options.path);
    }

    if (options.httpOnly) {
      single.push(&#39;HttpOnly=true&#39;);
    }

    // 将配置组合到 single 中后转为字符串存入 cookies
    cookies.push(single.join(&#39;; &#39;));

    // 设置给浏览器
    ctx.set(&#39;Set-Cookie&#39;, cookies);
  }

  // 将获取和设置 cookie 的方法挂在 cookies 对象上
  ctx.cookies = { get, set };

  await next();
});
</code></pre><p>在 <code>get</code> 方法内部获取 <code>cookie</code> 请求头的值并根据传入的 <code>key</code> 获取值，<code>set</code> 方法内，将传入的键值和选项拼接成符合 <code>cookie</code> 的字符串，通过 <code>Set-Cookie</code> 响应头设置给浏览器。</p><h2 id="session-的基本使用"><a href="#session-的基本使用" class="headerlink" title="session 的基本使用"></a>session 的基本使用</h2><h3 id="Node-js-原生使用-session"><a href="#Node-js-原生使用-session" class="headerlink" title="Node.js 原生使用 session"></a>Node.js 原生使用 session</h3><p>正常 <code>session</code> 是存放在数据库中的，我们这里为了方便就用一个名为 <code>session</code> 的对象来代替。</p><pre><code class="lang-js">/* 原生中使用 session */
const http = require(&#39;http&#39;);
const uuid = require(&#39;uuid/v1&#39;); // 生成随字符串
const querystring = require(&#39;querystring&#39;);

// 存放 session
const session = {};

// 创建服务
http.createServer((req, res) =&gt; {
  if (req.url === &#39;/user&#39;) {
    // 取出 cookie 存储的用户 ID
    let userId = querystring.parse(req.headers[&#39;cookie&#39;], &#39;; &#39;)[&#39;study&#39;];

    if (userId) {
      if (session[userId].studyCount === 0) res.end(&#39;您的学习次数已用完&#39;);
      session[userId].studyCount--;
    } else {
      // 生成 userId
      userId = uuid();

      // 将用户信息存入 session
      session[userId] = { studyCount: 30 };

      // 设置 cookie
      req.setHeader(&#39;Set-Cookie&#39;, [&#39;study=&#39; + userId]);
    }

    // 响应信息
    res.end(&#39;您的用户 ID 为 &#39; + userId + &#39;，\r\n剩余学习次数为：&#39; + session[userId].studyCount);
  } else {
    res.end(&#39;Not Found&#39;);
  }
}).listen(3000);
</code></pre><p>上面写的案例是一个网校的场景，一个新用户默认有 <code>30</code> 次学习机会，以后每次访问服务器学习次数减 <code>1</code>，如果 <code>studyCount</code> 值为 <code>0</code>，则提示学习次数用完，否则提示当前用户的 <code>ID</code> 和剩余学习次数，<code>session</code> 中存储的是每一个用户 <code>ID</code> 对应的剩余学习次数，这样就不会轻易的被修改学习剩余次数，因为服务器只认用户 <code>ID</code>，再通过 <code>ID</code> 去更改对应的剩余次数（当然忽略了别人冒充这个 <code>ID</code> 的情况，只能减，不能加），这样就不会因为篡改 <code>cookie</code> 而篡改用户存在 <code>session</code> 中的数据，除非连整个数据库都拖走。</p><h3 id="Koa-中使用-session"><a href="#Koa-中使用-session" class="headerlink" title="Koa 中使用 session"></a>Koa 中使用 session</h3><p>我们接下来使用 <code>Koa</code> 实现和上面一摸一样的场景，在 <code>Koa</code> 的社区中提供了专门操作 <code>session</code> 的中间件 <code>koa-session</code>，使用前需安装。</p><pre><code class="lang-js">/* Koa 中使用 session */
const Koa = require(&#39;koa&#39;);
const Router = require(&#39;koa-router&#39;);
const session = requier(&#39;koa-session&#39;);
const uuid = require(&#39;uuid/v1&#39;);

// 创建服务和路由
const app = new Koa();
const router = new Router();

// cookie 的签名
app.keys = [&#39;panda&#39;];

// 使用 koa-session 中间件
app.use(session({
  key: &#39;shen&#39;,
  maxAge: 10 * 1000
}, app));

router.get(&#39;/user&#39;, (ctx, next) =&gt; {
  // 取出 cookie 存储的用户 ID
  let userId = ctx.cookies.get(&#39;study&#39;);

  if (ctx.session.userId) {
    if (ctx.session[userId].studyCount === 0) res.end(&#39;您的学习次数已用完&#39;);
    ctx.session[userId].studyCount--;
  } else {
    // 生成 userId
    userId = uuid();

    // 将用户信息存入 session
    ctx.session[userId] = { studyCount: 30 };

    // 设置 cookie
    ctx.cookies.set(&#39;study&#39;, userId);
  }

  // 响应信息
  ctx.body = &#39;您的用户 ID 为 &#39; + userId + &#39;，\r\n剩余学习次数为：&#39; + session[userId].studyCount
});

// 使用路由
app.use(router.routes());
app.listen(3000);
</code></pre><p>使用 <code>Koa</code> 的 <code>koa-session</code> 以后，不再需要我们创建 <code>session</code> 对象进行存储，并且 <code>cookie-session</code> 中间件帮我们封装了 <code>API</code> 可以直接操作 <code>mongo</code> 和 <code>MySQL</code> 数据库，上面代码中与用原生相比还增加了 <code>cookie</code> 和 <code>session</code> 的签名和过期时间，比原生写起来要方便很多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>本篇内容更偏向于 <code>cookie</code> 和 <code>session</code> 在 <code>Node.js</code> 中的使用，没有过多的叙述理论性的内容，<code>cookie</code> 和 <code>session</code> 是相互依存的，也就是说共同使用的，现在已经有</strong> <a href="https://www.overtaking.top/20180816141146/" target="_blank">JWT</a> <strong>的方案来替代，因为相比较下有很多优点，但某些项目和特殊场景还在使用 <code>cookie</code> 和 <code>session</code>。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>cookie/session</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>通过一个案例理解 JWT</title>
    <url>/20180816141146/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/HTTP/20180816141146/jwt.png" title="JWT"><p><br></p><h2 id="JWT-简述"><a href="#JWT-简述" class="headerlink" title="JWT 简述"></a>JWT 简述</h2><blockquote class="pullquote default"><p><strong><code>JWT</code>（<code>json web token</code>）是为了在网络应用环境之间传递声明而基于 <code>json</code> 的开放标准，<code>JWT</code> 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。</strong></p></blockquote><a id="more"></a><h2 id="JWT-的应用场景"><a href="#JWT-的应用场景" class="headerlink" title="JWT 的应用场景"></a>JWT 的应用场景</h2><p><code>JWT</code> 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 <code>JWT</code>，可以对用户身份、路由、服务和资源的访问权限进行验证。</p><p>举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。</p><p>而在 <code>JWT</code> 之前，这样的验证我们大多都是通过 <code>cookie</code> 和 <code>session</code> 去实现的，我们接下来就来对比以下这两种方式的不同。</p><h2 id="JWT-对比-cookie-session"><a href="#JWT-对比-cookie-session" class="headerlink" title="JWT 对比 cookie/session"></a>JWT 对比 cookie/session</h2><p><strong><code>cookie/session</code> 的过程：</strong></p><p>由于浏览器的请求是无状态的，<code>cookie</code> 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 <code>session</code> 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。</p><p><strong><code>cookie/session</code> 的问题：</strong></p><p>从上面可以看出服务器植入 <code>cookie</code> 后每次请求都会带上 <code>cookie</code>，浪费带宽，而且 <code>cookie</code> 不支持跨域，不方便与其他的系统之间进行跨域访问，同时服务器会用 <code>session</code> 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 <code>session</code> 需要都拷贝过去。</p><p><strong>JWT 的过程：</strong></p><p>当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 <code>session</code> 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 <code>sha256</code> 和 <code>RSA</code> 等加密算法生成一个 <code>token</code> 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 <code>token</code> 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。</p><blockquote class="pullquote info"><p><strong><code>JWT</code> 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 <code>cookie</code> 不能跨域的问题。</strong></p></blockquote><h2 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h2><p><code>JWT</code> 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 <code>token</code> 就可以的，<code>JWT</code> 用于生成 <code>token</code> 的结构有三个部分，使用 <code>.</code> 隔开。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p><code>Header</code> 头部中主要包含两部分，<code>token</code> 类型和加密算法，如 <code>{typ: &#39;jwt&#39;, alg: &#39;HS256&#39;}</code>，<code>HS256</code> 就是指 <code>sha256</code> 算法，会将这个对象转成 <code>base64</code>。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p><code>Payload</code> 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明。</p><h4 id="标准中注册的声明"><a href="#标准中注册的声明" class="headerlink" title="标准中注册的声明"></a>标准中注册的声明</h4><p>下面是标准中注册的声明，建议但不强制使用。</p><blockquote class="pullquote danger"><ul><li><strong><code>iss</code>：<code>jwt</code> 签发者；</strong></li><li><strong><code>sub</code>：<code>jwt</code> 所面向的用户；</strong></li><li><strong><code>aud</code>：接收 <code>jwt</code> 的一方；</strong></li><li><strong><code>exp</code>：<code>jwt</code> 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；</strong></li><li><strong><code>nbf</code>：定义在什么时间之前，该 <code>jwt</code> 都是不可用的；</strong></li><li><strong><code>iat</code>：<code>jwt</code> 的签发时间。</strong></li></ul></blockquote><p>上面的标准中注册的声明中常用的有 <code>exp</code> 和 <code>nbf</code>。</p><h4 id="公共声明"><a href="#公共声明" class="headerlink" title="公共声明"></a>公共声明</h4><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 <code>{&#39;id&#39;, username: &#39;panda&#39;, adress: &#39;Beijing&#39;}</code>，会将这个对象转成 <code>base64</code>（可逆）。</p><h4 id="私有声明"><a href="#私有声明" class="headerlink" title="私有声明"></a>私有声明</h4><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 <code>base64</code> 是对称解密的，意味着该部分信息可以归类为明文信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p><code>Signature</code> 这一部分指将 <code>Header</code> 和 <code>Payload</code> 通过密钥 <code>secret</code> 和加盐算法进行加密后生成的签名，<code>secret</code> 密钥保存在服务端，不会发送给任何人，所以 <code>JWT</code> 的传输方式是很安全的。</p><p>最后将三部分使用 <code>.</code> 连接成字符串，就是要返回给浏览器的 <code>token</code> 浏览器一般会将这个 <code>token</code> 存储在 <code>localStorge</code> 以备其他需要验证用户身份的请求使用。</p><blockquote class="pullquote warning"><p><strong>经过上面对 <code>JWT</code> 的叙述可能还是没有完全的理解什么是 <code>JWT</code>，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 <code>express</code> 框架，数据库使用 <code>mongo</code> 来存储用户信息，前端使用 <code>Vue</code> 来实现，做一个登录页登录后进入订单页验证 <code>token</code> 的功能。</strong></p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><pre class="language-treeview">
  <code class="language-treeview">
    jwt-apply
      |- jwt-client
      | |- src
      | | |- views
      | | | |- Login.vue
      | | | |- Order.vue
      | | |- App.vue
      | | |- axios.js
      | | |- main.js
      | | |- router.js
      | |- .gitignore
      | |- babel.config
      | |- package.json
      |- jwt-server
      | |- model
      | | |- user.js
      | |- app.js
      | |- config.js
      | |- jwt-simple.js
      | |- package.json
  </code>
</pre><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>在搭建服务端之前需要安装我们使用的依赖，这里我们使用 <code>yarn</code> 来安装，命令如下：</p><pre><code class="lang-bash">$ yarn add express body-parse mongoose jwt-simple
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/config.js */
module.exports = {
  // 操作 mongo 自动生成这个数据库
  &#39;db_url&#39;: &#39;mongodb://localhost:27017/jwt&#39;,
  &#39;secret&#39;: &#39;pandashen&#39; // 密钥
};
</code></pre><p>上面配置文件中，<code>db_url</code> 存储的是 <code>mango</code> 数据库的地址，操作数据库自动创建，<code>secret</code> 是用来生成 <code>token</code> 的密钥。</p><h3 id="创建数据库模型"><a href="#创建数据库模型" class="headerlink" title="创建数据库模型"></a>创建数据库模型</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/model/user.js */
// 操作数据库的逻辑
const mongoose = require(&#39;mongoose&#39;);
const { db_url } = require(&#39;../config&#39;);

// 连接数据库，端口默认 27017
mongoose.connect(db_url, {
  useNewUrlParser: true // 去掉警告
});

// 创建一个骨架 Schema，数据会按照这个骨架格式存储
const UserSchema = new mongoose.Schema({
  username: String,
  password: String
});

// 创建一个模型
module.exports = mongoose.model(&#39;User&#39;, UserSchema);
</code></pre><p>我们将连接数据库、定义数据库字段和值类型以及创建数据模型的代码统一放在了 <code>model</code> 文件夹下的 <code>user.js</code> 当中，将数据模型导出方便在服务器的代码中进行查找操作。</p><h3 id="实现基本服务"><a href="#实现基本服务" class="headerlink" title="实现基本服务"></a>实现基本服务</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/app.js */
const express = require(&#39;express&#39;);
const bodyParser = require(&#39;body-parser&#39;);
const jwt = require(&#39;jwt-simple&#39;);
const User = require(&#39;./model/user&#39;);
const { secret } = require(&#39;./config&#39;);

// 创建服务器
const app = express();

/**
* 设置中间件
*/

/**
* 注册接口
*/

/**
* 登录接口
*/

/**
* 验证 token 接口
*/

// 监听端口号
app.listen(3000);
</code></pre><p>上面是一个基本的服务器，引入了相关的依赖，能保证启动，接下来添加处理 <code>post</code> 请求的中间件和实现 <code>cors</code> 跨域的中间件。</p><h3 id="添加中间件"><a href="#添加中间件" class="headerlink" title="添加中间件"></a>添加中间件</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/app.js */
// 设置跨域中间件
app.use((req, res, next) =&gt; {
  // 允许跨域的头
  res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);

  // 允许浏览器发送的头
  res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type,Authorization&#39;);

  // 允许哪些请求方法
  res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;GET,POST,PUT,DELETE,OPTIONS&#39;);

  // 如果当前请求是 OPTIONS 直接结束，否则继续执行
  req.method === &#39;OPTIONS&#39; ? res.end() : next();
});

// 设置处理 post 请求参数的中间件
app.use(bodyParser.json());
</code></pre><p>之所以设置处理 <code>post</code> 请求参数中间件是因为注册和登录都需要使用 <code>post</code> 请求，设置跨域中间件是因为我们项目虽小也是前后端分离的，需要用前端的 <code>8080</code> 端口访问服务器的 <code>3000</code> 端口，所以需要服务端使用 <code>cors</code> 处理跨域问题。</p><h3 id="注册接口的实现"><a href="#注册接口的实现" class="headerlink" title="注册接口的实现"></a>注册接口的实现</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/app.js */
// 注册接口的实现
app.post(&#39;/reg&#39;, async (req, res, next) =&gt; {
  // 获取 post 请求的数据
  let user = req.body;

  // 错误验证
  try {
    // 存入数据库，添加成功后返回的就是添加后的结果
    user = await User.create(user);

    // 返回注册成功的信息
    res.json({
      code: 0,
      data: {
        user: {
          id: user._id,
          username: user.username
        }
      }
    });
  } catch (e) {
    // 返回注册失败的信息
    res.json({ code: 1, data: &#39;注册失败&#39; });
  }
});
</code></pre><p>上面将用户注册的信息存入了 <code>mongo</code> 数据库，返回值为存入的数据，如果存入成功，则返回注册成功的信息，否则返回注册失败的信息。</p><h3 id="登录接口的实现"><a href="#登录接口的实现" class="headerlink" title="登录接口的实现"></a>登录接口的实现</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/app.js */
// 用户能登录
app.post(&#39;/login&#39;, async (req, res, next) =&gt; {
  let user = req.body;
  try {
    // 查找用户是否存在
    user = await User.findOne(user);

    if (user) {
      // 生成 token
      const token = jwt.encode({
        id: user._id,
        username: user.username,
        exp: Date.now() + 1000 * 10
      }, secret);

      res.json({
        code: 0,
        data: { token }
      });
    } else {
      res.json({ code: 1, data: &#39;用户不存在&#39; });
    }
  } catch (e) {
    res.json({ code: 1, data: &#39;登录失败&#39; });
  }
});
</code></pre><p>登录的过程中会先拿用户的账号和密码进数据库中进行验重和查找，如果存在，则登录成功并返回 <code>token</code>，如果不存在则登录失败。</p><h3 id="token-校验接口"><a href="#token-校验接口" class="headerlink" title="token 校验接口"></a>token 校验接口</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/app.js */
// 只针对 token 校验接口的中间件
const auth = (req, res, next) =&gt; {
  // 获取请求头 authorization
  const authorization = req.headers[&#39;authorization&#39;];
  // 如果存在，则获取 token
  if (authorization) {
    const token = authorization.split(&#39; &#39;)[1];
    try {
      // 对 token 进行校验
      req.user = jwt.decode(token, secret);
      next();
    } catch (e) {
      res.status(401).send(&#39;Not Allowed&#39;);
    }
  } else {
    res.status(401).send(&#39;Not Allowed&#39;);
  }
}

// 用户可以校验是否登录过，通过请求头 authorization: Bearer token
app.get(&#39;/order&#39;, auth, (req, res, next) =&gt; {
  res.json({
    code: 0,
    data: {
      user: req.user
    }
  });
});
</code></pre><p>在校验过程中，每次浏览器都会将 <code>token</code> 通过请求头 <code>authorization</code> 带给服务器，请求头的值为 <code>Bearer token</code>，这是 <code>JWT</code> 规定的，服务器取出 <code>token</code> 使用 <code>decode</code> 方法进行解码，并使用 <code>try...catch</code> 进行捕获，如果解码失败则会触发 <code>try...catch</code>，说明 <code>token</code> 过期、被篡改、或被伪造，返回 <code>401</code> 响应。</p><h2 id="前端的实现"><a href="#前端的实现" class="headerlink" title="前端的实现"></a>前端的实现</h2><p>我们使用 <code>3.0</code> 版本的 <code>vue-cli</code> 脚手架生成 <code>Vue</code> 项目，并安装 <code>axios</code> 发送请求。</p><pre><code class="lang-bash">$ yarn add global @vue/cli
$ yarn add axios
</code></pre><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-client/src/main.js */
import Vue from &#39;vue&#39;;
import App from &#39;./App.vue&#39;;
import router from &#39;./router&#39;;

// 是否为生产模式
Vue.config.productionTip = false

new Vue({
  router,
  render: h =&gt; h(App)
}).$mount(&#39;#app&#39;);
</code></pre><p>上面这个文件是 <code>vue-cli</code> 自动生成的，我们并没有做改动，但是为了方便查看我们会将主要文件的代码一一贴出来。</p><h3 id="主组件-App"><a href="#主组件-App" class="headerlink" title="主组件 App"></a>主组件 App</h3><pre><code class="lang-html">&lt;!-- 文件位置：~jwt-apply/jwt-client/src/App.vue --&gt;
&lt;template&gt;
  &lt;div id=&#39;app&#39;&gt;
    &lt;div id=&#39;nav&#39;&gt;
      &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; |
      &lt;router-link to=&quot;/order&quot;&gt;订单&lt;/router-link&gt;
    &lt;/div&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>在主组件中我们将 <code>router-link</code> 分别对应了 <code>/login</code> 和 <code>/order</code> 两个路由。</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-client/src/router.js */
import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
import Login from &#39;./views/Login.vue&#39;;
import Order from &#39;./views/Order.vue&#39;;

Vue.use(Router);

export default new Router({
  mode: &#39;history&#39;,
  base: process.env.BASE_URL,
  routes: [
    {
      path: &#39;/login&#39;,
      name: &#39;login&#39;,
      component: Login
    },
    {
      path: &#39;/order&#39;,
      name: &#39;order&#39;,
      component: Order
    }
  ]
});
</code></pre><p>我们定义了两个路由，一个对应登录页，一个对应订单页，并引入了组件 <code>Login</code> 和 <code>Order</code>，前端并没有写注册模块，可以使用 <code>postman</code> 发送注册请求生成一个账户以备后面验证使用。</p><h3 id="登录组件-Login"><a href="#登录组件-Login" class="headerlink" title="登录组件 Login"></a>登录组件 Login</h3><pre><code class="lang-html">&lt;!-- 文件位置：~jwt-apply/jwt-client/src/views/Login.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;login&quot;&gt;
    用户名
    &lt;input type=&quot;text&quot; v-model=&quot;user.username&quot;&gt;
    密码
    &lt;input type=&quot;text&quot; v-model=&quot;user.password&quot;&gt;
    &lt;button @click=&quot;login&quot;&gt;提交&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from &#39;../axios&#39;
export default {
  data() {
    return {
      user: {
        username: &#39;&#39;,
        password: &#39;&#39;
      }
    }
  },
  methods: {
    login() {
      // 发送请求访问服务器的登录接口
      axios.post(&#39;/login&#39;, this.user).then(res =&gt; {
        // 将返回的 token 存入 localStorage，并跳转订单页
        localStorage.setItem(&#39;token&#39;, res.data.token);
        this.$router.push(&#39;/order&#39;);
      }).catch(err =&gt; {
        // 弹出错误
        alert(err.data);
      });
    }
  }
}
&lt;/script&gt;
</code></pre><p><code>Login</code> 组件中将两个输入框的值同步到 <code>data</code> 中，用来存放账号和密码，当点击提交按钮时，触发点击事件 <code>login</code> 发送请求，请求成功后将返回的 <code>token</code> 存入 <code>localStorage</code>，并跳转路由到订单页，请求错误时弹出错误信息。</p><h3 id="订单组件-Order"><a href="#订单组件-Order" class="headerlink" title="订单组件 Order"></a>订单组件 Order</h3><pre><code class="lang-html">&lt;!-- 文件位置：~jwt-apply/jwt-client/src/views/Order.vue --&gt;
&lt;template&gt;
  &lt;div class=&quot;order&quot;&gt;
    {{username}} 的订单
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from &#39;../axios&#39;
export default {
  data() {
    return {
      username: &#39;&#39;
    }
  },
  mounted() {
    axios.get(&#39;/order&#39;).then(res =&gt;{
      this.username = res.data.user.username;
    }).catch(err =&gt; {
      alert(err);
    });
  }
}
&lt;/script&gt;
</code></pre><p><code>Order</code> 页面显示的内容是 “XXX 的订单”，在加载 <code>Order</code> 组件被挂载时发送请求获取用户名，即访问服务器的验证 <code>token</code> 接口，因为订单页就是一个涉及到验证用户的页面，当请求成功时，将用户名同步到 <code>data</code>，否则弹出错误信息。</p><p>在 <code>Login</code> 和 <code>Order</code> 两个组件中对请求的回调内似乎写的太简单了，其实是因为 <code>axios</code> 的返回值会在服务器返回的返回值外面包了一层，存放一些 <code>http</code> 响应的相关信息，两个接口访问时请求地址也是同一个服务器，而且在服务器响应时的错误处理都是对状态吗 <code>401</code> 的处理，在涉及验证用户信息的请求中需要设置请求头 <code>Authorization</code> 发送 <code>token</code>。</p><p>这些逻辑我们似乎在组件请求相关的代码中都没有看到，是因为我们使用 <code>axios</code> 的 <code>API</code> 设置了 <code>baseURL</code> 请求拦截和响应拦截，细心可以发现其实引入的 <code>axios</code> 并不是直接从 <code>node_modules</code> 引入，而是引入了我们自己的导出的 <code>axios</code>。</p><h3 id="axios-配置"><a href="#axios-配置" class="headerlink" title="axios 配置"></a>axios 配置</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-client/src/axios.js */
import axios from &#39;axios&#39;;
import router from &#39;./router&#39;;

// 设置默认访问地址
axios.defaults.baseURL = &#39;http://localhost:3000&#39;;

// 响应拦截
axios.interceptors.response.use(res =&gt; {
  // 报错执行 axios then 方法错误的回调，成功返回正确的数据
  return res.data.code !== 0 ? Promise.reject(res.data) : res.data;
}, res =&gt; {
  // 如果 token 验证失败则跳回登陆页，并执行 axios then 方法错误的回调
  if (res.response.status === 401) {
    router.history.push(&#39;/login&#39;);
  }
  return Promise.reject(&#39;Not Allowed&#39;);
});

// 请求拦截，用于将请求统一带上 token
axios.interceptors.request.use(config =&gt; {
  // 在 localStorage 获取 token
  const token = localStorage.getItem(&#39;token&#39;);

  // 如果存在则设置请求头
  if (token) {
    config.headers.Authorization = &#39;Bearer &#39; + token;
  }

  return config;
});

export default axios;
</code></pre><p>访问服务器时会将 <code>axios</code> 中的第一个参数拼接在 <code>axios.defaults.baseURL</code> 的后面作为请求地址。</p><p><code>axios.interceptors.response.use</code> 为响应拦截，<code>axios</code> 发送请求后所有的响应都会先执行这个方法内部的逻辑，返回值为数据，作为参数传递给 <code>axios</code> 返回值的 <code>then</code> 方法。</p><p><code>axios.interceptors.request.use</code> 为请求拦截，<code>axios</code> 发送的所有请求都会先执行这个方法的逻辑，然后发送给服务器，一般用来设置请求头。</p><h2 id="jwt-simple-模块的实现原理"><a href="#jwt-simple-模块的实现原理" class="headerlink" title="jwt-simple 模块的实现原理"></a>jwt-simple 模块的实现原理</h2><p>相信通过上面的过程已经非常清楚 <code>JWT</code> 如何生成的，<code>token</code> 的格式是怎样的，如何跟前端交互去验证 <code>token</code>，我们在这些基础上再深入的研究一下 <code>token</code> 的整个生成过程和验证过程，我们使用的 <code>jwt-simple</code> 模块的 <code>encode</code> 方法如何生成 <code>token</code>，使用 <code>decode</code> 方法如何验证 <code>token</code>，下面就看看一看 <code>jwt-simple</code> 的实现原理。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */
const crypto = require(&#39;crypto&#39;);

/**
* 其他方法
*/

// 创建对象
module.exports = {
  encode,
  decode
};
</code></pre><p>我们知道 <code>jwt-simple</code> 我们使用的有两个方法 <code>encode</code> 和 <code>decode</code>，所以最后导出的对象上有这两个方法，使用加盐算法进行签名需要使用 <code>crypto</code>，所以我们提前引入。</p><h3 id="字符串和-Base64-互相转换"><a href="#字符串和-Base64-互相转换" class="headerlink" title="字符串和 Base64 互相转换"></a>字符串和 Base64 互相转换</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */
// 将子子符串转换成 Base64
function stringToBase64(str) {
  return Buffer.from(str).toString(&#39;base64&#39;);
}

// 将 Base64 转换成字符串
function base64ToString(base64) {
  return Buffer.from(base64, &#39;base64&#39;).toString(&#39;utf8&#39;);
}
</code></pre><p>从方法的名字相信很容易看出用途和参数，所以就一起放在这了，其实本质是在两种编码之间进行转换，所以转换之前都应该先转换成 <code>Buffer</code>。</p><h3 id="生成签名的方法"><a href="#生成签名的方法" class="headerlink" title="生成签名的方法"></a>生成签名的方法</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */
function createSign(str, secret) {
  // 使用加盐算法进行加密
  return crypto.createHmac(&#39;sha256&#39;, secret).update(str).digest(&#39;base64&#39;);
}
</code></pre><p>这一步就是通过加盐算法使用 <code>sha256</code> 和密钥 <code>secret</code> 进行生成签名，但是为了方便我们把使用的加密算法给写死了，正常情况下是应该根据 <code>Header</code> 中 <code>alg</code> 字段的值去检索 <code>alg</code> 的值与加密算法名称对应的 <code>map</code>，去使用设置的算法生成签名。</p><h3 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */
function encode(payload, secret) {
  // 头部
  const = stringToBase64(JSON.stringify({
    typ: &#39;JWT&#39;,
    alg: &#39;HS256&#39;
  }));

  // 负载
  const content = stringToBase64(JSON.stringify(payload));

  // 签名
  const sign = createSign([header, content].join(&#39;.&#39;), secret);

  // 生成签名
  return [header, content, sign].join(&#39;.&#39;);
}
</code></pre><p>在 <code>encode</code> 中将 <code>Header</code>、<code>Payload</code> 转换成 <code>base64</code>，通过 <code>.</code> 连接在一起，然后使用 <code>secret</code> 密钥生成签名，最后将 <code>Header</code> 和 <code>Payload</code> 的 <code>base64</code> 通过 <code>.</code> 和生成的签名连接在一起，这就形成了 “明文” + “明文” + “暗文” 三段格式的 <code>token</code>。</p><h3 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h3><pre><code class="lang-js">/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */
function decode(token, secret) {
  let [header, content, sign] = token.split(&#39;.&#39;);

  // 将接收到的 token 的前两部分（base64）重新签名并验证，验证不通过抛出错误
  if (sign !== createSign([header, content].join(&#39;.&#39;), secret)) {
    throw new Error(&#39;Not Allow&#39;);
  }

  // 将 content 转成对象
  content = JSON.parse(base64ToString(content));

  // 检测过期时间，如果过去抛出错误
  if (content.exp &amp;&amp; content.exp &lt; Date.now()) {
    throw new Error(&#39;Not Allow&#39;);
  }

  return content;
}
</code></pre><p>在验证方法 <code>decode</code> 中，首先将 <code>token</code> 的三段分别取出，并用前两段重新生成签名，并与第三段 <code>sign</code> 对比，相同通过验证，不同说明篡改过并抛出错误，将 <code>Payload</code> 的内容重新转换成对象，也就是将 <code>content</code> 转换成对象，取出 <code>exp</code> 字段与当前时间对比来验证是否过期，如果过期抛出错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>JWT</code> 生成的 <code>token</code> 中，前两段明文可解，这样别人拦截后知道了我们的加密算法和规则，也知道我们传输的信息，也可以使用 <code>jwt-simple</code> 加密一段暗文拼接成 <code>token</code> 的格式给服务器去验证，为什么 <code>JWT</code> 还这么安全呢，这就说到了最最重点的地方，无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证是因为无法获取服务器的密钥 <code>secret</code>，真正能保证安全的就是 <code>secret</code>，同时证明了 <code>Header</code> 和 <code>Payload</code> 并不安全，可以被破解，所以不能存放敏感信息。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>HTTP</tag>
        <tag>cookie/session</tag>
        <tag>JWT</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL —— 简单聊一聊数据库设计</title>
    <url>/20180814131241/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/mysql-table-design.png" title="MySQL 数据库设计"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>这是关于 <code>MySQL</code> 系列文章的第三篇，本篇在 <code>MySQL</code> 使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 <code>MySQL</code> 的入门，这也是我的学习笔记，希望可以帮助大家。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote primary"><p><strong>系列文章：</strong></p><ul><li><a href="/20180808012303/" target="_blank">MySQL —— 数据库基础</a></li><li><a href="/20180809115245/" target="_blank">MySQL —— SQL 语句总结</a></li></ul></blockquote><h2 id="为什么设计数据库"><a href="#为什么设计数据库" class="headerlink" title="为什么设计数据库"></a>为什么设计数据库</h2><p>说到为什么要设计数据库，就要说到数据的完整性，我们要在设计数据库时保证域的完整性和实体的完整性，同时从性能出发，我们要保证最大限度的节省存储空间，比如一张成绩表，上面没必要存储学生的姓名、年龄等信息，只需要存储成绩，如果一个数据库设计的合理，最后的结果就是方便我们对数据库的开发和扩展。</p><p>如果是一个 “糟糕” 的数据库设计会造成一系列的不良反应，比如数据冗余，存储空间浪费，内存浪费，有时甚至会造成数据插入和更新的异常，比如学生表存了学生信息，而成绩表也存了，这样在修改时没有全部修改就会出现错误。</p><h2 id="软件项目开发中数据库设计的生命周期"><a href="#软件项目开发中数据库设计的生命周期" class="headerlink" title="软件项目开发中数据库设计的生命周期"></a>软件项目开发中数据库设计的生命周期</h2><blockquote class="pullquote success"><p><strong>软件项目开发中数据库设计的生命周期可大概分为以下几个阶段：</strong></p><ul><li><strong>需求分析阶段，分析客户的业务和数据处理需求；</strong></li><li><strong>概要设计阶段，设计数据库 <code>E-R</code> 模型图，确认需求的正确和完整性；</strong></li><li><strong>详细设计阶段，应用三大范式审核数据库；</strong></li><li><strong>代码编写阶段，物理实现数据库，编码实现应用；</strong></li><li><strong>软件测试阶段；</strong></li><li><strong>安装部署阶段。</strong></li></ul></blockquote><p>上面数据库的设计经历了从 “现实世界” 到 “信息世界” 到 “数据库模型” 再到 “数据库” 产生的一个完整过程。</p><h2 id="设计数据库的步骤"><a href="#设计数据库的步骤" class="headerlink" title="设计数据库的步骤"></a>设计数据库的步骤</h2><blockquote class="pullquote warning"><ul><li><strong>收集信息：收集信息其实就是与相关人员进行交流、访谈、调研，充分了解用户需求，理解整个项目的完整流程，并理解数据库需要完成的任务，这部分工作大部分由需求人员完成，并根技术人员进行对接。</strong></li><li><strong>标识实体和实体属性：开发人员在明确需求和流程之后，标识数据库的实体，比如学生信息表，每一条实体中应该由哪些字段组成，成绩表中实体由哪些字段组成等等。</strong></li><li><strong>标识实体之间的关系：其实就是通过表之间的某字段对表进行关联，对表的实体之间建立对应关系，如学生表的 <code>id</code> 字段会关联成绩表的 <code>student_id</code> 字段，用来查找某个学生的成绩。</strong></li></ul></blockquote><h2 id="数据库-E-R-图"><a href="#数据库-E-R-图" class="headerlink" title="数据库 E-R 图"></a>数据库 E-R 图</h2><h3 id="E-R-图基本概念"><a href="#E-R-图基本概念" class="headerlink" title="E-R 图基本概念"></a>E-R 图基本概念</h3><p><code>E-R</code> 图也叫做实体关系图，是指用实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据的概念模型。</p><blockquote class="pullquote danger"><ul><li><strong><code>E-R</code> 图的实体：即数据模型中的数据对象，每一张表就是一个 <code>E-R</code> 图的实体。</strong></li><li><strong><code>E-R</code> 图的属性：即数据对象中所具有的属性，例如学生表的学生、姓名、年龄等，属性又分为唯一属性和非唯一属性，唯一属性如经过唯一约束和主键约束的属性，不可重复，其他的都是非唯一属性。</strong></li><li><strong><code>E-R</code> 图的关系：用来表示每一个数据对象与数据对象之间的联系，即每一个实体之间的联系，例如学生表和成绩表之间的联系，因为每个学生都有自己的成绩。</strong></li></ul></blockquote><h3 id="E-R-图的关联关系"><a href="#E-R-图的关联关系" class="headerlink" title="E-R 图的关联关系"></a>E-R 图的关联关系</h3><h4 id="1-对-1-（1-1）"><a href="#1-对-1-（1-1）" class="headerlink" title="1 对 1 （1 : 1）"></a>1 对 1 （1 : 1）</h4><p><code>1</code> 对 <code>1</code> 关系是指对于实体集 <code>A</code> 和 实体集 <code>B</code>，<code>A</code> 中的每一个实体最多与 <code>B</code> 中的一个实体有关系，反之在实体集 <code>B</code> 中的每一个实体之多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/onetoone.png" alt="1 对 1 关系图"></div><div class="image-caption">1 对 1 关系图</div></figure><p><br></p><h4 id="1-对多（1-N）"><a href="#1-对多（1-N）" class="headerlink" title="1 对多（1 : N）"></a>1 对多（1 : N）</h4><p><code>1</code> 对多关系是指实体集 <code>A</code> 与实体集 <code>B</code> 中至少有 <em><code>N (N &gt; 0)</code></em> 个实体有关系，并且实体集 <code>B</code> 中最多与实体集 <code>A</code> 中的一个实体有关系。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/onetomany.png" alt="1 对多关系图"></div><div class="image-caption">1 对多关系图</div></figure><p><br></p><h4 id="多对多（M-N）"><a href="#多对多（M-N）" class="headerlink" title="多对多（M : N）"></a>多对多（M : N）</h4><p>多对多关系是指实体集 <code>A</code> 中的每一个实体与实体集 <code>B</code> 中至少有 <em><code>M (M &gt; 0)</code></em> 个实体有关系，并且实体集 <code>B</code> 中的每一个实体与实体集 <code>A</code> 中至少有 <em>N (N &gt; 0)</em> 个实体有关系。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/manytomany.png" alt="多对多关系图"></div><div class="image-caption">多对多关系图</div></figure><p><br></p><h2 id="数据库设计的三大范式"><a href="#数据库设计的三大范式" class="headerlink" title="数据库设计的三大范式"></a>数据库设计的三大范式</h2><h3 id="确保每列的原子性"><a href="#确保每列的原子性" class="headerlink" title="确保每列的原子性"></a>确保每列的原子性</h3><p>如果每列都是不可再分的最小单元信息，则满足第一范式，比如下图中，地址是由国家和城市组成的，显然可以继续在拆分成两个列，国家和城市，是不满足第一范式的，需要将地址列差分成国家和城市两个列。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/firstpattern.png" alt="原子性事例"></div><div class="image-caption">原子性事例</div></figure><p><br></p><p>举一个简单的例子，我们平时在淘宝购物的时候需要添加地址，在填写新地址时，都是让我们选择国家、省、城市、区、街道、小区这样的方式，而不是让我们自己将这些地址写在一起，其原因就是因为淘宝的数据库设计严格遵循每列的原子性，这样的提交可以方便后端获取每一个列的信息在数据库中进行存储。</p><h3 id="每张表只能描述一件事情"><a href="#每张表只能描述一件事情" class="headerlink" title="每张表只能描述一件事情"></a>每张表只能描述一件事情</h3><p>如下图中所示，在左侧的表中，描述了学生信息和课程信息，这明显是两件事情，假设再有一张成绩表，也要描述学生信息，课程信息和成绩等多件事情，就会造成数据的重复、冗余，也可能会导致更新、插入、删除数据异常的现象。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/secondpattern.png" alt="每个表描述一件"></div><div class="image-caption">每个表描述一件</div></figure><p><br></p><p>所以正确的做法是应该将左侧表差分成两张表分别为学生表和课程表，并使用学生编号与课程编号进行关联。</p><h3 id="其他列都不传递依赖于主键列"><a href="#其他列都不传递依赖于主键列" class="headerlink" title="其他列都不传递依赖于主键列"></a>其他列都不传递依赖于主键列</h3><p>其他列都不传递依赖于主键列的意思是表中各列必须都与主键直接相关，不能间接相关，从下图左表可以看出，学生编号为主键，年级 <code>ID</code> 也应该为主键，正常应该通过学生编号找到年级 <code>ID</code>，再找到年级名称，这样年级名称与学生编号之间就形成了一个传递并且依赖于主键年级 <code>ID</code>，即年级 <code>ID</code> 做为主键在中间隔了一层，这样就使年级名称与主键学生编号间接相关，如果在同一张表中，所有的字段都是应该直接依赖于主键，而不是再通过其他的主键传递。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/thirdpattern.png" alt="其他列都不传递依赖于主键列"></div><div class="image-caption">其他列都不传递依赖于主键列</div></figure><p><br></p><p>如果一个表中表述了多件事情并有多个作为主键的列，与上一条的处理方式相同，应该拆成多张表，并且每张表只有一个主键列。</p><h2 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC 基于角色的访问控制"></a>RBAC 基于角色的访问控制</h2><h3 id="RBAC-的含义"><a href="#RBAC-的含义" class="headerlink" title="RBAC 的含义"></a>RBAC 的含义</h3><blockquote class="pullquote info"><p><strong><code>RBAC</code>（<code>Role-Based Access Control</code>）基于角色的访问控制，就是用户通过角色与权限进行关联，简单的说，一个用户拥若干个角色，每个角色拥有若干个权限，这样就构造成了 “用户 → 角色 → 权限 → 资源” 的授权模型，在这个模型中，用户与角色之间，角色与权限之间，权限与资源之间，一般都是多对多的关系，在 <code>RBAC</code> 中最重要的概念主要有四部分，就是用户（<code>User</code>）、角色（<code>Role</code>）、权限（<code>Permission</code>）和资源（<code>Resource</code>）。</strong></p></blockquote><h3 id="RBAC-的安全原则"><a href="#RBAC-的安全原则" class="headerlink" title="RBAC 的安全原则"></a>RBAC 的安全原则</h3><blockquote class="pullquote default"><ul><li><strong>最小权限原则：最小权限原则之所以被 <code>RBAC</code> 所支持，是因为 <code>RBAC</code> 可以将其角色配置成完成任务所需要的最小的权限集；</strong></li><li><strong>责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一个帐目；</strong></li><li><strong>数据抽象原则：数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。</strong></li></ul></blockquote><h3 id="RBAC-的-E-R-图"><a href="#RBAC-的-E-R-图" class="headerlink" title="RBAC 的 E-R 图"></a>RBAC 的 E-R 图</h3><p>之前说 <code>RBAC</code> 最重要的概念由四部分，其实体现在数据库的表中有主要三部分，因为角色和用户是重叠的，那么主要有三张表分别为用户表、权限表和资源表，其中用户表与权限表之间有一张关联表，权限表与资源表之间有一张关联表，<code>E-R</code> 图如下。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180814131241/RBAC.png" alt="RBAC 的 E-R 图"></div><div class="image-caption">RBAC 的 E-R 图</div></figure><p><br></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="为什么需要事务？"><a href="#为什么需要事务？" class="headerlink" title="为什么需要事务？"></a>为什么需要事务？</h3><p>在生活中我们经常使用银行转账或者支付宝和微信支付，这种操作每一次至少影响两个用户的数据信息，比如一方给另一方转钱，如果成功则转钱方余额减去转出金额，而收钱方余额增加收到的金额，这应该是一个请求操作了数据表中的俩个实体，如果在两个操作数据的环节任意一个失败了，都会影响两个人数据的正确性，这种时候需要两个操作同时失败或同时成功，就是说有一个操作出现失败的情况，即使另一个成功了也需要进行回滚操作，这就是事务的由来。</p><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是作为单个逻辑工作单元执行的一系列操作，多个操作作为一个整体向系统提交，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。</p><p>转账过程就是一个整体，它需要两条 <code>UPDATE</code> 语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据（回滚），确保总余额不变。</p><p>这里再举一个例子，有一个上传文件的功能，后端接收到文件流时是需要先写入的，当写入成功后，会将上传成功的结果返回给客户端，如果文件很大，写入的时间就会长，如果在此期间突然写入失败，则会删除之前写入的内容，将整个操作回滚到写入之前，这里面主要两步操作，创建一个新文件并写入，写入成功删除旧文件，如果写入失败，两个操作将会同时失败，即不会删除旧文件，这也是一个事务的例子，只是没有转账那么明显。</p><h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性 ACID"></a>事务的特性 ACID</h3><blockquote class="pullquote default"><p><strong>事务具有以下特性，被简称为 <code>ACID</code>：</strong></p><ul><li><strong>原子性（<code>Atomicity</code>）：事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行；</strong></li><li><strong>一致性（<code>Consistency</code>）：当事务完成后，数据必须处理完整的状态；</strong></li><li><strong>隔离性（<code>Isolation</code>）：并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务；</strong></li><li><strong>持久性（<code>Durability</code>）：事务完成后，它对数据库的修改被永久保持。</strong></li></ul></blockquote><h3 id="如何创建事务"><a href="#如何创建事务" class="headerlink" title="如何创建事务"></a>如何创建事务</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>创建表 <code>account</code>，<code>id</code> 列为主键列，<code>name</code> 列为姓名，<code>balance</code> 为余额。</p><pre><code class="lang-sql">CREATE TABLE `account` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(64) NOT NULL,
  `balance` INT(11) DEFAULT 0
  PRIMARY KEY (`id`)
);
</code></pre><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>将表 <code>account</code> 添加两条数据，分别为 “张三” 和 “李四”，余额都为 <code>100</code>。</p><pre><code class="lang-sql">INSERT INTO `student` (`name`, `balance`) VALUES (&quot;张三&quot;, 100);
INSERT INTO `student` (`name`, `balance`) VALUES (&quot;李四&quot;, 100);
</code></pre><h4 id="使用-Node-js-实现事务"><a href="#使用-Node-js-实现事务" class="headerlink" title="使用 Node.js 实现事务"></a>使用 Node.js 实现事务</h4><pre><code class="lang-js">/* 一个非常简单的事务 */
const mysql = require(&#39;mysql&#39;);

// 创建数据库连接
const connection = mysql.createConnection({
  host: &#39;localhost&#39;, // 主机名
  port: &#39;3306&#39;, // 数据库服务端口号
  username: &#39;root&#39;, // 数据库名称
  pwd: &#39;123456&#39;, // 数据库密码
  database: &#39;school&#39;  // 连接的数据库名称
});

connection.connect();

// 开启事务
connection.beginTransaction(err =&gt; {
  // 回调参数为错误对象，返回结果，返回字段描述
  connection.query(&#39;UPDATE account SET balance - 50 WHERE id = 1&#39;, (err, result, fields) =&gt; {
    if (err) {
      connection.rollback(); // 如果失败直接回归
    } else {
      connection.query(&#39;UPDATE account SET balance + 50 WHERE id = 1&#39;, (err, result, fields) =&gt; {
        err ? connection.rollback() : connection.commit();
      });
    }
  });
});
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>到此关于 <code>MySQL</code> 的系列文章就告一段落了，希望前端的同学们在看了这几篇文章后对你们入门 <code>MySQL</code> 有一些帮助，那这几篇的文章就达到目的了，也欢迎后端的小伙伴来指出文章中的错误和不足。</strong></p></blockquote>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL —— SQL 语句总结</title>
    <url>/20180809115245/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/sql.png" title="SQL 语句"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于 <code>MySQL</code> 系列文章的第二篇，本篇大部分内容都贴近开发中的实际操作，，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 <code>MySQL</code> 的入门，这也是我的学习笔记，希望可以帮助大家。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章：</strong></p><ul><li><a href="/20180808012303/" target="_blank">MySQL —— 数据库基础</a></li><li><a href="/20180814131241/" target="_blank">MySQL —— 简单聊一聊数据库设计</a></li></ul></blockquote><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>还记得在上一篇的最后我们使用 <code>DDL</code> 创建了完整的表关系，<code>student</code>、<code>score</code> 和 <code>course</code> 三张表如下图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/student-score-course.png" alt="完整表关系图"></div><div class="image-caption">完整表关系图</div></figure><p><br></p><p>其中 <code>score</code> 是外键表，创建外键约束关联了两张主键表 <code>scudent</code> 和 <code>cource</code>，接下来的 <code>SQL</code> 语句都是基于这几张表来进行的。</p><h2 id="SQL-的组成"><a href="#SQL-的组成" class="headerlink" title="SQL 的组成"></a>SQL 的组成</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p><code>DDL</code>（<code>data definition language</code>）是数据定义语言，主要命令有 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code> 等，<code>DDL</code> 主要用在定义或改变数据表（<code>TABLE</code>）的结构、数据类型、表之间的链接和约束等初始化工作上，大多数在建立表时使用，在上一篇中 <code>DDL</code> 操作表的部分着重做了介绍并创建数据表，也可以将存储 <code>DDL</code> 语句的文件存储在 <code>.sql</code> 后缀名结尾的文件当中，在 <code>DBMS</code> 数据管理系统中导入，直接创建数据库。</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><code>DML</code>（<code>data manipulation language</code>）是数据操做语言，通过 <code>DML</code> 语句对数据库数据表中的实体进行增、删、改、查，数据量非常大时，我们不可能使用 <code>DBMS</code> 一条一条的操作数据，所以都是通过代码完成操作，<code>DML</code> 是在学习 <code>MySQL</code> 数据库中最最重要的内容，也是本篇的重点，后面会非常详细的说明。</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p><code>DCL</code>（<code>data control language</code>）是数据库控制语言，用来设置或更改数据库用户或角色权限的语句，包括 <code>grant</code>、<code>revoke</code> 等，<code>grant</code> 是授权命令，<code>revoke</code> 是收回权限命令。</p><h2 id="SQL-运算符"><a href="#SQL-运算符" class="headerlink" title="SQL 运算符"></a>SQL 运算符</h2><blockquote class="pullquote info"><p><strong><code>SQL</code> 元算符分为算术运算符、逻辑运算符和比较运算符，是用来完成列之间或者变量之间的比较和运算的。</strong></p></blockquote><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th style="width:20%">运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加运算，求两个数或表达式相加的和，如 1 + 1</td></tr><tr><td>-</td><td>减运算，求两个数或表达式相减的差，如 4 - 1</td></tr><tr><td>\*</td><td>乘运算，求两个数或表达式相乘的积，如 2 * 2</td></tr><tr><td>\</td><td>除运算，求两个数或表达式相除的商，如 6 / 4</td></tr><tr><td>%</td><td>取模运算，求两个数或表达式相除的余数，如 6 % 4</td></tr></tbody></table><p><br></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th style="width:20%">运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>当且仅当两个布尔表达式都为 true 时，返回 true</td></tr><tr><td>OR</td><td>当且仅当两个布尔表达式都为 false 时，返回 false</td></tr><tr><td>NOT</td><td>布尔表达式的值取反</td></tr></tbody></table><p><br></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table><thead><tr><th style="width:20%">运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;=&gt;</td><td>安全不等于</td></tr></tbody></table><p><br></p><h2 id="SQL-语句之数据增、删、改"><a href="#SQL-语句之数据增、删、改" class="headerlink" title="SQL 语句之数据增、删、改"></a>SQL 语句之数据增、删、改</h2><h3 id="插入数据行"><a href="#插入数据行" class="headerlink" title="插入数据行"></a>插入数据行</h3><p><strong>语法：</strong></p><pre><code class="lang-sql">INSERT [INTO] 表名 [(列名)] VALUES (值列表)
</code></pre><p>给上面的 <code>student</code> 表插入一条数据，姓名为张三，卡号为 <code>100</code>，年龄为 <code>20</code>，城市默认为北京。</p><pre><code class="lang-sql">INSERT INTO `student` (`name`, `idcard`, `age`, `city`)
VALUES (&quot;张三&quot;, &quot;100&quot;, 20, NULL);
</code></pre><blockquote class="pullquote danger"><p><strong>注意事项：</strong></p><ul><li><strong>每次插入一行数据，不能只插入一部分数据，即不能只插入了一个实体的某几列，插入的数据是否有效将严格按照实体的完整性要求来检验；</strong></li><li><strong>每个数据值的数据类型、精度、位数必须要与对应的列名精确匹配，严格按照域的完整性要求来检验；</strong></li><li><strong>不能为标识符指定值（规定），例如作为主键自增的标识列；</strong></li><li><strong>如果某字段设置非空约束，则该列必须插入不为 <code>null</code> 的数据；</strong></li><li><strong>插入数据时还要符合检查性约束的要求，如非空约束、唯一约束等；</strong></li><li><strong>设置了默认值的列，有缺省值时，可以使用 <code>DEFAULT</code> 关键字来代替插入的实际值。</strong></li></ul></blockquote><h3 id="更新数据行"><a href="#更新数据行" class="headerlink" title="更新数据行"></a>更新数据行</h3><p><strong>语法：</strong></p><pre><code class="lang-sql">UPDATE 表名 SET 列名 = 更新值 [WHERE &lt;更新条件&gt;]
</code></pre><p>将 <code>student</code> 表中 <code>id</code> 为 <code>1</code> 的实体的 <code>idcard</code> 列值改为 <code>200</code>，<code>age</code> 列值改为 <code>24</code>。</p><pre><code class="lang-sql">UPDATE `student`
SET `idcard` = &quot;200&quot;, `age` = 24
WHERE `id` = 1 AND `name` = &quot;张三&quot;;
</code></pre><p>将 <code>student</code> 表中 <code>city</code> 列为空的实体 <code>city</code> 列的值设置为 “上海”。</p><pre><code class="lang-sql">UPDATE `student`
SET `city` = &quot;上海&quot;
WHERE `city` IS NULL;
</code></pre><blockquote class="pullquote primary"><p><strong>注意事项：</strong></p><ul><li><strong>更新多列时，列赋值语句之间使用逗号分隔，一定要加更新条件，否则会更新所有的行；</strong></li><li><strong>多个联合条件根据逻辑关系使用 <code>AND</code> 或 <code>OR</code> 连接。</strong></li></ul></blockquote><h3 id="删除数据行"><a href="#删除数据行" class="headerlink" title="删除数据行"></a>删除数据行</h3><p><strong>语法：</strong></p><pre><code class="lang-sql">DELETE [FROM] 表名 [WHERE &lt;删除条件&gt;]
</code></pre><p>删除 <code>student</code> 表中 <code>age</code> 列值为 <code>24</code> 或者 <code>idcard</code> 列值为 <code>200</code> 的实体。</p><pre><code class="lang-sql">DELETE FROM `student`
WHERE `age` = 24 OR `idcard` = 200;
</code></pre><blockquote class="pullquote warning"><p><strong>注意事项：</strong></p><ul><li><strong>删除的是一整行的数据，所以不需要提供列名；</strong></li><li><strong>如果要删除主表数据，则要先删除外键连接对应的子表数据。</strong></li></ul></blockquote><h2 id="SQL-语句之数据查询"><a href="#SQL-语句之数据查询" class="headerlink" title="SQL 语句之数据查询"></a>SQL 语句之数据查询</h2><blockquote class="pullquote default"><p><strong>在 <code>SQL</code> 语句的增、删、改、查中，最繁琐和复杂的就是查询语句，在实际开发中七分查询三分增、删、改的说法一点也不为过，查询语句是在业务中使用最多的语句，所以我们将查询语句与增、删、改分离出来，用这单独的一节来叙述。</strong></p></blockquote><h3 id="查询简介"><a href="#查询简介" class="headerlink" title="查询简介"></a>查询简介</h3><p>查询就是从客户端发出查询，请求数据库服务器，并从数据库返回查询结果的过程，每次执行查询只是从数据表中提取数据，并按照表的方式呈现出来，查询产生的虚拟表并不会保存。</p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><pre><code class="lang-sql">SELECT &lt;列名&gt;
FROM &lt;表名&gt;
[WHERE &lt;查询条件表达式&gt;]
[ORDER BY &lt;排序的列名&gt; [ASC 或 DESC]]
LIMIT &lt;起始索引&gt;, &lt;查询条数&gt;;
</code></pre><p>我们继续操作之前的三张表，查询 “北京” 的学生并按 <code>id</code> 的正序排序。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `city` = &quot;北京&quot;
ORDER BY `id` ASC;
</code></pre><p>上面 <code>SQL</code> 语句中的 <code>*</code> 代表查询表中所有的列，如果查找某些列，列名之间用 <code>,</code> 分隔。</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>在查询数据表的某个列的时候可以通过别名改变查询到虚拟表列的名称，在列的后面使用 <code>AS</code> 关键字加上别名，<code>AS</code> 可以省略。</p><pre><code class="lang-sql">SELECT `name`, `age`, `city` AS `城市`
FROM `student`
WHERE `city` = &quot;北京&quot;
ORDER BY `id` DESC;
</code></pre><h3 id="查询空行"><a href="#查询空行" class="headerlink" title="查询空行"></a>查询空行</h3><p>假设表中的某一列值为 <code>null</code>，我们可以通过 <code>IS</code> 关键字查询这一列值为空的数据。</p><pre><code class="lang-sql">SELECT `name`, `age`, `city`
FROM `student`
WHERE `city` IS NULL
ORDER BY `id` DESC;
</code></pre><h3 id="常量列"><a href="#常量列" class="headerlink" title="常量列"></a>常量列</h3><p>查询一个数据表中没有的列，我们可以在查询时将这一列增加为常量列，如 <code>city</code> 的值都是中国的，我们可以增加一个常量列值都为 “中国”，列名为 <code>country</code>。</p><pre><code class="lang-sql">SELECT `name`, `age`, `city`, &quot;中国&quot; AS `country`
FROM `student`;
</code></pre><h3 id="查询列的不重复数据"><a href="#查询列的不重复数据" class="headerlink" title="查询列的不重复数据"></a>查询列的不重复数据</h3><p>假设查询 <code>student</code> 表中同学们来自那些城市，正常按照 <code>city</code> 列查询，有多条数据的 <code>city</code> 列都来自同一个城市，我们可以使用 <code>DISTINCT</code> 关键字，只保留一个。</p><pre><code class="lang-sql">SELECT DISTINCT `city`
FROM `student`;
</code></pre><h3 id="限制查询条数"><a href="#限制查询条数" class="headerlink" title="限制查询条数"></a>限制查询条数</h3><p><code>LIMIT</code> 关键字用来限制查询返回的条数，后面的值为数字，下面查询 <code>student</code> 表，只返回 <code>3</code> 条数据。</p><pre><code class="lang-sql">SELECT *
FROM `student`
LIMIT 3;
</code></pre><p>当 <code>LIMIT</code> 参数大于一个时，第一个参数代表起始的索引（跳过的条数），第二个参数代表返回的条数，中间用 <code>,</code> 隔开，还是查询 <code>student</code> 表，返回第 <code>4</code> 到 <code>6</code> 条数据。</p><pre><code class="lang-sql">SELECT *
FROM `student`
LIMIT 3, 3;
</code></pre><h3 id="运算符在查询中的使用"><a href="#运算符在查询中的使用" class="headerlink" title="运算符在查询中的使用"></a>运算符在查询中的使用</h3><pre><code class="lang-sql">SELECT 1 + 1; -- 2
SELECT 1 + &quot;1&quot;; -- 2
SELECT 1 + &quot;panda&quot;; -- 1
SELECT 1 + NULL; -- NULL
</code></pre><p>通过上面的例子可以看出在 <code>SQL</code> 语句中，使用算术运算符相加无法起到字符串拼接的作用，会将值转化为数字进行计算，字符串转为数字 <code>0</code>，数字与 <code>null</code> 相加结果为 <code>null</code>，没意义。</p><h3 id="查询语句练习案例"><a href="#查询语句练习案例" class="headerlink" title="查询语句练习案例"></a>查询语句练习案例</h3><p>首先我们将上面的三张表 <code>student</code>，<code>cource</code> 和 <code>score</code> 三张表插入数据。</p><pre><code class="lang-sql">-- 给 student 表插入数据
INSERT INTO `student`
VALUES (&quot;1&quot;, &quot;郭靖&quot;, &quot;1&quot;, &quot;40&quot;, &quot;济南&quot;, &quot;山东省&quot;, &quot;1978-09-03&quot;, 1, &quot;1@qq.com&quot;);
INSERT INTO `student`
VALUES (&quot;2&quot;, &quot;黄蓉&quot;, &quot;2&quot;, &quot;36&quot;, &quot;济南&quot;, &quot;山东省&quot;, &quot;1982-09-03&quot;, 0, &quot;2@qq.com&quot;);
INSERT INTO `student`
VALUES (&quot;3&quot;, &quot;杨过&quot;, &quot;3&quot;, &quot;22&quot;, &quot;终南山&quot;, &quot;陕西省&quot;, &quot;1996-09-03&quot;, 1, &quot;3@qq.com&quot;);
INSERT INTO `student`
VALUES (&quot;4&quot;, &quot;小龙女&quot;, &quot;4&quot;, &quot;28&quot;, &quot;终南山&quot;, &quot;陕西省&quot;, &quot;1990-09-03&quot;, 0, &quot;4@qq.com&quot;);
INSERT INTO `student`
VALUES (&quot;5&quot;, &quot;欧阳锋&quot;, &quot;5&quot;, &quot;70&quot;, &quot;白驼山&quot;, &quot;新疆&quot;, &quot;1948-09-03&quot;, 1, &quot;5@qq.com&quot;);

-- 给 cource 表插入数据
INSERT INTO `course` VALUES (&quot;1&quot;, &quot;语文&quot;);
INSERT INTO `course` VALUES (&quot;2&quot;, &quot;数学&quot;);
INSERT INTO `course` VALUES (&quot;3&quot;, &quot;英语&quot;);

-- 给 score 表插入数据
INSERT INTO `score` VALUES (&quot;1&quot;, &quot;1&quot;, &quot;100&quot;);
INSERT INTO `score` VALUES (&quot;1&quot;, &quot;2&quot;, &quot;90&quot;);
INSERT INTO `score` VALUES (&quot;1&quot;, &quot;3&quot;, &quot;70&quot;);
INSERT INTO `score` VALUES (&quot;2&quot;, &quot;1&quot;, &quot;100&quot;);
INSERT INTO `score` VALUES (&quot;2&quot;, &quot;2&quot;, &quot;40&quot;);
INSERT INTO `score` VALUES (&quot;2&quot;, &quot;3&quot;, &quot;80&quot;);
INSERT INTO `score` VALUES (&quot;3&quot;, &quot;1&quot;, &quot;100&quot;);
INSERT INTO `score` VALUES (&quot;3&quot;, &quot;2&quot;, &quot;60&quot;);
INSERT INTO `score` VALUES (&quot;3&quot;, &quot;3&quot;, &quot;80&quot;);
</code></pre><p><strong>添加数据后的三张表如下图：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/tables.png" alt="表的具体数据"></div><div class="image-caption">表的具体数据</div></figure><p><br></p><p><strong>查询山东省学生的全部信息：</strong></p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `province` = &quot;山东&quot;;
</code></pre><p><strong>查询山东省男学生的全部信息：</strong></p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `province` = &quot;山东&quot; AND `gender` = 1;
</code></pre><p><strong>查询没填写电子邮箱学生的姓名和身份证号：</strong></p><pre><code class="lang-sql">SELECT `name`, `idcard`
FROM `student`
WHERE `email` IS NULL;
</code></pre><p><strong>把学生的成绩按升序排列：</strong></p><pre><code class="lang-sql">SELECT *
FROM `score`
ORDER BY `grade` ASC;
</code></pre><p><strong>课程编号升序排列，成绩降序排列：</strong></p><pre><code class="lang-sql">SELECT *
FROM `score`
ORDER BY `course_id` ASC, `grade` DESC;
</code></pre><h2 id="SQL-语句之模糊查询"><a href="#SQL-语句之模糊查询" class="headerlink" title="SQL 语句之模糊查询"></a>SQL 语句之模糊查询</h2><blockquote class="pullquote primary"><p><strong>在上一节中我们所使用的查询叫 “完整查询” 或 “精准查询”，而本节的 “模糊查询” 是指查询条件不明确，可以尽量多的匹配满足查询条件的数据。</strong></p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>“通配符” 用于代替一个或多个真正的字符，与 <code>LIKE</code> 关键字一起使用，通配符的解释、示例如下表。</p><table><thead><tr><th style="width:15%">通配符</th><th>解释</th><th style="width:20%">示例</th><th style="width:25%">符合条件的值</th></tr></thead><tbody><tr><td>_</td><td>一个任意字符</td><td>LIKE "a_"</td><td>as、ad 等</td></tr><tr><td>%</td><td>任意长度的字符串</td><td>LIKE "c%"</td><td>code、cat 等</td></tr><tr><td>[ ]</td><td>括号中所指定范围内的一个字符</td><td>LIKE "1[35]5"</td><td>135 或 155</td></tr><tr><td>[^]</td><td>不再括号中所指定范围内的一个字符</td><td>LIKE "1[^1-2]5"</td><td>135 或 155 等</td></tr></tbody></table><p>查询 <code>student</code> 表中 <code>email</code> 列是 <code>qq</code> 邮箱的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `emai` LIKE `%qq%`;
</code></pre><p>查询 <code>student</code> 表中姓杨的名字为两个字的所有学生信息。</p><pre><code class="lang-sql">SELECT * FROM `student`
WHERE `name` LIKE &quot;杨_&quot;;
</code></pre><h3 id="BETWEEN…AND…"><a href="#BETWEEN…AND…" class="headerlink" title="BETWEEN…AND…"></a>BETWEEN…AND…</h3><p><code>BETWEEN...AND...</code> 用于查询某一列在指定范围内的记录，包括两个边界。</p><p>查询 <code>score</code> 表中成绩在 <code>80</code> 到 <code>90</code> 范围内的所有学生信息。</p><pre><code class="lang-sql">-- 精准查询
SELECT *
FROM `score`
WHERE `grade` &gt;= 80 AND `grade` &lt;= 90;

-- 模糊查询
SELECT *
FROM `score`
WHERE `grade` BETWEEN 80 AND 90;
</code></pre><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p>查询某一列中的值在列出的内容列表中。</p><p>查询 <code>student</code> 表中 <code>city</code> 列为 “北京” 或 “上海” 或 “杭州” 所有学生的信息。</p><pre><code class="lang-sql">-- 精准查询
SELECT *
FROM `student`
WHERE `city` = &quot;北京&quot; OR `city` = &quot;上海&quot; OR `city` = &quot;杭州&quot;;

-- 模糊查询
SELECT *
FROM `student`
WHERE `city` IN (&quot;北京&quot;, &quot;上海&quot;, &quot;杭州&quot;);
</code></pre><h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>作为主键的标识列，值是会随着数据的增加，自动递增的，且具有 “断号保留” 的特性，随着表中数据的增删，标识列的值会非常混乱，我们可以通过截断表来解决该问题。</p><blockquote class="pullquote success"><p><strong>截断表有两个作用如下：</strong></p><ul><li><strong>使表中数据的标识列的值重新从 <code>1</code> 开始计数；</strong></li><li><strong>清空表中数据。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>使用截断表时，表的列和约束不会改动，使用的前提是表与表之间不能存在外键约束，表之间如果通过外键进行关联，无法清空主表中数据，即无法截断表。</strong></p></blockquote><p><strong>语法：</strong></p><pre><code class="lang-sql">TRUNCATE TABLE 表名
</code></pre><p><strong>截断 student 表：</strong></p><pre><code class="lang-sql">TRUNCATE TABLE `student`;
</code></pre><blockquote class="pullquote danger"><p><strong>截断表操作轻易不要使用，因为普通的 <code>SQL</code> 操作会记录日志，并且可以还原，而 <code>TRUNCATE</code> 操作不会记录日志，并且不可还原，万一删错，彻底完蛋。</strong></p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote class="pullquote default"><p><strong>在 <code>MySQL</code> 中有很多内置的函数帮我们实现一些功能，函数大类可分为普通函数和聚合函数，我们本节主要介绍普通函数，常用的普通函数大概可分为字符函数、数字函数、日期函数和流程控制函数等，还有一些与数据库相关的辅助函数以及自定义函数，都会在本节一一介绍。</strong></p></blockquote><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><h4 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h4><p><code>LENGTH</code> 函数的作用是返回输入字符串的长度。</p><pre><code class="lang-sql">SELECT LENGTH(&quot;panda&quot;); -- 5
SELECT LENGTH(&quot;你好啊&quot;); -- 9
</code></pre><h4 id="CONCAT-和-CONCAT-WS"><a href="#CONCAT-和-CONCAT-WS" class="headerlink" title="CONCAT 和 CONCAT_WS"></a>CONCAT 和 CONCAT_WS</h4><p><code>CONCAT</code> 函数用于将多个字符串拼接成一个字符串，<code>CONCAT_WS</code> 函数用于使用分隔符将多个字符串拼接成一个字符串，第一个参数为分隔符。</p><pre><code class="lang-sql">SELECT CONCAT(&quot;Panda&quot;, &quot;Shen&quot;); -- PandaShen
SELECT CONCAT_WS(&quot;-&quot;, &quot;Hello&quot;, &quot;Panda&quot;, &quot;Shen&quot;); -- Hello-Panda-Shen
</code></pre><h4 id="UPPER-和-LOWER"><a href="#UPPER-和-LOWER" class="headerlink" title="UPPER 和 LOWER"></a>UPPER 和 LOWER</h4><p><code>UPPER</code> 函数用于将字符串转换为大写，<code>LOWER</code> 函数用于将字符串转换为小写。</p><pre><code class="lang-sql">SELECT UPPER(&quot;panda&quot;); -- PANDA
SELECT LOWER(&quot;PANDA&quot;); -- panda
</code></pre><h4 id="SUBSTR"><a href="#SUBSTR" class="headerlink" title="SUBSTR"></a>SUBSTR</h4><p><code>SUBSTR</code> 函数用于截取字符串，第一个参数为源字符串，第二个参数为起始的索引（从 <code>1</code> 开始），第三个参数为截取的长度，不传默认截取后面全部字符串。</p><pre><code class="lang-sql">SELECT SUBSTR(&quot;panda&quot;, 3); -- nda
SELECT SUBSTR(&quot;panda&quot;, 3, 2); -- nd
</code></pre><h4 id="LEFT-和-RIGHT"><a href="#LEFT-和-RIGHT" class="headerlink" title="LEFT 和 RIGHT"></a>LEFT 和 RIGHT</h4><p><code>LEFT</code> 函数和 <code>RIGHT</code> 函数分别代表在字符串取左边或右边的规定位数，第一个参数为源字符串，第二个参数为规定的位数。</p><pre><code class="lang-sql">SELECT LEFT(&quot;panda12345&quot;, 5); -- panda
SELECT RIGHT(&quot;panda12345&quot;, 5); -- 12345
</code></pre><h4 id="INSTR"><a href="#INSTR" class="headerlink" title="INSTR"></a>INSTR</h4><p><code>INSTR</code> 函数用于查找某个字符串在一个源字符串中的起始（第一个匹配到的）索引，第一个参数为源字符串，第二个参数为查询字符串，查询不到返回 <code>0</code>。</p><pre><code class="lang-sql">SELECT INSTR(&quot;panda&quot;, &quot;a&quot;); -- 2
SELECT INSTR(&quot;panda&quot;, &quot;x&quot;); -- 0
</code></pre><h4 id="LTRIM、RTRIM-和-TRIM"><a href="#LTRIM、RTRIM-和-TRIM" class="headerlink" title="LTRIM、RTRIM 和 TRIM"></a>LTRIM、RTRIM 和 TRIM</h4><p><code>LTRIM</code> 函数用于去掉字符串左侧空格，<code>RTRIM</code> 用于去掉字符串右侧空格，<code>TRIM</code> 用于去掉字符串两侧的空格，如果 <code>TRIM</code> 的参数将两个字符串使用 <code>FROM</code> 连接，则代表去掉右侧字符串左右两侧的左侧字符串（说的有点绕，看例子）。</p><pre><code class="lang-sql">SELECT LTRIM(&quot;  panda&quot;); -- panda
SELECT RTRIM(&quot;panda  &quot;); -- panda
SELECT TRIM(&quot;  panda  &quot;); -- panda
SELECT TRIM(&quot;@&quot; FROM &quot;@@panda@@&quot;); -- panda
</code></pre><h4 id="LPAD-和-RPAD"><a href="#LPAD-和-RPAD" class="headerlink" title="LPAD 和 RPAD"></a>LPAD 和 RPAD</h4><p><code>LPAD</code> 函数和 <code>RPAD</code> 函数分别用于向源字符串的左、右按照规定字符串的长度填充定义的字符。</p><pre><code class="lang-sql">SELECT LPAD(&quot;panda&quot;, 10, &quot;@&quot;); -- @@@@@panda
SELECT RPAD(&quot;panda&quot;, 10, &quot;@&quot;); -- panda@@@@@
</code></pre><h4 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h4><p><code>REPLACE</code> 函数用于替换某字符串的部分字符，第一个参数为源字符串，第二个参数为被替换字符，第三个参数为替换字符。</p><pre><code class="lang-sql">SELECT REPLACE(&quot;panda&quot;, &quot;a&quot;, &quot;e&quot;); -- pende
</code></pre><h4 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>id</code> 为 <code>3</code> 学生的邮箱域名。</p><pre><code class="lang-sql">SELECT SUBSTR(`email`, INSTR(`email`, &quot;@&quot;) + 1)
FROM `student`
WHERE `id` = 3;

-- qq.com
</code></pre><p>将 <code>student</code> 表中的邮箱地址全部由小写改成大写。</p><pre><code class="lang-sql">UPDATE `student`
SET `email` = UPPER(`email`);
</code></pre><p>给 <code>student</code> 表新增一列 <code>level</code>，类型为 <code>varchar</code>，值为 <code>1-1</code>、<code>1-2</code>、<code>1-3</code>、<code>2-1</code>、<code>2-2</code> 等，按照 <code>level</code> 列值中 <code>-</code> 的前半段正序排列，后半段逆序排列。</p><pre><code class="lang-sql">SELECT `level`,
SUBSTR(`level`, 1, INSTR(`level`, &quot;-&quot;) - 1),
SUBSTR(`level`, INSTR(`level`, &quot;-&quot;) + 1)
FROM `student`
ORDER BY
SUBSTR(`level`, 1, INSTR(`level`, &quot;-&quot;) - 1) ASC,
SUBSTR(`level`, INSTR(`level`, &quot;-&quot;) + 1) DESC;
</code></pre><p>将 <code>pandashen</code> 转换成 <code>Panda_Shen</code>，将两个单词拆开，并实现首字母大写，其他字符小写，然后用 <code>_</code> 拼接。</p><pre><code class="lang-sql">SELECT
CONCAT(
  CONCAT(
    UPPER(SUBSTR(SUBSTR(&quot;pandashen&quot;, 1, 5), 1, 1)),
    SUBSTR(SUBSTR(&quot;pandashen&quot;, 1, 5), 2)
  ),
  &quot;_&quot;,
  CONCAT(
    UPPER(SUBSTR(SUBSTR(&quot;pandashen&quot;, 6), 1, 1)),
    SUBSTR(SUBSTR(&quot;pandashen&quot;, 6), 2)
  )
);

-- Panda_Shen
</code></pre><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><h4 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h4><p><code>FORMAT</code> 函数用于将数字格式化，第一个参数为要格式化的数字，第二个参数为保留的小数位数，返回值为字符串，整数部分每三位使用 <code>,</code> 分隔。</p><pre><code class="lang-sql">SELECT FORMAT(100000, 2); -- 100,000.00
SELECT FORMAT(100.31111, 3); -- 100.311
SELECT FORMAT(100.31111, 0); -- 100
SELECT FORMAT(423423234.65534453, 2); -- 423,423,234.66
</code></pre><h4 id="CEIL-和-FLOOR"><a href="#CEIL-和-FLOOR" class="headerlink" title="CEIL 和 FLOOR"></a>CEIL 和 FLOOR</h4><p><code>CEIL</code> 函数为向上取整，<code>FLOOR</code> 函数为向下取整。</p><pre><code class="lang-sql">SELECT CEIL(2.4); -- 3
SELECT FLOOR(2.4); -- 2
</code></pre><h4 id="ROUND-和-TRUNCATE"><a href="#ROUND-和-TRUNCATE" class="headerlink" title="ROUND 和 TRUNCATE"></a>ROUND 和 TRUNCATE</h4><p><code>ROUND</code> 函数为四舍五入，<code>TRUNCATE</code> 函数为小数截断，第一个参数为截断的数字，第二个参数为保留的小数位数。</p><pre><code class="lang-sql">SELECT ROUND(2.1); -- 2
SELECT ROUND(2.5); -- 3
SELECT TRUNCATE(1.66, 0); -- 1
SELECT TRUNCATE(1.66, 1); -- 1.6
SELECT TRUNCATE(1.66, 2); -- 1.66
SELECT TRUNCATE(1.66, 3); -- 1.66
</code></pre><h4 id="POWER"><a href="#POWER" class="headerlink" title="POWER"></a>POWER</h4><p><code>POWER</code> 函数用于幂运算，第一个参数为底数，第二个参数为指数。</p><pre><code class="lang-sql">SELECT POWER(2, 3); -- 8
</code></pre><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p><code>MOD</code> 函数用于取余运算，第一个参数为被除数，第二个参数为除数。</p><pre><code class="lang-sql">SElECT MOD(10, 3); -- 1
</code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="NOW、CURDATE-和-CURTIME"><a href="#NOW、CURDATE-和-CURTIME" class="headerlink" title="NOW、CURDATE 和 CURTIME"></a>NOW、CURDATE 和 CURTIME</h4><p><code>NOW</code> 函数用于获取当前的时间，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURDATE</code> 函数用于获取当前日期，格式为 <code>yyyy-mm-dd hh:mm:ss</code>，<code>CURTIME</code> 函数用于获取当前时间，格式为 <code>hh:mm:ss</code>，返回类型均为日期格式。</p><pre><code class="lang-sql">SELECT NOW(); -- 2018-08-09 19:23:18
SELECT CURDATE(); -- 2018-08-09
SELECT CURTIME(); -- 19:25:31
</code></pre><h4 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h4><p><code>DATE_ADD</code> 函数用于增加时间，即将时间求和，第一个参数为 <code>yyyy-mm-dd hh:mm:ss</code> 格式的时间，第二个参数为时间间隔，<code>INTERVAL</code> 关键字代表时间间隔，后面跟上数字，单位为 <code>DAY</code>、<code>MONTH</code>、<code>YEAR</code> 等，返回类型为字符串。</p><pre><code class="lang-sql">SELECT DATE_ADD(NOW(), INTERVAL 365 DAY); -- 2019-08-09 19:30:15
SELECT DATE_ADD(NOW(), INTERVAL 1 MONTH); -- 2018-09-09 19:30:15
SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR); -- 2019-08-09 19:30:15
</code></pre><h4 id="STR-TO-DATE"><a href="#STR-TO-DATE" class="headerlink" title="STR_TO_DATE"></a>STR_TO_DATE</h4><p><code>STR_TO_DATE</code> 函数可以将一个日期格式的字符串转换成日期，第一个参数为日期格式的字符串，第二个参数为日期的格式描述，如 <code>%Y-%m-%d</code>，传入的日期字符串的格式与日期格式描述必须保持一致。</p><pre><code class="lang-sql">SELECT STR_TO_DATE(&quot;2018-08-09&quot;, &quot;%Y-%m-%d&quot;); -- 2018-08-09
SELECT STR_TO_DATE(&quot;2018/08/09&quot;, &quot;%Y/%m/%d&quot;); -- 2018-08-09
SELECT STR_TO_DATE(&quot;2018.08.09&quot;, &quot;%Y.%m.%d&quot;); -- 2018-08-09
</code></pre><p>从 <code>student</code> 表中查询一个生日（列名为 <code>birthday</code>）为 <code>1982</code> 年 <code>9</code> 月 <code>3</code> 的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `birthday` = STR_TO_DATE(&#39;09-03 1982&#39;,&#39;%m-%d %Y&#39;);

-- 结果查到了黄蓉的信息
</code></pre><p><strong>格式描述参考下表：</strong></p><table><thead><tr><th style="width:20%">序号</th><th style="width:20%">格式符</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>%Y</td><td>4 位的年份</td></tr><tr><td>2</td><td>%y</td><td>2 位的年份</td></tr><tr><td>3</td><td>%m</td><td>月份（01，02）</td></tr><tr><td>4</td><td>%c</td><td>月份（1，2）</td></tr><tr><td>5</td><td>%d</td><td>日（01，02）</td></tr><tr><td>6</td><td>%H</td><td>小时（24 小时制）</td></tr><tr><td>7</td><td>%h</td><td>小时（12 小时制）</td></tr><tr><td>8</td><td>%i</td><td>分钟（00，01）</td></tr><tr><td>9</td><td>%s</td><td>秒（00，01）</td></tr></tbody></table><p><br></p><h4 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT"></a>DATE_FORMAT</h4><p><code>DATE_FORMAT</code> 函数与 <code>STR_TO_DATE</code> 作用正好相反，是将一个日期类型按照格式描述转换成日期字符串，第一个参数为日期对象，第二个参数为日期的格式描述。</p><pre><code class="lang-sql">SELECT DATE_FORMAT(STR_TO_DATE(&quot;2018-08-09&quot;, &quot;%Y-%m-%d&quot;), &quot;%Y年%m月%d日&quot;);

-- 2018年08月09日
</code></pre><h4 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h4><p><code>DATEDIFF</code> 函数用于计算时间间隔，两个参数均为日期对象，得到的结果为第一个与第二个的差值，单位为 “天”。</p><pre><code class="lang-sql">SELECT DATEDIFF(NOW(), STR_TO_DATE(&quot;2018-08-08&quot;, &quot;%Y-%m-%d&quot;)); -- 1
</code></pre><p>通过查询 <code>student</code> 的 <code>birthday</code> 列计算每个人的年龄（周岁）。</p><pre><code class="lang-sql">SELECT FLOOR(DATEDIFF(NOW(), `birthday`) / 365)
FROM `student`;
</code></pre><h4 id="返回日期中指定的部分"><a href="#返回日期中指定的部分" class="headerlink" title="返回日期中指定的部分"></a>返回日期中指定的部分</h4><blockquote class="pullquote info"><p><strong>下面方法传入参数均为日期对象，返回的时间中对应的部分均为字符串：</strong></p><ul><li><strong><code>YEAR</code>：返回年；</strong></li><li><strong><code>MONTH</code>：返回月；</strong></li><li><strong><code>DAY</code>：返回日；</strong></li><li><strong><code>HOUR</code>：返回小时；</strong></li><li><strong><code>MINUTE</code>：返回分钟；</strong></li><li><strong><code>SECOND</code>：返回秒；</strong></li><li><strong><code>MONTHNAME</code>：返回月份名称（英文）。</strong></li></ul></blockquote><pre><code class="lang-sql">SELECT YEAR(NOW()); -- 2018
SELECT MONTH(NOW()); -- 8
SELECT DAY(NOW()); -- 9
SELECT HOUR(NOW()); -- 19
SELECT MINUTE(NOW()); -- 48
SELECT SECOND(NOW()); -- 53
SELECT MONTHNAME(NOW()); -- August
</code></pre><h4 id="综合练习-1"><a href="#综合练习-1" class="headerlink" title="综合练习"></a>综合练习</h4><p>查询 <code>student</code> 表中出生月份是 <code>9</code> 月的学生。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE MONTH(`birthday`) = 9;
</code></pre><p>查询 <code>student</code> 表中生日是今天的学生。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE MONTH(NOW()) = MONTH(`birthday`) AND DAY(NOW()) = DAY(`birthday`);
</code></pre><p>在 <code>student</code> 表中查询年龄超过 <code>18</code> 岁的男同学。</p><pre><code class="lang-sql">-- 写法 1：求生日与现在时间的差值转换成年与年龄比较
SELECT *
FROM `student`
WHERE DATEDIFF(NOW(), `birthday`) / 365 &gt; 18;
</code></pre><pre><code class="lang-sql">-- 写法 2：给生日加上 18 年看看是否大于今天的时间
SELECT *
FROM `student`
WHERE DATE_ADD(`birthday`, INTERVAL 18 YEAR) &lt; NOW();
</code></pre><pre><code class="lang-sql">-- 写法 3：获取今天时间的年份和生日的年份做差，看是否大于 18
SELECT *
FROM `student`
WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; 18;
</code></pre><h3 id="数据库辅助函数"><a href="#数据库辅助函数" class="headerlink" title="数据库辅助函数"></a>数据库辅助函数</h3><h4 id="CONNECTION-ID"><a href="#CONNECTION-ID" class="headerlink" title="CONNECTION_ID"></a>CONNECTION_ID</h4><p>连接每个数据库都会分配对应的连接号，我们称为连接 <code>ID</code>，<code>CONNECTION_ID</code> 函数可以帮我们获取连接 <code>ID</code>。</p><pre><code class="lang-sql">SELECT CONNECTION_ID(); -- 10
</code></pre><h4 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h4><p><code>DATABASE</code> 函数用于查看当前的连接的数据库，返回数据库名称。</p><pre><code class="lang-sql">SELECT DATABASE(); -- school
</code></pre><h4 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h4><p><code>VERSION</code> 函数用来查看当前 <code>MySQL</code> 数据库的版本号。</p><pre><code class="lang-sql">SELECT VERSION(); -- 5.5.61
</code></pre><h4 id="LAST-INSERT-ID"><a href="#LAST-INSERT-ID" class="headerlink" title="LAST_INSERT_ID"></a>LAST_INSERT_ID</h4><p><code>LAST_INSERT_ID</code> 可以获取上次向表中（任意表）插入数据时，插入数据的 <code>id</code> 号。</p><pre><code class="lang-sql">select LAST_INSERT_ID(); -- 0
</code></pre><h4 id="USER-和-PASSWORD"><a href="#USER-和-PASSWORD" class="headerlink" title="USER 和 PASSWORD"></a>USER 和 PASSWORD</h4><p><code>USER</code> 用于查询当前数据库登录的用户。</p><pre><code class="lang-sql">SELECT USER(); -- root@
</code></pre><p>在 <code>MySQL</code> 数据库中存在一张表存放着 <code>MySQL</code> 当前所有的用户，可以通过下面命令查询。</p><pre><code class="lang-sql">SELECT * FROM mysql.user;
</code></pre><p>通过查询结果可以看出密码的位置存储的是密文，如果要修改密码需要将设置的密码转换成密文进行存储，<code>PASSWORD</code> 函数就是来做这件事的，修改密码命令如下。</p><pre><code class="lang-sql">UPDATE FROM mysql.user
SET `password` = PASSWORD(&quot;123456&quot;);
</code></pre><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p><code>MD5</code> 可以将传入的字符串进行一个 <code>MD5</code> 散列算法的转换并输出。</p><pre><code class="lang-sql">SELECT MD5(&quot;panda&quot;); -- ce61649168c4550c2f7acab92354dc6e
</code></pre><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><h4 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h4><p><code>IF</code> 函数可以根据传入的判断条件在两个结果中进行选择输出。</p><pre><code class="lang-sql">SELECT IF(1 &gt; 2, &quot;yes&quot;, &quot;no&quot;); -- no
</code></pre><h4 id="CASE、WHEN、THEN、ELSE-和-END"><a href="#CASE、WHEN、THEN、ELSE-和-END" class="headerlink" title="CASE、WHEN、THEN、ELSE 和 END"></a>CASE、WHEN、THEN、ELSE 和 END</h4><p><code>CASE</code>、<code>WHEN</code>、<code>THEN</code>、<code>ELSE</code> 和 <code>END</code> 共同组成了一个流程控制函数，可以代替多个 <code>IF</code>，<code>CASE</code> 为条件判断起始关键字，<code>WHEN</code> 为判断条件关键字（可以有多个），<code>THEN</code> 为输出结果关键字，<code>ELSE</code> 为默认输出关键字，<code>END</code> 为流程结束关键字。</p><pre><code class="lang-sql">SELECT `grade`,
CASE
WHEN `grade` &gt; 90 THEN &quot;优&quot;
WHEN `grade` &gt; 80 THEN &quot;良&quot;
WHEN `grade` &gt; 70 THEN &quot;中&quot;
WHEN `grade` &gt; 60 THEN &quot;及格&quot;
ELSE &quot;不及格&quot;
END
FROM `score`;
</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><blockquote class="pullquote default"><ul><li><strong>自定义函数是对 <code>MySQL</code> 的扩展，使用方式和内置函数相同；</strong></li><li><strong>函数必须要有参数和返回值，函数可以接收任意类型的值和参数，返回值只能有一个；</strong></li><li><strong>函数体由合法的 <code>SQL</code> 语句组成，可以包含声明、循环和流程控制，也可以是 <code>SELECT</code> 或 <code>INSERT</code> 语句，如果函数体是复合结构（多条语句）要用 <code>BEGIN...END</code>。</strong></li></ul></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="lang-sql">CREATE FUNCTION FUNC_NAME RETURNS {String|Integer}
BODY
RETURN VALUE
</code></pre><p><code>CREATE FUNCTION</code> 为创建函数关键字，<code>FUNC_NAME</code> 为函数的名字，<code>RETURNS</code> 为返回类型关键字，<code>{ }</code> 中的内容为返回值类型，如 <code>varchar</code> 等，<code>BODY</code> 代表函数体，<code>RETURN VALUE</code> 代表返回值。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>写一个自定义函数用于获取中文格式的当前时间。</p><pre><code class="lang-sql">-- 函数 ZHNOW
CREATE FUNCTION ZHNOW() RETURNS VARCHAR(64)
RETURN DATE_FORMAT(NOW(), &quot;%Y年%m月%d日&quot;);

-- 使用 ZHNOW
SELECT ZHNOW(); -- 2018年08月10日
</code></pre><p>实现一个自定义函数对两个数字进行相乘运算并将结果返回。</p><pre><code class="lang-sql">-- 函数 MYPRODUCT，参数为两个数字
CREATE FUNCTION MYPRODUCT(n INT, m INT) RETURNS INT
RETURN n * m;

-- 使用 MYPRODUCT
SELECT MYPRODUCT(2, 5); -- 10
</code></pre><p>针对上面的 <code>course</code> 学科表，写一个自定义函数用来增加学科并返回增加数据的 <code>id</code> 值。</p><pre><code class="lang-sql">-- 函数 ADD_COURSE，参数为添加课程的名称
CREATE FUNCTION ADD_COURSE(name VARCHAR(32)) RETURNS INT
BEGIN
INSERT INTO `course` (`name`)
VALUES (name);
RETURN LAST_INSERT_ID();
END

-- 使用 ADD_COURSE
SELECT ADD_COURSE(&quot;体育&quot;); -- 4
</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><blockquote class="pullquote info"><p><strong>上一节中的函数都是普通函数，多用于操作表达式后返回结果，而聚合函数更多是对一组值进行计算，并返回计算后的值，一般用来统计数据，使用难度要大于普通函数。</strong></p></blockquote><h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><p><code>SUM</code> 函数用于累加所有行的值。</p><p>还是以上面的 <code>score</code> 表为例，我们取出 <code>student_id</code> 值为 <code>1</code> 的学生全部科目的总成绩。</p><pre><code class="lang-sql">SELECT SUM(`grade`)
FROM `score`
WHERE `student_id` = 1; -- 260
</code></pre><p>其实上面的操作是分为两部分进行，首先先查出 <code>student_id</code> 为 <code>1</code> 的所有学科的成绩，在对这些成绩进行求和计算后返回。</p><h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><p><code>AVG</code> 函数用于计算所有行的平均值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>3</code> 的学生全部科目成绩的平均值。</p><pre><code class="lang-sql">SELECT AVG(`grade`)
FROM `score`
WHERE `student_id` = 3; -- 80
</code></pre><h3 id="MAX-和-MIN"><a href="#MAX-和-MIN" class="headerlink" title="MAX 和 MIN"></a>MAX 和 MIN</h3><p><code>MAX</code> 和 <code>MIN</code> 分别用于计算所有行的最大值和最小值。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>2</code> 的学生全部科目成绩的最大值和最小值。</p><pre><code class="lang-sql">SELECT MAX(`grade`), MIN(`grade`)
FROM `score`
WHERE `student_id` = 2; -- 100 40
</code></pre><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p><code>COUNT</code> 按照某一列统计所有行的总条数，如果参照的列值为 <code>null</code> 则不统计在内。</p><p>在 <code>score</code> 表中查询 <code>student_id</code> 值为 <code>1</code> 的学生成绩总数。</p><pre><code class="lang-sql">SELECT COUNT(`grade`)
FROM `score`
WHERE `student_id` = 1; -- 3
</code></pre><h2 id="SQL-语句之分组聚合"><a href="#SQL-语句之分组聚合" class="headerlink" title="SQL 语句之分组聚合"></a>SQL 语句之分组聚合</h2><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组查询就是按某一列或某几列的值进行分组，相同的值分为一组，然后可以对组内使用聚合函数分别进行统计。</p><p><strong>以 <code>score</code> 表为例，分组表示图如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/group.jpg" alt="成绩表分组数据"></div><div class="image-caption">成绩表分组数据</div></figure><p><br></p><p><strong>语法：</strong></p><pre><code class="lang-sql">SELECT 列名, 查询表达式
FROM  &lt;表名&gt;
GROUP BY &lt;分组字段&gt;
</code></pre><p><code>GROUP BY</code> 关键字用于对筛选后的结果进行分组。</p><p><strong>例子：</strong></p><p>统计 <code>score</code> 表中每位同学的平均成绩（单列分组，对 <code>student_id</code> 进行分组）。</p><pre><code class="lang-sql">SELECT `student_id`, AVG(`grade`)
FROM `score`
GROUP BY `student_id`;
</code></pre><p>统计 <code>score</code> 表中每门课程的最高分（单列分组，对 <code>course_id</code> 进行分组），并按照分数从低到高排序。</p><pre><code class="lang-sql">SELECT `course_id`, MAX(`grade`)
FROM `score`
GROUP BY `course_id`
ORDER BY `grade` ASC;
</code></pre><p>统计 <code>student</code> 表中各省男女同学人数（多列分组，按照 <code>province</code> 和 <code>gender</code> 进行分组）。</p><pre><code class="lang-sql">SELECT `province`, `gender`, COUNT(*)
FROM `student`
GROUP BY `province`, `gender`;
</code></pre><p><code>COUNT</code> 中的 <code>*</code> 代表任意一列。</p><h3 id="分组筛选"><a href="#分组筛选" class="headerlink" title="分组筛选"></a>分组筛选</h3><p><strong>语法：</strong></p><pre><code class="lang-sql">SELECT 列名, 查询表达式
FROM  &lt;表名&gt;
WHERE  &lt;条件&gt;
GROUP BY &lt;分组字段&gt;
HAVING 分组后的过滤条件
ORDER BY 列名 [ASC, DESC]
LIMIT 偏移量, 条数
</code></pre><p><code>WHERE</code> 用于过滤掉不符合条件的记录，<code>HAVING</code> 用于过滤分组后的记录。</p><blockquote class="pullquote warning"><p><strong>注意：上面查询的关键字不一定每条查询语句都要有，但是如果有其中的某些关键字，一定要按照上面的顺序进行。</strong></p></blockquote><p><strong>例子：</strong></p><p>统计 <code>student</code> 表中学生人数多于一个的省份。</p><pre><code class="lang-sql">SELECT `province`, COUNT(*)
FROM `student`
GROUP BY `province`
HAVING COUNT(*) &gt; 1;
</code></pre><p>统计 <code>score</code> 表中不及格次数大于 <code>1</code> 的学生按逆序排列并取前 <code>3</code> 条。</p><pre><code class="lang-sql">SELECT `student_id`, COUNT(*)
FROM `score`
WHERE `grade` &lt; 60
GROUP BY `student_id`
HAVING COUNT(`grade`) &gt; 1
ORDER BY COUNT(`grade`) DESC
LIMIT 0, 3;
</code></pre><h2 id="SQL-语句之子查询"><a href="#SQL-语句之子查询" class="headerlink" title="SQL 语句之子查询"></a>SQL 语句之子查询</h2><blockquote class="pullquote danger"><p><strong>子查询的注意点：</strong></p><ul><li><strong>子查询是出现在其他 SQL 语句中的 <code>SELECT</code> 语句；</strong></li><li><strong>子查询嵌套在查询内部，且必须写在圆括号中，外层可以是 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>SET</code> 等；</strong></li><li><strong>子查询可以包含多个关键字或条件；</strong></li><li><strong>子查询可以返回常量、一行数据、一列数据或其它子查询（返回多行数据需使用其他关键字处理）。</strong></li></ul></blockquote><h3 id="比较运算符连接子查询"><a href="#比较运算符连接子查询" class="headerlink" title="比较运算符连接子查询"></a>比较运算符连接子查询</h3><p>在查询通过 <code>WHERE</code> 进行条件筛选时，可以使用比较运算符连接子查询。</p><p>查询年龄大于平均年龄的学生。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; (
  SELECT AVG(YEAR(NOW()) - YEAR(`birthday`))
  FROM `student`
);
</code></pre><h3 id="IN-和-NOT-IN"><a href="#IN-和-NOT-IN" class="headerlink" title="IN 和 NOT IN"></a>IN 和 NOT IN</h3><p>当查询一张表的数据需要另一张表中的数据作为筛选条件时，可以在查询时通过 <code>IN</code> 和 <code>NOT IN</code> 关键字连接子查询。</p><p>查询 <code>student</code> 有不及格成绩的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `id` IN (
  SELECT DISTINCT `student_id`
  FROM `score`
  WHERE `grade` &lt; 60
);

-- 结果查到了黄蓉
</code></pre><p>上面例子查到了 “黄蓉” 同学的信息，如果将 <code>IN</code> 修改为 <code>NOT IN</code> 则会查询到除 “黄蓉” 以外其他同学的信息。</p><p>查询 <code>student</code> 表中在 <code>score</code> 表中有成绩的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE student.id IN (
  SELECT DISTINCT `student_id`
  FROM `score`
);
</code></pre><h3 id="EXISTS-和-NOT-EXISTS"><a href="#EXISTS-和-NOT-EXISTS" class="headerlink" title="EXISTS 和 NOT EXISTS"></a>EXISTS 和 NOT EXISTS</h3><p><code>EXISTS</code> 和 <code>NOT EXISTS</code> 关键字用于连接子查询，代表 “存在” 或 “不存在” 的意思，接收的子查询返回为数据为布尔值。</p><p>拿上面查询 <code>student</code> 表在 <code>score</code> 表中有成绩学生信息的例子，使用 <code>EXISTS</code> 实现查询。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE EXISTS (
  SELECT `student_id`
  FROM `score`
  WHERE score.student_id = student.id
);
</code></pre><blockquote class="pullquote success"><p><strong><code>IN</code>、<code>NOT IN</code> 与 <code>EXISTS</code>、<code>NOT EXISTS</code> 比较，后者的性能更高，查询速度更快，因为判断是在子查询内部，<code>EXISTS</code>、<code>NOT EXISTS</code> 只需要判断布尔值就可以了，<code>IN</code>、<code>NOT IN</code> 在子查询返回数据的基础上还要再次过滤。</strong></p></blockquote><h3 id="ALL、SOME-和-ANY"><a href="#ALL、SOME-和-ANY" class="headerlink" title="ALL、SOME 和 ANY"></a>ALL、SOME 和 ANY</h3><p>当子查询返回了多条数据的时候，可以使用 <code>ALL</code>、<code>SOME</code> 和 <code>ANY</code> 关键字作为比较运算符和子查询之间的连接。</p><blockquote class="pullquote warning"><ul><li><strong><code>ALL</code> 关键字代表全部，即查询的数据筛选条件要去和所有子查询返回的比较并都满足；</strong></li><li><strong><code>SOME</code> 关键字代表某些，查询数据筛选条件只要满足子查询返回数据的某些条即可；</strong></li><li><strong><code>ANY</code> 关键字代表任何一个，查询数据的筛选条件只要满足子查询返回数据的任意一条即可。</strong></li></ul></blockquote><p>查询 <code>student</code> 表中年龄大于等于所有人的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `age` &gt;= ALL (
  SELECT `age`
  FROM `student`
);

-- 结果查到了欧阳锋
</code></pre><p>查询 <code>student</code> 表中年龄大于某些人的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `age` &gt; SOME (
  SELECT `age`
  FROM `student`
);

-- 结果查到除杨过以外的所有人（因为杨过年龄最小）
</code></pre><p>查询 <code>student</code> 表中年龄大于任意一个人的学生信息。</p><pre><code class="lang-sql">SELECT *
FROM `student`
WHERE `age` &gt; ANY (
  SELECT `age`
  FROM `student`
);

-- 返回结果同 SOME 没区别
</code></pre><h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><h3 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h3><blockquote class="pullquote info"><p><strong>在 MySQL 中的表连接类型：</strong></p><ul><li><strong><code>INNER JOIN</code>：内连接，代表取两张关联表的交集，可以用 <code>JOIN</code> 关键字代替；</strong></li><li><strong><code>LEFT</code>：左外连接，代表取两张表的交集后再和左侧表求并集，即包含左侧表全部数据；</strong></li><li><strong><code>RIGHT</code>：右外连接，代表取两张表的交际后再和右侧表求并集，即包含右侧表全部数据。</strong></li></ul></blockquote><p><strong>三种连接类型表示如下图：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/table-join.jpg" alt="表连接类型韦恩图"></div><div class="image-caption">表连接类型韦恩图</div></figure><p><br></p><h3 id="连接条件-ON"><a href="#连接条件-ON" class="headerlink" title="连接条件 ON"></a>连接条件 ON</h3><p><code>ON</code> 关键字用来设定表的连接条件，也可以使用 <code>WHERE</code> 对结果进行过滤的方式来代替。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用内连接。</p><pre><code class="lang-sql">SELECT *
FROM `student`
INNER JOIN `score` ON student.id = score.student_id;
</code></pre><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/inner-join-result.png" alt="内连接查询结果"></div><div class="image-caption">内连接查询结果</div></figure><p><br></p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用左外连接。</p><pre><code class="lang-sql">SELECT *
FROM `student`
LEFT JOIN `score` ON student.id = score.student_id;
</code></pre><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/left-join-result.png" alt="左外连接查询结果"></div><div class="image-caption">左外连接查询结果</div></figure><p><br></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>对 <code>student</code> 和 <code>score</code> 两张表使用右外连接。</p><pre><code class="lang-sql">SELECT *
FROM `student`
RIGHT JOIN `score` ON student.id = score.student_id;
</code></pre><p><strong>查询结果如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180809115245/right-join-result.png" alt="右外连接查询结果"></div><div class="image-caption">右外连接查询结果</div></figure><p><br></p><h4 id="多表连接案例"><a href="#多表连接案例" class="headerlink" title="多表连接案例"></a>多表连接案例</h4><p>连接 <code>student</code>、<code>score</code> 和 <code>course</code> 三张表，分别查询学生姓名、学科和分数。</p><pre><code class="lang-sql">SELECT student.name, course.name, score.grade
FROM `score`
INNER JOIN `student` ON student.id = score.student_id
INNER JOIN `course` ON course.id = score.course_id;
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>到此 <code>MySQL</code> 系列文章的第二篇就结束了，本篇的大部分都是和操作数据库的 <code>SQl</code> 语句相关的知识点，里面涵盖了基本的增、删、改、查以及函数、聚合函数的应用等，如果记不住的话（当然我也记不住，只是负责替大家和我自己整理）建议收藏，在使用时随时查阅，这一篇的内容对于前端而言，可以说基本够用了。</strong></p></blockquote>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL —— 数据库基础</title>
    <url>/20180808012303/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/SQL/20180808012303/mysql-use.png" title="MySQL"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>MySQL</code> 是目前使用最广泛的关系型数据库，是在软件开发中所必备的技能之一，这是关于 <code>MySQL</code> 的系列文章，将从 <code>MySQL</code> 的基本概念、基本使用、<code>SQL</code> 语句、函数、聚合函数、表连接以及表设计等多方面对 <code>MySQL</code> 进行总结，而本篇是数据库基础部分，大多都是一些概念性的内容和表的创建，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 <code>MySQL</code> 的入门。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote default"><p><strong>系列文章：</strong></p><ul><li><a href="/20180809115245/" target="_blank">MySQL —— SQL 语句总结</a></li><li><a href="/20180814131241/" target="_blank">MySQL —— 简单聊一聊数据库设计</a></li></ul></blockquote><h2 id="MySQL-的基本概念"><a href="#MySQL-的基本概念" class="headerlink" title="MySQL 的基本概念"></a>MySQL 的基本概念</h2><blockquote class="pullquote warning"><ul><li><p><strong><code>MySQL</code> 的特点：开源免费、性能高、安装使用简单。</strong></p></li><li><p><strong><code>MySQL</code> 的作用：</strong></p><ul><li><strong>存储大量数据，方便检索和访问；</strong></li><li><strong>保持数据信息的一致、完整；</strong></li><li><strong>实现数据的共享和安全；</strong></li><li><strong>通过组合分析产生新的有用信息。</strong></li></ul></li><li><p><strong>实体：只要是客观存在，能够被描述出来的都是实体，每一条数据都是一个实体。</strong></p></li><li><p><strong><code>DB</code>：是数据库的意思，就是存储数据的仓库，可以存放结构化的数据。</strong></p></li><li><p><strong><code>DBMS</code>：代表数据管理系统，是一种系统软件，提供操作数据库的环境，如 <code>Navicat for MySQL</code>，可以通过数据库管理系统对数据进行增、删、改、查。</strong></p></li><li><p><strong><code>SQL</code>：结构化查询语言，专门用来和数据库进行交流的语言，几乎所有的 <code>DBMS</code> 都支持 <code>SQL</code>。</strong></p></li><li><p><strong>数据表：</strong></p><ul><li><strong>表是数据库中包含所有数据的数据库对象，也是其他对象的基础；</strong></li><li><strong>表定义是一个集合，数据在表中是按行和列的格式组织的，用来存放数据；</strong></li><li><strong>行被称为记录，用来存放一个实体，列称为字段用来描述实体的某一个属性。</strong></li></ul></li></ul></blockquote><h2 id="MySQL-的配置和命令"><a href="#MySQL-的配置和命令" class="headerlink" title="MySQL 的配置和命令"></a>MySQL 的配置和命令</h2><h3 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><blockquote class="pullquote danger"><p><strong>在 <code>MySQL</code> 的默认安装目录中 <code>my.ini</code> 文件是专门用来配置的，常用配置项如下：</strong></p><ul><li><strong><code>port</code>：端口号；</strong></li><li><strong><code>basedir</code>：安装目录；</strong></li><li><strong><code>datadir</code>：数据存放目录；</strong></li><li><strong><code>charcter-set-server</code>：字符集；</strong></li><li><strong><code>default-storage-engine</code>：存储引擎；</strong></li><li><strong><code>sql-mode</code>：语法模式；</strong></li><li><strong><code>max-connections</code>：最大连接数。</strong></li></ul></blockquote><h3 id="MySQL-命令"><a href="#MySQL-命令" class="headerlink" title="MySQL 命令"></a>MySQL 命令</h3><p><strong><code>MySQL</code> 服务启动和停止：</strong></p><pre><code class="lang-sql">net start MySQL
net stop MySQL
</code></pre><p><strong>连接和退出数据库：</strong></p><pre><code class="lang-sql">mysql -h 127.0.0.1 -P 3306 -uroot -p123456
exit
</code></pre><p><code>-h</code> 代表主机名，<code>-p</code> 代表端口号，<code>-u</code> 和 <code>-p</code> 分别代表当前 <code>MySQL</code> 服务的账号和密码。</p><p><strong>查看当前 <code>MySQL</code> 中的数据库：</strong></p><pre><code class="lang-sql">show dbs;
show database;
</code></pre><p><strong>切换数据库：</strong></p><pre><code class="lang-sql">use dataname;
</code></pre><p><strong>查看数据库的表：</strong></p><pre><code class="lang-sql">show tables;
show tables from mysql;
</code></pre><p><strong>查看当前所在的数据库：</strong></p><pre><code class="lang-sql">select database();
</code></pre><p><strong>查询表结构：</strong></p><pre><code class="lang-sql">desc tablename;
</code></pre><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>数据完整性是指，数据库种所有数据值均为正确状态，如果数据存储有不正确的的数据值，则该数据库丧失数据完整性，为了实现数据完整性，需要检验数据库表中每行每列的数据是否符合要求，在创建表时，应该保证以后输入的数据都是正确的，错误的数据不允许输入。</p><h3 id="域（列）完整性"><a href="#域（列）完整性" class="headerlink" title="域（列）完整性"></a>域（列）完整性</h3><p>域完整性是对数据表中字段属性的约束，通常指数据的有效性，它包括字段的值域、字段的类型及字段的有效规则等约束，它是由确定关系结构时所定义的字段的属性决定的，如关于年龄的字段，数据类型应为 <code>int</code>，关于普通的字符串值得类型应该为 <code>varchar</code> 等等，并在规定值类型时相应得规定值的长度，即所占的字节数。</p><p><strong>数据类型图如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180808012303/fields-type.png" alt="数据类型图"></div><div class="image-caption">数据类型图</div></figure><p><br></p><blockquote class="pullquote success"><p><strong>数值类型整数型：</strong></p><ul><li><strong><code>tinyint</code>：存储所占 <code>1</code> 字节，无符号可以存储 <code>0</code> ~ <code>255</code>，有符号可以存储 <code>-128</code> ~ <code>127</code>；</strong></li><li><strong><code>smallint</code>：存储所占 <code>2</code> 字节，无符号可以存储 <code>0</code> ~ <code>65535</code>，有符号可以存储 <code>-32768</code> ~ <code>32767</code>；</strong></li><li><strong><code>mediumint</code>：存储所占 <code>3</code> 字节，无符号可以存储 <code>0</code> ~ <code>16777215</code>，有符号可以存储 <code>-8388608</code> ~ <code>8388607</code>；</strong></li><li><strong><code>int</code>：存储所占 <code>4</code> 字节，无符号可以存储 <code>0</code> ~ <code>4294967295</code>，有符号可以存储 <code>-2147483648</code> ~ <code>2147483647</code>；</strong></li><li><strong><code>bigint</code>：存储所占 <code>8</code> 字节，无符号可以存储 <code>0</code> ~ <code>18446744073709551615</code>，有符号可以存储 <code>-9223372036854775808</code> ~ <code>9223372036854775807</code>。</strong></li></ul></blockquote><p>上面的整数型用来规定字段存储的数据必须为整数，从上到下需要占用的空间越来越多，能表示的数字也越来越大，定义字段时选择满足需求的数字范围即可。</p><blockquote class="pullquote primary"><p><strong>数值类型小数型：</strong></p><ul><li><strong><code>float</code>：单精度浮点型，存储所占 <code>4</code> 字节，数值范围为 <code>-3.4E38 ~ 3.4E38</code>，<code>7</code> 个有效位；</strong></li><li><strong><code>double</code>：双精度浮点型，存储所占 <code>8</code> 字节，数值范围为 <code>-1.7E308~1.7E308</code>，<code>15</code> 个有效位；</strong></li><li><strong><code>decimal</code>：定点型，存储所占 <code>16</code> 字节，<code>28</code> 个有效位，不存在精度损失，常用于银行账目计算。</strong></li></ul></blockquote><p>数值存储范围越小，精度越高，范围越大，精度越不准确，既要求精度，又固定小数点位数的数值存储，建议使用 <code>decimal</code>，优点在于可以自定义小数点位数，精度高，特殊情况，数值范围巨大，只能使用 <code>float</code> 类型，该类型一般不建议使用。</p><blockquote class="pullquote info"><p><strong>字符串类型：</strong></p><ul><li><strong><code>set</code>：存储字符串对象，最多包含 <code>64</code> 个元素，并且可以取到集合中任意元素；</strong></li><li><strong><code>enum</code>：存储字符串对象，最多包含 <code>65536</code> 个元素，只能取到集合中一个元素；</strong></li><li><strong><code>blob</code>：用于存储二进制字符串，有子类型；</strong></li><li><strong><code>text</code>：用于存储大文本，有子类型；</strong></li><li><strong><code>char</code>：定长，最大 <code>255</code> 字节，存储空间未满，会在数据右侧填充空格；</strong></li><li><strong><code>varchar</code>：不定长，最大 <code>65536</code> 字节，当长度小于 <code>4</code> 时，会自动转换成 <code>char</code>。</strong></li></ul></blockquote><p>上面类型中最常用的为 <code>varchar</code> 可以根据字段内容的自定义长度。</p><blockquote class="pullquote warning"><p><strong>时间类型：</strong></p><ul><li><strong><code>year</code>：<code>yyyy</code> 格式表示的年份值；</strong></li><li><strong><code>timestamp</code>：<code>yyyymmddhhmmss</code> 格式表示的时间戳；</strong></li><li><strong><code>time</code>：<code>hh:mm:ss</code> 格式表示的时间值；</strong></li><li><strong><code>date</code>：<code>yyyy-mm-dd</code> 格式表示的日期值；</strong></li><li><strong><code>datetime</code>：<code>yyyy-mm-dd hh:mm:ss</code> 格式表示的日期和时间。</strong></li></ul></blockquote><blockquote class="pullquote primary"><ul><li><p><strong>默认值：默认值是指如果某个字段没有指定值的情况下，会为该字段指定一个预先设定的值。</strong></p></li><li><p><strong>非空约束：我们可以指定某个字段不能不输入，必须提供一个非空的值，即不能为 <code>null</code>。</strong></p></li></ul></blockquote><h3 id="实体（行）完整性"><a href="#实体（行）完整性" class="headerlink" title="实体（行）完整性"></a>实体（行）完整性</h3><p>实体完整性是对关系中的记录唯一性，也就是主键的约束，准确地说，实体完整性是指关系中的主属性值不能为 <code>null</code> 且不能有相同值，定义表中的所有行唯一的标识，一般用主键。</p><blockquote class="pullquote success"><ul><li><p><strong>主键：表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不能重复，如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为 “组合主键”。</strong></p></li><li><p><strong>主键的选择标准：</strong></p><ul><li><strong>最少性：尽量选择单个键作为主键；</strong></li><li><strong>稳定性：由于主键是用来在两个表之间建立关联的，不能经常更新或者说一般不更新，所以最好选择无意义的列作为主键，如各种 <code>id</code> 值。</strong></li></ul></li></ul></blockquote><h3 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h3><p>引用完整性意思是对关系型数据库中建立关联关系的数据表之间数据参照引用的约束，也就是对外键的约束，准确地说，是指关系中的外键必须是另一个关系的主键有效值，或者是 <code>null</code>，参考完整性，维护表间数据的有效性，完整性，通常通过建立外部键联系另一张关联表的主键实现。</p><blockquote class="pullquote danger"><p><strong>外键：用于连接两张表的字段称为外键，属于外键表，通常要关联的主键表的字段作为外键，保证了引用完整性。</strong></p><p><strong>外键约束：外键表的外键必须引用主键表的主键，主表没有记录。</strong></p><p><strong>如果一个表的外键引用了一个表的主键会有以下限制：</strong></p><ul><li><strong>在外键表里不能添加主键表里没有的数据，外键表的数据与主键表的数据必须通过外键一一对应；</strong></li><li><strong>要想删除主键表的数据必须删除所有外键表的数据。</strong></li></ul><p><strong>唯一约束：唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值，如某个人的身份证号，需将外键的索引类型设置为 <code>Unique</code>。</strong></p><p><strong>标识列：当表中没有适合做主键的列时，此时创建作为主键的无意义列称为标识列，标识列的值是自动生成的，不能输入修改，且是自增的，可以设置每次的增量，具有 “断号保留” 的特性，当某一个实体被删除时，该标识列的值是永久保存的，其他新增实体会在这个标识列的基础上继续自增。</strong></p></blockquote><h2 id="DDL-数据定义语言的使用"><a href="#DDL-数据定义语言的使用" class="headerlink" title="DDL 数据定义语言的使用"></a>DDL 数据定义语言的使用</h2><blockquote class="pullquote default"><p><strong>我们可以通过两种方式创建表，可以使用 <code>DDL</code>（<code>data defintion language</code>）数据定义语言来创建，也可以使用 <code>DBMS</code> 数据管理系统来创建，使用 <code>DBMS</code> 还是很方便的，而且也是最常用的方式，但 <code>DDL</code> 创建方式我们不得不说，就是通过代码的方式来实现表的创建和操作，因为这是最原始的方式，即使图形化的操作会更方便，我们也应该了解。</strong></p></blockquote><h3 id="SQL-规范"><a href="#SQL-规范" class="headerlink" title="SQL 规范"></a>SQL 规范</h3><blockquote class="pullquote success"><p><strong><code>SQL</code> 语句的规范如下：</strong></p><ul><li><strong><code>SQL</code> 语句不区分大小写，建议 <code>SQL</code> 关键字大写，表名和列表小写；</strong></li><li><strong>命令用分号结尾；</strong></li><li><strong>命令可以缩进和换行，一种类型的关键字放在一行；</strong></li><li><strong>可以写单行和多行注释 , <code>#</code> 和 <code>--</code> 是单行注释， <code>/*/</code> 是多行注释。</strong></li></ul></blockquote><h3 id="使用-DDL-操作表"><a href="#使用-DDL-操作表" class="headerlink" title="使用 DDL 操作表"></a>使用 DDL 操作表</h3><p>在 DBMS 中的查询编辑器可以代替命令行实现命令的编写，为了视觉效果，我们都使用 <code>Navicat for MySQL</code> 的查询编辑器，操作界面如下图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180808012303/navicat-mysql.png" alt="Navicat For MySQL 操作界面"></div><div class="image-caption">Navicat For MySQL 操作界面</div></figure><p><br></p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>创建表 <code>student</code>，创建一个标识列 <code>id</code> 不为空，设为主键并自增，创建 <code>name</code> 列，<code>varchar</code> 类型，<code>64</code> 位，不为空，创建 <code>age</code> 列，<code>int</code> 类型，不为空，创建 <code>city</code> 列，<code>varchar</code> 类型，<code>32</code> 位，默认值为 “北京”。</p><pre><code class="lang-sql">CREATE TABLE `student`
(
  `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(64) NOT NULL,
  `age` INT NOT NULL,
  `city` VARCHAR(32) DEFAULT &quot;北京&quot;
);
</code></pre><h4 id="操作表的列"><a href="#操作表的列" class="headerlink" title="操作表的列"></a>操作表的列</h4><p>给上面的表 <code>student</code> 增加 <code>idcard</code> 列，值为空，将 <code>idcard</code> 列类型大小修改为 <code>32</code> 位，添加 <code>province</code> 列，插入到 <code>city</code> 列前面，查询表结构，删除 <code>idcard</code> 列，删除表 <code>student</code>。</p><pre><code class="lang-sql">ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL;
ALTER TABLE `student` MODIFY COLUMN `idcard` VARCHAR(32) NULL;
ALTER TABLE `student` ADD COLUMN `province` VARCHAR(32) AFTER `age`;
DESC `student`;
ALTER TABLE `student` DROP COLUMN `idcard`;
DROP TABLE `student`;
</code></pre><h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><p>重新创建上面的 <code>student</code> 表，<code>city</code> 不设置默认值，不添加主键约束和标识列，再通过命令添加主键约束。</p><pre><code class="lang-sql">CREATE TABLE `student`
(
  `id` INT NOT NULL,
  `name` VARCHAR(64) NOT NULL,
  `age` INT NOT NULL,
  `city` VARCHAR(32)
);
ALTER TABLE `student` ADD PRIMARY KEY(id);
</code></pre><h4 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h4><p>将上面我们 <code>student</code> 表中的 <code>idcard</code> 列再加回来，给 <code>idcard</code> 列添加唯一约束，外键名为 <code>uq_idcard</code>。</p><pre><code class="lang-sql">ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL;
ALTER TABLE `student` ADD UNIQUE INDEX uq_idcard(`idcard`);
</code></pre><h4 id="添加默认约束"><a href="#添加默认约束" class="headerlink" title="添加默认约束"></a>添加默认约束</h4><p>将 <code>student</code> 表 <code>city</code> 列的默认值设置为 “北京”。</p><pre><code class="lang-sql">ALTER TABLE `student` MODIFY COLUMN `city` VARCHAR(64) DEFAULT &quot;北京&quot;;
</code></pre><h4 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h4><p>创建一个子表 <code>score</code>，添加 <code>student_id</code> 列，添加外键 <code>fk_student_id</code>，将 <code>student_id</code> 与 <code>student</code> 表的主键 <code>id</code> 相关联，此时 <code>student</code> 为主表（主键表），<code>score</code> 为子表（外键表）。</p><pre><code class="lang-sql">CREATE TABLE `score`
(
  `student_id` INT
);
ALTER TABLE `score` ADD CONSTRAINT `fk_student_id`
FOREIGN KEY (`student_id`)
REFERENCES `student` (`id`);
</code></pre><blockquote class="pullquote danger"><p><em><strong>注意：在项目中一般不会添加这个约束，因为在开发时会频繁操作表和修改数据，会经常报错，非常麻烦，不添加这个约束并不影响数据的检索和修改。</strong></em></p></blockquote><h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><p>删除 <code>score</code> 表与 <code>student</code> 表的外键约束，即删除外键 <code>fk_student_id</code>。</p><pre><code class="lang-sql">ALTER TABLE `score` DROP FOREIGN KEY `fk_student_id`;
</code></pre><h3 id="使用-DDL-创建一个完整的表关系"><a href="#使用-DDL-创建一个完整的表关系" class="headerlink" title="使用 DDL 创建一个完整的表关系"></a>使用 DDL 创建一个完整的表关系</h3><p><strong>完整的表关系图如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/SQL/20180808012303/student-score-course.png" alt="完整表关系图"></div><div class="image-caption">完整表关系图</div></figure><p><br></p><p><strong><code>DDL</code> 命令如下：</strong></p><pre><code class="lang-sql">-- 创建表 student
CREATE TABLE `student` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(50) NOT NULL,
  `idcard` VARCHAR(18) DEFAULT NULL,
  `age` INT(11) DEFAULT NULL,
  `city` VARCHAR(50) DEFAULT &quot;北京&quot;,
  PRIMARY KEY (`id`)
);

-- 创建表 course
CREATE TABLE `course` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
);

-- 创建表 score，并添加外键约束
CREATE TABLE `score` (
  `student_id` INT(11) NOT NULL DEFAULT &quot;0&quot;,
  `course_id` INT(11) NOT NULL DEFAULT &quot;0&quot;,
  `grade` FLOAT DEFAULT NULL,
  PRIMARY KEY (`student_id`, `course_id`),
  KEY `fk_courseid` (`course_id`),
  CONSTRAINT `fk_courseid`
  FOREIGN KEY (`course_id`) REFERENCES `course` (`id`),
  CONSTRAINT `fk_student_id`
  FOREIGN KEY (`student_id`) REFERENCES `student` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre><blockquote class="pullquote warning"><p><em><strong>在实际开发当中使用 <code>DDL</code> 对表的编辑并不多，因为命令繁琐，在效率上，使用 <code>DBMS</code> 效率更高，但是 <code>DDL</code> 是学习 <code>MySQL</code> 数据库的根本之一，应该会写。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>到此 <code>MySQL</code> 系列文章的第一篇就结束了，里面大部分内容都是关于 <code>MySQL</code> 数据库的概念以及表的创建，非常枯燥，但又是初学 <code>MySQL</code> 所必须要懂的知识点，相信大家通过本节已经对 MySQL 有了一定的认识，那么下一篇将是重中之重，是在开发中经常使用的 <code>DML</code> 数据库操作语言，也就是我们平时所说的 <code>SQL</code> 语句，在此期待我们的下一篇</strong> <a href="/20180809115245/" target="_blank">《MySQL —— SQL 语句总结》</a><strong>。</strong></p></blockquote>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 核心模块 tapable 解析</title>
    <url>/20180806184412/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20180806184412/tapable.png" title="tapable"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>Webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块构建工具，是对前端项目实现工程化和优化必不可少的工具，<code>Webpack</code> 的 <code>loader</code>（加载器）和 <code>plugin</code>（插件）是由 <code>Webpack</code> 开发者和社区开发者共同贡献的，而目前又没有比较系统的开发文档，想写加载器和插件最好对要 <code>Webpack</code> 的原理有所了解，<code>tapable</code> 则是 <code>Webpack</code> 依赖的核心库，是 <code>Webpack</code> 中很重要的部分，所以本篇会对 <code>tapable</code> 提供的类进行解析和模拟。</strong></p></blockquote><a id="more"></a><h2 id="tapable-介绍"><a href="#tapable-介绍" class="headerlink" title="tapable 介绍"></a>tapable 介绍</h2><blockquote class="pullquote success"><p><strong><code>Webpack</code> 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 <code>tapable</code>，<code>Webpack</code> 中最核心的，负责编译的 <code>Compiler</code> 和负责创建 <code>bundles</code> 的 <code>Compilation</code> 都是 <code>tapable</code> 构造函数的实例。</strong></p></blockquote><p>打开 <code>Webpack 4.0</code> 的源码中一定会看到下面这些以 <code>Sync</code>、<code>Async</code> 开头，以 <code>Hook</code> 结尾的方法，这些都是 <code>tapable</code> 核心库的类，为我们提供不同的事件流执行机制，我们称为 “钩子”。</p><pre><code class="lang-js">/* 引入 tapable 如下 */
const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
 } = require(&#39;tapable&#39;);
</code></pre><blockquote class="pullquote warning"><p><em><strong>上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。</strong></em></p></blockquote><h2 id="Sync-类型的钩子"><a href="#Sync-类型的钩子" class="headerlink" title="Sync 类型的钩子"></a>Sync 类型的钩子</h2><h3 id="SyncHook"><a href="#SyncHook" class="headerlink" title="SyncHook"></a>SyncHook</h3><p><code>SyncHook</code> 为串行同步执行，不关心事件处理函数的返回值，在触发事件之后，会按照事件注册的先后顺序执行所有的事件处理函数。</p><pre><code class="lang-js">/* SyncHook 钩子的使用 */
const { SyncHook } = require(&#39;tapable&#39;);

// 创建实例
const syncHook = new SyncHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
syncHook.tap(&#39;1&#39;, (name, age) =&gt; console.log(&#39;1&#39;, name, age));
syncHook.tap(&#39;2&#39;, (name, age) =&gt; console.log(&#39;2&#39;, name, age));
syncHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age));

// 触发事件，让监听函数执行
syncHook.call(&#39;panda&#39;, 18);

// 1 panda 18
// 2 panda 18
// 3 panda 18
</code></pre><blockquote class="pullquote danger"><p><strong>在 <code>tapable</code> 解构的 <code>SyncHook</code> 是一个类，注册事件需先创建实例，创建实例时支持传入一个数组，数组内存储事件触发时传入的参数名称，实例的 <code>tap</code> 方法用于注册事件，支持传入两个参数：</strong></p><ul><li><strong>第一个参数为事件名称，在 <code>Webpack</code> 中一般用于存储事件对应的插件名称（名字随意，只是起到注释作用）；</strong></li><li><strong>第二个参数为事件处理函数，在实例调用 <code>call</code> 后执行，形参为创建实例时所定义，通过 <code>call</code> 调用传入实参；</strong></li></ul></blockquote><pre><code class="lang-js">/* 模拟 SyncHook 类 */
class SyncHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    // 也可在参数不足时抛出异常
    if (args.length &lt; this.args.length) throw new Error(&#39;参数不足&#39;);

    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 依次执行事件处理函数
    this.tasks.forEach(task =&gt; task(...args));
  }
}
</code></pre><p><code>tasks</code> 数组用于存储事件处理函数，<code>call</code> 方法调用时传入参数超过创建 <code>SyncHook</code> 实例传入的数组长度时，多余参数可处理为 <code>undefined</code>，也可在参数不足时抛出异常，不灵活，后面的例子中就不再这样写了。</p><h3 id="SyncBailHook"><a href="#SyncBailHook" class="headerlink" title="SyncBailHook"></a>SyncBailHook</h3><p><code>SyncBailHook</code> 同样为串行同步执行，如果事件处理函数执行时有一个返回值不为空（即返回值不为 <code>undefined</code>），则跳过剩下未执行的事件处理函数（如类的名字，意义在于保险）。</p><pre><code class="lang-js">/* SyncBailHook 钩子的使用 */
const { SyncBailHook } = require(&#39;tapable&#39;);

// 创建实例
const syncBailHook = new SyncBailHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
syncBailHook.tap(&#39;1&#39;, (name, age) =&gt; console.log(&#39;1&#39;, name, age));

syncBailHook.tap(&#39;2&#39;, (name, age) =&gt; {
  console.log(&#39;2&#39;, name, age);
  return &#39;2&#39;; // 返回值不为空
});

syncBailHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age));

// 触发事件，让监听函数执行
syncBailHook.call(&#39;panda&#39;, 18);

// 1 panda 18
// 2 panda 18
</code></pre><p>通过上面的用法可以看出，<code>SyncHook</code> 和 <code>SyncBailHook</code> 在逻辑上只是 <code>call</code> 方法不同，导致事件的执行机制不同，对于后面其他的 “钩子”，也是 <code>call</code> 的区别，接下来实现 <code>SyncBailHook</code> 类。</p><pre><code class="lang-js">/* 模拟 SyncBailHook 类 */
class SyncBailHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 依次执行事件处理函数，如果返回值不为空，则停止向下执行
    let i = 0, ret;
    do {
      ret = this.tasks[i++](...args);
    } while (!ret);
  }
}
</code></pre><p>在上面代码的 <code>call</code> 方法中，我们设置返回值为 <code>ret</code>，第一次执行后没有返回值则继续循环执行，如果有返回值则立即停止循环，即实现 “保险” 的功能。</p><h3 id="SyncWaterfallHook"><a href="#SyncWaterfallHook" class="headerlink" title="SyncWaterfallHook"></a>SyncWaterfallHook</h3><p><code>SyncWaterfallHook</code> 为串行同步执行，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，依次类推，正因如此，只有第一个事件处理函数的参数可以通过 <code>call</code> 传递，而 <code>call</code> 的返回值为最后一个事件处理函数的返回值。</p><pre><code class="lang-js">/* SyncWaterfallHook 钩子的使用 */
const { SyncWaterfallHook } = require(&#39;tapable&#39;);

// 创建实例
const syncWaterfallHook = new SyncWaterfallHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
syncWaterfallHook.tap(&#39;1&#39;, (name, age) =&gt; {
  console.log(&#39;1&#39;, name, age);
  return &#39;1&#39;;
});

syncWaterfallHook.tap(&#39;2&#39;, data =&gt; {
  console.log(&#39;2&#39;, data);
  return &#39;2&#39;;
});

syncWaterfallHook.tap(&#39;3&#39;, data =&gt; {
  console.log(&#39;3&#39;, data);
  return &#39;3&#39;
});

// 触发事件，让监听函数执行
const ret = syncWaterfallHook.call(&#39;panda&#39;, 18);
console.log(&#39;call&#39;, ret);

// 1 panda 18
// 2 1
// 3 2
// call 3
</code></pre><p><code>SyncWaterfallHook</code> 名称中含有 “瀑布”，通过上面代码可以看出 “瀑布” 形象生动的描绘了事件处理函数执行的特点，与 <code>SyncHook</code> 和 <code>SyncBailHook</code> 的区别就在于事件处理函数返回结果的流动性，接下来看一下 <code>SyncWaterfallHook</code> 类的实现。</p><pre><code class="lang-js">/* 模拟 SyncWaterfallHook 类 */
class SyncWaterfallHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 依次执行事件处理函数，事件处理函数的返回值作为下一个事件处理函数的参数
    const [first, ...others] = this.tasks;
    return others.reduce((ret, task) =&gt; task(ret), first(...args));
  }
}
</code></pre><p>上面代码中 <code>call</code> 的逻辑是将存储事件处理函数的 <code>tasks</code> 拆成两部分，分别为第一个事件处理函数，和存储其余事件处理函数的数组，使用 <code>reduce</code> 进行归并，将第一个事件处理函数执行后的返回值作为归并的初始值，依次调用其余事件处理函数并传递上一次归并的返回值。</p><h3 id="SyncLoopHook"><a href="#SyncLoopHook" class="headerlink" title="SyncLoopHook"></a>SyncLoopHook</h3><p><code>SyncLoopHook</code> 为串行同步执行，事件处理函数返回 <code>true</code> 表示继续循环，即循环执行当前事件处理函数，返回 <code>undefined</code> 表示结束循环，<code>SyncLoopHook</code> 与 <code>SyncBailHook</code> 的循环不同，<code>SyncBailHook</code> 只决定是否继续向下执行后面的事件处理函数，而 <code>SyncLoopHook</code> 的循环是指循环执行每一个事件处理函数，直到返回 <code>undefined</code> 为止，才会继续向下执行其他事件处理函数，下一个事件处理函数执行机制同理。</p><pre><code class="lang-js">/* SyncLoopHook 钩子的使用 */
const { SyncLoopHook } = require(&#39;tapable&#39;);

// 创建实例
const syncLoopHook = new SyncLoopHook([&#39;name&#39;, &#39;age&#39;]);

// 定义辅助变量
let total1 = 0;
let total2 = 0;

// 注册事件
syncLoopHook.tap(&#39;1&#39;, (name, age) =&gt; {
  console.log(&#39;1&#39;, name, age, total1);
  return total1++ &lt; 2 ? true : undefined;
});

syncLoopHook.tap(&#39;2&#39;, (name, age) =&gt; {
  console.log(&#39;2&#39;, name, age, total2);
  return total2++ &lt; 2 ? true : undefined;
});

syncLoopHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age));

// 触发事件，让监听函数执行
syncLoopHook.call(&#39;panda&#39;, 18);

// 1 panda 18 0
// 1 panda 18 1
// 1 panda 18 2
// 2 panda 18 0
// 2 panda 18 1
// 2 panda 18 2
// 3 panda 18
</code></pre><blockquote class="pullquote danger"><p><strong>通过上面的执行结果可以清楚的看到 <code>SyncLoopHook</code> 的执行机制，但有一点需要注意，返回值必须严格是 <code>true</code> 才会触发循环，多次执行当前事件处理函数，必须严格返回 <code>undefined</code>，才会结束循环去执行后面的事件处理函数，如果事件处理函数的返回值不是 <code>true</code> 也不是 <code>undefined</code>，则会死循环。</strong></p></blockquote><p>在了解 <code>SyncLoopHook</code> 的执行机制以后，我们接下来看看 <code>SyncLoopHook</code> 的 <code>call</code> 方法是如何实现的。</p><pre><code class="lang-js">/* 模拟 SyncLoopHook 类 */
class SyncLoopHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 依次执行事件处理函数，如果返回值为 true，则继续执行当前事件处理函数
    // 直到返回 undefined，则继续向下执行其他事件处理函数
    this.tasks.forEach(task =&gt; {
      let ret;
      do {
        ret = this.task(...args);
      } while (ret === true || !(ret === undefined));
    });
  }
}
</code></pre><p>在上面代码中可以看到 <code>SyncLoopHook</code> 类 <code>call</code> 方法的实现更像是 <code>SyncHook</code> 和 <code>SyncBailHook</code> 的 <code>call</code> 方法的结合版，外层循环整个 <code>tasks</code> 事件处理函数队列，内层通过返回值进行循环，控制每一个事件处理函数的执行次数。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>Sync</code> 类型 “钩子” 下执行的插件都是顺序执行的，只能使用 <code>tab</code> 注册。</strong></em></p></blockquote><h2 id="Async-类型的钩子"><a href="#Async-类型的钩子" class="headerlink" title="Async 类型的钩子"></a>Async 类型的钩子</h2><blockquote class="pullquote info"><p><strong><code>Async</code> 类型可以使用 <code>tap</code>、<code>tapAsync</code> 和 <code>tapPromise</code> 注册不同类型的插件 “钩子”，分别通过 <code>call</code>、<code>callAsync</code> 和 <code>promise</code> 方法调用，我们下面会针对 <code>AsyncParallelHook</code> 和 <code>AsyncSeriesHook</code> 的 <code>async</code> 和 <code>promise</code> 两种方式分别介绍和模拟。</strong></p></blockquote><h3 id="AsyncParallelHook"><a href="#AsyncParallelHook" class="headerlink" title="AsyncParallelHook"></a>AsyncParallelHook</h3><p><code>AsyncParallelHook</code> 为异步并行执行，通过 <code>tapAsync</code> 注册的事件，通过 <code>callAsync</code> 触发，通过 <code>tapPromise</code> 注册的事件，通过 <code>promise</code> 触发（返回值可以调用 <code>then</code> 方法）。</p><h4 id="tapAsync-callAsync"><a href="#tapAsync-callAsync" class="headerlink" title="tapAsync/callAsync"></a>tapAsync/callAsync</h4><p><code>callAsync</code> 的最后一个参数为回调函数，在所有事件处理函数执行完毕后执行。</p><pre><code class="lang-js">/* AsyncParallelHook 钩子：tapAsync/callAsync 的使用 */
const { AsyncParallelHook } = require(&#39;tapable&#39;);

// 创建实例
const asyncParallelHook = new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
console.time(&#39;time&#39;);
asyncParallelHook.tapAsync(&#39;1&#39;, (name, age, done) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;1&#39;, name, age, new Date());
    done();
  }, 1000);
});

asyncParallelHook.tapAsync(&#39;2&#39;, (name, age, done) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;2&#39;, name, age, new Date());
    done();
  }, 2000);
});

asyncParallelHook.tapAsync(&#39;3&#39;, (name, age, done) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;3&#39;, name, age, new Date());
    done();
    console.timeEnd(&#39;time&#39;);
  }, 3000);
});

// 触发事件，让监听函数执行
asyncParallelHook.callAsync(&#39;panda&#39;, 18, () =&gt; {
  console.log(&#39;complete&#39;);
});

// 1 panda 18 2018-08-07T10:38:32.675Z
// 2 panda 18 2018-08-07T10:38:33.674Z
// 3 panda 18 2018-08-07T10:38:34.674Z
// complete
// time: 3005.060ms
</code></pre><blockquote class="pullquote success"><p><strong>异步并行是指，事件处理函数内三个定时器的异步操作最长时间为 <code>3s</code>，而三个事件处理函数执行完成总共用时接近 <code>3s</code>，所以三个事件处理函数是几乎同时执行的，不需等待。</strong></p></blockquote><p>所有 <code>tabAsync</code> 注册的事件处理函数最后一个参数都为一个回调函数 <code>done</code>，每个事件处理函数在异步代码执行完毕后调用 <code>done</code> 函数，则可以保证 <code>callAsync</code> 会在所有异步函数都执行完毕后执行，接下来看一看 <code>callAsync</code> 是如何实现的。</p><pre><code class="lang-js">/* 模拟 AsyncParallelHook 类：tapAsync/callAsync */
class AsyncParallelHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tabAsync(name, task) {
    this.tasks.push(task);
  }
  callAsync(...args) {
    // 先取出最后传入的回调函数
    const finalCallback = args.pop();

    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 定义一个 i 变量和 done 函数
    // 每次执行检测 i 值和队列长度，决定是否执行 callAsync 的回调函数
    let i = 0;
    const done = () =&gt; {
      if (++i === this.tasks.length) {
        finalCallback();
      }
    };

    // 依次执行事件处理函数
    this.tasks.forEach(task =&gt; task(...args, done));
  }
}
</code></pre><p>在 <code>callAsync</code> 中，将最后一个参数（所有事件处理函数执行完毕后执行的回调）取出，并定义 <code>done</code> 函数，通过比较 <code>i</code> 和存储事件处理函数的数组 <code>tasks</code> 的 <code>length</code> 来确定回调是否执行，循环执行每一个事件处理函数并将 <code>done</code> 作为最后一个参数传入，所以每个事件处理函数内部的异步操作完成时，执行 <code>done</code> 就是为了检测是不是该执行 <code>callAsync</code> 的回调，当所有事件处理函数均执行完毕满足 <code>done</code> 函数内部 <code>i</code> 和 <code>length</code> 相等的条件时，则调用 <code>callAsync</code> 的回调。</p><h4 id="tapPromise-promise"><a href="#tapPromise-promise" class="headerlink" title="tapPromise/promise"></a>tapPromise/promise</h4><p>要使用 <code>tapPromise</code> 注册事件，对事件处理函数有一个要求，必须返回一个 <code>Promise</code> 实例，而 <code>promise</code> 方法也返回一个 <code>Promise</code> 实例，<code>callAsync</code> 的回调函数在 <code>promise</code> 方法中用 <code>then</code> 的方式代替。</p><pre><code class="lang-js">/* AsyncParallelHook 钩子：tapPromise/promise 的使用 */
const { AsyncParallelHook } = require(&#39;tapable&#39;);

// 创建实例
const asyncParallelHook = new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
console.time(&#39;time&#39;);
asyncParallelHook.tapPromise(&#39;1&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;1&#39;, name, age, new Date());
      resolve(&#39;1&#39;);
    }, 1000);
  });
});

asyncParallelHook.tapPromise(&#39;2&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;2&#39;, name, age, new Date());
      resolve(&#39;2&#39;);
    }, 2000);
  });
});

asyncParallelHook.tapPromise(&#39;3&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;3&#39;, name, age, new Date());
      resolve(&#39;3&#39;);
      console.timeEnd(&#39;time&#39;);
    }, 3000);
  });
});

// 触发事件，让监听函数执行
asyncParallelHook.promise(&#39;panda&#39;, 18).then(ret =&gt; {
  console.log(ret);
});

// 1 panda 18 2018-08-07T12:17:21.741Z
// 2 panda 18 2018-08-07T12:17:22.736Z
// 3 panda 18 2018-08-07T12:17:23.739Z
// time: 3006.542ms
// [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ]
</code></pre><p>上面每一个 <code>tapPromise</code> 注册事件的事件处理函数都返回一个 <code>Promise</code> 实例，并将返回值传入 <code>resolve</code> 方法，调用 <code>promise</code> 方法触发事件时，如果所有事件处理函数返回的 <code>Promise</code> 实例结果都成功，会将结果存储在数组中，并作为参数传递给 <code>promise</code> 的 <code>then</code> 方法成功的回调，如果有一个失败就是将失败的结果返回作为参数传递给失败的回调。</p><pre><code class="lang-js">/* 模拟 AsyncParallelHook 类 tapPromise/promise */
class AsyncParallelHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tapPromise(name, task) {
    this.tasks.push(task);
  }
  promise(...args) {
    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 将所有事件处理函数转换成 Promise 实例，并发执行所有的 Promise
    return Promise.all(this.tasks.map(task =&gt; task(...args)));
  }
}
</code></pre><p>其实根据上面对于 <code>tapPromise</code> 和 <code>promise</code> 使用的描述就可以猜到，<code>promise</code> 方法的逻辑是通过 <code>Promise.all</code> 来实现的。</p><h3 id="AsyncSeriesHook"><a href="#AsyncSeriesHook" class="headerlink" title="AsyncSeriesHook"></a>AsyncSeriesHook</h3><p><code>AsyncSeriesHook</code> 为异步串行执行，与 <code>AsyncParallelHook</code> 相同，通过 <code>tapAsync</code> 注册的事件，通过 <code>callAsync</code> 触发，通过 <code>tapPromise</code> 注册的事件，通过 <code>promise</code> 触发，可以调用 <code>then</code> 方法。</p><h4 id="tapAsync-callAsync-1"><a href="#tapAsync-callAsync-1" class="headerlink" title="tapAsync/callAsync"></a>tapAsync/callAsync</h4><p>与 <code>AsyncParallelHook</code> 的 <code>callAsync</code> 方法类似，<code>AsyncSeriesHook</code> 的 <code>callAsync</code> 方法也是通过传入回调函数的方式，在所有事件处理函数执行完毕后执行 <code>callAsync</code> 的回调函数。</p><pre><code class="lang-js">/* AsyncSeriesHook 钩子：tapAsync/callAsync 的使用 */
const { AsyncSeriesHook } = require(&#39;tapable&#39;);

// 创建实例
const asyncSeriesHook = new AsyncSeriesHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
console.time(&#39;time&#39;);
asyncSeriesHook.tapAsync(&#39;1&#39;, (name, age, next) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;1&#39;, name, age, new Date());
    next();
  }, 1000);
});

asyncSeriesHook.tapAsync(&#39;2&#39;, (name, age, next) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;2&#39;, name, age, new Date());
    next();
  }, 2000);
});

asyncSeriesHook.tapAsync(&#39;3&#39;, (name, age, next) =&gt; {
  settimeout(() =&gt; {
    console.log(&#39;3&#39;, name, age, new Date());
    next();
    console.timeEnd(&#39;time&#39;);
  }, 3000);
});

// 触发事件，让监听函数执行
asyncSeriesHook.callAsync(&#39;panda&#39;, 18, () =&gt; {
  console.log(&#39;complete&#39;);
});

// 1 panda 18 2018-08-07T14:40:52.896Z
// 2 panda 18 2018-08-07T14:40:54.901Z
// 3 panda 18 2018-08-07T14:40:57.901Z
// complete
// time: 6008.790ms
</code></pre><blockquote class="pullquote default"><p><strong>异步串行是指，事件处理函数内三个定时器的异步执行时间分别为 <code>1s</code>、<code>2s</code> 和 <code>3s</code>，而三个事件处理函数执行完总共用时接近 <code>6s</code>，所以三个事件处理函数执行是需要排队的，必须一个一个执行，当前事件处理函数执行完才能执行下一个。</strong></p></blockquote><p><code>AsyncSeriesHook</code> 类的 <code>tabAsync</code> 方法注册的事件处理函数参数中的 <code>next</code> 可以与 <code>AsyncParallelHook</code> 类中 <code>tabAsync</code> 方法参数的 <code>done</code> 进行类比，同为回调函数，不同点在于 <code>AsyncSeriesHook</code> 与 <code>AsyncParallelHook</code> 的 <code>callAsync</code> 方法的 “并行” 和 “串行” 的实现方式。</p><pre><code class="lang-js">/* 模拟 AsyncSeriesHook 类：tapAsync/callAsync */
class AsyncSeriesHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tabAsync(name, task) {
    this.tasks.push(task);
  }
  callAsync(...args) {
    // 先取出最后传入的回调函数
    const finalCallback = args.pop();

    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 定义一个 i 变量和 next 函数，每次取出一个事件处理函数执行，并维护 i 的值
    // 直到所有事件处理函数都执行完，调用 callAsync 的回调
    // 如果事件处理函数中没有调用 next，则无法继续
    let i = 0;
    const next = () =&gt; {
      const task = this.tasks[i++];
      task ? task(...args, next) : finalCallback();
    };
    next();
  }
}
</code></pre><p><code>AsyncParallelHook</code> 是通过循环依次执行了所有的事件处理函数，<code>done</code> 方法只为了检测是否已经满足条件执行 <code>callAsync</code> 的回调，如果中间某个事件处理函数没有调用 <code>done</code>，只是不会调用 <code>callAsync</code> 的回调，但是所有的事件处理函数都执行了。</p><p>而 <code>AsyncSeriesHook</code> 的 <code>next</code> 执行机制更像 <code>Express</code> 和 <code>Koa</code> 中的中间件，在注册事件的回调中如果不调用 <code>next</code>，则在触发事件时会在没有调用 <code>next</code> 的事件处理函数的位置 “卡死”，即不会继续执行后面的事件处理函数，只有都调用 <code>next</code> 才能继续，而最后一个事件处理函数中调用 <code>next</code> 决定是否调用 <code>callAsync</code> 的回调。</p><h4 id="tapPromise-promise-1"><a href="#tapPromise-promise-1" class="headerlink" title="tapPromise/promise"></a>tapPromise/promise</h4><p>与 <code>AsyncParallelHook</code> 类似，<code>tapPromise</code> 注册事件的事件处理函数需要返回一个 <code>Promise</code> 实例，<code>promise</code> 方法最后也返回一个 <code>Promise</code> 实例。</p><pre><code class="lang-js">/* AsyncSeriesHook 钩子：tapPromise/promise 的使用 */
const { AsyncSeriesHook } = require(&#39;tapable&#39;);

// 创建实例
const asyncSeriesHook = new AsyncSeriesHook([&#39;name&#39;, &#39;age&#39;]);

// 注册事件
console.time(&#39;time&#39;);
asyncSeriesHook.tapPromise(&#39;1&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;1&#39;, name, age, new Date());
      resolve(&#39;1&#39;);
    }, 1000);
  });
});

asyncSeriesHook.tapPromise(&#39;2&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;2&#39;, name, age, new Date());
      resolve(&#39;2&#39;);
    }, 2000);
  });
});

asyncParallelHook.tapPromise(&#39;3&#39;, (name, age) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    settimeout(() =&gt; {
      console.log(&#39;3&#39;, name, age, new Date());
      resolve(&#39;3&#39;);
      console.timeEnd(&#39;time&#39;);
    }, 3000);
  });
});

// 触发事件，让监听函数执行
asyncSeriesHook.promise(&#39;panda&#39;, 18).then(ret =&gt; {
  console.log(ret);
});

// 1 panda 18 2018-08-07T14:45:52.896Z
// 2 panda 18 2018-08-07T14:45:54.901Z
// 3 panda 18 2018-08-07T14:45:57.901Z
// time: 6014.291ms
// [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ]
</code></pre><p>分析上面的执行过程，所有的事件处理函数都返回了 <code>Promise</code> 的实例，如果想实现 “串行”，则需要让每一个返回的 <code>Promise</code> 实例都调用 <code>then</code>，并在 <code>then</code> 中执行下一个事件处理函数，这样就保证了只有上一个事件处理函数执行完后才会执行下一个。</p><pre><code class="lang-js">/* 模拟 AsyncSeriesHook 类 tapPromise/promise */
class AsyncSeriesHook {
  constructor(args) {
    this.args = args;
    this.tasks = [];
  }
  tapPromise(name, task) {
    this.tasks.push(task);
  }
  promise(...args) {
    // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined
    args = args.slice(0, this.args.length);

    // 将每个事件处理函数执行并调用返回 Promise 实例的 then 方法
    // 让下一个事件处理函数在 then 方法成功的回调中执行
    const [first, ...others] = this.tasks;
    return others.reduce((promise, task) =&gt; {
      return promise.then(() =&gt; task(...args));
    }, first(...args));
  }
}
</code></pre><p>上面代码中的 “串行” 是使用 <code>reduce</code> 归并来实现的，首先将存储所有事件处理函数的数组 <code>tasks</code> 解构成两部分，第一个事件处理函数和存储其他事件处理函数的数组 <code>others</code>，对 <code>others</code> 进行归并，将第一个事件处理函数执行后返回的 <code>Promise</code> 实例作为归并的初始值，这样在归并的过程中上一个值始终是上一个事件处理函数返回的 <code>Promise</code> 实例，可以直接调用 <code>then</code> 方法，并在 <code>then</code> 的回调中执行下一个事件处理函数，直到归并完成，将 <code>reduce</code> 最后返回的 <code>Promise</code> 实例作为 <code>promise</code> 方法的返回值，则实现 <code>promise</code> 方法执行后继续调用 <code>then</code> 来实现后续逻辑。</p><h2 id="对其他异步钩子补充"><a href="#对其他异步钩子补充" class="headerlink" title="对其他异步钩子补充"></a>对其他异步钩子补充</h2><p>在上面 <code>Async</code> 异步类型的 “钩子中”，我们只着重介绍了 “串行” 和 “并行”（<code>AsyncParallelHook</code> 和 <code>AsyncSeriesHook</code>）以及回调和 <code>Promise</code> 的两种注册和触发事件的方式，还有一些其他的具有一定特点的异步 “钩子” 我们并没有进行分析，因为他们的机制与同步对应的 “钩子” 非常的相似。</p><p><code>AsyncParallelBailHook</code> 和 <code>AsyncSeriesBailHook</code> 分别为异步 “并行” 和 “串行” 执行的 “钩子”，返回值不为 <code>undefined</code>，即有返回值，则立即停止向下执行其他事件处理函数，实现逻辑可结合 <code>AsyncParallelHook</code> 、<code>AsyncSeriesHook</code> 和 <code>SyncBailHook</code>。</p><p><code>AsyncSeriesWaterfallHook</code> 为异步 “串行” 执行的 “钩子”，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，实现逻辑可结合 <code>AsyncSeriesHook</code> 和 <code>SyncWaterfallHook</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>tapable</code> 源码中，注册事件的方法 <code>tab</code>、<code>tapAsync</code>、<code>tapPromise</code> 和触发事件的方法 <code>call</code>、<code>callAsync</code>、<code>promise</code> 都是通过 <code>compile</code> 方法快速编译出来的，我们本文中这些方法的实现只是遵照了 <code>tapable</code> 库这些 “钩子” 的事件处理机制进行了模拟，以方便我们了解 <code>tapable</code>，为学习 <code>Webpack</code> 原理做了一个铺垫，在 <code>Webpack</code> 中，这些 “钩子” 的真正作用就是将通过配置文件读取的插件与插件、加载器与加载器之间进行连接，“并行” 或 “串行” 执行，相信在我们对 <code>tapable</code> 中这些 “钩子” 的事件机制有所了解之后，再重新学习 <code>Webpack</code> 的源码应该会有所头绪。</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>Webpack</tag>
        <tag>tapable</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 多进程和集群</title>
    <url>/20180727140233/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180727140233/multi-processing.png" title="多进程和集群"><p><br></p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><blockquote class="pullquote default"><p><strong>“进程” 是计算机系统进行资源分配和调度的基本单位，我们可以理解为计算机每开启一个任务就会创建至少一个进程来处理，有时会创建多个，如 <code>Chrome</code> 浏览器的选项卡，其目的是为了防止一个进程挂掉而应用停止工作，而 “线程” 是程序执行流的最小单元，<code>Node.js</code> 默认是单进程、单线程的，我们将这个进程称为主进程，也可以通过 <code>child_process</code> 模块创建子进程实现多进程，我们称这些子进程为 “工作进程”，并且归主进程管理，进程之间默认是不能通信的，且所有子进程执行任务都是异步的。</strong></p></blockquote><a id="more"></a><h2 id="spawn-实现多进程"><a href="#spawn-实现多进程" class="headerlink" title="spawn 实现多进程"></a>spawn 实现多进程</h2><h3 id="spawn-创建子进程"><a href="#spawn-创建子进程" class="headerlink" title="spawn 创建子进程"></a>spawn 创建子进程</h3><p>在 <code>Node.js</code> 中执行一个 <code>JS</code> 文件，如果想在这个文件中再同时（异步）执行另一个 <code>JS</code> 文件，可以使用 <code>child_process</code> 模块中的 <code>spawn</code> 来实现，<code>spawn</code> 可以帮助我们创建一个子进程，用法如下。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;, &#39;--port&#39;, &#39;3000&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;) // 指定子进程的当前工作目录
});

// 出现错误触发
child.on(&#39;error&#39;, err =&gt; console.log(err));

// 子进程退出触发
child.on(&#39;exit&#39;, () =&gt; console.log(&#39;exit&#39;));

// 子进程关闭触发
child.on(&#39;close&#39;, () =&gt; console.log(&#39;close&#39;));

// exit
// close
</code></pre><blockquote class="pullquote danger"><p><strong><code>spawn</code> 方法可以帮助我们创建一个子进程，这个方法的返回值就是子进程 <code>id</code>，<code>spawn</code> 接收以下几个参数：</strong></p><ul><li><strong><code>command</code>：要运行的命令；</strong></li><li><strong><code>args</code>：类型为数组，数组内第一项为文件名，后面项依次为执行文件的命令参数和值；</strong></li><li><strong><code>options</code>：选项，类型为对象，用于指定子进程的当前工作目录和主进程、子进程的通信规则等，具体可查看</strong> <a href="http://Node.js.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" target="_blank">官方文档</a><strong>。</strong></li></ul></blockquote><p><code>error</code> 事件在子进程出错时触发，<code>exit</code> 事件在子进程退出时触发，<code>close</code> 事件在子进程关闭后触发，在子进程任务结束后 <code>exit</code> 一定会触发，<code>close</code> 不一定触发。</p><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 打印子进程执行 sub_process.js 文件的参数
console.log(process.argv);
</code></pre><p>通过上面代码打印了子进程执行时的参数，但是我们发现主进程窗口并没有打印，我们希望的是子进程的信息可以反馈给主进程，要实现通信需要在创建子进程时在第三个参数 <code>options</code> 中配置 <code>stdio</code> 属性定义。</p><h3 id="spawn-定义输入、输出"><a href="#spawn-定义输入、输出" class="headerlink" title="spawn 定义输入、输出"></a>spawn 定义输入、输出</h3><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;, &#39;--port&#39;, &#39;3000&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;) // 指定子进程的当前工作目录
  // stdin: [process.stdin, process.stdout, process.stderr]
  stdio: [0, 1, 2] // 配置标准输入、标准输出、错误输出
});

// C:\Program Files\Node.js\node.exe,g:\process\test\sub_process.js,--port,3000
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 使用主进程的标准输出，输出 sub_process.js 文件执行的参数
process.stdout.write(process.argv.toString());
</code></pre><p>通过上面配置 <code>options</code> 的 <code>stdio</code> 值为数组，上面的两种写法作用相同，都表示子进程和主进程共用了主进程的标准输入、标准输出、和错误输出，实际上并没有实现主进程与子进程的通信，其中 <code>0</code> 和 <code>stdin</code> 代表标准输入，<code>1</code> 和 <code>stdout</code> 代表标准输出，<code>2</code> 和 <code>stderr</code> 代表错误输出。</p><p>上面这样的方式只要子进程执行 <code>sub_process.js</code> 就会在窗口输出，如果我们希望是否输出在主进程里面控制，即实现子进程与主进程的通信，看下面用法。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: [&#39;pipe&#39;]
});

child.stdout.on(&#39;data&#39;, data =&gt; console.log(data.toString()));

// hello world
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 子进程执行 sub_process.js
process.stdout.write(&#39;hello world&#39;);
</code></pre><p>上面将 <code>stdio</code> 内数组的值配置为 <code>pipe</code>（默认不写就是 <code>pipe</code>），则通过流的方式实现主进程和子进程的通信，通过子进程的标准输出（可写流）写入，在主进程通过子进程的标准输出通过 <code>data</code> 事件读取的流在输出到窗口（这种写法很少用），上面都只在主进程中开启了一个子进程，下面举一个开启多个进程的例子。</p><p>例子的场景是主进程开启两个子进程，先运行子进程 <code>1</code> 传递一些参数，子进程 <code>1</code> 将参数取出返还给主进程，主进程再把参数传递给子进程 <code>2</code>，通过子进程 <code>2</code> 将参数写入到文件 <code>param.txt</code> 中，这个过程不代表真实应用场景，主要目的是体会主进程和子进程的通信过程。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child1 = spawn(&#39;node&#39;, [&#39;sub_process_1.js&#39;, &#39;--port&#39;, &#39;3000&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
});

const child2 = spawn(&#39;node&#39;, [&#39;sub_process_2.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
});


// 读取子进程 1 写入的内容，写入子进程 2
child1.stdout.on(&#39;data&#39;, data =&gt; child2.stdout.write(data.toString));
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process_1.js */
// 获取 --port 和 3000
process.argv.slice(2).forEach(item =&gt; process.stdout.write(item));
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process_2.js */
const fs = require(&#39;fs&#39;);

// 读取主进程传递的参数并写入文件
process.stdout.on(&#39;data&#39;, data =&gt; {
  fs.writeFile(&#39;param.txt&#39;, data, () =&gt; {
    process.exit();
  });
});
</code></pre><p>有一点需要注意，在子进程 <code>2</code> 写入文件的时候，由于主进程不知道子进程 <code>2</code> 什么时候写完，所以主进程会卡住，需要子进程在写入完成后调用 <code>process.exit</code> 方法退出子进程，子进程退出并关闭后，主进程会随之关闭。</p><p>在我们给 <code>options</code> 配置 <code>stdio</code> 时，数组内其实可以对标准输入、标准输出和错误输出分开配置，默认数组内为 <code>pipe</code> 时代表三者都为 <code>pipe</code>，分别配置看下面案例。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;spawn&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: [0, &#39;pipe&#39;, 2]
});

// world
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
console.log(&#39;hello&#39;);
console.error(&#39;world&#39;);
</code></pre><p>上面代码中对 <code>stderr</code> 实现了默认打印而不通信，对标准输入实现了通信，还有一种情况，如果希望子进程只是默默的执行任务，而在主进程命令窗口什么类型的输出都禁止，可以在数组中对应位置给定值 <code>ignore</code>，将上面案例修改如下。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;spawn&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;]
});
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
console.log(&#39;hello&#39;);
console.error(&#39;world&#39;);
</code></pre><p>这次我们发现无论标准输出和错误输出都没有生效，上面这些方式其实是不太方便的，因为输出有 <code>stdout</code> 和 <code>stderr</code>，在写法上没办法统一，可以通过下面的方式来统一。</p><h3 id="标准进程通信"><a href="#标准进程通信" class="headerlink" title="标准进程通信"></a>标准进程通信</h3><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;spawn&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;, &#39;ipc&#39;]
});

child.on(&#39;message&#39;, data =&gt; {
  console.log(data);

  // 回复消息给子进程
  child.send(&#39;world&#39;);

  // 杀死子进程
  // process.kill(child.pid);
});

// hello
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 给主进程发送消息
process.send(&#39;hello&#39;);

// 接收主进程回复的消息
process.on(&#39;message&#39;, data =&gt; {
  console.log(data);

  // 退出子进程
  process.exit();
});

// world
</code></pre><p>这种方式被称为标准进程通信，通过给 <code>options</code> 的 <code>stdio</code> 数组配置 <code>ipc</code>，只要数组中存在 <code>ipc</code> 即可，一般放在数组开头或结尾，配置 <code>ipc</code> 后子进程通过调用自己的 <code>send</code> 方法发送消息给主进程，主进程中用子进程的 <code>message</code> 事件进行接收，也可以在主进程中接收消息的 <code>message</code> 事件的回调当中，通过子进程的 <code>send</code> 回复消息，并在子进程中用 <code>message</code> 事件进行接收，这样的编程方式比较统一，更贴近于开发者的意愿。</p><h3 id="退出和杀死子进程"><a href="#退出和杀死子进程" class="headerlink" title="退出和杀死子进程"></a>退出和杀死子进程</h3><p>上面代码中子进程在接收到主进程的消息时直接退出，也可以在子进程发送给消息给主进程时，主进程接收到消息直接杀死子进程，代码如下。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;spawn&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;, &#39;ipc&#39;]
});

child.on(&#39;message&#39;, data =&gt; {
  console.log(data);

  // 杀死子进程
  process.kill(child.pid);
});

// hello world
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 给主进程发送消息
process.send(&#39;hello&#39;);
</code></pre><p>从上面代码我们可以看出，杀死子进程的方法为 <code>process.kill</code>，由于一个主进程可能有多个子进程，所以指定要杀死的子进程需要传入子进程的 <code>pid</code> 属性作为 <code>process.kill</code> 的参数。</p><blockquote class="pullquote warning"><p><em><strong>注意：退出子进程 <code>process.exit</code> 方法是在子进程中操作的，此时 <code>process</code> 代表子进程，杀死子进程 <code>process.kill</code> 是在主进程中操作的，此时 <code>process</code> 代表主进程。</strong></em></p></blockquote><h3 id="独立子进程"><a href="#独立子进程" class="headerlink" title="独立子进程"></a>独立子进程</h3><p>我们前面说过，<code>child_process</code> 模块创建的子进程是被主进程统一管理的，如果主进程挂了，所有的子进程也会受到影响一起挂掉，但其实使用多进程一方面为了提高处理任务的效率，另一方面也是为了当一个进程挂掉时还有其他进程可以继续工作，不至于整个应用挂掉，这样的例子非常多，比如 <code>Chrome</code> 浏览器的选项卡，比如 <code>VSCode</code> 编辑器运行时都会同时开启多个进程同时处理任务，其实在 <code>spawn</code> 创建子进程时，也可以实现子进程的独立，即子进程不再受主进程的控制和影响。</p><pre><code class="lang-js">/* 文件：process.js */
const { spawn } = require(&#39;spawn&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  stdio: &#39;ignore&#39;,
  detached: true
});

// 与主进程断绝关系
child.unref();
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
const fs = require(&#39;fs&#39;);

setInterval(() =&gt; {
  fs.appendFileSync(&#39;test.txt&#39;, &#39;hello&#39;);
});
</code></pre><p>要想创建的子进程独立，需要在创建子进程时配置 <code>detached</code> 参数为 <code>true</code>，表示该子进程不受控制，还需调用子进程的 <code>unref</code> 方法与主进程断绝关系，但是仅仅这样子进程可能还是会受主进程的影响，要想子进程完全独立需要保证子进程一定不能和主进程共用标准输入、标准输出和错误输出，也就是 <code>stdio</code> 必须设置为 <code>ignore</code>，这也就代表着独立的子进程是不能和主进程进行标准进程通信，即不能设置 <code>ipc</code>。</p><h2 id="fork-实现多进程"><a href="#fork-实现多进程" class="headerlink" title="fork 实现多进程"></a>fork 实现多进程</h2><h3 id="fork-的使用"><a href="#fork-的使用" class="headerlink" title="fork 的使用"></a>fork 的使用</h3><p><code>fork</code> 也是 <code>child_process</code> 模块的一个方法，与 <code>spawn</code> 类似，是在 <code>spawn</code> 的基础上又做了一层封装，我们看一个 <code>fork</code> 使用的例子。</p><pre><code class="lang-js">/* 文件：process.js */
const fork = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 创建子进程
const child = fork(&#39;sub_process.js&#39;, [&#39;--port&#39;, &#39;3000&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  silent: true
});

child.send(&#39;hello world&#39;);
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 接收主进程发来的消息
process.on(&#39;message&#39;, data =&gt; console.log(data));
</code></pre><p><code>fork</code> 的用法与 <code>spawn</code> 相比有所改变，第一个参数是子进程执行文件的名称，第二个参数为数组，存储执行时的参数和值，第三个参数为 <code>options</code>，其中使用 <code>slilent</code> 属性替代了 <code>spawn</code> 的 <code>stdio</code>，当 <code>silent</code> 为 <code>true</code> 时，此时主进程与子进程的所有非标准通信的操作都不会生效，包括标准输入、标准输出和错误输出，当设为 <code>false</code> 时可正常输出，返回值依然为一个子进程。</p><blockquote class="pullquote info"><p><em><strong><code>fork</code> 创建的子进程可以直接通过 <code>send</code> 方法和监听 <code>message</code> 事件与主进程进行通信。</strong></em></p></blockquote><h3 id="fork-的原理"><a href="#fork-的原理" class="headerlink" title="fork 的原理"></a>fork 的原理</h3><p>其实 <code>fork</code> 的原理非常简单，只是在子进程模块 <code>child_process</code> 上挂了一个 <code>fork</code> 方法，而在该方法内调用 <code>spawn</code> 并将 <code>spawn</code> 返回的子进程作为返回值返回，下面进行简易实现。</p><pre><code class="lang-js">/* 文件：fork.js */
const childProcess = require(&#39;child_process&#39;);
const path = require(&#39;path&#39;);

// 封装原理
childProcess.fork = function(modulePath, args, options) {
  const stdio = options.silent ?
    [&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;, &#39;ipc&#39;] :
    [0, 1, 2, &#39;ipc&#39;];

  return childProcess.spawn(&#39;node&#39;, [modulePath, ...args], {
    ...options,
    stdio
  });
}

// 创建子进程
const child = fork(&#39;sub_process.js&#39;, [&#39;--port&#39;, &#39;3000&#39;], {
  cwd: path.join(__dirname, &#39;test&#39;),
  silent: false
});

// 向子进程发送消息
child.send(&#39;hello world&#39;);
</code></pre><pre><code class="lang-js">/* 文件：~test/sub_process.js */
// 接收主进程发来的消息
process.on(&#39;message&#39;, data =&gt; console.log(data));

// hello world
</code></pre><p><code>spawn</code> 中的有一些 <code>fork</code> 没有传的参数（如使用 <code>node</code> 执行文件），都在内部调用 <code>spawn</code> 时传递默认值或将默认参数与 <code>fork</code> 传入的参数进行整合，着重处理了 <code>spawn</code> 没有的参数 <code>silent</code>，其实就是处理成了 <code>spawn</code> 的 <code>stdio</code> 参数两种极端的情况（默认使用 <code>ipc</code> 通信），封装 <code>fork</code> 就是让我们能更方便的创建子进程，可以更少的传参。</p><h2 id="execFile-和-exec-实现多进程"><a href="#execFile-和-exec-实现多进程" class="headerlink" title="execFile 和 exec 实现多进程"></a>execFile 和 exec 实现多进程</h2><p><code>execFile</code> 和 <code>exec</code> 是 <code>child_process</code> 模块的两个方法，<code>execFile</code> 是基于 <code>spawn</code> 封装的，而 <code>exec</code> 是基于 <code>execFile</code> 封装的，这两个方法用法大同小异，<code>execFile</code> 可以直接创建子进程进行文件操作，而 <code>exec</code> 可以直接开启子进程执行命令，常见的应用场景如 <code>http-server</code> 以及 <code>weboack-dev-server</code> 等命令行工具在启动本地服务时自动打开浏览器。</p><pre><code class="lang-js">/* execFile 和 exec */
const { execFile, exec } = require(&#39;child_process&#39;);

const execFileChild = execFile(&#39;node&#39;, [&#39;--version&#39;], (err, stdout, stderr) =&gt; {
  if (error) throw error;
  console.log(stdout);
  console.log(stderr);
});

const execChild = exec(&#39;node --version&#39;, (err, stdout, stderr) =&gt; {
  if (err) throw err;
  console.log(stdout);
  console.log(stderr);
});
</code></pre><p><code>exec</code> 与 <code>execFile</code> 的区别在于传参，<code>execFile</code> 第一个参数为文件的可执行路径或命令，第二个参数为命令的参数集合（数组），第三个参数为 <code>options</code>，最后一个参数为回调函数，回调函数的形参为错误、标准输出和错误输出。</p><p><code>exec</code> 在传参上将 <code>execFile</code> 的前两个参数进行了整合，也就是命令与命令参数拼接成字符串作为第一参数，后面的参数都与 <code>execFile</code> 相同。</p><h2 id="cluster-集群"><a href="#cluster-集群" class="headerlink" title="cluster 集群"></a>cluster 集群</h2><blockquote class="pullquote primary"><p><strong>开启进程需要消耗内存，所以开启进程的数量要适合，合理运用多进程可以大大提高效率，如 <code>Webpack</code> 对资源进行打包，就开启了多个进程同时进行，大大提高了打包速度，集群也是多进程重要的应用之一，用多个进程同时监听同一个服务，一般开启进程的数量跟 <code>CPU</code> 核数相同为好，此时多个进程监听的服务会根据请求压力分流处理，也可以通过设置每个子进程处理请求的数量来实现 “负载均衡”。</strong></p></blockquote><h3 id="使用-ipc-实现集群"><a href="#使用-ipc-实现集群" class="headerlink" title="使用 ipc 实现集群"></a>使用 ipc 实现集群</h3><p><code>ipc</code> 标准进程通信使用 <code>send</code> 方法发送消息时第二个参数支持传入一个服务，必须是 <code>http</code> 服务或者 <code>tcp</code> 服务，子进程通过 <code>message</code> 事件进行接收，回调的参数分别对应发送的参数，即第一个参数为消息，第二个参数为服务，我们就可以在子进程创建服务并对主进程的服务进行监听和操作（<code>listen</code> 除了可以监听端口号也可以监听服务），便实现了集群，代码如下。</p><pre><code class="lang-js">/* 文件：server.js */
// os 模块用于获取系统信息
const os = require(&#39;os&#39;);
const http = require(&#39;http&#39;);
const path = require(&#39;path&#39;);
const { fork } = rquire(&#39;child_process&#39;);

// 创建服务
const server = createServer((res, req) =&gt; {
  res.end(&#39;hello&#39;);
}).listen(3000);

// 根据 CPU 个数创建子进程
os.cpus().forEach(() =&gt; {
  fork(&#39;child_server.js&#39;, {
    cwd: path.join(__dirname)
  }).send(&#39;server&#39;, server);
});
</code></pre><pre><code class="lang-js">/* 文件：child_server.js */
const http = require(&#39;http&#39;);

// 接收来自主进程发来的服务
process.on(&#39;message&#39;, (data, server) =&gt; {
  // // 子进程共用主进程的服务
  http.createServer((req, res) =&gt; {
    res.end(&#39;child&#39; + process.pid);
  }).listen(server);
});
</code></pre><p>上面代码中由主进程处理的请求会返回 <code>hello</code>，由子进程处理的请求会返回 <code>child</code> 加进程的 <code>pid</code> 组成的字符串。</p><h3 id="使用-cluster-实现集群"><a href="#使用-cluster-实现集群" class="headerlink" title="使用 cluster 实现集群"></a>使用 cluster 实现集群</h3><p><code>cluster</code> 模块是 <code>Node.js</code> 提供的用来实现集群的，他将 <code>child_process</code> 创建子进程的方法集成进去，实现方式要比使用 <code>ipc</code> 更简洁。</p><pre><code class="lang-js">/* 文件：cluster.js */
const cluster = require(&#39;cluster&#39;);
const http = require(&#39;http&#39;);
const os = require(&#39;os&#39;);

// 判断当前执行的进程是否为主进程，为主进程则创建子进程，否则用子进程监听服务
if (cluster.isMaster) {
  // 创建子进程
  os.cpus().forEach(() =&gt; cluster.fork());
} else {
  // 创建并监听服务
  http.createServer((req, res) =&gt; {
    res.end(&#39;child&#39; + process.pid);
  }).listen(3000);
}
</code></pre><p>上面代码既会执行 <code>if</code> 又会执行 <code>else</code>，这看似很奇怪，但其实不是在同一次执行的，主进程执行时会通过 <code>cluster.fork</code> 创建子进程，当子进程被创建会将该文件再次执行，此时则会执行 <code>else</code> 中对服务的监听，还有另一种用法将主进程和子进程执行的代码拆分开，逻辑更清晰，用法如下。</p><pre><code class="lang-js">/* 文件：cluster.js */
const cluster = require(&#39;cluster&#39;);
const path = require(&#39;path&#39;);
const os = require(&#39;os&#39;);

// 设置子进程读取文件的路径
cluster.setupMaster({
  exec: path.join(__dirname, &#39;cluster-server.js&#39;)
});

// 创建子进程
os.cpus().forEach(() =&gt; cluster.fork());
</code></pre><pre><code class="lang-js">/* 文件：cluster-server.js */
const http = require(&#39;http&#39;);

// 创建并监听服务
http.createServer((req, res) =&gt; {
  res.end(&#39;child&#39; + process.pid);
}).listen(3000);
</code></pre><p>通过 <code>cluster.setupMaster</code> 设置子进程执行文件以后，就可以将主进程和子进程的逻辑拆分开，在实际的开发中这样的方式也是最常用的，耦合度低，可读性好，更符合开发的原则。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>本篇着重的介绍了 <code>Node.js</code> 多进程的实现方式以及集群的使用，之所以在开头长篇大论的介绍 <code>spawn</code>，是因为其他的所有跟多进程相关的方法包括 <code>fork</code>、<code>exec</code> 等，以及模块 <code>cluster</code> 都是基于 <code>spawn</code> 的封装，如果对 <code>spawn</code> 足够了解，其他的也不在话下，希望大家通过这篇可以在 <code>Node.js</code> 多进程相关的开发中起到一个 “路标” 的作用。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>process</tag>
        <tag>Cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack —— tree-staking 解析</title>
    <url>/20180726122146/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20180726122146/ast-tree-shaking.png" title="tree-staking"><p><br></p><h2 id="tree-shaking-简介"><a href="#tree-shaking-简介" class="headerlink" title="tree-shaking 简介"></a>tree-shaking 简介</h2><blockquote class="pullquote info"><p><strong><code>tree-shaking</code> 是 <code>Webpack 2</code> 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，<code>tree-shaking</code> 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。</strong></p></blockquote><a id="more"></a><h2 id="AST-语法树分析"><a href="#AST-语法树分析" class="headerlink" title="AST 语法树分析"></a>AST 语法树分析</h2><p>假设我们现在使用了 <code>ElementUI</code> 组件库的两个组件，通常会使用解构赋值来引入。</p><pre><code class="lang-js">/* 优化前 */
import { Button, Alert } from &#39;element-ui&#39;;
</code></pre><p>这样引用资源，<code>Webpack</code> 在打包的时候会找到 <code>element-ui</code> 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，<code>tree-shaking</code> 是通过在 <code>Webpack</code> 中配置 <code>babel-plugin-import</code> 插件来实现的，它可以将解构的代码转换成下面的形式。</p><pre><code class="lang-js">/* 优化后 */
import Button from &#39;element-ui/lib/button&#39;;
import Alert from &#39;element-ui/lib/Alert&#39;;
</code></pre><p>转化后会去 <code>node_modules</code> 中的 <code>element-ui</code> 模块找到 <code>Button</code> 和 <code>Alert</code> 两个组件对应的文件，并打包到出口文件中。</p><p>通过上面的转换可以看出，其实 <code>tree-shaking</code> 的实现原理是通过改变 <a href="/20180725130233/" target="_blank">AST 抽象语法树</a> 的结构来实现的，我们可以通过在线转换网站 <a href="http://esprima.org/demo/parse.html" target="_blank">http://esprima.org/demo/parse.html</a> 将 JS 代码装换成 AST 语法树。</p><pre><code class="lang-json">/* 优化前的 AST 语法树 */
{
  &quot;type&quot;: &quot;Program&quot;,
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;ImportDeclaration&quot;,
      &quot;specifiers&quot;: [
        {
          &quot;type&quot;: &quot;ImportSpecifier&quot;,
          &quot;local&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Button&quot;
          },
          &quot;imported&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Button&quot;
          }
        },
        {
          &quot;type&quot;: &quot;ImportSpecifier&quot;,
          &quot;local&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Alert&quot;
          },
          &quot;imported&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Alert&quot;
          }
        }
      ],
      &quot;source&quot;: {
        &quot;type&quot;: &quot;Literal&quot;,
        &quot;value&quot;: &quot;element-ui&quot;,
        &quot;raw&quot;: &quot;\&quot;element-ui\&quot;&quot;
      }
    }
  ],
  &quot;sourceType&quot;: &quot;module&quot;
}
</code></pre><pre><code class="lang-json">/* 优化后的 AST 语法树 */
{
  &quot;type&quot;: &quot;Program&quot;,
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;ImportDeclaration&quot;,
      &quot;specifiers&quot;: [
        {
          &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,
          &quot;local&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Button&quot;
          }
        }
      ],
      &quot;source&quot;: {
        &quot;type&quot;: &quot;Literal&quot;,
        &quot;value&quot;: &quot;element-ui/lib/button&quot;,
        &quot;raw&quot;: &quot;\&quot;element-ui/lib/button\&quot;&quot;
      }
    },
    {
      &quot;type&quot;: &quot;ImportDeclaration&quot;,
      &quot;specifiers&quot;: [
        {
          &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,
          &quot;local&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;name&quot;: &quot;Alert&quot;
          }
        }
      ],
      &quot;source&quot;: {
        &quot;type&quot;: &quot;Literal&quot;,
        &quot;value&quot;: &quot;element-ui/lib/Alert&quot;,
        &quot;raw&quot;: &quot;\&quot;element-ui/lib/Alert\&quot;&quot;
      }
    }
  ],
  &quot;sourceType&quot;: &quot;module&quot;
}
</code></pre><p>从上面的语法树对比，可以看出在优化前 <code>body</code> 里面只有一个对象，使用的组件信息存在 <code>specifiers</code> 里，<code>source</code> 指向了 <code>element-ui</code>，而在优化后，将两个组件分别拆成了两个对象存在 <code>body</code> 中，每个对象的的 <code>specifiers</code> 只存储一个组件，并在 <code>source</code> 里面指向了当前组件对应的路径。</p><blockquote class="pullquote warning"><p><strong><code>tree-shaking</code> 主要秉持着几个原则分为不同的处理方式，如代码不可触达，死变量只写不读等，我们上面描述的多用于 <code>UI</code> 组件库，也叫按需加载，其他的情况目前均由 <code>Webpack</code> 底层逻辑实现，我们本篇重点介绍按需加载的实现。</strong></p></blockquote><h2 id="模拟-tree-staking"><a href="#模拟-tree-staking" class="headerlink" title="模拟 tree-staking"></a>模拟 tree-staking</h2><p>既然我们已经清楚要修改语法树的位置，下面就使用 <code>AST</code> 来模拟 <code>tree-shaking</code> 功能，对语法树的操作是依赖于 <code>babel-core</code> 和 <code>babel-types</code> 两个核心模块的，下面先安装依赖。</p><pre><code class="lang-bash">$ npm install babel-core babel-types
</code></pre><pre><code class="lang-js">/* 文件：babel-plugin-my-import.js */
const babel = require(&#39;babel-core&#39;);
const types = require(&#39;babel-types&#39;);

const code = `import { Button, Alert } from &#39;element-ui&#39;`;

const importPlugin = {
  visitor: {
    ImportDeclaration(path) {
      const node = path.node;
      const source = node.source.value;
      let specifiers = node.specifiers;

      // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出
      if (!types.isImportDefaultSpecifier(specifiers[0])) {
        // 如果不是默认导出，则需要转换
        specifiers = specifiers.map(specifier =&gt; {
          // 数组内容：当前默认导出的标识、从哪里导入
          return types.importDeclaration(
            [types.importDefaultSpecifier(specifier.local)],
            types.stringLiteral(source + &#39;/lib/&#39; + specifier.local.name.toLowerCase())
          )
        });

        // 替换树结构
        path.replaceWithMultiple(specifiers);
      }
    }
  }
};

const result = babel.transform(code, {
  plugins: [importPlugin]
});

console.log(result.code);

// import Button from &#39;element-ui/lib/button&#39;;
// import Alert from &#39;element-ui/lib/alert&#39;;
</code></pre><p>通过上面的代码可以发现我们使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 <code>API</code> 可以查看 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank">https://github.com/babel/babel/tree/6.x/packages/babel-types</a>。</p><h2 id="结合-Webpack-使用插件"><a href="#结合-Webpack-使用插件" class="headerlink" title="结合 Webpack 使用插件"></a>结合 Webpack 使用插件</h2><p>前面只是验证了 <code>tree-shaking</code> 中 <code>JS</code> 语法的转换过程，接下来将上面的代码转换成插件配合 <code>Webpack</code> 使用，来彻底感受 <code>tree-shaking</code> 的工作过程。</p><pre><code class="lang-js">/* 文件：~node_modules/babel-plugin-my-import.js */
const babel = require(&#39;babel-core&#39;);
const types = require(&#39;babel-types&#39;);

const importPlugin = {
  visitor: {
    ImportDeclaration(path) {
      const node = path.node;
      const source = node.source.value;
      let specifiers = node.specifiers;

      // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出
      if (!types.isImportDefaultSpecifier(specifiers[0])) {
        // 如果不是默认导出，则需要转换
        specifiers = specifiers.map(specifier =&gt; {
          // 数组内容：当前默认导出的标识、从哪里导入
          return types.importDeclaration(
            [types.importDefaultSpecifier(specifier.local)],
            types.stringLiteral(source + &#39;/lib/&#39; + specifier.local.name.toLowerCase())
          );
        });

        // 替换树解构
        path.replaceWithMultiple(specifiers);
      }
    }
  }
};

module.exports = importPlugin;
</code></pre><p>上面删掉了多余的测试代码，将模块中的 <code>importPlugin</code> 插件导出，并把 <code>babel-plugin-my-import.js</code> 移入了 <code>node_modules</code> 当中。</p><p><strong>接下来安装需要的依赖：</strong></p><pre><code class="lang-bash">$ npm install webpack webpack-cli babel-loader babel-presets-env
$ npm install vue element-ui --save
</code></pre><p>安装完依赖，写一个要编译的文件，使用 <code>Webpack</code> 进行打包，查看使用插件前和使用插件后出口文件的大小。</p><pre><code class="lang-js">/* 文件：import.js */
import Vue from &#39;vue&#39;;
import { Button, Alert } from &#39;element-ui&#39;;
</code></pre><p><strong>一个简单的 <code>Webpack</code> 配置文件如下：</strong></p><pre><code class="lang-js">/* 文件：webpcak.config.js */
module.exports = {
  mode: &#39;development&#39;,
  entry: &#39;import.js&#39;,
  output: {
    filename: &#39;bundle.js&#39;,
    path: __dirname
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: {
        loader: &#39;babel-loader&#39;,
        options: {
          presets: [
            &#39;env&#39;,
          ],
          plugins: [
            // 插件：不使用插件打包注释掉该行即可
            [&#39;my-import&#39;, { libararyName: &#39;element-ui&#39; }]
          ]
        }
      },
      exclude: /node_modules/
    }]
  }
};
</code></pre><p>为了防止 <code>babel</code> 相关的依赖升级 <code>7.0</code> 后出现一些问题导致 <code>Webpack</code> 无法启动，再此贴出 <code>package.json</code> 文件，按照对应版本下载依赖保证上面 <code>Webpack</code> 配置生效。</p><pre><code class="lang-json">/* 文件：package.json */
{
  &quot;name&quot;: &quot;ast-lesson&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;tree-staking&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.26.3&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.5&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
    &quot;babel-types&quot;: &quot;^6.26.0&quot;,
    &quot;escodegen&quot;: &quot;^1.10.0&quot;,
    &quot;esprima&quot;: &quot;^4.0.0&quot;,
    &quot;estraverse&quot;: &quot;^4.2.0&quot;,
    &quot;webpack&quot;: &quot;^4.16.0&quot;,
    &quot;webpack-cli&quot;: &quot;^3.0.8&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.17&quot;,
    &quot;element-ui&quot;: &quot;^2.4.6&quot;
  }
}
</code></pre><h2 id="对比使用插件前后的出口文件"><a href="#对比使用插件前后的出口文件" class="headerlink" title="对比使用插件前后的出口文件"></a>对比使用插件前后的出口文件</h2><p>接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 <code>bondle.js</code> 的大小。</p><pre><code class="lang-bash">$ npx webpack
</code></pre><p><strong>使用 <code>babel-plugin-my-import</code> 前：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Compile/20180726122146/before-babel-plugin.jpg" alt="使用 tree-staking 之前"></div><div class="image-caption">使用 tree-staking 之前</div></figure><p><br></p><p><strong>使用 <code>babel-plugin-my-import</code> 后：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Compile/20180726122146/after-babel-plugin.jpg" alt="使用 tree-staking 之后"></div><div class="image-caption">使用 tree-staking 之后</div></figure><p><br></p><blockquote class="pullquote success"><p><strong>通过对比，可以看到使用 <code>tree-shaking</code> 即我们自己实现的 <code>babel-plugin-my-import</code> 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote default"><p><strong>上面对 <code>Webpack</code> 的 <code>tree-shaking</code> 进行了分析，并模拟 <code>babel-plugin-import</code> 简易的实现了一版 <code>tree-shaking</code> 的优化插件，这个过程中相信大家已经了解了 <code>tree-shaking</code> 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，<code>tree-shaking</code> 优化的方式是根据 <code>ES6</code> 语法 <code>import</code> “静态” 引入的特性实现的，如果要说 <code>tree-shaking</code> 很强大，还不如说 <code>ES6</code> 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 <code>tree-shaking</code> 只支持遍历一层 <code>import</code> 关键字。</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>Babel</tag>
        <tag>Webpack</tag>
        <tag>AST</tag>
        <tag>tree-staking</tag>
      </tags>
  </entry>
  <entry>
    <title>AST 抽象语法树</title>
    <url>/20180725130233/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20180725130233/ast.png" title="AST"><p><br></p><h2 id="AST-抽象语法树简介"><a href="#AST-抽象语法树简介" class="headerlink" title="AST 抽象语法树简介"></a>AST 抽象语法树简介</h2><blockquote class="pullquote default"><p><code>AST</code>（<code>Abstract Syntax Tree</code>）是源代码的抽象语法结构树状表现形式，<code>Webpack</code>、<code>ESLint</code>、<code>JSX</code>、<code>TypeScript</code> 的编译和模块化规则之间的转化都是通过 <code>AST</code> 来实现对代码的检查、分析以及编译等操作。</p></blockquote><a id="more"></a><h2 id="JavaScript-语法的-AST-语法树"><a href="#JavaScript-语法的-AST-语法树" class="headerlink" title="JavaScript 语法的 AST 语法树"></a>JavaScript 语法的 AST 语法树</h2><p><code>JavaScript</code> 中想要使用 <code>AST</code> 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，可以通过 <a href="http://esprima.org/demo/parse.html" target="_blank">http://esprima.org/demo/parse.html</a> 来实现 <code>JavaScript</code> 语法的在线转换。</p><p>通过在线编译工具，可以将 <code>function fn(a, b) {}</code> 编译为下面的结构。</p><pre><code class="lang-json">{
  &quot;type&quot;: &quot;Program&quot;,
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;FunctionDeclaration&quot;,
      &quot;id&quot;: {
        &quot;type&quot;: &quot;Identifier&quot;,
        &quot;name&quot;: &quot;fn&quot;
      },
      &quot;params&quot;: [
        {
          &quot;type&quot;: &quot;Identifier&quot;,
          &quot;name&quot;: &quot;a&quot;
        },
        {
          &quot;type&quot;: &quot;Identifier&quot;,
          &quot;name&quot;: &quot;b&quot;
        }
      ],
      &quot;body&quot;: {
        &quot;type&quot;: &quot;BlockStatement&quot;,
        &quot;body&quot;: []
      },
      &quot;generator&quot;: false,
      &quot;expression&quot;: false,
      &quot;async&quot;: false
    }
  ],
  &quot;sourceType&quot;: &quot;script&quot;
}
</code></pre><blockquote class="pullquote primary"><p><strong>将 <code>JavaScript</code> 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。</strong></p></blockquote><h2 id="esprima、estraverse-和-escodegen"><a href="#esprima、estraverse-和-escodegen" class="headerlink" title="esprima、estraverse 和 escodegen"></a>esprima、estraverse 和 escodegen</h2><p><code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 模块是操作 <code>AST</code> 的三个重要模块，也是实现 <code>babel</code> 的核心依赖，下面是分别介绍三个模块的作用。</p><h3 id="esprima-将-JS-转换成-AST"><a href="#esprima-将-JS-转换成-AST" class="headerlink" title="esprima 将 JS 转换成 AST"></a>esprima 将 JS 转换成 AST</h3><p><strong><code>esprima</code> 模块的用法如下：</strong></p><pre><code class="lang-js">/* 文件：esprima-test.js */
const esprima = require(&#39;esprima&#39;);

const code = &#39;function fn() {}&#39;;

// 生成语法树
const tree = esprima.parseScript(code);

console.log(tree);

// Script {
//   type: &#39;Program&#39;,
//   body:
//   [ FunctionDeclaration {
//     type: &#39;FunctionDeclaration&#39;,
//     id: [Identifier],
//     params: [],
//     body: [BlockStatement],
//     generator: false,
//     expression: false,
//     async: false } ],
//   sourceType: &#39;script&#39; }
</code></pre><p>通过上面的案例可以看出，通过 <code>esprima</code> 模块的 <code>parseScript</code> 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 <code>parseModule</code> 方法转换一个模块。</p><h3 id="estraverse-遍历和修改-AST"><a href="#estraverse-遍历和修改-AST" class="headerlink" title="estraverse 遍历和修改 AST"></a>estraverse 遍历和修改 AST</h3><p><strong>查看遍历过程：</strong></p><pre><code class="lang-js">/* 文件：estraverse-test.js */
const esprima = require(&#39;esprima&#39;);
const estraverse = require(&#39;estraverse&#39;);

const code = &#39;function fn() {}&#39;;

// 遍历语法树
estraverse.traverse(esprima.parseScript(code), {
  enter(node) {
    console.log(&#39;enter&#39;, node.type);
  },
  leave() {
    console.log(&#39;leave&#39;, node.type);
  }
});

// enter Program
// enter FunctionDeclaration
// enter Identifier
// leave Identifier
// enter BlockStatement
// leave BlockStatement
// leave FunctionDeclaration
// leave Program
</code></pre><p>上面代码通过 <code>estraverse</code> 模块的 <code>traverse</code> 方法将 <code>esprima</code> 模块转换的 <code>AST</code> 进行了遍历，并打印了所有的 <code>type</code> 属性并打印，每含有一个 <code>type</code> 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。</p><blockquote class="pullquote info"><p><strong>其实深度遍历 <code>AST</code> 就是在遍历每一层的 <code>type</code> 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 <code>estraverse</code> 的 <code>traverse</code> 方法中分别用参数指定的 <code>entry</code> 和 <code>leave</code> 两个函数监听，但是我们一般只使用 <code>entry</code>。</strong></p></blockquote><h3 id="escodegen-将-AST-转换成-JS"><a href="#escodegen-将-AST-转换成-JS" class="headerlink" title="escodegen 将 AST 转换成 JS"></a>escodegen 将 AST 转换成 JS</h3><p>下面的案例是一个段 <code>JS</code> 代码块被转换成 <code>AST</code>，并将遍历、修改后的 <code>AST</code> 重新转换成 <code>JS</code> 的全过程。</p><pre><code class="lang-js">/* 文件：escodegen-test.js */
const esprima = require(&#39;esprima&#39;);
const estraverse = require(&#39;estraverse&#39;);
const escodegen = require(&#39;escodegen&#39;);

const code = &#39;function fn() {}&#39;;

// 生成语法树
const tree = esprima.parseScript(code);

// 遍历语法树
estraverse.traverse(tree, {
  enter(node) {
    // 修改函数名
    if (node.type === &#39;FunctionDeclaration&#39;) {
      node.id.name = &#39;ast&#39;;
    }
  }
});

// 编译语法树
const result = escodegen.generate(tree);

console.log(result);

// function ast() {
// }
</code></pre><blockquote class="pullquote warning"><p><em><strong>在遍历 <code>AST</code> 的过程中 <code>params</code> 值为数组，没有 <code>type</code> 属性。</strong></em></p></blockquote><h2 id="实现-Babel-语法转换插件"><a href="#实现-Babel-语法转换插件" class="headerlink" title="实现 Babel 语法转换插件"></a>实现 Babel 语法转换插件</h2><p>实现语法转换插件需要借助 <code>babel-core</code> 和 <code>babel-types</code> 两个模块，其实这两个模块就是依赖 <code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 的。</p><p><strong>使用这两个模块需要安装，命令如下：</strong></p><pre><code class="lang-bash">$ npm install babel-core babel-types
</code></pre><h3 id="模拟-plugin-transform-arrow-functions"><a href="#模拟-plugin-transform-arrow-functions" class="headerlink" title="模拟 plugin-transform-arrow-functions"></a>模拟 plugin-transform-arrow-functions</h3><blockquote class="pullquote success"><p><code>plugin-transform-arrow-functions</code> 是 <code>Babel</code> 家族成员之一，用于将箭头函数转换 <code>ES5</code> 语法的函数表达式。</p></blockquote><pre><code class="lang-js">/* 文件：plugin-transform-arrow-functions.js */
const babel = require(&#39;babel-core&#39;);
const types = require(&#39;babel-types&#39;);

// 箭头函数代码块
const sumCode = `
const sum = (a, b) =&gt; {
  return a + b;
}`;
const minusCode = `const minus = (a, b) =&gt; a - b;`;

// 转化 ES5 插件
const ArrowPlugin = {
  // 访问者（访问者模式）
  visitor: {
    // path 是树的路径
    ArrowFunctionExpression(path) {
      // 获取树节点
      const node = path.node;

      // 获取参数和函数体
      const params = node.params;
      const body = node.body;

      // 判断函数体是否是代码块，不是代码块则添加 return 和 {}
      if (!types.isBlockStatement(body)) {
        const returnStatement = types.returnStatement(body);
        body = types.blockStatement([returnStatement]);
      }

      // 生成一个函数表达式树结构
      const func = types.functionExpression(null, params, body, false, false);

      // 用新的树结构替换掉旧的树结构
      path.replaceWith(func);
    }
  }
};

// 生成转换后的代码块
const sumResult = babel.transform(sumCode, {
  plugins: [ArrowPlugin]
});

const minusResult = babel.transform(minusCode, {
  plugins: [ArrowPlugin]
});

console.log(sumResult.code);
console.log(minusResult.code);

// const sum = function (a, b) {
//   return a + b;
// };
// const minus = function (a, b) {
//   return a - b;
// };
</code></pre><p>我们主要使用 <code>babel-core</code> 的 <code>transform</code> 方法将 <code>AST</code> 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 <code>plugins</code> 值为数组，存储修改 <code>babal-core</code> 转换的 <code>AST</code> 的插件（对象），使用 <code>transform</code> 方法将旧的 <code>AST</code> 处理成新的代码块后，返回值为一个对象，对象的 <code>code</code> 属性为转换后的代码块（字符串）。</p><p>内部修改通过 <code>babel-types</code> 模块提供的方法实现，<code>API</code> 可以到 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank">https://github.com/babel/babel/tree/6.x/packages/babel-types</a> 中查看。</p><p><code>ArrowPlugin</code> 就是传入 <code>transform</code> 方法的插件，必须含有 <code>visitor</code> 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 <code>API</code>，对应的方法会修改 <code>AST</code> 对应的节点。</p><p>在 <code>types.functionExpression</code> 方法中参数分别代表，函数名（匿名函数为 <code>null</code>）、函数参数（必填）、函数体（必填）、是否为 <code>generator</code> 函数（默认 <code>false</code>）、是否为 <code>async</code> 函数（默认 <code>false</code>），返回值为修改后的 <code>AST</code>，<code>path.replaceWith</code> 方法用于替换 <code>AST</code>，参数为新的 <code>AST</code>。</p><h3 id="模拟-plugin-transform-classes"><a href="#模拟-plugin-transform-classes" class="headerlink" title="模拟 plugin-transform-classes"></a>模拟 plugin-transform-classes</h3><blockquote class="pullquote info"><p><strong><code>plugin-transform-classes</code> 也是 <code>Babel</code> 家族中的成员之一，用于将 <code>ES6</code> 的 <code>class</code> 类转换成 <code>ES5</code> 的构造函数。</strong></p></blockquote><pre><code class="lang-js">/* 文件：plugin-transform-classes.js */
const babel = require(&#39;babel-core&#39;);
const types = require(&#39;babel-types&#39;);

// 类
const code = `
class Person {
  constructor(name) {
    this.name = name;
  }
  getName () {
    return this.name;
  }
}`;

// 将类转化 ES5 构造函数插件
const ClassPlugin = {
  visitor: {
    ClassDeclaration(path) {
      const node = path.node;
      const classList = node.body.body;

      // 将取到的类名转换成标识符 { type: &#39;Identifier&#39;, name: &#39;Person&#39; }
      const className = types.identifier(node.id.name);
      const body = types.blockStatement([]);
      let func = types.functionDeclaration(className, [], body, false, false);
      path.replaceWith(func);

      // 用于存储多个原型方法
      const es5Func = [];

      // 获取 class 中的代码体
      classList.forEach((item, index) =&gt; {
        // 函数的代码体
        const body = classList[index].body;

        // 获取参数
        let params = item.params.length ? item.params.map(val =&gt; val.name) : [];

        // 转化参数为标识符
        params = types.identifier(params);

        // 判断是否是 constructor，如果构造函数那就生成新的函数替换
        if (item.kind === &#39;constructor&#39;) {
          // 生成一个构造函数树结构
          func = types.functionDeclaration(className, [params], body, false, false);
        } else {
          // 其他情况是原型方法
          const proto = types.memberExpression(className, types.identifier(&#39;prototype&#39;));

          // 左侧层层定义标识符 Person.prototype.getName
          const left = types.memberExpression(proto, types.identifier(item.key.name));

          // 右侧定义匿名函数
          const right = types.functionExpression(null, [params], body, false, false);

          // 将左侧和右侧进行合并并存入数组
          es5Func.push(types.assignmentExpression(&#39;=&#39;, left, right));
        }
      });

      // 如果没有原型方法，直接替换
      if (es5Func.length === 0) {
        path.replaceWith(func);
      } else {
        es5Func.push(func);
        // 替换 n 个节点
        path.replaceWithMultiple(es5Func);
      }
    }
  }
};

// 生成转换后的代码块
const result = babel.transform(code, {
  plugins: [ClassPlugin]
});

console.log(result.code);

// Person.prototype.getName = function () {
//     return this.name;
// }
// function Person(name) {
//     this.name = name;
// }
</code></pre><p>上面这个插件的实现要比 <code>plugin-transform-arrow-functions</code> 复杂一些，归根结底还是将要互相转换的 <code>ES6</code> 和 <code>ES5</code> 语法树做对比，找到他们的不同，并使用 <code>babel-types</code> 提供的 <code>API</code> 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 <code>path.replaceWithMultiple</code> 与 <code>path.replaceWith</code> 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>通过本节我们了解了什么是 <code>AST</code> 抽象语法树、抽象语法树在 <code>JavaScript</code> 中的体现以及在 <code>Node.js</code> 中用于生成、遍历和修改 <code>AST</code> 抽象语法树的核心依赖，并通过使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块简易模拟了 <code>ES6</code> 新特性转换为 <code>ES5</code> 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。</strong></p></blockquote>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Babel</tag>
        <tag>Webpack</tag>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行工具 —— 手写类似 http-server 的静态服务器</title>
    <url>/20180722110147/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180722110147/static-server.png" title="http-server 命令行工具"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><strong><code>npm</code> 生态中的 <code>http-server</code> 模块，是一个简单的、零配置的 <code>HTTP</code> 服务，它非常强大，同时非常简单，可以方便的帮助我们开启本地服务器，以及局域网共享，可以用来做调试、开发、学习时的环境配置，我们本节就模拟 <code>http-server</code> 实现一个启动本地服务的命令行工具。</strong></p></blockquote><a id="more"></a><h2 id="http-server-使用"><a href="#http-server-使用" class="headerlink" title="http-server 使用"></a>http-server 使用</h2><p><strong><code>http-server</code> 服务器通过命令行启动，使用时需要安装，命令如下：</strong></p><pre><code class="lang-bash">$ npm install http-server -g
</code></pre><p><strong>启动本地服务器时在根目录下执行下面命令即可：</strong></p><pre><code class="lang-bash">$ http-server [path] [option]
</code></pre><p><code>path</code> 默认情况下是 <code>./public</code>，否则是 <code>./</code>，启动后可以通过 <a href="javascript:;">http://localhost:8080</a> 来访问服务器，<code>options</code> 为其他参数， <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/http-server" target="_blank">https://www.npmjs.com/package/http-server</a> 有详细说明。</p><blockquote class="pullquote warning"><p><strong>功能：当通过浏览器访问</strong> <a href="javascript:;">http://localhost:8080</a> <strong>以后，会将我们服务器根目录的目录结构显示在浏览器页面上，当点击文件夹时，可以继续显示内部的文件和文件夹，当点击文件时会直接通过服务器访问文件，并将文件内容显示在浏览器页面上。</strong></p></blockquote><h2 id="实现命令行工具依赖的模块"><a href="#实现命令行工具依赖的模块" class="headerlink" title="实现命令行工具依赖的模块"></a>实现命令行工具依赖的模块</h2><h3 id="chalk-模块"><a href="#chalk-模块" class="headerlink" title="chalk 模块"></a>chalk 模块</h3><p><strong><code>chalk</code> 模块是用来控制命令行输出的文字颜色的第三方模块，使用前需要安装，安装命令如下：</strong></p><pre><code class="lang-bash">$ npm install chalk
</code></pre><p><code>chalk</code> 模块的用法如下，模块支持的颜色和更多的 <code>API</code> 可以在 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/chalk" target="_blank">https://www.npmjs.com/package/chalk</a> 中查看。</p><pre><code class="lang-js">/* 文件位置：~static/tests/staticchalk-test.js */
const chalk = require(&#39;chalk&#39;);

// 在命令行打印绿色和红色的 hello
console.log(chalk.green(&#39;hello&#39;));
console.log(chalk.red(&#39;hello&#39;));
</code></pre><p>在命令行窗口输入 <code>node chalk-test.js</code> 查看命令行打印 <code>hello</code> 的颜色。</p><h3 id="debug-模块"><a href="#debug-模块" class="headerlink" title="debug 模块"></a>debug 模块</h3><p><strong><code>debug</code> 模块可以匹配当前环境变量 <code>DEBUG</code> 的值并输出相关信息，作用在于命令行工具可以根据不同情况输出的信息进行调试，是第三方模块，使用前需安装，命令如下：</strong></p><pre><code class="lang-bash">$ npm install debug
</code></pre><p><code>debug</code> 的简单使用如下，如果想了解更详细的 <code>API</code> 可以在 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/debug" target="_blank">https://www.npmjs.com/package/debug</a> 中查看。</p><pre><code class="lang-js">/* 文件位置：~static/tests/debug-test1.js —— 用法 1 */
const debug = require(&#39;debug&#39;)(&#39;hello&#39;);

debug(&#39;hi panda&#39;);
</code></pre><p>当我们在命令行中执行 <code>node debug-test1.js</code> 时发现命令窗口什么也没有打印，那是因为当前根目录的环境变量 <code>DEBUG</code> 的值必须和我们设置的 <code>hello</code> 相匹配才会打印相关信息。</p><p>设置环境变量，<code>Windows</code> 系统通过 <code>set DEBUG=hello</code> 设置，<code>Mac</code> 系统通过 <code>export DEBUG=hello</code> 设置，设置环境变量后再次执行 <code>node debug-test.js</code>，我们会发现命令行打印出了下面内容。</p><pre><code class="lang-bash">hello hi panda +0ms
</code></pre><p>其中 <code>hello</code> 为我们设置 <code>DEBUG</code> 环境变量的值，<code>hi panda</code> 为 <code>debug</code> 调试方法打印的信息，<code>+0ms</code> 为距离上次执行的间隔时间。</p><pre><code class="lang-js">/* 文件位置：~static/tests/debug-test2.js —— 用法 2 */
const debugA = require(&#39;debug&#39;)(&#39;hello:a&#39;);
const debugB = require(&#39;debug&#39;)(&#39;hello:b&#39;);

debugA(&#39;hi panda&#39;);
debugB(&#39;hello panda&#39;);
</code></pre><p>上面的代码目的是可以让我们不同的 <code>debug</code> 方法可以匹配不同的环境变量，所以需要重新将环境变量的值设置为 <code>hello:*</code>，这样再次执行 <code>node debug-test2.js</code> 发现命令窗口打印了如下内容。</p><pre><code class="lang-bash">hello:a hi panda +0ms
hello:b hello panda +0ms
</code></pre><p>使用 <code>debug</code> 的好处就是可以在开发的时候打印一些调试用的信息，在开发完成后因为匹配不到环境变量，这些信息就会被隐藏。</p><h3 id="commander-模块"><a href="#commander-模块" class="headerlink" title="commander 模块"></a>commander 模块</h3><p><strong><code>commander</code> 是一个开发命令行工具的解决方案（的作者是 <code>Node</code> 大神 <code>tj</code>），提供了用户命令行输入和参数解析的强大功能，<code>commander</code> 是第三方模块，使用时需要安装，命令如下：</strong></p><pre><code class="lang-bash">$ npm install commander
</code></pre><p>基本用法如下：</p><pre><code class="lang-js">/* 文件位置：~static/tests/commander-test1.js */
const commander = require(&#39;commander&#39;);

// 解析 Node 进程执行时的参数
commander.version(&#39;1.0.0&#39;).parse(process.argv);
</code></pre><p>上面文件中 <code>version</code> 方法代表当前执行文件模块的版本，<code>parse</code> 是解析当前命令行进程参数的方法，<code>process.argv</code> 是参数集合（数组），第一个参数为执行的 <code>Node</code> 环境程序执行文件的绝对路径，第二个参数是 <code>node</code> 命令执行文件的绝对路径，后面为通过命令行传入的参数，如 <code>--host</code>、<code>--port</code> 等。</p><p><strong>在命令行执行 <code>node commander-test.js --help</code> 时默认会在命令行输出如下信息：</strong></p><pre><code class="lang-bash">Usage: [options]
Options:
    -V, --version  output the version number
    -h, --help     output usage information
</code></pre><p>当然在我们的命令行工具中，参数不只 <code>--version</code> 和 <code>--help</code> 两个，我们希望更多的参数更多的功能，并且可定制的描述信息，使用案例如下：</p><pre><code class="lang-js">/* 文件位置：~static/tests/commander-test2.js */
const commander = require(&#39;commander&#39;);

// 解析 Node 进程执行时的参数
commander
  .version(&#39;1.0.0&#39;)
  .usage(&#39;[options]&#39;)
  .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;)
  .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;)
  .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;)
  .parse(process.argv);

console.log(commander.port); // 3000
console.log(commander.host); // localhost
console.log(commander.dir); // public
</code></pre><p>在执行命令 <code>node commander-test2.js --help</code> 后会在命令窗口输出如下信息：</p><pre><code class="lang-bash">Usage: yourname-http-server [options]
ptions:
    -V, --version   output the version number
    -p, --port &lt;n&gt;  server port
    -o, --host &lt;n&gt;  server host
    -d, --dir  &lt;n&gt;  server dir
    -h, --help      output usage information
</code></pre><p><code>usage</code> 方法可以让我们详细的定制参数的类型和描述，<code>option</code> 方法可以让我们添加执行 <code>--help</code> 指令时打印的命令以及对应的描述信息。</p><p><strong>执行下面命令：</strong></p><pre><code class="lang-bash">$ node commander-test2.js --port 3000 --host localhost --dir public
</code></pre><p>执行命令后我们发现其实给我们的参数挂在了 <code>commander</code> 对象上，方便我们取值。</p><p>在我们使用别人的命令行工具时会发现在上面输出信息的时候经常会在下面输出 <code>How to use</code> 的列表，更详细的描述了每条命令的作用及用法。</p><pre><code class="lang-js">/* 文件位置：~static/tests/commander-test3.js */
const commander = require(&#39;commander&#39;);

// 必须写到 parse 方法的前面
commander.on(&#39;--help&#39;, function () {
  console.log(&#39;\r\n  How to use:&#39;)
  console.log(&#39;    yourname-http-server --port &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --host &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --dir &lt;val&gt;&#39;);
});

// 解析 Node 进程执行时的参数
commander
  .version(&#39;1.0.0&#39;)
  .usage(&#39;[options]&#39;)
  .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;)
  .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;)
  .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;)
  .parse(process.argv);
</code></pre><p>再次执行命令 <code>node commander-test2.js --help</code> 后会在命令窗口输出如下信息：</p><pre><code class="lang-bash">Usage: yourname-http-server [options]
Options:
    -V, --version  output the version number
    -p, --port &lt;n&gt;  server port
    -o, --host &lt;n&gt;  server host
    -d, --dir &lt;n&gt;   server dir
    -h, --help     output usage information
How to use:
    yourname-http-server --port &lt;val&gt;
    yourname-http-server --host &lt;val&gt;
    yourname-http-server --dir &lt;val&gt;
</code></pre><p>以上是 <code>commander</code> 模块的基本用法，如想了解更详细的 <code>API</code> 和使用案例可以到 <code>npm</code> 官方文档查看，地址如下 <a href="https://www.npmjs.com/package/commander" target="_blank">https://www.npmjs.com/package/commander</a> 。</p><h2 id="实现静态服务的功能"><a href="#实现静态服务的功能" class="headerlink" title="实现静态服务的功能"></a>实现静态服务的功能</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><pre class="language-treeview">
  <code class="language-treeview">
    static
      |- bin
      | |- yourname-http-server.js
      |- public
      | |- css
      | | |- style.css
      | |- index.html
      | |- 1.txt
      |- tests
      | |- chalk-test.js
      | |- commander-test1.js
      | |- commander-test2.js
      | |- commander-test3.js
      | |- debug-test1.js
      | |- debug-test2.js
      |- config.js
      |- index.html
      |- index.js
      |- package-lock.json
      |- package.json
  </code>
</pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在启动静态服务的时候，我们希望可以通过命令行传参的形式来定义当前启动服务的主机名端口号，以及默认检索的文件根目录，所以需要配置文件来实现灵活传参。</p><pre><code class="lang-js">/* 文件位置：~static/config.js */
module.exports = {
  port: 3000,
  host: &#39;localhost&#39;,
  dir: process.cwd()
}
</code></pre><blockquote class="pullquote info"><p><strong>在上面的配置中，默认端口号为 <code>3000</code>，默认主机名为 <code>localhost</code>，我们设置默认检索文件的根目录为通过命令行启动服务器的目录，而 <code>process.cwd()</code> 的值就是我们启动命令行执行命令的目录的绝对路径。</strong></p></blockquote><h3 id="创建服务器-Server-类"><a href="#创建服务器-Server-类" class="headerlink" title="创建服务器 Server 类"></a>创建服务器 Server 类</h3><p>因为我们的命令行工具启动本地服务可能是在系统的任意位置，或者指定启动服务访问的域，提高可配置性，并且要更方便给服务器扩展更多的方法处理不同的逻辑，所以需要创建一个 <code>Server</code> 类。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— Server 类的创建 */
// 引入依赖
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const path = require(&#39;path&#39;);
const fs = require(&#39;mz/fs&#39;);
const mime = require(&#39;mime&#39;);
const zlib = require(&#39;zlib&#39;);
const chalk = require(&#39;chalk&#39;);
const ejs = require(&#39;ejs&#39;);
const debug = require(&#39;debug&#39;)(&#39;http:a&#39;);

// 引入配置文件
const config = require(&#39;./config&#39;);

// 读取模板文件
const templateStr = fs.readFileSync(path.join(__dirname, &#39;index.html&#39;),&#39;utf8&#39;);

class Server {
  constructor() {
    this.config = config; // 配置
    this.template = templateStr; // 模板
  }
}
</code></pre><p>我们在上面代码中引入了 <code>config.js</code> 配置文件，读取了用于启动服务后展示页面 <code>index.html</code> 的内容，并都挂在了 <code>Server</code> 类的实例上，目的是方便内部的方法使用以及达到不轻易操作全局变量的目的。</p><h3 id="启动服务器的-start-方法"><a href="#启动服务器的-start-方法" class="headerlink" title="启动服务器的 start 方法"></a>启动服务器的 start 方法</h3><p>后面为了方便代码的拆分，我们将原型上的方法统一使用 <code>Server.prototype.xxx</code> 的方式来书写，实际上是写在 <code>Server</code> 类里面的。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— start 方法 */
Server.prototype.start = function () {
  // 创建服务
  const server = http.createServer(this.handleRequest.bind(this));

  // 从配置中解构端口号和主机名
  const { port, host } = this.config;

  // 启动服务
  server.listen(port, host, () =&gt; {
    debug(&#39;server start http://&#39; + host + &#39;:&#39; + chalk.green(port));
  });
}
</code></pre><p>在 <code>start</code> 方法中创建了服务，在启动服务时只需要创建 <code>Server</code> 的实例并调用 <code>start</code> 方法，由于服务的回调中会处理很多请求响应的逻辑，会导致 <code>start</code> 方法的臃肿，所以将服务的回调函数抽取成 <code>Server</code> 类的一个实例方法 <code>handleRequest</code>，需要注意的是 <code>handleRequest</code> 内部的 <code>this</code> 指向需要我们修正。</p><p>在启动服务时我们根据配置可以灵活的设置服务的地址，当设置 <code>host</code> 后，服务将只能通过 <code>host</code> 的值作为主机名的地址访问静态服务器，启动服务的提示我们通过匹配环境变量 <code>DEBUG</code> 的 <code>debug</code> 方法来打印，并将端口号设置成绿色。</p><h3 id="服务回调-handleRequest-方法"><a href="#服务回调-handleRequest-方法" class="headerlink" title="服务回调 handleRequest 方法"></a>服务回调 handleRequest 方法</h3><blockquote class="pullquote danger"><p><strong>在实现 <code>handleRequest</code> 之前我们应该了解要实现的功能：</strong></p><ul><li><strong>在 <code>http-server</code> 中，如果访问的服务地址路径后面指定具体要访问的文件，并且当前启动服务根目录按照访问路径可以查找到文件，将文件内容读取后响应给客户端；</strong></li><li><strong>如果没指定文件，应该检索当前启动服务根目录或默认设置的目录结构，并将文件的结构通过模板渲染成超链接后将页面响应给客户端；</strong></li><li><strong>再次点击页面的上的链接，如果是文件，直接读取并响应文件内容，如果是文件夹，则继续检索内部结构通过模板渲染成页面。</strong></li></ul></blockquote><pre><code class="lang-js">/* 文件位置：~static/index.js —— handleRequest 方法 */
Server.prototype.handleRequest = async function (req, res) {
  // 获取访问的路径，默认为 /
  this.pathname = url.parse(req.url, true).pathname;

  // 将访问的路径名转换成绝对路径，取到的 dir 就是绝对路径
  this.realPath = path.join(this.config.dir, this.pathname);

  debug(realPath); // 打印当前访问的绝对路径，用于调试

  try {
    // 获取 statObj 对象，如果 await 同步使用 try...catch 捕获非法路径
    const statObj = await fs.stat(this.realPath);

    if (statObj.isFile()) {
      // 如果是文件，直接返回文件内容
      this.sendFile(req, res, statObj);
    } else {
      // 如果是文件夹则检索文件夹通过模板渲染后返回页面
      this.sendDirDetails(req, res, statObj);
    }
  } catch (e) {
    // 如果路径非法，发送错误响应
    this.sendError(req, res, e);
  }
}
</code></pre><p><code>handleRequest</code> 由于内部需要使用异步操作获取 <code>statObj</code> 对象，所以我们使用了 <code>async</code> 函数，为了函数内部可以使用 <code>await</code> 避免异步回调嵌套，由于 <code>await</code> 会等待到异步执行完毕后继续向下执行，我们可以使用 <code>try...catch...</code> 捕获非法的访问路径，并做出错误响应。</p><p>如果路径合法，我们需要检测访问路径对应的是文件还是文件夹，如果是文件则执行响应内容的逻辑，是文件夹执行检索文件夹渲染内部文件列表返回页面的逻辑。</p><p>所以我们将错误处理逻辑、响应文件内容逻辑和返回文件夹详情页面的逻辑分别抽离成 <code>Server</code> 类的三个实例方法 <code>sendError</code>、<code>sendFile</code> 和 <code>sendDirDetails</code>，使得 <code>handleRequest</code> 方法逻辑清晰且不那么臃肿。</p><h3 id="错误响应-sendError-方法"><a href="#错误响应-sendError-方法" class="headerlink" title="错误响应 sendError 方法"></a>错误响应 sendError 方法</h3><p>在服务器处理不同的请求和响应时可能需要处理不同的错误，这些错误的不同就是捕获错误对象的不同，所以我们的 <code>sendError</code> 方法为了更方便的或取请求参数、处理响应以及更好的复用，将参数设置为请求对象、响应对象和错误对象。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— sendError 方法 */
Server.prototype.sendError = function (req, res, err) {
  // 打印错误对象，方便调试
  console.log(chalk.red(err));

  // 设置错误状态码并响应 Not Found
  res.statusCode = 404;
  res.end(&#39;Not Found&#39;);
}
</code></pre><h3 id="渲染目录-sendDirDetails-方法"><a href="#渲染目录-sendDirDetails-方法" class="headerlink" title="渲染目录 sendDirDetails 方法"></a>渲染目录 sendDirDetails 方法</h3><p>在渲染文件夹详情之前我们首先要做的就是异步读取文件目录，所以我们同样使用 <code>async</code> 函数来实现，<code>Node.js</code> 中有很多渲染页面的模板，我们本次使用 <code>ejs</code>，语法简单，比较常用，<code>ejs</code> 为第三方模块，使用前需安装，更详细的用法可参照 <code>npm</code> 官方文档 <a href="https://www.npmjs.com/package/ejs" target="_blank">https://www.npmjs.com/package/ejs</a>。</p><pre><code class="lang-bash">$ npm install ejs
</code></pre><p><code>sendDirDetails</code> 的参数为请求对象、响应对象和 <code>statObj</code>。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— sendDirDetails 方法 */
Server.prototype.sendDirDetails = async function (req, res, statObj) {
  // 读取当前文件夹
  let dirs = await fs.readdir(this.realPath);

  // 构造模板需要的数据
  dirs = dirs.map(dir =&gt; ({
    name: dir,
    path: path.join(this.pathname, dir)
  }));

  // 渲染模板
  const pageStr = ejs.render(this.template, { dirs });

  // 响应客户端
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);
  res.end(pageStr);
}
</code></pre><p>还记得 <code>Server</code> 类的实例属性 <code>template</code> 存储的就是我们的模板（字符串），里面写的就是 <code>ejs</code> 的语法，我们使用 <code>ejs</code> 模块渲染的 <code>render</code> 方法可以将模板中的 <code>JS</code> 执行，并用传给该方法的参数的值替换掉模板中的变量，返回新的字符串，我们直接将字符串响应给客户端即可。</p><blockquote class="pullquote warning"><p><em><strong>注意：在构建模板数据的时候 <code>path</code> 为超链接标签要跳转的路径，如果直接使用 <code>dir</code> 的值，多级访问还是会在根目录去查找，所以路径非法会返回 <code>Not Found</code>，我们需要在每次访问的时候都将上一次访问的路径与当前访问的文件夹或文件名进行拼接，保证路径的正确性。</strong></em></p></blockquote><h3 id="ejs-模板-index-html"><a href="#ejs-模板-index-html" class="headerlink" title="ejs 模板 index.html"></a>ejs 模板 index.html</h3><p>上面已经知道了该怎样使用 <code>ejs</code> 对模板进行渲染，也对模板构造了数据，接下来就是使用 <code>ejs</code> 的语法编写我们的模板内容。</p><pre><code class="lang-ejs">&lt;!-- 文件位置：~static/index.html —— 模板 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Server&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;% dirs.forEach(function (item) { %&gt;
    &lt;li&gt;
      &lt;a href=&quot;&lt;%= item.path%&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;/a&gt;
    &lt;/li&gt;
  &lt;% }) %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote class="pullquote info"><p><em><strong>模板中 <code>JS</code> 逻辑使用 <code>&lt;% %&gt;</code> 包裹，使用 <code>&lt;%= %&gt;</code> 输出变量。</strong></em></p></blockquote><h3 id="返回文件内容-sendFile-方法"><a href="#返回文件内容-sendFile-方法" class="headerlink" title="返回文件内容 sendFile 方法"></a>返回文件内容 sendFile 方法</h3><p>由于都是根据路径查找或操作文件目录并做出响应，<code>sendFile</code> 方法与 <code>sendDirDetails</code> 方法的参数相同，分别为 <code>req</code>、<code>res</code> 和 <code>statObj</code>。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— sendFile 方法 */
Server.prototype.sendFile = function (req, res, statObj) {
  // 设置和处理缓存
  if (this.cache(req, res, statObj)) {
    res.statusCode = 304;
    return res.end();
  }

  // 创建可读流
  const rs = fs.createReadStream(this.realPath);

  // 响应文件类型
  res.setHeader(&#39;Content-Type&#39;, mime.getType(this.realPath) + &#39;;charset=utf8&#39;);

  // 压缩
  const zip = this.compress(req, res, statObj);
  if (zip) return rs.pipe(zip).pipe(res);

  // 处理范围请求
  if (this.range(req, res, statObj)) return;

  // 响应文件内容
  rs.pipe(res);
}
</code></pre><p>其实上面的方法在根目录执行 <code>node index.js</code> 启动服务后，通过我们默认配置的地址访问服务器，表面上就已经实现了 <code>http-server</code> 的功能，但是我们为了服务器的性能和功能更强大，又在这基础上实现了缓存策略、服务器压缩和处理范围请求的逻辑。</p><blockquote class="pullquote primary"><p><strong>推荐阅读：</strong></p><ul><li><a href="/20180720110647/" target="_blank">HTTP 缓存的那些事儿</a></li><li><a href="/20180718181823/" target="_blank">Node.js 服务器实现 gzip 压缩</a></li><li><a href="/20180713130808/" target="_blank">Node.js 使用 Range 请求实现下载功能</a></li></ul></blockquote><p>我们将上面的三个功能分别抽离成了 <code>Server</code> 类的三个原型方法，<code>cache</code>、<code>compress</code> 和 <code>range</code>，并且这三个方法的参数都为 <code>req</code>、<code>res</code> 和 <code>statObj</code>。</p><h3 id="缓存策略-cache-方法"><a href="#缓存策略-cache-方法" class="headerlink" title="缓存策略 cache 方法"></a>缓存策略 cache 方法</h3><p>我们本次的缓存兼容 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 版本，并且同时使用强制缓存和协商缓存共同存在的策略。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— cache 方法 */
Server.prototype.cache = function (req, res, statObj) {
  // 创建协商缓存标识
  const etag = statObj.ctime.toGMTString() + statObj.size;
  const lastModified = statObj.ctime.toGMTString();

  // 设置强制缓存
  res.setHeader(&#39;Cache-Control&#39;, &#39;max-age=30&#39;);
  res.setHeader(&#39;Expires&#39;, new Date(Date.now() + 30 * 1000).toUTCString());

  // 设置协商缓存
  res.setHeader(&#39;Etag&#39;, etag);
  res.setHeader(&#39;Last-Modified&#39;, lastModified);

  // 获取协商缓存请求头
  const {
    &#39;if-none-match&#39;: ifNodeMatch,
    &#39;if-modified-since&#39;: ifModifiedSince
  } = req.headers;

  if (etag !== ifNodeMatch &amp;&amp; lastModified !== ifModifiedSince) {
    return false;
  } else {
    return true;
  }
}
</code></pre><blockquote class="pullquote success"><p><em><strong>我们使用的缓存策略为同时设置强制缓存和协商缓存，当强制缓存有效期内再次请求不会访问服务器，待强制缓存过期再次请求执行协商缓存策略，带标识访问服务器进行确认，确认的同时重新设置强制缓存和协商缓存的响应头信息，如果协商缓存任然生效，则直接返回 <code>304</code> 状态码，如果协商缓存失效则读取文件内容返回浏览器。</strong></em></p></blockquote><h3 id="服务器压缩-compress-方法"><a href="#服务器压缩-compress-方法" class="headerlink" title="服务器压缩 compress 方法"></a>服务器压缩 compress 方法</h3><p>为了减少文件数据在传输过程中消耗的流量和时间，我们在浏览器支持解压的情况下使用服务器压缩功能，浏览器会在请求时默认发送请求头 <code>Accept-Encoding</code> 通知我们的服务器当前支持的压缩格式，我们要做的就是按照压缩格式的优先级进行匹配，按照最高优先级的压缩格式进行压缩，将压缩后的数据返回，并通过响应头 <code>Content-Encoding</code> 通知浏览器当前的压缩格式（压缩流的本质为转化流）。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— compress 方法 */
Server.prototype.compress = function (req, res, statObj) {
  // 获取浏览器支持的压缩格式
  const encoding = req.headers[&#39;accept-encoding&#39;];

  // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩
  if (encoding &amp;&amp; encoding.match(/\bgzip\b/)) {
    res.setHeader(&#39;Content-Encoding&#39;, &#39;gzip&#39;);
    return zlib.createGzip();
  } else if (encoding &amp;&amp; encoding.match(/\bdeflate\b/)) {
    res.setHeader(&#39;Content-Encoding&#39;, &#39;deflate&#39;);
    return zlib.createDeflate();
  } else {
    return false; // 不支持压缩返回 false
  }
}
</code></pre><p>当浏览器支持压缩时，<code>compress</code> 方法返回的为优先级最高压缩格式的压缩流，不支持返回 <code>false</code>，存在压缩流，则将数据压缩并响应浏览器，与不压缩响应不同的是，需要使用压缩流将可读流转化为可写流写入响应 <code>res</code> 中，所以可读流执行了两次 <code>pipe</code> 方法。</p><h3 id="处理范围请求-range-方法"><a href="#处理范围请求-range-方法" class="headerlink" title="处理范围请求 range 方法"></a>处理范围请求 range 方法</h3><p><code>range</code> 方法处理的场景为客户端发送请求只想获取文件的某个范围的数据，此时通过 <code>range</code> 方法读取文件范围对应的内容响应给客户端，通过响应头 <code>Accept-Ranges</code> 通知浏览器当前响应范围请求，通过响应头 <code>Content-Range</code> 通知客户端响应的范围以及文件的总字节数。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— range 方法 */
Server.prototype.range = function (req, res, statObj) {
  // 获取 range 请求头
  const range = req.headers[&#39;range&#39;];

  if (range) {
    // 获取范围请求的开始和结束位置
    let [, start, end] = range.match(/(\d*)-(\d*)/);

    // 处理请求头中范围参数不传的问题
    start = start ? ParseInt(start) : 0;
    end = end ? ParseInt(end) : statObj.size - 1;

    // 设置范围请求响应
    res.statusCode = 206;
    res.setHeader(&#39;Accept-Ranges&#39;, &#39;bytes&#39;);
    res.setHeader(&#39;Content-Range&#39;, &#39;bytes &#39; + start + &#39;-&#39; + end + &#39;/&#39; + statObj.size);
    fs.createReadStream(this.realPath, { start, end }).pipe(res);

    return true;
  } else {
    return false;
  }
}
</code></pre><p><code>range</code> 方法默认返回值为布尔值，当不是范围请求时返回值为 <code>false</code>，则直接向下执行 <code>sendFile</code> 中的代码，正常读取文件全部内容并响应给浏览器，如果是范围请求则会处理范围请求后在直接结束后返回 <code>true</code>，会在 <code>sendFile</code> 中直接 <code>return</code>，不再向下执行。</p><h2 id="将静态服务器关联到命令行"><a href="#将静态服务器关联到命令行" class="headerlink" title="将静态服务器关联到命令行"></a>将静态服务器关联到命令行</h2><h3 id="命令行启动服务器"><a href="#命令行启动服务器" class="headerlink" title="命令行启动服务器"></a>命令行启动服务器</h3><p><code>http-server</code> 实际上是通过命令行启动、并传参的，我们需要将我们的程序与命令行关联，关联命令行只需以下几个步骤。</p><p>首先，在根目录 <code>package.json</code> 文件中加入 <code>bin</code> 字段，值为对象，对象内属性为命令名称，值为对应执行文件的路径。</p><pre><code class="lang-json">// 文件位置：~static/package.json
{
  &quot;name&quot;: &quot;yourname-http-server&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^2.4.1&quot;,
    &quot;commander&quot;: &quot;^2.17.1&quot;,
    &quot;debug&quot;: &quot;^3.1.0&quot;,
    &quot;ejs&quot;: &quot;^2.6.1&quot;,
    &quot;mime&quot;: &quot;^2.3.1&quot;,
    &quot;mz&quot;: &quot;^2.7.0&quot;
  },
  &quot;bin&quot;: {
    &quot;yourname-http-server&quot;: &quot;bin/yourname-http-server.js&quot;
  },
  &quot;devDependencies&quot;: {},
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre><p>其次，在 <code>yourname-http-server.js</code> 文件中首行加入注释 <code>#! /usr/bin/env node</code>，在命令行执行命令时，默认会以 <code>Node</code> 执行 <code>yourname-http-server.js</code> 文件。</p><p>最后，想要使用我们的命令启动 <code>yourname-http-server.js</code> 文件，则需要将这条命令连接到全局（与 <code>-g</code> 安装效果相同），在当前根目录下执行以下命令。</p><pre><code class="lang-bash">$ npm link
</code></pre><blockquote class="pullquote default"><p><em><strong>当在命令行执行 <code>yourname-http-server</code> 时，<code>Node</code> 会默认执行 <code>yourname-http-server.js</code> 文件。</strong></em></p></blockquote><h3 id="命令行的参数传递"><a href="#命令行的参数传递" class="headerlink" title="命令行的参数传递"></a>命令行的参数传递</h3><p>我们现在知道在命令行执行命令后用 Node 启动的文件为 <code>yourname-http-server.js</code>，在启动文件时我们应该启动我们的服务器，并结合 <code>commander</code> 模块的参数解析，则需要用命令行传递的参数替换掉 <code>config.js</code> 中的默认参数。</p><pre><code class="lang-js">/* 文件位置：~static/bin/yourname-http-server.js —— 命令行执行文件 */
const commander = require(&#39;commander&#39;);
const Server = require(&#39;../index&#39;);

// 增加 How to use
commander.on(&#39;--help&#39;, function () {
  console.log(&#39;\r\n  How to use: \r\n&#39;)
  console.log(&#39;    yourname-http-server --port &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --host &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --dir &lt;val&gt;&#39;);
});

// 解析 Node 进程执行时的参数
commander
  .version(&#39;1.0.0&#39;)
  .usage(&#39;[options]&#39;)
  .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;)
  .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;)
  .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;)
  .parse(process.argv);

// 创建 Server 实例传入命令行解析的参数
const server = new Server(commander);

// 启动服务器
server.start();
</code></pre><p>我们之前把 <code>config.js</code> 的配置直接挂在了 <code>Server</code> 实例的 <code>config</code> 属性上，创建服务使用的参数也是直接从该属性上获取的，因此我们要用 <code>commander</code> 对象对应的参数覆盖实例上 <code>config</code> 的参数，所以在创建 <code>Server</code> 实例时传入了 <code>commander</code> 对象，下面稍微修改 <code>Server</code> 类的部分代码。</p><pre><code class="lang-js">/* 文件位置：~static/index.js —— Server 类 */
class Server {
  constructor(options) {
    // 通过解构赋值将 options 的参数覆盖 config 的参数
    this.config = { ...config, ...options }; // 配置
    this.template = templateStr; // 模板
  }
}
</code></pre><p>执行下面命令，并通过浏览器访问 <a href="javascript:;">http://127.0.0.1:4000</a> 来测试服务器功能。</p><pre><code class="lang-bash">$ yourname-http-server --port 4000 --host 127.0.0.1
</code></pre><h3 id="在启动服务时自动打开浏览器"><a href="#在启动服务时自动打开浏览器" class="headerlink" title="在启动服务时自动打开浏览器"></a>在启动服务时自动打开浏览器</h3><p>由于 <code>JS</code> 是单线程的，在命令行输入命令启动服务的同时不能去做其他的事，此时要靠多进程来帮助我们打开浏览器，在 <code>JS</code> 中开启一个子进程来打开浏览器。</p><pre><code class="lang-js">/* 文件位置：~static/bin/yourname-http-server.js —— 命令行执行文件 */
const commander = require(&#39;commander&#39;);
const Server = require(&#39;../index&#39;);

// 增加 How to use
commander.on(&#39;--help&#39;, function () {
  console.log(&#39;\r\n  How to use: \r\n&#39;)
  console.log(&#39;    yourname-http-server --port &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --host &lt;val&gt;&#39;);
  console.log(&#39;    yourname-http-server --dir &lt;val&gt;&#39;);
});

// 解析 Node 进程执行时的参数
commander
  .version(&#39;1.0.0&#39;)
  .usage(&#39;[options]&#39;)
  .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;)
  .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;)
  .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;)
  .parse(process.argv);

// 创建 Server 实例传入命令行解析的参数
const server = new Server(commander);

// 启动服务器
server.start();

// ********** 以下为新增代码 **********
const { exec } = require(&#39;child_process&#39;);

// 判断系统执行不同的命令打开浏览器
const systemOrder = process.platform === &#39;win32&#39; ? &#39;start&#39; : &#39;open&#39;;
exec(systemOrder + &#39;http://&#39; + commander.localhost + &#39;:&#39; + commander.port);
// ********** 以上为新增代码 **********
</code></pre><h3 id="发布命令行工具到-npm"><a href="#发布命令行工具到-npm" class="headerlink" title="发布命令行工具到 npm"></a>发布命令行工具到 npm</h3><p>在发布我们自己实现的 <code>npm</code> 模块之前需要先做一件事，就是解除当前模块与全局环境的 <code>link</code>，我们可以通过两种方式，第一种方式是直接到系统存储命令文件的文件夹删除模块对应命令的 <code>yourname-http-server.cmd</code> （<code>Windows</code>）文件，第二种方式是在模块根目录启动命令行并输入如下命令。</p><pre><code class="lang-bash">$ npm unlink
</code></pre><p>输入下面命令进行登录：</p><pre><code class="lang-bash">$ npm login
</code></pre><p>登录成功后执行下面命令进行发布：</p><pre><code class="lang-bash">$ npm publish
</code></pre><p>发布成功后再次使用自己的模块需要通过 <code>npm</code> 下载并全局安装，命令如下：</p><pre><code class="lang-bash">$ npm install yourname-http-server -g
</code></pre><p>任意文件夹内打开命令行，并执行命令启动服务验证。</p><blockquote class="pullquote warning"><p><em><strong>在发布模块之前如果使用 <code>nrm</code> 切换过其他的源，必须切换回 <code>npm</code>，再进行登录和发布操作。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>其实我们实现的静态服务器核心还在于处理请求和响应的逻辑上，只是不再手动输入 <code>node</code> 命令启动，而是借助一些第三方模块关联到了命令行并通过命令启动，开发其他类型的命令行工具也需要借助这些第三方模块，静态服务器只是其中之一，其实类似这种命令行工具在开发的角度来讲属于 “造轮子” 系列，可以独立开发命令行工具是一个成为前端架构的必备技能，希望通过本篇文章可以了解命令行工具的开发流程，在未来 “造轮子” 的道路上提供帮助。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>命令行</tag>
        <tag>HTTP</tag>
        <tag>http-server</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 缓存的那些事儿</title>
    <url>/20180720110647/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/caching.png" title="HTTP 缓存策略"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote primary"><p><strong><code>HTTP</code> 缓存机制作为 <code>Web</code> 应用性能优化的重要手段，对于从事 <code>Web</code> 开发的同学们来说，应该是知识体系的基础环节，也是想要成为前端架构的必备技能。</strong></p></blockquote><a id="more"></a><h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><blockquote class="pullquote default"><p><strong>我们为什么使用缓存，是因为缓存可以给我们的 <code>Web</code> 项目带来以下好处，以提高性能和用户体验。</strong></p><ul><li><strong>加快了浏览器加载网页的速度；</strong></li><li><strong>减少了冗余的数据传输，节省网络流量和带宽；</strong></li><li><strong>减少服务器的负担，大大提高了网站的性能。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>由于从本地缓存读取静态资源，加快浏览器的网页加载速度是一定的，也确实的减少了数据传输，就提高网站性能来说，可能一两个用户的访问对于减小服务器的负担没有明显效果，但如果这个网站在高并发的情况下，使用缓存对于减小服务器压力和整个网站的性能都会发生质的变化。</strong></p></blockquote><h2 id="缓存规则简介"><a href="#缓存规则简介" class="headerlink" title="缓存规则简介"></a>缓存规则简介</h2><p>为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/cache-rule.png" alt="缓存流程图"></div><div class="image-caption">缓存流程图</div></figure><p><br></p><blockquote class="pullquote success"><p><strong>当浏览器地址栏输入地址后请求的 <code>index.html</code> 是不会被缓存的，但 <code>index.html</code> 内部请求的其他资源会遵循缓存策略，<code>HTTP</code> 缓存有多种规则，根据是否需要向服务器发送请求主要分为两大类，强制缓存和协商缓存。</strong></p></blockquote><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><h3 id="强制缓存流程"><a href="#强制缓存流程" class="headerlink" title="强制缓存流程"></a>强制缓存流程</h3><p>强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据，强制缓存的流程如下。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/mandatory-cache.png" alt="强制缓存流程图"></div><div class="image-caption">强制缓存流程图</div></figure><p><br></p><h3 id="强制缓存判断到期时间"><a href="#强制缓存判断到期时间" class="headerlink" title="强制缓存判断到期时间"></a>强制缓存判断到期时间</h3><p>那么如何判断缓存是否到期呢？其实还是根据第一次访问时服务器的响应头来实现的，在 <code>HTTP 1.0</code> 版本和 <code>HTTP 1.1</code> 版本有所不同。</p><blockquote class="pullquote primary"><ul><li><strong>在 <code>HTTP 1.0</code> 版本，服务器使用的响应头字段为 <code>Expires</code>，值是将来的绝对时间（时间戳），浏览器请求时的当前时间超过了 <code>Expires</code> 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。</strong><br>-</li><li><strong>在 <code>HTTP 1.1</code> 版本，服务器使用的响应头字段为 <code>Cache-Control</code>，有多个值，意义各不相同。</strong><ul><li><strong><code>private</code>：客户端可以缓存；</strong></li><li><strong><code>public</code>：客户端和代理服务器都可以缓存（对于前端而言，可以认为与 <code>private</code> 效果相同）；</strong></li><li><strong><code>max-age=xxx</code>：缓存的内容将在 <code>xxx</code> 秒后过期（相对时间，秒为单位）；</strong></li><li><strong><code>no-cache</code>：需要使用协商缓存（后面介绍）来验证数据是否过期；</strong></li><li><strong><code>no-store</code>：所有内容都不会缓存，强制缓存和协商缓存都不会触发。</strong></li></ul></li></ul></blockquote><p><code>Cache-Control</code> 的值中最常用的为 <code>max-age=xxx</code>，缓存本身就是为了数据传输的优化和性能而存在的，所以 <code>no-store</code> 很少使用。</p><blockquote class="pullquote warning"><p><strong>注意：在 <code>HTTP 1.0</code> 版本中，<code>Expires</code> 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 <code>HTTP 1.1</code> 版本中，因为 <code>Cache-Control</code> 的值 <code>max-age=xxx</code> 中的 <code>xxx</code> 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 <code>HTTP 1.0</code> 中缓存命中存在误差的缺点，为了兼容低版本 <code>HTTP</code> 协议，两种响应头会同时使用，<code>HTTP 1.1</code> 版本优先级高于 <code>HTTP 1.0</code>。</strong></p></blockquote><h3 id="通过-Network-查看强制缓存"><a href="#通过-Network-查看强制缓存" class="headerlink" title="通过 Network 查看强制缓存"></a>通过 Network 查看强制缓存</h3><p>我们通过 <code>Chrome</code> 浏览器的开发者工具，打开 <code>NetWork</code> 查看强制缓存的相关信息。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-mandatory-response.png" alt="缓存响应头"></div><div class="image-caption">缓存响应头</div></figure><p><br></p><p>上面是百度网站 <code>Logo</code> 图片的响应，我们可以清楚的看到，其中兼容了 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 版本，并使用强制缓存存储了 <code>10</code> 年。</p><p>下面看一看通过缓存取出的数据在 <code>Network</code> 中与其他资源的区别。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-mandatory-cache.png" alt="命中缓存"></div><div class="image-caption">命中缓存</div></figure><p><br></p><blockquote class="pullquote info"><p><strong>其实缓存的储存是内存和磁盘两个位置，由当前浏览器本身的策略决定，比较随机，从内存的缓存中取出的数据会显示 <code>(from memory cache)</code>，从磁盘的缓存中取出的数据会显示 <code>(from disk cache)</code>。</strong></p></blockquote><h3 id="Node-js-服务器实现强制缓存"><a href="#Node-js-服务器实现强制缓存" class="headerlink" title="Node.js 服务器实现强制缓存"></a>Node.js 服务器实现强制缓存</h3><pre><code class="lang-js">/* 强制缓存 */
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const path = require(&#39;path&#39;);
const mime = require(&#39;mime&#39;);
const fs = require(&#39;fs&#39;);

const server = http.createServer((req, res) =&gt; {
  let { pathname } = url.parse(req.url, true);
  pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;;

  // 获取读取文件的绝对路径
  const filePath = path.join(__dirname, pathname);

  // 查看路径是否合法
  fs.access(filePath, err =&gt; {
    // 路径不合法则直接中断连接
    if (err) return res.end(&#39;Not Found&#39;);

    // 设置强制缓存
    res.setHeader(&#39;Expires&#39;, new Date(Date.now() + 30000).toGMTString());
    res.setHeader(&#39;Cache-Control&#39;, &#39;max-age=30&#39;);

    // 设置文件类型并响应给浏览器
    res.setHeader(&#39;Content-Type&#39;, mime.getType(filePath) + &#39;;charset=utf8&#39;);
    fs.createReadStream(filePath).pipe(res);
  });
});

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>上面 <code>mime</code> 模块的 <code>getType</code> 方法可以成功返回传入路径下文件对应的文件类型，如 <code>text/html</code> 和 <code>application/javascript</code> 等，是第三方模块，使用之前需要安装。</p><pre><code class="lang-bash">$ npm install mime
</code></pre><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h3 id="协商缓存流程"><a href="#协商缓存流程" class="headerlink" title="协商缓存流程"></a>协商缓存流程</h3><p>协商缓存又叫对比缓存，设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，响应浏览器通知数据未更改，浏览器会去缓存中获取数据，如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中，协商缓存的流程如下。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/compared-cache.png" alt="协商缓存流程图"></div><div class="image-caption">协商缓存流程图</div></figure><p><br></p><blockquote class="pullquote success"><p><strong>协商缓存和强制缓存不同的是，协商缓存每次请求都需要跟服务器通信，而且命中缓存服务器返回状态码不再是 <code>200</code>，而是 <code>304</code>。</strong></p></blockquote><h3 id="协商缓存判断标识"><a href="#协商缓存判断标识" class="headerlink" title="协商缓存判断标识"></a>协商缓存判断标识</h3><p>强制缓存是通过过期时间来控制是否访问服务器，而协商缓存每次都要与服务器交互对比缓存标识，同样的，对于协商缓存的实现在 <code>HTTP 1.0</code> 版本和 <code>HTTP 1.1</code> 版本也有所不同。</p><p>在 <code>HTTP 1.0</code> 版本中，服务器通过 <code>Last-Modified</code> 响应头来设置缓存标识，通常取请求数据的最后修改时间（绝对时间）作为值，而浏览器将接收到返回的数据和标识存入缓存，再次请求会自动发送 <code>If-Modified-Since</code> 请求头，值为之前返回的最后修改时间（标识），服务器取出 <code>If-Modified-Since</code> 的值与数据的上次修改时间对比，如果上次修改时间大于了 <code>If-Modified-Since</code> 的值，说明被修改过，则通过 <code>Last-Modified</code> 响应头返回新的最后修改时间和新的数据，否则未被修改，返回状态码 <code>304</code> 通知浏览器命中缓存。</p><p>在 <code>HTTP 1.1</code> 版本中，服务器通过 <code>Etag</code> 响应头来设置缓存标识（唯一标识，像一个指纹一样，生成规则由服务器来决定），浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 <code>If-None-Match</code> 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，返回新标识和数据，相同，则返回状态码 <code>304</code> 通知浏览器命中缓存。</p><p><strong>HTTP 协商缓存策略流程图如下：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/cache-flow-chart.jpg" alt="缓存策略流程图"></div><div class="image-caption">缓存策略流程图</div></figure><p><br></p><blockquote class="pullquote warning"><p><strong>注意：使用协商缓存时 <code>HTTP 1.0</code> 版本还是不太靠谱，假设一个文件增加了一个字符后又删除了，文件相当于没更改，但是最后修改时间变了，会被当作修改处理，本应该命中缓存，服务器却重新发送了数据，因此 <code>HTTP 1.1</code> 中使用的 <code>Etag</code> 唯一标识是根据文件内容或摘要生成的，保证了只要文件内容不变，则一定会命中缓存，为了兼容低版本 <code>HTTP</code> 协议，开发中两种响应头也会同时使用，同样 <code>HTTP 1.1</code> 版本的实现优先级高于 <code>HTTP 1.0</code>。</strong></p></blockquote><h3 id="通过-Network-查看协商缓存"><a href="#通过-Network-查看协商缓存" class="headerlink" title="通过 Network 查看协商缓存"></a>通过 Network 查看协商缓存</h3><p>我们同样通过 <code>Chrome</code> 浏览器的开发者工具，打开 <code>NetWork</code> 查看协商缓存的相关信息。</p><p><strong>再次请求服务器的请求头信息：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-mandatory-request.png" alt="再次请求服务器的请求头信息"></div><div class="image-caption">再次请求服务器的请求头信息</div></figure><p><br></p><p><strong>命中协商缓存的响应头信息：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-mandatory-response-cache.png" alt="命中协商缓存的响应头信息"></div><div class="image-caption">命中协商缓存的响应头信息</div></figure><p><br></p><p>下面看一看通过协商缓存取出的数据在 <code>Network</code> 中与第一次加载的区别。</p><p><strong>第一次请求：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-compared-before-cache.png" alt="第一次请求"></div><div class="image-caption">第一次请求</div></figure><p><br></p><p><strong>缓存后请求：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180720110647/network-compared-cache.png" alt="缓存后请求"></div><div class="image-caption">缓存后请求</div></figure><p><br></p><p>通过两图的对比，我们可以发现，协商缓存生效时的状态码为 <code>304</code>，并且报文大小和请求时间大大减少，原因是服务端在进行标识比对后只返回了 <code>header</code> 部分，通过状态码来通知浏览器使用缓存，不再需要将报文主体部分一起返回给浏览器。</p><h3 id="Node-js-服务器实现协商缓存"><a href="#Node-js-服务器实现协商缓存" class="headerlink" title="Node.js 服务器实现协商缓存"></a>Node.js 服务器实现协商缓存</h3><pre><code class="lang-js">/* 协商缓存 */
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const path = require(&#39;path&#39;);
const mime = require(&#39;mime&#39;);
const fs = require(&#39;fs&#39;);0
const crytpo = require(&#39;crytpo&#39;);

const server = http.createServer((req, res) =&gt; {
  let { pathname } = url.parse(req.url, true);
  pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;;

  // 获取读取文件的绝对路径
  const filePath = path.join(__dirname, pathname);

  // 查看路径是否合法
  fs.stat(filePath, (err, statObj) =&gt; {
    // 路径不合法则直接中断连接
    if (err) return res.end(&#39;Not Found&#39;);

    const md5 = crypto.createHash(&#39;md5&#39;); // 创建加密的转换流
    const rs = fs.createReadStream(filePath); // 创建可读流

    // 读取文件内容并加密
    rs.on(&#39;data&#39;, data =&gt; md5.update(data));

    rs.on(&#39;end&#39;, () =&gt; {
      const ctime = statObj.ctime.toGMTString(); // 获取文件最后修改时间
      const flag = md5.digest(&#39;hex&#39;); // 获取加密后的唯一标识

      // 获取协商缓存的请求头
      const ifModifiedSince = req.headers[&#39;if-modified-since&#39;];
      const ifNoneMatch = req.headers[&#39;if-none-match&#39;];

      if (ifModifiedSince === ctime || ifNoneMatch === flag) {
        res.statusCode = 304;
        res.end();
      } else {
        // 设置协商缓存
        res.setHeader(&#39;Last-Modified&#39;, ctime);
        res.setHeader(&#39;Etag&#39;, flag);

        // 设置文件类型并响应给浏览器
        res.setHeader(&#39;Content-Type&#39;, mime.getType(filePath) + &#39;;charset=utf8&#39;);
        rs.pipe(res);
      }
    });
  });
});

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>在上面的代码中是通过可读流读取文件内容，并通过 <code>crypto</code> 模块进行了 <code>md5</code> 加密后的结果作为了唯一标识，这样就能保证只要文件内容不变，就会命中缓存，其中兼容了 <code>HTTP 1.0</code> 和 <code>HTTP 1.1</code> 两个版本，只要满足一个则直接返回 <code>304</code> 通知浏览器命中缓存。</p><blockquote class="pullquote warning"><p><strong>注意：其实读取文件内容加密这种做法并不可取，假如读取的是大文件，在读取文件内容和进行 <code>md5</code> 加密这个过程会非常消耗时间，所以在开发中要针对业务的实际情况选择可以保证服务器性能的方式生成唯一标识，比如根据文件的摘要。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>为了使缓存策略更加健壮、灵活，<code>HTTP 1.0</code> 版本 和 <code>HTTP 1.1</code> 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 <code>Etag</code> 和 <code>Last-Modified</code> 通过请求头 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 <code>304</code> 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>性能优化</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 加密 —— crypto 模块</title>
    <url>/20180719190551/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180719190551/crypto.png" title="Node.js 加密模块 crypto"><p><br></p><h2 id="加密简介"><a href="#加密简介" class="headerlink" title="加密简介"></a>加密简介</h2><blockquote class="pullquote danger"><p><strong>加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义，通过这种方式提高网络数据传输的安全性，加密算法常见的有哈希算法、<code>HMAC</code> 算法、签名、对称性加密算法和非对称性加密算法，加密算法也分为可逆和不可逆，比如 <code>md5</code> 就是不可逆加密，只能暴力破解（撞库），我们在 <code>Node.js</code> 开发中就可以通过 <code>crypto</code> 模块直接使用这些加密算法，是包含对 <code>OpenSSL</code> 的哈希、<code>HMAC</code>、加密、解密、签名以及验证功能的一整套封装，核心模块，使用时不需安装。</strong></p></blockquote><a id="more"></a><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法也叫散列算法，用来把任意长度的输入变换成固定长度的输出，常见的有 <code>md5</code>、<code>sha1</code> 等，这类算法实现对原数据的转化过程是否能被称为加密备受争议，为了后面叙述方便我们姑且先叫做加密。</p><pre><code class="lang-js">/* 查看哈希加密算法的种类 */
const crypto = require(&#39;crypto&#39;);

// getHashes 方法用于查看支持的加密算法
console.log(crypto.getHashes());

// [ &#39;DSA&#39;, &#39;DSA-SHA&#39;, &#39;DSA-SHA1&#39;, &#39;DSA-cSHA1-old&#39;,
//   &#39;RSA-MD4&#39;, &#39;RSA-MD5&#39;, &#39;RSA-MDC2&#39;, &#39;RSA-RIPEMD160&#39;,
//   &#39;RSA-SHA&#39;, &#39;RSA-SHA1&#39;, &#39;RSA-SHA1-2&#39;, &#39;RSA-SHA224&#39;,
//   &#39;RSA-SHA256&#39;, &#39;RSA-SHA384&#39;, &#39;RSA-SHA512&#39;,
//   &#39;dsaEncryption&#39;, &#39;dsaWithSHA&#39;, &#39;dsaWithSHA1&#39;, &#39;dss1&#39;,
//   &#39;ecdsa-with-SHA1&#39;, &#39;md4&#39;, &#39;md4WithRSAEncryption&#39;,
//   &#39;md5&#39;, &#39;md5WithRSAEncryption&#39;, &#39;mdc2&#39;, &#39;mdc2WithRSA&#39;,
//   &#39;ripemd&#39;, &#39;ripemd160&#39;, &#39;ripemd160WithRSA&#39;, &#39;rmd160&#39;,
//   &#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, &#39;sha224&#39;,
//   &#39;sha224WithRSAEncryption&#39;, &#39;sha256&#39;,
//   &#39;sha256WithRSAEncryption&#39;, &#39;sha384&#39;,
//   &#39;sha384WithRSAEncryption&#39;, &#39;sha512&#39;,
//   &#39;sha512WithRSAEncryption&#39;, &#39;shaWithRSAEncryption&#39;,
//   &#39;ssl2-md5&#39;, &#39;ssl3-md5&#39;, &#39;ssl3-sha1&#39;, &#39;whirlpool&#39; ]
</code></pre><blockquote class="pullquote info"><p><strong><code>md5</code> 是开发中经常使用的算法之一，官方称为摘要算法，具有以下几个特点：</strong></p><ul><li><strong>不可逆；</strong></li><li><strong>不管加密的内容多长，最后输出的结果长度都是相等的；</strong></li><li><strong>内容不同输出的结果完全不同，内容相同输出的结果完全相同。</strong></li></ul></blockquote><p>由于相同的输入经过 <code>md5</code> 加密后返回的结果完全相同，所以破解时通过 “撞库” 进行暴力破解，当连续被 <code>md5</code> 加密 <code>3</code> 次以上时就很难被破解了，所以使用 <code>md5</code> 一般会进行多次加密。</p><pre><code class="lang-js">/* md5 加密 —— 返回 Buffer */
const crytpo = require(&#39;crytpo&#39;);

// createHash 创建 MD5，update 传入加密信息并加密，digest 获取加密后结果
const md5 = crytpo.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest();
console.log(md5);
// &lt;Buffer 5d 41 40 2a bc 4b 2a 76 b9 71 9d 91 10 17 c5 92&gt;
</code></pre><p><code>digest</code> 方法参数用于指定加密后的返回值的格式，不传参默认返回加密后的 <code>Buffer</code>，常用的参数有 <code>hex</code> 和 <code>Base64</code>，<code>hex</code> 代表十六进制，加密后长度为 <code>32</code>，<code>Base64</code> 的结果长度为 <code>24</code>，以 <code>==</code> 结尾。</p><pre><code class="lang-js">/* md5 加密 —— 返回十六进制 */
const crypto = require(&#39;crypto&#39;);

const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest(&#39;hex&#39;);
console.log(md5); // 5d41402abc4b2a76b9719d911017c592
</code></pre><pre><code class="lang-js">/* md5 加密 —— 返回 Base64 */
const crypto = require(&#39;crypto&#39;);

const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest(&#39;Base64&#39;);
console.log(md5); // XUFAKrxLKna5cZ2REBfFkg==
</code></pre><p><code>update</code> 方法的返回值就是 <code>this</code>，即当前实例，所以支持链式调用，较长的信息也可以多次调用 <code>update</code> 方法进行分段加密，调用 <code>digest</code> 方法同样会返回整个加密后的值。</p><pre><code class="lang-js">/* 链式调用和分段加密 */
const crypto = require(&#39;crypto&#39;);

const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;he&#39;).update(&#39;llo&#39;).digest(&#39;hex&#39;);
console.log(md5); // 5d41402abc4b2a76b9719d911017c592
</code></pre><p>由于可以使用 <code>update</code> 进行分段加密，就可以结合流来使用，其实 <code>crypto</code> 的本质是创建 <code>Transform</code> 类型的转化流，可以将可读流转化成可写流。</p><pre><code class="lang-js">/* 对可读流读取的数据进行 md5 加密 */
const crypto = require(&#39;crypto&#39;);
const fs = require(&#39;fs&#39;);

const md5 = crypto.createHash(&#39;md5&#39;);
const rs = fs.createReadSteam(&#39;./readme.txt&#39;, {
  highWaterMark: 3
});

// 连续读取数据并分段加密
rs.on(&#39;data&#39;, data =&gt; md5.update(data));

rs.on(&#39;end&#39;, () =&gt; {
  const result = md5.digest(&#39;hex&#39;);
  console.log(result);
});
</code></pre><blockquote class="pullquote info"><p><strong>使用场景：</strong></p><ul><li><strong>经常被使用在数据的校验，比如服务器与服务器之间进行通信发送的明文摘要加 <code>md5</code> 加密摘要后的暗文，接收端拿到数据以后将明文摘要按照相同的 <code>md5</code> 算法加密后与暗文摘要对比验证，目的是防止数据传输过程中被劫持并篡改。</strong></li><li><strong>在浏览器缓存策略中，可以通过对静态资源的信息摘要使用 <code>md5</code> 加密，每次向服务器发送加密后的密钥进行比对就可以了，不至于对整个文件内容进行比较。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>缺点：由于规定使用 <code>md5</code> 的哈希算法加密，别人可以使用同样的算法对信息进行伪造，安全性不高。</strong></p></blockquote><h2 id="Hmac-算法"><a href="#Hmac-算法" class="headerlink" title="Hmac 算法"></a>Hmac 算法</h2><h3 id="Hmac-算法的使用"><a href="#Hmac-算法的使用" class="headerlink" title="Hmac 算法的使用"></a>Hmac 算法的使用</h3><p><code>Hmac</code> 算法又称加盐算法，是将哈希算法与一个密钥结合在一起，用来阻止对签名完整性的破坏，同样具备 <code>md5</code> 加密的几个特点。</p><pre><code class="lang-js">/* 使用加盐算法加密 */
const crytpo = require(&#39;crytpo&#39;);

const hmac = crytpo.createHmac(&#39;sha1&#39;, &#39;panda&#39;).update(&#39;hello&#39;).digest(&#39;Base64&#39;);
console.log(hmac); // 7spMLxN8WJdcEtQ8Hm/LR9pUE3YsIGag9Dcai7lwioo=
</code></pre><p><code>crytpo.createHmac</code> 第一个参数同 <code>crytpo.createHash</code>，为加密的算法，常用 <code>sha1</code> 和 <code>sha256</code>，第二个参数为密钥。</p><p><code>digest</code> 方法生成的加密结果长度要大于 <code>md5</code>，<code>hex</code> 生成的结果长度为 <code>64</code>，<code>Base64</code> 生成的结果长度为 <code>44</code>，以 <code>=</code> 结尾。</p><blockquote class="pullquote success"><p><strong>安全性高于 <code>md5</code>，通过密钥来加密，不知道密钥无法破解，缺点是密钥传输的过程容易被劫持，可以通过一些生成随机密钥的方式避免。</strong></p></blockquote><h3 id="创建密钥的方法"><a href="#创建密钥的方法" class="headerlink" title="创建密钥的方法"></a>创建密钥的方法</h3><p><strong>可以安装 <code>openSSH</code> 客户端，并通过命令行生成存储密钥的文件，命令如下:</strong></p><pre><code class="lang-bash">$ openssl genrsa -out rsa_private.key 1024
</code></pre><p><code>openssl genrsa</code> 代表生成密钥，<code>-out</code> 代表输出文件，<code>rsa_private.key</code> 代表文件名，<code>1024</code> 代表输出密钥的大小。</p><pre><code class="lang-js">/* 直接读取密钥文件配合加盐算法加密 */
const fs = require(&#39;fs&#39;);
const crytpo = require(&#39;crytpo&#39;);
const path = require(&#39;path&#39;);

const key = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;));
const hmac = crytpo.createHmac(&#39;sha256&#39;, key).update(&#39;hello&#39;).digest(&#39;Base64&#39;);

console.log(hmac); // bmi2N+6kwgwt5b+U+zSgjL/NFs+GsUnZmcieqLKBy4M=
</code></pre><h2 id="对称性加密"><a href="#对称性加密" class="headerlink" title="对称性加密"></a>对称性加密</h2><p>对称性加密是发送数据时使用密钥和加密算法进行加密，接收数据时需要使用相同的密钥和加密算法的逆算法（解密算法）进行解密，也就是说对称性加密的过程是可逆的，<code>crytpo</code> 中使用的算法为 <code>blowfish</code>。</p><pre><code class="lang-js">/* 对称性加密 */
const fs = require(&#39;fs&#39;);
const crypto = require(&#39;crypto&#39;);
const path = require(&#39;path&#39;);

const key = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;));

// 加密
const cipher = crypto.createCipher(&#39;blowfish&#39;, key);
cipher.update(&#39;hello&#39;);

// final 方法不能链式调用
const result = cipher.final(&#39;hex&#39;);
console.log(result); // 3eb9943113c7aa1e

// 解密
const decipher = crypto.createDecipher(&#39;blowfish&#39;, key);
decipher.update(result, &#39;hex&#39;);

const data = decipher.final(&#39;utf8&#39;);
console.log(data); // hello
</code></pre><p>加密使用 <code>crypto.createCipher</code> 方法，解密使用 <code>crypto.createDecipher</code> 方法，但是使用的算法和密钥必须相同，需要注意的是解密过程中 <code>update</code> 中需要在第二个参数中指定加密时的格式（其实在加密的时候 <code>update</code> 也存在第二个参数，默认值为 <code>utf8</code>）如 <code>hex</code>，在 <code>final</code> 还原数据时需要指定加密字符的编码格式，如 <code>utf8</code>。</p><blockquote class="pullquote warning"><p><strong>注意：使用对称性加密的字符串有长度限制，不得超过 <code>7</code> 个字符，否则虽然可以加密成功，但是无法解密。</strong></p></blockquote><blockquote class="pullquote danger"><p><strong>缺点：密钥在传输过程中容易被截获，存在安全风险。</strong></p></blockquote><h2 id="非对称性加密"><a href="#非对称性加密" class="headerlink" title="非对称性加密"></a>非对称性加密</h2><p>非对称性加密相也是可逆的，较于对称性加密要更安全，消息传输方和接收方都会在本地创建一对密钥，公钥和私钥，互相将自己的公钥发送给对方，每次消息传递时使用对方的公钥加密，对方接收消息后使用他的的私钥解密，这样在公钥传递的过程中被截获也无法解密，因为公钥加密的消息只有配对的私钥可以解密。</p><p>接下来我们使用 <code>openSSH</code> 对之前生成的私钥 <code>rsa_private.key</code> 产生一个对应的公钥，命令如下。</p><pre><code class="lang-bash">$ openssl rsa -in rsa_private.key -pubout -out rsa_public.key
</code></pre><p>上面的命令意思根据一个私钥生成对应的公钥，<code>-pubout -out</code> 代表公钥输出，<code>rsa_public.key</code> 为公钥的文件名。</p><pre><code class="lang-js">/* 非对称性加密 */
const fs = require(&#39;fs&#39;);
const crypto = require(&#39;crypto&#39;);
const path = require(&#39;path&#39;);

// 获取公钥和私钥
const publicKey = fs.readFileSync(path.join(__dirname, &#39;/rsa_public.key&#39;));
const privateKey = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;));

// 加密
const secret = crytpo.publicEncrypt(publicKey, Buffer.from(&#39;hello&#39;));

// 解密
const result = crytpo.provateDecrypt(privateKey, secret);

console.log(result); // hello
</code></pre><p>使用公钥加密的方法是 <code>crytpo.publicEncrypt</code>，第一个参数为公钥，第二个参数为加密信息（必须是 <code>Buffer</code>），使用私钥解密的方法是 <code>crytpo.provateDecrypt</code>，第一个参数为私钥，第二个参数为解密的信息。</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名与非对称性加密非常类似，同样有公钥和私钥，不同的是使用私钥加密，对方使用公钥进行解密验证，以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180719190551/sign.png" alt="签名"></div><div class="image-caption">签名</div></figure><p><br></p><p>我们还使用 <code>rsa_public.key</code> 和 <code>rsa_private.key</code> 作为公钥和私钥，<code>crypto</code> 实现签名代码如下。</p><pre><code class="lang-js">/* 签名 */
const fs = require(&#39;fs&#39;);
const crypto = require(&#39;crypto&#39;);
const path = require(&#39;path&#39;);

// 获取公钥和私钥
const publicKey = fs.readFileSync(path.join(__dirname, &#39;rsa_public.key&#39;), &#39;ascii&#39;);
const privateKey = fs.readFileSync(path.join(__dirname, &#39;rsa_private.key&#39;), &#39;ascii&#39;);

// 生成签名
const signed = crypto.createSign(&#39;RSA-SHA256&#39;).update(&#39;panda&#39;).sign(privateKey, &#39;hex&#39;);

// 验证签名
const verify = crypto.createVerify(&#39;RSA-SHA256&#39;).update(&#39;panda&#39;).verify(publicKey, signed, &#39;hex&#39;);

console.log(verify); // true
</code></pre><p>生成签名的 <code>sign</code> 方法有两个参数，第一个参数为私钥，第二个参数为生成签名的格式，最后返回的 <code>signed</code> 为生成的签名（字符串）。</p><p>验证签名的 <code>verify</code> 方法有三个参数，第一个参数为公钥，第二个参数为被验证的签名，第三个参数为生成签名时的格式，返回为布尔值，即是否通过验证。</p><blockquote class="pullquote primary"><p><strong>使用场景：经常用于对 <code>cookie</code> 签名返回浏览器，当浏览器访问同域服务器将 <code>cookie</code> 带过来时再进行验证，防止 <code>cookie</code> 被篡改和 <code>CSRF</code> 跨站请求伪造。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>各种项目在数据传输时根据信息的敏感度以及用途进行不同的加密算法和加密方式，在 <code>Node.js</code> 中，<code>crypto</code> 的 <code>API</code> 完全可以实现我们的加密需求，也可以将上面的加密方案组合使用实现更复杂的加密方案。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>加密</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 服务器实现 gzip 压缩</title>
    <url>/20180718181823/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180718181823/gzip.png" title="Node.js 实现 gzip 压缩"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote success"><p><strong>在浏览器向服务器请求静态资源时，服务器为了减小在网络传输过程中消耗的流量和时间，都是将静态资源经过压缩后返回给服务器的，实现压缩的算法有 <code>deflate</code> 和 <code>gzip</code> 等，最常用的是 <code>gzip</code> 压缩。</strong></p></blockquote><a id="more"></a><h2 id="gzip-简介"><a href="#gzip-简介" class="headerlink" title="gzip 简介"></a>gzip 简介</h2><p>在浏览器和服务器之间通过 <code>gzip</code> 压缩流实现传输的过程可以用下图表示。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180718181823/how-gzip-works.png" alt="gzip 压缩工作原理"></div><div class="image-caption">gzip 压缩工作原理</div></figure><p><br></p><p>当浏览器向服务器请求静态资源，服务器会将静态资源经过处理转换为压缩流，大大减小文件体积，然后将压缩流返回给浏览器，浏览器通过压缩的类型重新将压缩流解析成静态文件。</p><h2 id="zlib-模块的使用"><a href="#zlib-模块的使用" class="headerlink" title="zlib 模块的使用"></a>zlib 模块的使用</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>在 Node.js 中通过 <code>zlib</code> 模块帮助我们实现不同类型的压缩，其实压缩的过程就是创建流的过程，创建的压缩流是 Transform 类型（转化流），读取文件的内容经过转化流创建一个新类型的文件。</p><pre><code class="lang-js">/* 文件：gzip.js */
const zlib = require(&#39;zlib&#39;);
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 压缩
function gzip(source) {
  // 处理输入和输出的文件路径
  const sourcePath = path.join(__dirname, source);
  const gzipPath = sourcePath + &#39;.gz&#39;;

  // 创建转化流
  const gzip = zlib.createGzip();

  // 创建可读流
  const rs = fs.createReadStream(sourcePath);

  // 创建可写流
  const ws = fs.createWriteStream(gzipPath);

  // 实现转化
  rs.pipe(gzip).pipe(ws);
}

gzip(&#39;index.html&#39;);
</code></pre><p>执行上面代码查看根目路是否出现 <code>index.gz</code> 压缩包。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>压缩的过程是可逆的，可以压缩就可以解压，无论是在浏览器还是在服务器，我们下面实现解压的方法。</p><pre><code class="lang-js">/* 文件：gunzip.js */
const zlib = require(&#39;zlib&#39;);
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 解压
function gunzip(source) {
  // 处理输入和输出的文件路径
  const sourcePath = path.join(__dirname, source);
  const filePath = path.join(__dirname, path.basename(source, &#39;.gz&#39;));

  // 创建转化流
  const unzip = zlib.createGunzip();

  // 创建可读流
  const rs = fs.createReadStream(sourcePath);

  // 创建可写流
  const ws = fs.createWriteStream(filePath);

  // 实现转化
  rs.pipe(unzip).pipe(ws);
}

gunzip(&#39;index.html.gz&#39;);
</code></pre><p>删除原来 <code>index.html</code>，执行解压代码，查看文件根目录是否生成 <code>index.html</code>。</p><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><p>在浏览器与服务器的交互中，浏览器其实会通过请求头 <code>Accept-Encoding</code> 告诉服务器当前支持解压的压缩格式，值为 <code>gzip, deflate, br</code>，多个压缩格式用 <code>,</code> 隔开，服务器在接收到浏览器请求后，会按照请求头的格式压缩资源，将压缩后的资源返回，并通过响应头 <code>Content-Encoding</code> 告诉浏览器当前服务器压缩的格式。</p><pre><code class="lang-js">/* 文件：server.js */
// 引入依赖
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const path = require(&#39;path&#39;);
const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

// 创建服务器
const server = http.createServer((req, res) =&gt; {
  // 处理 pathname，&#39;/&#39; 时默认读取 &#39;/index.html&#39;
  let { pathname } = url.parse(req.url, true);
  pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;;

  // 获取读取文件的绝对路径
  const filePath = path.join(__dirname, pathname);

  // 查看路径是否合法
  fs.access(filePath, err =&gt; {
    // 路径不合法则直接中断连接
    if (err) return res.end(&#39;Not Found&#39;);

    // 创建压缩流变量，压缩类型变量
    let compress, compressType

    // 获取浏览器支持的压缩格式
    const encoding = req.headers[&#39;accept-encoding&#39;];

    // 创建可读流
    const rs = fs.createReadStream(filePath);

    // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩
    if (encoding &amp;&amp; encoding.match(/\bgzip\b/)) {
      compress = zlib.createGzip();
      compressType = &#39;gzip&#39;;
    } else if (encoding &amp;&amp; encoding.match(/\bdeflate\b/)) {
      compress = zlib.createDeflate();
      compressType = &#39;deflate&#39;;
    } else {
      // 否则直接返回可读流
      return rs.pipe(res);
    }

    // 将压缩流返回并设置响应头
    res.setHeader(&#39;Content-Encoding&#39;, compressType);
    rs.pipe(compress).pipe(res);
  });
});

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>在上面服务器代码中如果不通过响应头通知浏览器当前资源的压缩格式，浏览器会不知道该如何解压，默认会当成文件下载，如 <code>Chrome</code>，所以在返回压缩流时必须通过 <code>Content-Encoding</code> 响应头通知浏览器当前的压缩格式。</p><h2 id="测试服务器压缩"><a href="#测试服务器压缩" class="headerlink" title="测试服务器压缩"></a>测试服务器压缩</h2><p>我们在文件根目录创建一个 <code>index.html</code> 文件，代码如下。</p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;gzip&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;Hello GZIP!&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>启动服务器 <code>server.js</code>，然后通过浏览器访问 <a href="javascript:;">localhost:3000</a>，查看页面能否正确返回，并查看开发者工具 Network 中的响应头 <code>Content-Encoding</code> 的值是否正确。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p><strong>服务器压缩其实是客户端与服务器在网络传输时的一种优化手段，可以大大减小流量的消耗和响应时间，而 <code>gzip</code> 只是目前最常用的一种压缩格式，即压缩算法。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>http-headers</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 实现简易的多语言服务</title>
    <url>/20180717111807/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180717111807/multi-language.png" title="Node.js 实现多语言"><p><br></p><h2 id="什么是多语言？"><a href="#什么是多语言？" class="headerlink" title="什么是多语言？"></a>什么是多语言？</h2><blockquote class="pullquote warning"><p><strong>我们平时访问一些文档类型的网站时，经常可以看到页面右上角有一个下拉框用来选择当前页面支持的语言，并在选中后将整个网页的内容切换为选中的语言，这就是项目中的多语言，多语言可以根据浏览器请求发送的语言类型在服务器进行设置，也可以在请求服务器时返回多种语言，并根据权重和浏览器的支持情况进行选择和渲染。</strong></p></blockquote><a id="more"></a><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>在本文中我们通过客户端向服务器发送请求告诉服务器客户端所支持的语言及权重，服务器检索语言包并根据客户端发送的语言类型和权重返回对应语言的内容。</p><p>在这个过程中客户端向服务器发送请求需要使用请求头 <code>Accept-Language</code>，值中设置语言类型和权重，语言与语言之间使用 <code>,</code> 隔开，语言与权重之间使用 <code>;</code> 隔开，权重用 <code>q</code> 表示，与值用 <code>=</code> 隔开，如果权重值为 <code>1</code> 则可省略（最大值），值的格式为 <code>zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1</code>。</p><p>服务器响应时，应通过响应头告诉浏览器返回的内容为何种语言，响应头为 <code>Content-Language</code>, 值的格式为 <code>zh-CN, en</code>，多个语言之间使用 <code>,</code> 隔开。</p><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><pre><code class="lang-js">/* 文件：server.js */
const http = require(&#39;http&#39;);
const querystring = require(&#39;querystring&#39;);

// 语言包
const languagesPackage = {
  &#39;zh-CN&#39;: &#39;你好&#39;,
  &#39;en&#39;: &#39;Hello&#39;,
  &#39;fr&#39;: &#39;Bonjour&#39;
};

// 默认语言为英语
languagesPackage.defaultLanguage = &#39;en&#39;;

// 创建服务器
const server = http.createServer((req, res) =&gt; {
  // 获取请求头中的语言和权重
  const languages = req.headers[&#39;accept-language&#39;];

  // 如果客户端设置了语言
  if (languages) {
    // 解析语言为 [{ name: &#39;zh-CN&#39;, q: 1 }, { name: &#39;en&#39;, q: &#39;0.8&#39; }] 格式
    const lans = languages.split(&#39;,&#39;).map(lang =&gt; {
      const [name, q = 1] = Object.keys(querystring.parse(lang.tirm(), &#39;;q=&#39;, true));
      return { name, q };
    }).sort((a, b) =&gt; b.q - a.q); // 并按照权重逆序排序

    // 循环检测 languagesPackage 是否存在客户端的语言
    for (let i = 0; i &lt; lans.length; i++) {
      const { name } = lans[i];
      const content = languagesPackage[name];

      // 如果存在直接设置响应头并返回内容
      if (content) {
        res.setHeader(&#39;Content-Type&#39;, name);
        return res.end(content);
      }
    }
  }

  // 如果客户端没设置语言活语言找不到时返回服务器设置的默认语言
  res.setHeader(&#39;Content-Type&#39;, languagesPackage.defaultLanguage);
  res.end(languagesPackage[languagesPackage.defaultLanguage]);
});

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>其实上面服务器和客户端配合实现多语言的思路就是客户端向服务器发送 <code>Accept-Language</code> 告诉服务器需要的语言和权重，服务器解析后根据权重从大到小排序，然后循环判断语言包中是否含有客户端需要的语言，如果有，则中断循环直接设置响应头和返回对应内容，如果不存在客户端的需要的语言或者客户端没有向后台发送 <code>Accept-Language</code> 则返回服务器默认设置的语言类型和内容。</p><blockquote class="pullquote danger"><p><strong>通常多语言的语言包是通过其他服务和一些其他的规则请求回来的，我们为了方便是在服务里通过 <code>config</code> 写死了。</strong></p></blockquote><h2 id="验证多语言"><a href="#验证多语言" class="headerlink" title="验证多语言"></a>验证多语言</h2><p>为了方便我们使用 <code>curl</code> 模拟客户端向服务器发送请求查看返回内容是否正确，之所以使用 <code>curl</code> 是因为只发送验证的请求，方便设置 <code>Accept-Language</code> 请求头，更灵活的控制多语言的类型和权重。</p><p>启动服务器 <code>server.js</code>，打开命令行窗口，输入下面的命令执行，查看返回命令行响应体中的内容和设置的语言是否对应。</p><pre><code class="lang-bash">$ curl -v --header &quot;Accept-Language: zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1&quot; http://localhost:3000
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>这样我们就实现了一个简单的多语言服务，其实真正的多语言在服务器是需要做繁琐的解析和性能优化（只解析界面有的单词返回，保证响应体中的内容最小），也可以通过配合成熟的 <code>il8n</code>（国际化语言包）库来实现。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>http-headers</tag>
        <tag>multi-language</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 服务器数据处理（表单、json 字符串和普通字符串）</title>
    <url>/20180716155948/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180716155948/form-submit.png" title="Node.js 处理不同类型数据"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><strong>从浏览器向服务器提交数据时，常见有表单提交，<code>json</code> 字符串提交和普通字符串提交，不同情况需要附带不同的请求头信息，告诉服务器客户端可以直接解析的数据格式，如果发送的数据为 <code>json</code> 字符串，后两种类型都可以成功发送到服务器，只是加上请求头信息服务器更容易判断该以什么格式返回数据。</strong></p></blockquote><a id="more"></a><h2 id="querystring-模块解析请求体"><a href="#querystring-模块解析请求体" class="headerlink" title="querystring 模块解析请求体"></a>querystring 模块解析请求体</h2><blockquote class="pullquote info"><p><strong>在 <code>get</code> 请求中，我们可以通过 <code>url</code> 模块的 <code>parse</code> 方法来解析，如果是带有请求体的请求类型，如 <code>post</code>、<code>put</code> 我们应该使用 <code>querystring</code> 模块的 <code>parse</code> 方法将请求体中的数据解析成对象，在这个方法中有三个参数。</strong></p><ul><li><strong><code>str</code>：要解析的查询字符串；</strong></li><li><strong><code>sep</code>：查询字符串中键值对之间的分隔符，默认为 <code>&amp;</code>；</strong></li><li><strong><code>eq</code>：查询字符串中的键与值的分隔符，默认为 <code>=</code>。</strong></li></ul></blockquote><pre><code class="lang-js">/* 文件：querystring-test.js */
const querystring = require(&#39;querystring&#39;);

const query1 = &#39;name=pandashen&amp;age=27&#39;;
const query2 = &#39;name*pandashen!&amp;age*27&#39;;

const params1 = querystring.parse(query1);
const params2 = querystring.parse(query2, &#39;!&amp;&#39;, &#39;*&#39;);

console.log(params1); // { name: &#39;pandashen&#39;, age: &#39;27&#39;}
console.log(params2); // { name: &#39;pandashen&#39;, age: &#39;27&#39;}
</code></pre><p><code>querystring</code> 也是很常用的模块，就在这里多说几句关于 <code>querystring</code> 模块常用方法 <code>parse</code> 的实现。</p><pre><code class="lang-js">/* 文件：my-querystring.js */
exports.parse = (str, sep = &#39;&amp;&#39;, eq = &#39;=&#39;) =&gt; {
  // 存储解析出键值的对象
  const query = {};

  // 先将查询字符串切割成 [k=v, k=b] 的形式
  const fields = str.split(sep);

  // 循环将每一项切割成 k 和 v 并存入 queryObj 中
  fields.forEach(field =&gt; {
    const [key, value] = field.split(eq);
    query[key] = value;
  });

  // 返回 query 对象
  return query;
};
</code></pre><h2 id="服务器的实现"><a href="#服务器的实现" class="headerlink" title="服务器的实现"></a>服务器的实现</h2><p>向服务器发送请求的请求头为 <code>Content-Type</code>，表单提交、<code>json</code> 和字符串作为请求体时，在 <code>Content-Type</code> 中对应的值分别为 <code>application/x-www-form-urlencoded</code>、<code>application/json</code> 和 <code>text/plain</code>。</p><p>其中 <code>text/plain</code> 为 <code>Ajax</code> 的默认提交方式，我们在服务器中针对上面这几种类型的请求头和 <code>get</code> 请求做处理，将发来的数据再次返回客户端。</p><pre><code class="lang-js">/* 文件：server.js */
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const querystring = require(&#39;querystring&#39;);

const server = http.createServer((req, res) =&gt; {
  // 获取 get 请求参数
  const { query } = url.parse(req.url, true);
  // 获取数据类型请求头
  const type = req.headers[&#39;content-type&#39;];
  // 接收数据
  const buffers = [];

  res.on(&#39;data&#39;, data =&gt; buffers.push(data));
  res.on(&#39;end&#39;, () =&gt; {
    // 合并数据并设置默认响应头和返回数据
    let data = Buffer.concat(buffers).toString();
    let contentType = &#39;application/json&#39;;

    // 判断是否为 get 请求，是则直接返回解析后的数据，不是则判断请求类型
    if (req.method.toLowerCase() === &#39;get&#39;) {
      data = JSON.stringify(query);
    } else {
      // 判断请求数据类型并做相应处理
      if (type === &#39;application/x-www-form-urlencoded&#39;) {
        data = JSON.stringify(querystring.parse(data));
      } else if (type === &#39;application/json&#39;) {
        data = JSON.stringify(JSON.parse(data));
      } else {
        contentType = &#39;text/plain&#39;;
      }
    }

    // 设置响应头并返回数据
    res.setHeader(&#39;Content-Type&#39;, contentType);
    res.end(data);
  });
});

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
}
</code></pre><p>当请求类型为 <code>get</code>，将查询字符串通过 <code>url</code> 模块解析后再处理成字符串返回客户端。</p><p>当请求类型为 <code>post</code>，设置默认响应头为 <code>application/json</code>，如果是表单提交，请求体中的内容为查询字符串格式，使用 <code>querystring</code> 解析后再使用 <code>JSON.stringify</code> 处理成字符串返回，如果是 <code>json</code>，则使用 <code>JSON.parse</code> 解析，并使用 <code>JSON.stringify</code> 处理成字符串返回，如果是默认值 <code>text/plain</code>，则设置响应头的值为 <code>text/plain</code> 并将读取的结果直接返回。</p><h2 id="使用客户端进行测试"><a href="#使用客户端进行测试" class="headerlink" title="使用客户端进行测试"></a>使用客户端进行测试</h2><p>在这里我们为了方便就不用浏览器访问了（需要创建各种不同类型提交的页面），因为上面的服务器代码比较简单，只处理了数据，并没有处理静态文件请求，所以我们通过 <code>Node.js</code> 来实现客户端。</p><h3 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h3><pre><code class="lang-js">/* 文件：get.js */
const http = require(&#39;http&#39;);

const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  path: &#39;/?name=pandashen&amp;age=27&#39;
};

// 发送 get 请求
http.get(config, res =&gt; {
  // 接收服务器返回的数据
  const buffers = [];
  res.on(&#39;data&#39;, data =&gt; buffers.push(data));
  res.on(&#39;end&#39;, () =&gt; {
    const data = Buffer.concat(buffers).toString();
    console.log(data);
  });
});
</code></pre><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node get.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求表单提交"><a href="#post-请求表单提交" class="headerlink" title="post 请求表单提交"></a>post 请求表单提交</h3><pre><code class="lang-js">/* 文件：post-from.js */
const http = require(&#39;http&#39;);

const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  method: &#39;post&#39;
  headers: {
    &#39;Content-type&#39;: &#39;application/x-www-form-urlencoded&#39;
  }
};

http.request(config, res =&gt; {
  // 接收服务器返回的数据
  const buffers = [];
  res.on(&#39;data&#39;, data =&gt; buffers.push(data));
  res.on(&#39;end&#39;, () =&gt; {
    const data = Buffer.concat(buffers).toString();
    console.log(data);
  });
}).end(&#39;name=pandashen&amp;age=27&#39;);
</code></pre><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-form.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求-json-字符串数据"><a href="#post-请求-json-字符串数据" class="headerlink" title="post 请求 json 字符串数据"></a>post 请求 json 字符串数据</h3><pre><code class="lang-js">/* 文件：post-json.js */
const http = require(&#39;http&#39;);

const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  method: &#39;post&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/json&#39;
  }
};

http.request(config, res =&gt; {
  // 接收服务器返回的数据
  const buffers = [];
  res.on(&#39;data&#39;, data =&gt; buffers.push(data));
  res.on(&#39;end&#39;, () =&gt; {
    const data = Buffer.concat(buffers).toString();
    console.log(data);
  });
}).end(&#39;{ name: pandashen, age: 27 }&#39;);
</code></pre><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-json.js</code> 查看命令窗口中输出的结果。</p><h3 id="post-请求普通字符串数据"><a href="#post-请求普通字符串数据" class="headerlink" title="post 请求普通字符串数据"></a>post 请求普通字符串数据</h3><pre><code class="lang-js">/* 文件：post-string.js */
const http = require(&#39;http&#39;);

const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  method: &#39;post&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;text/plain&#39;
  }
};

http.request(config, res =&gt; {
  // 接收服务器返回的数据
  const buffers = [];
  res.on(&#39;data&#39;, data =&gt; buffers.push(data));
  res.on(&#39;end&#39;, () =&gt; {
    let data = Buffer.concat(buffers).toString();
    console.log(data);
  });
}).end(&#39;pandashen27&#39;);
</code></pre><p>启动服务器 <code>server.js</code>，通过命令行执行 <code>node post-string.js</code> 查看命令窗口中输出的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>通过本篇的内容可以了解 <code>HTTP</code> 在数据传输中的类型，即请求头类型，服务端通过请求头类型可以返回客户端可以直接解析的数据，上面的几种类型只是向服务器提交数据的最常见类型，涵盖表单提交和 <code>Ajax</code> 等（在上传文件时还存在二进制传输）。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>http-headers</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 服务器实现资源防盗链</title>
    <url>/20180714150009/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180714150009/resource-security.png" title="Node.js 资源防盗链"><p><br></p><h2 id="什么是-“盗链”？"><a href="#什么是-“盗链”？" class="headerlink" title="什么是 “盗链”？"></a>什么是 “盗链”？</h2><blockquote class="pullquote primary"><p><strong>“盗链” 说白了就是利用别人网站的资源链接放在自己的站点，在未经允许的情况下去获取别人网站里面的图片或者视频等资源，导致资源所有者的网站的流量费用增加或收入减少，为了防止资源链接随意被人盗用的手段被称为 “防盗链”。</strong></p></blockquote><a id="more"></a><h2 id="模拟-“盗链”-场景"><a href="#模拟-“盗链”-场景" class="headerlink" title="模拟 “盗链” 场景"></a>模拟 “盗链” 场景</h2><p>我们先来模拟一下 “盗链” 场景，在本地启动服务运行 <code>hotlinking.html</code> 文件，并在文件中盗用百度视频的图片资源，看看效果。</p><pre><code class="lang-html">&lt;!-- 文件：hotlinking.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;盗链&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;img src=&quot;http://c.hiphotos.baidu.com/c9f1faaf51f2de66ad.jpg&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>我们通过 <code>http-server</code> 来启动服务器访问 <code>hotlinking.html</code>，使用 <code>http-server</code> 需全局安装。</p><pre><code class="lang-bash">$ http-server install -g
</code></pre><p>在服务中打开 <code>hotlinking.html</code> 后我们发现图片并不是我们盗用链接的资源，而是变成了下面这张图片。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180714150009/embezzle.png" alt="百度盗链返回图片"></div><div class="image-caption">百度盗链返回图片</div></figure><p><br></p><p>这张图用来提醒我们盗用了别人资源，是因为百度的服务器做了防盗链处理，如果所有盗用别人的资源都变成这样，盗用也就没有实际意义了，我们本篇就通过 <code>Node.js</code> 来实现防盗链处理，用来保护自己站点的资源。</p><blockquote class="pullquote warning"><p><strong>注意：具备防盗链处理的网站的资源链接可以直接通过浏览器地址栏访问，也可以在文件域（<code>file</code> 协议）访问，限制的是在未经允许的情况下其他服务器的访问。</strong></p></blockquote><h2 id="Node-js-服务器实现防盗链"><a href="#Node-js-服务器实现防盗链" class="headerlink" title="Node.js 服务器实现防盗链"></a>Node.js 服务器实现防盗链</h2><h3 id="模拟两个域名"><a href="#模拟两个域名" class="headerlink" title="模拟两个域名"></a>模拟两个域名</h3><p><strong>在本地的 <code>hosts</code> 文件中加入两个域名：</strong></p><pre><code class="lang-vim">127.0.0.1   panda.com
127.0.0.1   shen.com
</code></pre><h3 id="准备图片资源"><a href="#准备图片资源" class="headerlink" title="准备图片资源"></a>准备图片资源</h3><p>在根目录创建文件夹 <code>public</code> 并存入两张图片，<code>success.png</code> 是正常请求的图片资源，<code>error.png</code> 是经过防盗链处理后返回的图片资源，两张图片如下。</p><p><strong>正常返回的图片资源 <code>success.png</code></strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180714150009/success.png" alt="正常返回资源"></div><div class="image-caption">正常返回资源</div></figure><p><br></p><p><strong>防盗链处理后返回的图片资源 <code>error.png</code></strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180714150009/error.png" alt="盗链返回资源"></div><div class="image-caption">盗链返回资源</div></figure><p><br></p><h3 id="页面-index-html"><a href="#页面-index-html" class="headerlink" title="页面 index.html"></a>页面 index.html</h3><p>在页面当中通过 <code>img</code> 标签分别访问 <a href="javascript">shen.com</a>、<a href="javascript">panda.com</a> 和 <a href="javascript">localhost</a> 域下的 <code>success.png</code> 文件。</p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;盗链&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;img src=&quot;http://panda.com:3000/success.png&quot;&gt;
  &lt;img src=&quot;http://shen.com:3000/success.png&quot;&gt;
  &lt;img src=&quot;http://localhost:3000/success.png&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="服务端-server-js"><a href="#服务端-server-js" class="headerlink" title="服务端 server.js"></a>服务端 server.js</h3><blockquote class="pullquote default"><p><strong>在写服务端代码之前需要介绍两个重要的请求头：</strong></p><ul><li><strong><code>host</code>：资源所在的域</strong></li><li><strong><code>referer</code>：请求来源的域</strong></li></ul></blockquote><p>其实资源防盗就是设置白名单，通过检测 <code>referer</code> 是否在白名单中，如果在则正常返回资源，不存在则返回经过防盗链处理的资源。</p><blockquote class="pullquote info"><p><em><strong>注意：<code>referer</code> 请求头在地址栏输入地址时发送的请求是不存在的（如请求 <code>index.html</code> 页面），在旧版本的 <code>HTTP</code> 协议中 <code>referer</code> 的写法为 <code>referered</code>，所以为了兼容旧版本协议应该做兼容处理。</strong></em></p></blockquote><pre><code class="lang-js">/* 文件：server.js */
// 引入依赖
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const path = require(&#39;path&#39;);
const fs = require(&#39;mz/fs&#39;);

const server = http.createServer(responseImages); // 创建服务器
const static = path.resolve(__dirname, &#39;public&#39;); // 静态资源目录
const whiteList = [&#39;shen.com&#39;]; // 白名单

async function responseImages(req, res) {
  // 解析 url 中的文件目录处理成绝对路径
  let imgPath = path.join(static, url.parse(req.url).pathname);

  // 检测文件路径是否合法，不合法直接返回 Not Found
  const isExist = await fs.exists(imgPath);

  if (isExist) {
    // 获取 referer
    const refer = req.headers[&#39;referer&#39;] || req.headers[&#39;referered&#39;];

    // 存在 referer 继续检测
    if (refer) {
      // 请求资源存在 referer，做防盗链处理
      const referHost = url.parse(refer).hostname;
      const host = req.headers[&#39;host&#39;].split(&#39;:&#39;)[0];

      // 当访问源的域和资源所在的域不是同一个域，做防盗链处理
      if (referHost !== host) {
        const isInWhiteList = whiteList.includes(refer);
        imgPath = isInWhiteList ? imgPath : path.join(static, &#39;error.png&#39;);
      }
    }

    // 第一次访问请求页面 index.html，不存在 referer，将静态资源返回
    // 第二次访问请求图片资源，如果 referer 和资源所本就是同一个域，直接将资源返回
    fs.createReadStream(imgPath).pipe(res);
  } else {
    res.statusCode = 404;
    res.end(&#39;Not Found&#39;);
  }
}

server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>其实上面的服务器是 <a href="javascript:;">shen.com</a>、<a href="javascript:;">panda.com</a> 和 <a href="javascript:;">localhost</a> 所共用的，只是通过不同的域名访问。</p><p>启动服务器，然后通过 <a href="javascript:;">localhost:3000</a> 访问，此时由于与 <a href="javascript:;">shen.com</a> 和 <a href="javascript:;">panda.com</a> 为不同域，所以只有第三张图片返回 <code>success.png</code>。</p><p>通过 <a href="javascript:;">shen.com:3000</a> 访问，由于存在白名单中，所以三张图片都返回 <code>success.png</code>。</p><p>通过 <a href="javascript:;">panda.com:3000</a> 访问，由于 <a href="javascript:;">shen.com</a> 在不同域，所以没有返回 <code>success.png</code>。</p><blockquote class="pullquote primary"><p><strong>无论通过</strong> <a href="javascript:;">shen.com</a> <strong>还是</strong> <a href="javascript:;">panda.com</a> <strong>访问</strong> <a href="javascript:;">localhost</a> <strong>的资源都是在同域的，所以都能获取到。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在上面我们利用本地服务实现了一个最基本的防盗链，思路就是 <code>referer</code> 与资源同域，正常返回，不同域检测白名单，在真实的开发场景可能会更细化，更复杂一些，其实整个防盗链实现的核心就是利用 <code>HTTP</code> 的 <code>referer</code> 和 <code>host</code> 请求头做检测，希望通过本篇的学习，大家可以对资源防盗链有所了解，并在后面开发类似功能时提供思路。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>http-headers</tag>
        <tag>资源防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 使用 Range 请求实现下载功能</title>
    <url>/20180713130808/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180713130808/byte-range.png" title="HTTP 范围请求"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong>本篇使用 <code>Node.js</code> 的 <code>HTTP</code> 服务创建客户端，使用 <code>Range</code> 请求实现下载功能，并通过本篇的 <code>Demo</code> 扩展在业务中实现断点续传等功能的思路。</strong></p></blockquote><a id="more"></a><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>我们通过 <code>http</code> 模块创建服务器处理 <code>Range</code> 请求，在服务器代码中我们为了减少回调嵌套使用 <code>async</code> 函数，所以需要将异步的操作方法转换成 <code>Promise</code>， <code>util</code> 的 <code>promisify</code> 来可以将异步方法一个一个转换，比较麻烦，可以直接使用第三方模块 <code>mz</code> 并直接引入转换好的替代模块。</p><p><strong>使用 <code>mz</code> 之前需要先安装：</strong></p><pre><code class="lang-bash">$ npm install mz
</code></pre><p><strong>服务端代码如下：</strong></p><pre><code class="lang-js">/* 文件：server.js */
const http = require(&#39;http&#39;);
const path = require(&#39;path&#39;);
const url = require(&#39;url&#39;);

// 引入 mz 模块转换成 Promise 的 fs 模块
const fs = require(&#39;mz/fs&#39;);

// 请求处理函数
async function listener(req, res) {
  // 获取 range 请求头，格式为 Range:bytes=0-5
  const range = req.headers[&#39;range&#39;];

  // 下载文件路径
  const downloadPath = path.resovle(__dirname, url.parse(req.url, true).pathname);

  // 存在 range 请求头将返回范围请求的数据
  if (range) {
    // 获取范围请求的开始和结束位置
    let [, start, end] = range.match(/(\d*)-(\d*)/);

    // 错误处理
    try {
      const statObj = await fs.stat(downloadPath);
    } catch (e) {
      res.end(&#39;Not Found&#39;);
    }

    // 文件总字节数
    const total = statObj.size;

    // 处理请求头中范围参数不传的问题
    start = start ? ParseInt(start) : 0;
    end = end ? ParseInt(end) : total - 1;

    // 响应客户端
    res.statusCode = 206;
    res.setHeader(&#39;Accept-Ranges&#39;, &#39;bytes&#39;);
    res.setHeader(&#39;Content-Range&#39;, &#39;bytes &#39; + start + &#39;-&#39; + end + &#39;/&#39; + total);
    fs.createReadStream(downloadPath, { start, end }).pipe(res);
  } else {
    // 没有 range 请求头时将整个文件内容返回给客户端
    fs.createReadStream(downloadPath).pipe(res);
  }
}

// 创建服务器
const server = http.createServer(listener);

// 监听端口
server.listen(3000, () =&gt; {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>在上面服务端的代码中，需要兼容 <code>Range</code> 请求和普通请求，两种请求的区别是，如果客户端发送的是 <code>Range</code> 请求，会携带 <code>Range:bytes=0-5</code> 格式的请求头，我们可以通过 <code>req</code> 的 <code>headers</code> 属性获取，在获取请求头时，原本大写字母开头 <code>Node.js</code> 统一处理成小写，所以获取时应小写。</p><p>如果是 <code>Range</code> 请求则通过可读流读取对应的内容返回客户端，如果不是，则通过可读流读取整个文件返回客户端，在响应 <code>Range</code> 请求的过程中需要设置响应状态为 <code>206</code>，需要设置响应头 <code>Accept-Ranges</code> 值为 <code>bytes</code>，需要设置响应头 <code>Content-Range</code> 值为 <code>byte 0-5/100</code> 的格式，<code>0</code> 为返回数据开始的索引，<code>5</code> 为结束的索引（包含），<code>100</code> 为文件的总字节数。</p><p>在通过 <code>url</code> 和 <code>path</code> 模块解析和拼接下载文件路径时，应该进行错误检测，如果文件不存在则直接返回客户端 <code>Not Found</code>。</p><p>我们可以使用 <code>curl</code> 命令来检测我们的服务端代码，在命令行工具中输入下面命令，在命令窗口查看返回值是否正确。</p><pre><code class="lang-bash">$ curl -v --header &quot;Range:bytes=0-5&quot; http://localhost:3000
</code></pre><h2 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h2><p>在上面使用 <code>curl</code> 命令来访问我们的服务器时，只能请求固定范围的数据，而不是类似于下载功能，每次都下载一个范围的数据，但是想要多次下载并自动维护 <code>Range</code> 的范围需要借助我们自己实现的客户端逻辑。</p><p>为了简便，我们的下载客户端是在命令行窗口运行的，通过指令来模拟实际项目中的开始下载、暂停和恢复按钮，当在窗口中输入 <code>s</code> 指令时开始下载，输入 <code>p</code> 指令时暂停下载，输入 <code>r</code> 指令时恢复下载。</p><pre><code class="lang-js">/* 文件：client.js */
const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 请求配置
const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  path: &#39;/download.txt&#39;
};

let start = 0; // 请求初始值
let step = 5; // 每次请求字符个数
let pause = false; // 暂停状态
let total; // 文件总长度

// 创建可写流
const ws = fs.createWriteStream(path.resolve(__dirname, config.path.slice(1)));

// 下载函数
function download() {
  // 配置，每次范围请求 step 个字节
  config.headers = {
    Range: &#39;bytes=&#39; + start + &#39;-&#39; + (start + step - 1);
  };

  // 维护下次 start 的值
  start += step;

  // 发送请求
  http.request(config, res =&gt; {
    // 获取文件总长度
    if (typeof total !== &#39;number&#39;) {
      total = res.headers[&#39;content-ranges&#39;].match(/\/(\d*)/)[1];
    }

    // 读取返回数据
    const buffers = [];
    res.on(&#39;data&#39;, data =&gt; buffers.push(data));
    res.on(&#39;end&#39;, () =&gt; {
      // 合并数据并写入文件
      const buf = Buffer.concat(buffers);
      ws.write(buf);

      // 递归进行下一次请求
      if (!pause &amp;&amp; start &lt; total) {
        download();
      }
    });
  }).end();
}

// 监控输入
process.stdin.on(&#39;data&#39;, data =&gt; {
  // 获取指令
  const ins = data.toString().match(/(\w*)\/r/)[1];
  switch (ins) {
    case &#39;s&#39;:
    case &#39;r&#39;:
      pause = false;
      download();
      break;
    case &#39;p&#39;:
      pause = true;
      break;
  }
});
</code></pre><p>在上面代码中下载的文件通过 <code>config</code> 中的 <code>path</code> 属性配置，每次调用 <code>download</code> 函数下载时都会重新计算当前范围请求的初始位置和结束位置，并设置 <code>Range</code> 请求头，下一次请求靠递归 <code>download</code> 来实现。</p><p>在执行时需先启动我们的服务器，在通过命令行输入 <code>node client.js</code> 来启动客户端，在命令窗口输入对应的指令进行开始下载、暂停下载和恢复下载操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>相信现在已经了解什么是范围请求，范围请求客户端和服务端需要做些什么，其实说白了就是对应的请求头和响应头的使用，需要注意的是范围请求的响应状态码为 <code>206</code>，这样的需求在一些上传、下载资源的网站也很常见，其目的就是为了让我们实现断点续传，不至于一次没有上传或下载完成的资源文件，在下一次的做同样操作时需要重新来过，可以接着上次的位置继续，范围请求在视频网站上也广泛应用，边请求边观看，不至于一次加载整个视频资源，节省流量，节省时间。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>范围请求</tag>
        <tag>http-headers</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 搭建 HTTP 服务器</title>
    <url>/20180712195514/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180712195514/your-first-node-server.png" title="HTTP 服务器"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote success"><p><strong><code>Node.js</code> 可以用 <code>http</code> 模块来创建 <code>Web</code> 服务，本篇就来介绍关于使用 <code>http</code> 模块搭建 <code>HTTP</code> 服务和客户端的方法，以及模块的基本 <code>API</code>。</strong></p></blockquote><a id="more"></a><h2 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h2><h3 id="创建-HTTP-服务器"><a href="#创建-HTTP-服务器" class="headerlink" title="创建 HTTP 服务器"></a>创建 HTTP 服务器</h3><blockquote class="pullquote warning"><p><strong>在 <code>Node.js</code> 中，创建 <code>HTTP</code> 服务可以与 <code>net</code> 模块创建 <code>TCP</code> 服务对比（可以阅读</strong> <a href="/20180708120357/" target="_blank">基于 TCP 实现简易聊天室</a>），<strong>创建服务有也两种方式。</strong></p></blockquote><p><strong>方式 1：</strong></p><pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer(function (req, res) {
  // ......
});

server.listen(3000);
</code></pre><p><strong>方式 2：</strong></p><pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer();

server.on(&#39;request&#39;, function (req, res) {
  // ......
});

server.listen(3000);
</code></pre><p>在 <code>createServer</code> 的回调和 <code>request</code> 事件的回调函数中有两个参数，<code>req</code>（请求）、<code>res</code>（响应），基于 <code>socket</code>，这两个对象都是 <code>Duplex</code> 类型的可读可写（双工）流。</p><p><code>http</code> 模块是基于 <code>net</code> 模块实现的，所以 <code>net</code> 模块原有的事件在 <code>http</code> 中依然存在。</p><pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer();

// net 模块事件
server.on(&#39;connection&#39;, function (socket) {
  console.log(&#39;连接成功&#39;);
});

server.listen(3000);
</code></pre><h3 id="获取请求信息"><a href="#获取请求信息" class="headerlink" title="获取请求信息"></a>获取请求信息</h3><p>在请求对象 <code>req</code> 中存在请求的方法、请求的 <code>url</code>（包含参数，即查询字符串）、当前的 <code>HTTP</code> 协议版本和请求头等信息。</p><pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer();

server.on(&#39;request&#39;, function (req, res) {
  console.log(req.method); // 获取请求方法
  console.log(req.url); // 获取请求路径（包含查询字符串）
  console.log(req.httpVersion); // 获取 HTTP 协议版本
  console.log(req.headers); // 获取请求头（对象）

  // 获取请求体的内容
  const buffers = [];

  req.on(&#39;data&#39;, function (data) {
    buffers.push(data);
  });

  req.on(&#39;end&#39;, function () {
    console.log(Buffer.concat(buffers).toString());
  });
});

server.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>通过 <code>req</code> 对应的属性可以拿到请求行和请求首部的信息，请求体内的内容通过流操作来获取，其中 <code>url</code> 中存在多个常用的参数，我们自己处理会很麻烦，可以通过 <code>Node.js</code> 自带的 <code>url</code> 模块进行解析。</p><pre><code class="lang-js">const url = require(&#39;url&#39;);
const str = &#39;http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash&#39;;

// parse 方法帮助我们解析 url 路径
const info = url.parse(str, true);
console.log(info);

// {
//   protocol: &#39;http:&#39;,
//   slashes: true,
//   auth: &#39;user:pas&#39;,
//   host: &#39;www.pandashen.com:8080&#39;,
//   port: &#39;8080&#39;,
//   hostname: &#39;www.pandashen.com&#39;,
//   hash: &#39;#hash&#39;,
//   search: &#39;?a=1&amp;b=2&#39;,
//   query: &#39;{ a: &#39;1&#39;, b: &#39;2&#39; }&#39;,
//   pathname: &#39;/src/index.html&#39;
//   path: &#39;/src/index.html?a=1&amp;b=2&#39;,
//   href: &#39;http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash&#39;
// }
</code></pre><blockquote class="pullquote info"><p><strong>在被解析路径返回的对象中有几个属性被经常使用：</strong></p><ul><li><strong><code>host</code>：主机（域名 + 端口号）；</strong></li><li><strong><code>hostname</code>：主机名；</strong></li><li><strong><code>query</code>：请求参数（查询字符串或参数对象）；</strong></li><li><strong><code>pathname</code>：资源路径（根据不同的路径返回不同的资源）。</strong></li></ul></blockquote><p>我们使用 <code>url</code> 的 <code>parse</code> 方法来帮我们解析请求路径，在真实的服务器中传入的第一个参数为 <code>req.url</code>，第二个参数不传时，<code>query</code> 会被解析成 <code>a=1&amp;b=2</code> 的形式，第二个参数传入 <code>true</code>，<code>query</code> 属性的查询字符串会被解析成对象的形式。</p><p><code>url</code> 模块中，将查询字符串 <code>a=1&amp;b=2</code> 转换为对象 <code>{ a: &#39;1&#39;, b: &#39;2&#39; }</code> 的实现方式其实是使用正则替换实现的。</p><p><strong>模拟查询字符串转换对象的核心逻辑：</strong></p><pre><code class="lang-js">const query = &#39;a=1&amp;b=2&amp;c=3&#39;;
const info = {};

query.replace(/([^=&amp;]+)=([^=&amp;]+)/g, function () {
  info[arguments[1]] = arguments[2];
});

console.log(info); // { a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }
</code></pre><blockquote class="pullquote primary"><p><strong>在上面代码的</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank">replace</a> <strong>方法的回调函数中参数集合的第一项为匹配到的字符串，第二项为第一个分组的值，第三项为第二个分组的值，依次类推，倒数第二项为分组匹配的索引，最后一项为原字符串。</strong></p></blockquote><h3 id="设置响应信息"><a href="#设置响应信息" class="headerlink" title="设置响应信息"></a>设置响应信息</h3><p>我们可以通过 <code>req</code> 来获取请求信息，自然也可以通过 <code>res</code> 来设置响应信息返回给客户端。</p><pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer();

server.on(&#39;request&#39;, function (req, res) {
  // 设置响应头（过去的用法），不能多次调用，见到要认识
  res.writeHead(200, { &#39;Content-Type&#39;: &#39;text&#39;, data: &#39;hello world&#39; });

  // 设置响应头（现在的用法，常用），可以多次调用，每次设置一个响应头
  res.setHeader(&#39;Content-Type&#39;, &#39;text&#39;);

  // 设置状态码，不设置默认为 200
  res.statusCode = 200;

  // 不发送 Date（日期）响应头
  res.sendDate = false;

  // 返回内容
  res.write(&#39;hello world&#39;); // 不会关闭连接
  res.end(&#39;hello world&#39;); // 将内容返回后关闭连接
});

server.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p>返回给客户端的信息主要分为两部分，分别为响应头和返回给浏览器的内容，在不设置响应头的情况下，默认会设置响应头 <code>Content-Length</code> 和 <code>Date</code> ，代表当前返回给客户端的内容长度和日期。</p><p>返回给浏览器的内容可以通过 <code>res</code> 的 <code>write</code> 方法和 <code>end</code> 方法进行发送，<code>write</code> 方法不会断开连接（通常在响应后需要断开与客户端的连接），<code>end</code> 方法会断开连接，在 <code>end</code> 方法存在参数时，会在内部调用 <code>write</code> 将参数内容（只支持 <code>string</code> 和 <code>buffer</code>）返回给客户端，并断开连接。</p><h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><p>在 <code>net</code> 模块中可以通过 <code>net.createConnection</code> 来创建客户端，并发送请求到服务端，在 <code>http</code> 模块同样可以创建客户端，并向 <code>http</code> 服务器发送请求。</p><pre><code class="lang-js">/* 客户端：client.js */
const http = require(&#39;http&#39;);

// 发送请求的配置
const config = {
  host: &#39;localhost&#39;,
  port: 3000,
  method: &#39;get&#39;,
  headers: {
    data: 1
  }
};

// 创建客户端
const client = http.request(config, function (res) {
  // 接收服务端返回的数据
  const buffers = [];

  res.on(&#39;data&#39;, function (data) {
    buffers.push(data);
  });

  res.on(&#39;end&#39;, function () {
    console.log(Buffer.concat(buffers).toString());
  });
});

// 发送请求
client.end();
</code></pre><p>在 <code>http</code> 模块中通过 <code>request</code> 方法创建客户端，该方法第一个参数为发送请求的配置，包含请求地址、端口号、请求方法以及请求头等，第二个参数为回调函数，在请求被响应后执行，回调函数的参数为服务器的响应对象 <code>res</code>，创建的客户端通过 <code>end</code> 方法将请求发出与服务端进行通信。</p><blockquote class="pullquote info"><p><strong>使用 <code>Node.js</code> 实现的 “爬虫” 其实就可以通过 <code>http</code> 模块创建的客户端来实现，客户端帮我们向我们要抓取数据的地址发送请求，并拿到响应的数据进行解析。</strong></p></blockquote><h2 id="同时使用-HTTP-客户端和服务器"><a href="#同时使用-HTTP-客户端和服务器" class="headerlink" title="同时使用 HTTP 客户端和服务器"></a>同时使用 HTTP 客户端和服务器</h2><p>我们使用自己创建的客户端访问自己的服务端，并体会请求响应的过程，就是用上面 <code>client.js</code> 作为客户端，启动 <code>server.js</code> 后再启动 <code>client.js</code> 查看效果。</p><pre><code class="lang-js">/* 服务器：server.js */
const http = require(&#39;http&#39;);

http.createServer(function (req, res) {
  console.log(&#39;The request came&#39;);

  // 获取客户端请求信息
  console.log(req.method);
  console.log(req.headers);

  // 返回数据
  res.write(&#39;hello world&#39;);
}).listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><h2 id="简易爬虫"><a href="#简易爬虫" class="headerlink" title="简易爬虫"></a>简易爬虫</h2><p>我们结合 <code>http</code> 模块创建的服务端和客户端实现一个简易版的 “爬虫” 去抓取百度新闻页所有 <code>li</code> 标签内的文章标题。</p><pre><code class="lang-js">/* 简易爬虫：crawl.js */
const http = require(&#39;http&#39;);

// 创建服务器
const server = http.createServer();

// 发送请求的配置
const config = {
  host: &#39;news.baidu.com&#39;,
  method: &#39;get&#39;,
  port: 80
}

// 监听请求
server.on(&#39;request&#39;, function (req, res) {
  const client = http.request(config, function (r) {
    // 接收百度新闻返回的数据
    const buffers = [];

    r.on(&#39;data&#39;, function (data) {
      buffers.push(data);
    });

    r.on(&#39;end&#39;, function () {
      // 处理数据
      const result = Buffer.concat(buffers).toString();
      const matches = result.match(/&lt;li class=&#39;bold-item&#39;&gt;([\s\S*?])&lt;\/li&gt;/gm);

      // 设置返回给浏览器的文档类型和编码格式
      res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;);

      // 响应浏览器
      res.end(matches.join(&#39;&#39;));
    });
  });

  client.end();
});

server.listen(3000);
</code></pre><p>上面的正则匹配中 <code>([\s\S*?])</code> 代表匹配 <code>&lt;li class=&#39;bold-item&#39;&gt;</code> 到 <code>&lt;\/li&gt;</code> 之间所有内容（多个字符、非贪婪模式），<code>gm</code> 代表全局并多行匹配。</p><p>上面爬取百度新闻数据的过程中，我们自己的 <code>Node</code> 服务器扮演了一个 “中间层” 的角色，我们通过浏览器访问自己的服务器 <a href="javascript:;">localhost:3000</a> 触发 <code>request</code> 事件，执行了回调，在回调中创建客户端向 <a href="javascript:;">news.baidu.com</a> 发送了请求，并在客户端的回调中处理了响应（百度新闻页返回的数据），将处理后的内容通过我们自己 <code>Node</code> 服务器的 <code>res</code> 对象返回给了浏览器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote warning"><p><strong>相信在读过本篇文章之后对搭建一个 <code>Node</code> 服务应该已经有了思路，为未来通过 <code>Node</code> 服务实现复杂的业务场景及数据的处理打下了一个基础，希望初学 <code>Node</code> 的小伙伴在看了这篇文章后能有所收获。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 基础</title>
    <url>/20180709185149/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/img.png" title="HTTP 基础"><p><br></p><h2 id="HTTP-和-TCP-的关系"><a href="#HTTP-和-TCP-的关系" class="headerlink" title="HTTP 和 TCP 的关系"></a>HTTP 和 TCP 的关系</h2><blockquote class="pullquote info"><p><strong><code>HTTP</code> 是在 <code>TCP</code> 传输协议上层的应用层协议，主要解决 <code>Web</code> 端的数据传输并对 <code>TCP</code> 传输的数据进行包装和拆解，关于 <code>TCP/IP</code> 和 <code>HTTP</code> 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）<code>TCP/IP</code> 协议，但是如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如 <code>HTTP</code>、<code>FTP</code>、<code>TELNET</code> 等，也可以自己定义应用层协议，<code>Web</code> 使用 <code>HTTP</code> 协议作应用层协议，以封装 <code>HTTP</code> 文本信息，然后使用 <code>TCP/IP</code> 做传输层协议将它发到网络上”。</strong></p></blockquote><a id="more"></a><h2 id="HTTP-协议和-TCP-协议"><a href="#HTTP-协议和-TCP-协议" class="headerlink" title="HTTP 协议和 TCP 协议"></a>HTTP 协议和 TCP 协议</h2><h3 id="HTTP-访问到服务器的过程"><a href="#HTTP-访问到服务器的过程" class="headerlink" title="HTTP 访问到服务器的过程"></a>HTTP 访问到服务器的过程</h3><p><strong>从在浏览器中输入一个网址直到请求到达服务器的过程中如下图：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/imgtcp.png" alt="HTTP 协议访问服务器流程"></div><div class="image-caption">HTTP 协议访问服务器流程</div></figure><p><br></p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>在 <code>HTTP1.0</code> 版本中，每一个请求都需要在 <code>TCP</code> 协议中经历 “三次握手四次挥手”，在 <code>HTTP1.1</code> 中有了长连接，这个问题得到了改善，可以通过创建的一次 <code>TCP</code> 连接，对短时间内连续请求响应进行传输通道的复用，结束后关闭 <code>TCP</code> 连接。</p><p><strong>HTTP1.0 版本：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/connection.png" alt="HTTP1.0 版本"></div><div class="image-caption">HTTP1.0 版本</div></figure><p><br></p><p><strong>HTTP1.1 长连接版本：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/keepalive.png" alt="HTTP1.1 版本"></div><div class="image-caption">HTTP1.1 版本</div></figure><p><br></p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>在不同的浏览器中对于访问同一个域名，都有一个最大的请求数限制，数量大小因浏览器而异，如果请求数量大于最大请求数限制，则需要排队等待其他请求结束。</p><p>管线化技术，在超出最大请求数限制，客户端继续发送请求到服务端，而不需要其他请求得到响应的时候才能进行，实现并行发送请求，<code>CDN</code> 是比较典型的解决方式，将静态资源分发到不同 <code>ip</code> 下的服务器，请求资源是通过不同的代理服务器去同时获取，可以提高页面初始化响应的速度。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/pipeline.png" alt="HTTP 管线化"></div><div class="image-caption">HTTP 管线化</div></figure><p><br></p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><blockquote class="pullquote info"><ul><li><strong><code>URI</code>：是统一资源标识符，在某个规则下能把这个资源独一无二标示出来，类似人的身份证号；</strong></li><li><strong><code>URL</code>：统一资源定位符，表示资源的地点，是 <code>URI</code> 的特例，也是使用浏览器访问 <code>Web</code> 页面时输入的地址。</strong></li></ul></blockquote><p><strong>URL 的组成：</strong></p><blockquote class="pullquote success"><p><a href="javascript:;">http://username:password@www.pandashen.com:80/2018/07/09/index.html?uid=1&amp;name=panda#ch1</a></p><ul><li><strong><code>http</code>：协议类型；</strong></li><li><strong><code>username:password</code>：登录信息（如 <code>Github</code>，不安全）；</strong></li><li><strong><code>www.pandashen.com</code>：服务器地址（与前面用 <code>@</code> 连接）；</strong></li><li><strong><code>80</code>：服务器端口号（与前面用 <code>:</code> 连接）；</strong></li><li><strong><code>/2018/07/09/index.html</code>：带层次的文件路径；</strong></li><li><strong><code>uid=1&amp;name=panda</code>：查询字符串（与前面用 <code>?</code> 连接）；</strong></li><li><strong><code>ch1</code>：片段标识符（<code>hash</code> 值，与前面使用 <code>#</code> 连接）。</strong></li></ul></blockquote><h2 id="HTTP-的组成"><a href="#HTTP-的组成" class="headerlink" title="HTTP 的组成"></a>HTTP 的组成</h2><blockquote class="pullquote primary"><p><strong>请求的一方叫客户端，响应的一方叫服务器端，通过请求和响应达成通信，<code>HTTP</code> 是一种无状态的协议。</strong></p></blockquote><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>请求报文包含请求行、请求首部和请求体三个部分。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/request.png" alt="请求报文"></div><div class="image-caption">请求报文</div></figure><p><br></p><blockquote class="pullquote default"><p><strong>请求行由三个部分组成，并写在同一行，分别为请求方法、请求路径（域名和端口号后面的部分）和协议/版本号。</strong></p></blockquote><blockquote class="pullquote warning"><p><strong>请求方法：</strong></p><ul><li><strong><code>GET</code>：获取资源</strong></li><li><strong><code>POST</code>：向服务器端发送数据，传输实体主体</strong></li><li><strong><code>PUT</code>：传输文件</strong></li><li><strong><code>HEAD</code>：获取报文首部</strong></li><li><strong><code>DELETE</code>：删除文件</strong></li><li><strong><code>OPTIONS</code>：询问支持的方法</strong></li><li><strong><code>TRACE</code>：追踪路径</strong></li></ul></blockquote><p><strong>追踪路径方式如下图：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/trace.png" alt="TRACE 追踪路径"></div><div class="image-caption">TRACE 追踪路径</div></figure><p><br></p><blockquote class="pullquote primary"><p><strong>请求体内的内容为向服务端发送的数据，首部分为通用首部、请求首部、响应首部和实体首部四种，在后面详细说明。</strong></p></blockquote><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应报文同样包含三个部分，响应行、响应首部和响应体。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/HTTP/20180709185149/response.png" alt="响应报文"></div><div class="image-caption">响应报文</div></figure><p><br></p><p>响应行由三个部分组成，并写在同一行，分别为协议/版本号、状态码和状态码原因短语。</p><blockquote class="pullquote warning"><p><strong>注意：在请求首部与请求体之间、在响应首部与响应体之间都应该空一个空行。</strong></p></blockquote><h2 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h2><p>状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误。</p><h3 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h3><table><thead><tr><th style="width:30%">类别</th><th>原因短语</th></tr></thead><thead></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td></tr><tr><td>3XX</td><td>Redirection（重定向）</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态吗）</td></tr></tbody></table><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><h4 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h4><table><thead><tr><th style="width:10%">状态码</th><th style="width:25%">原因短语</th><th>原因解释</th></tr></thead><thead></thead><tbody><tr><td>200</td><td>OK</td><td>客户端发过来的数据被正常处理</td></tr><tr><td>204</td><td>Not Content</td><td>正常响应，没有实体</td></tr><tr><td>206</td><td>Partial Content</td><td>范围请求，返回部分数据，响应报文中由 Content-Range 指定实体内容</td></tr></tbody></table><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><table><thead><tr><th style="width:10%">状态码</th><th style="width:25%">原因短语</th><th>原因解释</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久重定向</td></tr><tr><td>302</td><td>Found</td><td>临时重定向，规范要求方法名不变，但是都会改变成 GET</td></tr><tr><td>303</td><td>See Other</td><td>和 302 类似，但必须用 GET 方法</td></tr><tr><td>304</td><td>Not Modified</td><td>状态未改变，配合（If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since）</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向，不该改变请求方法</td></tr></tbody></table><h4 id="客户端错误"><a href="#客户端错误" class="headerlink" title="客户端错误"></a>客户端错误</h4><table><thead><tr><th style="width:10%">状态码</th><th style="width:25%">原因短语</th><th>原因解释</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>请求报文语法错误</td></tr><tr><td>401</td><td>Unauthorized</td><td>需要认证</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器拒绝访问对应的资源</td></tr><tr><td>404</td><td>Not Found</td><td>服务器上无法找到资源</td></tr></tbody></table><h4 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h4><table><thead><tr><th style="width:10%">状态码</th><th style="width:25%">原因短语</th><th>原因解释</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器故障</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器处于超负载或正在停机维护</td></tr></tbody></table><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><blockquote class="pullquote info"><p><strong><code>HTTP</code> 首部字段是 <code>HTTP</code> 报文首部的重要部分，在客户端和服务器进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。</strong></p></blockquote><blockquote class="pullquote default"><p><strong>HTTP 首部主要分为通用首部、请求首部、响应首部和实体首部四种：</strong></p><ul><li><strong>通用首部字段：请求和响应报文两方都会使用的首部字段；</strong></li><li><strong>请求首部字段：从客户端向服务器发送请求报文时使用的首部字段，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息；</strong></li><li><strong>响应首部字段：从服务器向客户端返回响应报文时使用的首部字段，补充了响应的附加内容，也会要求客户端附加额外的内容信息；</strong></li><li><strong>实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容的更新时间等与实体有关的信息。</strong></li></ul></blockquote><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th style="width:30%">首部字段名</th><th>说明</th></tr></thead><thead></thead><tbody><tr><td>Cache-Control</td><td>控制缓存行为</td></tr><tr><td>Connection</td><td>链接的管理</td></tr><tr><td>Date</td><td>报文日期</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文尾部的首部</td></tr><tr><td>Trasfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th style="width:30%">首部字段名</th><th>说明</th></tr></thead><thead></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的编码</td></tr><tr><td>Accept-Langulage</td><td>优先的语言</td></tr><tr><td>Authorization</td><td>Web 认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在的服务器</td></tr><tr><td>If-Match</td><td>比较实体标记</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（ 与 If-Modified-Since相反 ）</td></tr><tr><td>Max-Forwards</td><td>最大传输跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器需要客户端认证</td></tr><tr><td>Range</td><td>实体字节范围请求</td></tr><tr><td>Referer</td><td>请求中的URI的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table><thead><tr><th style="width:30%">首部字段名</th><th>说明</th></tr></thead><thead></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围</td></tr><tr><td>Age</td><td>资源的创建时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>客户端重定向至指定的 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>再次发送请求的时机</td></tr><tr><td>Server</td><td>服务器的信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>www-Authenticate</td><td>服务器对客户端的认证</td></tr></tbody></table><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table><thead><tr><th style="width:30%">首部字段名</th><th>说明</th></tr></thead><thead></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体的编码方式</td></tr><tr><td>Content-Language</td><td>实体的自然语言</td></tr><tr><td>Content-Length</td><td>实体的内容大小（字节为单位）</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体过期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改时间</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>本篇重点介绍关于 <code>HTTP</code> 协议的一点基础知识，关于请求、响应以及报文对应的信息及内容，也可以用作查询使用。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 TCP 实现简易聊天室</title>
    <url>/20180708120357/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180708120357/nodejs-tcp-ip.png" title="TCP + Node.js 简易聊天室"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong><code>TCP</code> 为传输层协议，在 <code>Node.js</code> 中，基于 <code>TCP</code> 的核心模块为 <code>net</code>，<code>http</code> 和 <code>https</code> 模块都是基于 <code>net</code> 实现的，我们先简单介绍 <code>net</code> 的用法，再根据 <code>net</code> 实现一个简易的聊天室。</strong></p></blockquote><a id="more"></a><h2 id="net-模块的基本用法"><a href="#net-模块的基本用法" class="headerlink" title="net 模块的基本用法"></a>net 模块的基本用法</h2><h3 id="使用-net-创建一个网络服务"><a href="#使用-net-创建一个网络服务" class="headerlink" title="使用 net 创建一个网络服务"></a>使用 net 创建一个网络服务</h3><p><strong>方式 1：</strong></p><pre><code class="lang-js">const net = require(&#39;net&#39;);

// 创建 TCP 服务
const server = net.createServer(function (socket) {
  // ......
});

server.listen(3000);
</code></pre><p><strong>方式 2：</strong></p><pre><code class="lang-js">const net = require(&#39;net&#39;);

// 创建 TCP 服务
const server = net.createServer();

// 监听连接
server.on(&#39;connection&#39;, function (socket) {
  // ......
});

server.listen(3000);
</code></pre><p>上面两种创建网络服务的方式第二种更常用，回调函数的参数都为 <code>socket</code>（套接字），在产生连接时执行，每产生一个连接就会产生一个 <code>socket</code>，我们也可以将 <code>socket</code> 理解为客户端。</p><p>如果现在使用浏览器连接这个服务可以成功接收到请求，但浏览器是 <code>http</code> 协议，不识别，所以不会有任何响应。</p><h3 id="使用-TCP-模拟-http"><a href="#使用-TCP-模拟-http" class="headerlink" title="使用 TCP 模拟 http"></a>使用 TCP 模拟 http</h3><pre><code class="lang-js">const net = require(&#39;net&#39;);

// 创建 TCP 服务
const server = net.createServer();

// 监听连接
server.on(&#39;connection&#39;, function (socket) {
  // 设置编码
  socket.setEncoding(&#39;utf8&#39;);

  // 读取请求报文
  socket.on(&#39;data&#39;, function (data) {
    console.log(data);
  });

  // 给浏览器返回响应报文
  socket.write(`
HTTP/1.1 200 ok
Content-Length: 5

hello
  `);
});

server.listen(3000);

// GET /favicon.ico HTTP/1.1
// Host: localhost:3000
// Connection: keep-alive
// Pragma: no-cache
// Cache-Control: no-cache
// ...... 后面省略
</code></pre><p><code>soket</code> 是一个可读可写流 <code>Duplex</code>（双工流），所以既可以读取来自浏览器的请求信息，又可以写入响应信息，在模拟 <code>http</code> 时需遵循 <code>http</code> 协议规则，每行前面不允许有空格或制表符，响应头与响应正文之间需空一行。</p><p>此时启动服务，使用浏览器访问 <a href="javascript:;">localhost:3000</a> 可以在控制台打印请求报文，并在浏览器中显示 <code>hello</code>。</p><blockquote class="pullquote primary"><p><strong><code>http</code> 的头部信息可以通过命令窗口中使用 <code>curl</code> 发送请求进行查看：</strong></p><ul><li><strong>输入命令：<code>curl -v http://.....</code></strong></li></ul><p><strong><code>Windows</code> 系统中默认命令行窗口不支持 <code>curl</code> 命令，请在</strong> <a href="https://curl.haxx.se/download.html" target="_blank">curl 官网</a> <strong>下载系统对应的版本，下载后的压缩包解压后将 <code>curl.exe</code> 和 <code>ca-bundle.crt</code> 拷贝至 <code>C:\Windows\System32</code> 或将所在文件夹添加至系统环境变量。</strong></p></blockquote><h3 id="server、socket-的属性和方法"><a href="#server、socket-的属性和方法" class="headerlink" title="server、socket 的属性和方法"></a>server、socket 的属性和方法</h3><p>在 TCP 创建的服务 <code>server</code> 和连接中的 <code>socket</code> 本身具有一些属性、方法和事件，我们通过下面这个例子来介绍。</p><pre><code class="lang-js">const net = require(&#39;net&#39;);

// 创建 TCP 服务器
const server = net.createServer();

server.on(&#39;connection&#39;, function (socket) {
  // 客户端的 ip + 端口号
  const key = socket.remoteAddress + socket.remotePort;

  server.getConnetions(function (err, count) {
    socket.write(&#39;当前有&#39; + count + &#39;人，总人数为&#39; + server.maxConnections + &#39;人。&#39;);
  });

  socket.on(&#39;data&#39;, function (data) {
    // 设置编码
    socket.setEncoding(&#39;utf8&#39;);

    // 关闭客户端
    // socket.end();

    // 关闭服务器
    // server.close();
    server.unref();
  });
});

// 最大连接数
server.maxConnections = 3;

server.on(&#39;close&#39;, function () {
  console.log(&#39;服务端关闭&#39;);
});

server.on(&#39;error&#39;, function (err) {
  if (err.code === &#39;EADDRINUSE&#39;) {
    server.listen(err.port + 1);
  }
});

server.listen(3000, function () {
  console.log(&#39;server start 3000&#39;);
});
</code></pre><p><code>socket.remoteAddress</code> 属性，获取客户端的 IP 地址。</p><p><code>socket.remotePort</code> 属性，获取客户端的端口号。</p><p><code>socket.setEncoding</code> 方法，设置编码格式。</p><p><code>socket.write</code> 方法，向客户端写入内容，写入内容的值只能为字符串或 Buffer。</p><p><code>socket.end</code> 方法，断开对应客户端的连接，并返回信息，返回内容的值只能为字符串或 Buffer，<code>soket</code> 可以监听 <code>end</code> 事件，当关闭客户端时触发并执行回调。</p><p><code>socket.destroy</code> 方法，用于销毁当前客户端对应的 <code>socket</code> 对象。</p><p><code>server.maxConnections</code> 属性，是当前服务器允许的最大连接数，数值类型，当连接数超过设定值时，新的客户端将无法连接服务器。</p><p><code>server.getConnetions</code> 方法，获取当前的连接数，参数为回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>count</code>（当前连接数），异步执行。</p><p><code>server.close</code> 方法，关闭服务器，并没有真的关闭服务器，而是不允许新的连接，直到所有连接都断开后自动关闭服务器。</p><p><code>server.unref</code> 方法，关闭服务器的另一种形式，不阻止新的连接，当所有连接都断开时自动关闭服务器。</p><p><code>server.listen</code> 方法，监听端口号，支持传入回调，在启动服务后执行。</p><p><code>server</code> 的 <code>close</code> 事件，参数为回调函数，异步执行，当服务器关闭时触发。</p><p><code>server</code> 的 <code>error</code> 事件，参数为回调函数，回调函数的参数为 <code>err</code>（错误对象），异步执行，当启动服务器或服务器运行时出现错误触发。</p><blockquote class="pullquote success"><p><strong>在 <code>Webpack</code> 中如果启动 <code>webpack-dev-server</code> 在端口号被占用时，端口号会自动 <code>+1</code>，我们可以利用 <code>err</code> 错误对象来模拟，在 <code>err</code> 事件对象上有很多属性，其中的 <code>code</code> 属性值为 <code>EADDRINUSE</code> 时代表端口号被占用，所以在判断 <code>code</code> 值后，重新调用了 <code>server.listen</code> 并传入重新计算后的端口号。</strong></p></blockquote><p>想看一看上面代码的效果需要客户端的支持，本文中模拟客户端访问服务器有三种方式，使用一种即可。</p><h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><blockquote class="pullquote info"><p><strong>验证我们自己实现的 <code>TCP</code> 服务器需要客户端访问，在本文的主题简易聊天室当中也需要用户和客户端，所以介绍一下创建客户端的方式。</strong></p><ul><li><strong>可以使用 <code>net</code> 模块创建客户端，并启访问服务器；</strong></li><li><strong><code>Mac</code> 中可以直接在命令窗口执行 <code>brew install telnet</code> 安装 <code>telnet</code>，安装后输入 <code>telnet localhost 3000</code> 即可以访问上面的服务器；</strong></li><li><strong><code>Windows</code> 中 <code>telnet</code> 接收到的服务器响应会变成乱码，所以可以使用</strong> <a href="http://www.netsarang.com/download/main.html" target="_blank">Xshell</a> <strong>和</strong> <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank">PuTTY</a> <strong>等客户端工具。</strong></li></ul></blockquote><p>使用 <code>net</code> 创建客户端代码如下：</p><pre><code class="lang-js">/* 客户端：client.js */
const net = require(&#39;net&#39;);

// 创建客户端
const client = net.createConnection({ port: 3000 });

// 给服务器发送消息
client.write(&#39;s:username:message&#39;);
</code></pre><blockquote class="pullquote default"><p><strong>由于本人目前使用 <code>Windows</code> 电脑，文中使用 <code>PuTTY</code> 工具，在使用之前需打开 <code>Telnet</code> 服务端和客户端，步骤如下：</strong></p><ul><li><strong>打开控制面板；</strong></li><li><strong>打开或关闭 <code>Windows</code> 功能；</strong></li><li><strong>勾选 <code>Telnet</code> 服务端和客户端。</strong></li></ul></blockquote><p><code>PuTTY</code> 界面如下，在 <code>Connection type</code>（连接类型）中默认为 <code>SSH</code>，我们之所以使用 <code>Raw</code> 而不使用其他类型是因为其他的方式在连接服务器时会发送窗口信息，我们不需要这些数据。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180708120357/PuTTY.png" alt="PuTTY 界面"></div><div class="image-caption">PuTTY 界面</div></figure><p><br></p><p>点击界面下面的 <code>Open</code> 按钮就可以创建一个客户端连接，客户端窗口如下，可以通过输入并回车确定的方式向服务端发送消息。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180708120357/PuTTY-window.png" alt="PuTTY 客户端窗口"></div><div class="image-caption">PuTTY 客户端窗口</div></figure><p><br></p><p>目前所有的准备工作已经就绪，下面就是我们的正题，用 <code>net</code> 模块实现一个 <code>TCP</code> 服务，并使用 <code>PuTTY</code> 作为客户端，实现一个简易的聊天室。</p><h2 id="实现简易聊天室"><a href="#实现简易聊天室" class="headerlink" title="实现简易聊天室"></a>实现简易聊天室</h2><h3 id="定义聊天室规则"><a href="#定义聊天室规则" class="headerlink" title="定义聊天室规则"></a>定义聊天室规则</h3><blockquote class="pullquote primary"><p><strong>聊天室主要有四个功能，都需要输入对应的命令：</strong></p><ul><li><strong>显示在线用户：命令为 <code>l</code>；</strong></li><li><strong>改名：聊天室默认用户名为匿名，重命名的命令为 <code>r:newname</code>；</strong></li><li><strong>私聊：私聊的参数为聊天对象的名字和消息内容，命令为 <code>s:username:message</code>；</strong></li><li><strong>广播：发送的消息除自己以外的所有人都能接收到，命令为 <code>b:message</code>。</strong></li></ul></blockquote><p>在存储所有的客户端时，都使用客户端的 <code>ip + port</code> 作为用户的唯一标识。</p><h3 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h3><pre><code class="lang-js">/* 服务器：server.js */
const net = require(&#39;net&#39;);

// 处理输入命令模块
const processInstructs = require(&#39;./process-instructs&#39;);

const server = net.createServer(); // 创建服务
const client = {}; // 客户端
const port = 3000; // 端口号

// 监听连接
server.on(&#39;connection&#39;, socket =&gt; {
  // 客户端的 ip + 端口号 作为存储客户端的唯一标识
  const key = socket.remoteAddress + socket.remotePort;

  // 将客户端添加到 client 存储中
  client[key] = { username: &#39;匿名&#39;, socket };

  // 欢迎功能
  server.getConnections((err, count) =&gt; {
    socket.write(&#39;欢迎加入！目前有 &#39; + count &#39;人。\r\n&#39;);
  });

  // 设置编码
  socket.setEncoding(&#39;utf8&#39;);

  // 监听用户输入
  socket.on(&#39;data&#39;, data =&gt; {
    // 由于输入消息按回车键确认，所以需处理消息中的回车
    data = data.replace(/\r\n/, &#39;&#39;);

    // 处理输入并做出响应
    processInstructs(client, key, data);
  });

  // 客户端主动关闭后在服务器客户端存储中清除客户端，并销毁对应的 socket
  socket.on(&#39;end&#39;, () =&gt; {
    socket.destroy();
    delete client[key];
  });
});

// 监听端口号
server.listen(port, () =&gt; {
  console.log(&#39;server start &#39; + port);
});
</code></pre><p>在上面的服务搭建当中，创建了 <code>client</code> 对象，专门存储聊天室内的客户端及信息，客户端使用 <code>ip + port</code> 作为存储的唯一标识，用户名默认为 “匿名”，设置了欢迎功能，并显示当前在线人数，监听用户的输入，并处理了消息中的回车，引入 <code>process-instructs</code> 对指令进行处理，最后处理了离开的用户，目的是防止有离开后，其他的人使用了私聊或广播功能通知这个人，因为找不到对应的 <code>socket</code> 而出现错误。</p><h3 id="处理指令模块-process-instructs"><a href="#处理指令模块-process-instructs" class="headerlink" title="处理指令模块 process-instructs"></a>处理指令模块 process-instructs</h3><pre><code class="lang-js">/* 文件：process-instructs.js */
// 引入处理不同指令的功能函数
const { list, rename, privateChat, broadcast } = require(&#39;./instructs&#39;);

module.exports = function (client, key, data) {
  const dataArr = data.split(&#39;:&#39;);

  // 针对不同的指令调用不同的处理方法
  switch (dataArr[0]) {
    case &#39;l&#39;:
      list(client, key);
      break;
    case &#39;r&#39;:
      rename(client, key, dataArr);
      break;
    case &#39;s&#39;:
      privateChat(client, key, dataArr);
      break;
    case &#39;b&#39;:
      broadcast(client, key, dataArr);
      break;
    default:
      socket.write(&#39;命令有误\r\n&#39;);
  }
};
</code></pre><p>在上面对指令的处理中针对不同的指令引入了 <code>instructs</code> 模块对应的处理方法。</p><h3 id="指令处理方法模块-instructs"><a href="#指令处理方法模块-instructs" class="headerlink" title="指令处理方法模块 instructs"></a>指令处理方法模块 instructs</h3><pre><code class="lang-js">/* 文件：instructs.js */
// 处理 l 指令，显示在线用户
exports.list = function (client, key) {
  // 获取当前 socket
  const socket = client[key].socket;

  // 写入信息
  soket.write(&#39;当前用户列表:\r\n&#39;);
  Object.values(client).forEach(path =&gt; {
    socket.write(path.username + &#39;\r\n&#39;);
  });
};

// 处理 r 指令，用户重命名
exports.rename = function (client, key, dataArr) {
  const newName = dataArr[1];

  // 更新对应 socket 的新用户名并通知
  client[key].username = newName;
  client[key].socket.write(&#39;新用户名是: &#39; + newName + &#39;\r\n&#39;);
};

// 处理 s 指令，私聊
exports.privateChat = function (client, key, dataArr) {
  Object.keys(client).forEach(path =&gt; {
    if (client[path].username === dataArr[1]) {
      client[path].socket.write(client[key].username + &#39;: &#39; + dataArr[2] + &#39;\r\n&#39;);
    }
  });
};

// 处理 b 指令，广播
exports.broadcast = function (client, key, dataArr) {
  Object.keys(client).forEach(path =&gt; {
    if (path !== key) {
      client[path].socket.write(client[key].username + &#39;: &#39; + dataArr[1] + &#39;\r\n&#39;);
    }
  });
};
</code></pre><p>显示在线用户功能的思路是将 <code>client</code> 内部所有在线用户的用户名循环写入到当前 <code>socket</code> 中。</p><p>重命名功能的思路是获取输入的新用户名替换掉 <code>client</code> 中对应的 <code>username</code> 并将当前新用户名设置成功的消息返回当前 <code>socket</code>。</p><p>私聊功能的思路是循环 <code>client</code> 内的所有客户端，当 <code>username</code> 和发送的用户名相同时，将消息写入这个用户名对应的 <code>socket</code>。</p><p>广播功能思路是循环 <code>client</code>，将消息写入给出自己以外的所有客户端。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p><strong>本文重点在于理解多人聊天功能的基本开发思路，及 <code>Node.js</code> 中 <code>TCP</code> 传输对应的 <code>net</code> 模块的应用，实际上本文中聊天室的代码在用户重名的情况下并没有做任何处理，正常情况应该使用 <code>id</code> 作为唯一标识，而不是指定用户名，在 <code>Node.js</code> 开发中其实很少直接使用 <code>net</code> 大多情况下使用 <code>http</code> 和 <code>https</code> 来替代，但是我们应该知道他们都是基于 <code>net</code> 封装的，了解 <code>net</code> 会在使用 <code>http</code> 和 <code>https</code> 时更得心应手。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>HTTP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Node.js 可读流实现 “行读取器”</title>
    <url>/20180706120428/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180706120428/line-reader.png" title="TCP + LineReader 行读取器"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote danger"><p><strong>本文是对于 <code>Node.js</code> 核心模块 <code>fs</code> 可读流 <code>createReadeStream</code> 的应用，实现 “行读取器”，功能为读取一个文档的内容，每读完一行触发一次监听的事件，并对这一行数据进行处理。</strong></p></blockquote><blockquote class="pullquote success"><p><strong>推荐阅读文章：</strong></p><ul><li><a href="/20180703231032/" target="_blank">Node.js —— Stream 的基本使用</a></li><li><a href="/20180629115313/" target="_blank">Node.js —— Buffer 解读</a></li><li><a href="/20180628204755/" target="_blank">EventEmitter 源码分析与简易实现</a></li></ul></blockquote><a id="more"></a><h2 id="LineReader-类的创建"><a href="#LineReader-类的创建" class="headerlink" title="LineReader 类的创建"></a>LineReader 类的创建</h2><p>实现 “行读取器” 的整体思路是创建一个类的实例，然后在这个实例上监听一个事件，并开始读取文件，每次读完一行触发，我们这里将这个类命名为 <code>LineReader</code>，因为类需要监听事件，所以需要继承 <code>EventEmitter</code>。</p><pre><code class="lang-js">/* 行读取器 LineReader 类 */
// 引入依赖
const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

// 行读取器的类，参数为读取文件的路径
class LineReader extends EventEmitter {
  contructor(path) {
    super();
    this.path = path; // 文件路径
    this._rs = fs.createReadStream(this.path); // 创建可读流
    this.current = null; // 存储每次读到的单个字节
    this.buffers = []; // 存放文件每一行单个字节 Buffer 的数组
    this.system = null; // 默认的系统（windows 或 mac）
    this.RETURN = 13; // \r 的十六进制数
    this.LINE = 10; // \n 的十六进制数

    // 监听 newListener
    this.on(&#39;newListener&#39;, readLineCallback.bind(this));
  }
}
</code></pre><p>在 <code>LineReader</code> 实例上定义了 <code>system</code>（当前系统）、<code>current</code>（每次读取的单个字节）、<code>RETURN</code>（<code>\r</code> 十六进制编码）和 <code>LINE</code>（<code>\n</code> 十六进制编码）等属性方便后面使用。</p><p>我们希望在监听的事件触发之前，就执行读取文件一行内容的逻辑，就说明我们需要一个在监听事件时就能执行的函数，那就需要在创建实例之前先监听 <code>newListener</code> 事件，把 <code>newListener</code> 的回调来作为这个函数执行，并能顺带在参数中获取事件类型。</p><p>我们把读取文件的核心逻辑放在了 <code>newListener</code> 事件的回调函数中，将这个回调函数命名为 <code>readLineCallback</code>，为了保证执行时 <code>readLineCallback</code> 内部使用的 <code>this</code> 是 <code>LineReader</code> 的实例，使用 <code>bind</code> 进行修正。</p><h2 id="行读取器核心逻辑-readLineCall-函数"><a href="#行读取器核心逻辑-readLineCall-函数" class="headerlink" title="行读取器核心逻辑 readLineCall 函数"></a>行读取器核心逻辑 readLineCall 函数</h2><p>如果需要默认就开始读取，并且每次读取一个字节后还可以进行下一次循环读取，这种场景最符合可读流的暂停模式 <code>readable</code> 事件默认触发一次，“容器” 内读走了一个字节，就会自动 “续杯” 的特点。</p><pre><code class="lang-js">/* 行读取器的核心逻辑 */
function readLineCallback(type) {
  // 使用暂停模式进行读取
  this.on(&#39;readable&#39;, () =&gt; {
    if (type === &#39;newLine&#39;) {
      // 为了与 \r 和 \n 对比，每次只读一个字节
      while ((this.current = this._rs.read(1))) {
        // 结果为 Buffer，所以使用索引取出对比
        switch (this.current[0]) {
          case RETURN: // 针对 Windows
            this.system = &#39;windows&#39;;
            this.disposeLine(); // 处理换行逻辑
            break;
          case LINE: // 针对 Mac
            this.system = &#39;mac&#39;;
            this.disposeLine(); // 处理换行逻辑
            break;
          default:
            // 每读到换行的字符存入数组中
            this.buffers.push(current);
        }
      }
    }
  });

  // 防止最后一行丢失
  this.on(&#39;end&#39;, this.disposeLine.bind(this));
}
</code></pre><p>在上面代码中监听了 <code>readable</code> 事件并验证了事件类型是否为 <code>newLine</code>，然后循环读取文件内容，为了与换行的十六进制码进行对比，每次只读取一个字节，当遇到换行符时，明确当前系统并调用换行符处理函数 <code>disposeLine</code> 进行处理。</p><blockquote class="pullquote warning"><p><em><strong>注意：在最后一次的时候文件最后一行可能没有换行，所以不满足 <code>switch</code> 内语句的条件，即没使用 <code>disposeLine</code> 进行处理，所以监听可读流的 <code>end</code> 事件，并在 <code>end</code> 触发时让 <code>disposeLine</code> 作为回调函数执行，注意使用 <code>bind</code> 修正 <code>this</code> 为当前实例。</strong></em></p></blockquote><h2 id="兼容操作系统的换行符处理函数"><a href="#兼容操作系统的换行符处理函数" class="headerlink" title="兼容操作系统的换行符处理函数"></a>兼容操作系统的换行符处理函数</h2><p>在换行符处理函数中，<code>Windows</code> 与其他系统（<code>Mac</code>、<code>Linux</code>）系统唯一的区别就是 Window 系统的换行符为 <code>\r\n</code>，比 Mac 和 Linux 的 <code>\n</code> 多了一个字节，而在读取下一行时，这个字节是无用的，需要忽略。</p><pre><code class="lang-js">/* 换行符处理函数 */
LineReader.prototype.disposeLine = function () {
  // 将这一行的内容发射出来并清空数组
  this.emit(&#39;newLine&#39;, Buffer.concat(this.buffers).toString());
  this.buffers = [];

  // 如果是 window 系统，下一个是 \n，就往下多读一个字节不存入组即可
  if (this.system === &#39;windows&#39;) {
    this._rs.read(1);
  }
};
</code></pre><h2 id="验证-LineReader-行读取器"><a href="#验证-LineReader-行读取器" class="headerlink" title="验证 LineReader 行读取器"></a>验证 LineReader 行读取器</h2><p>创建一个 “行读取器” 需要创建 <code>LineReader</code> 类的实例，并传入被读取文件的路径，由于在源码中执行的是 <code>newListener</code> 的回调函数，所以只需添加 <code>newLine</code> 事件监听就可以了，然后会在 <code>readable</code> 默认触发时在内部循环读取，并把每行读到的内容重新整合后发送，实现 <code>newLine</code> 事件的连续触发，直到文件读完。</p><pre><code class="lang-js">/* 使用行读取器 */
// 创建文件 1.txt 每次内容为 1~9 9个数字，每 3 个字符为一行
const lineReader = new LineReader(&#39;1.txt&#39;);

lineReader.on(&#39;newLine&#39;, data =&gt; {
  console.log(&#39;------ &#39; + data + &#39;------&#39;);
});

// ------ 123 ------
// ------ 456 ------
// ------ 789 ------
</code></pre><p>“行读取器” <code>lineReader</code> 对读取到每一行的数据进行处理的逻辑主要在 <code>newLine</code> 事件的回调函数中，比如上面例子，在每一行的前、后添加了 <code>------</code> 并打印。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>Node.js</code> 中，流的应用非常广泛，“行读取器” 只是其中的一种应用，可以根据流的不同模式的不同特性实现更复杂的功能，所以流在 <code>Node.js</code> 中还是非常重要的。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Stream</tag>
        <tag>LineReader</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js —— 自定义流的实现</title>
    <url>/20180705125501/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180705125501/custom-stream.png" title="自定义流的实现原理"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote info"><p><strong>常见的自定义流有四种，<code>Readable</code>（可读流）、<code>Writable</code>（可写流）、<code>Duplex</code>（双工流）和 <code>Transform</code>（转换流），常见的自定义流应用有 <code>HTTP</code> 请求、响应，<code>crypto</code> 加密，进程 <code>stdin</code> 通信等等。</strong></p></blockquote><blockquote class="pullquote success"><p><strong>流相关文章推荐：</strong></p><ul><li><a href="/20180703231032/" target="_blank">Node.js —— Stream 的基本使用</a></li><li><a href="/20180704175217/" target="_blank">Node.js —— 流的原理分析与简易实现</a></li></ul></blockquote><a id="more"></a><h2 id="stream-模块介绍"><a href="#stream-模块介绍" class="headerlink" title="stream 模块介绍"></a>stream 模块介绍</h2><blockquote class="pullquote default"><p><strong>在 <code>Node.js</code> 中要想实现自定义流，需要依赖模块 <code>stream</code>，直接引入，不需下载，所有种类的流都是继承这个模块内部提供的对应不同种类的类来实现的。</strong></p></blockquote><h2 id="实现一个自定义可读流-Readable"><a href="#实现一个自定义可读流-Readable" class="headerlink" title="实现一个自定义可读流 Readable"></a>实现一个自定义可读流 Readable</h2><h3 id="创建自定义可读流的类-MyRead"><a href="#创建自定义可读流的类-MyRead" class="headerlink" title="创建自定义可读流的类 MyRead"></a>创建自定义可读流的类 MyRead</h3><p>我们创建一个名为 <code>MyRead</code> 的自定义可读流，并继承 <code>stream</code> 中的 <code>Readable</code> 类，重写 <code>_read</code> 方法，重写核心方法是实现自定义流的套路。</p><pre><code class="lang-js">/* 创建自定义可读流 */
const { Readable } = require(&#39;stream&#39;);

// 创建自定义可读流的类
class MyRead extends Readable {
  constructor() {
    super();
    this.index = 0;
  }

  // 重写自定义的可读流的 _read 方法
  _read() {
    this.index++;
    this.push(this.index + &#39;&#39;);

    if (this.index === 3) {
      this.push(null);
    }
  }
}
</code></pre><p>我们自己写的 <code>_read</code> 方法会继承很多流原有的特性，比如在读取时使用 <code>push</code> 方法将数据读取出来，直到 <code>push</code> 的值为 <code>null</code> 才会停止，否则会认为没有读取完成，会继续调用 <code>_read</code>。</p><h3 id="验证自定义可读流"><a href="#验证自定义可读流" class="headerlink" title="验证自定义可读流"></a>验证自定义可读流</h3><pre><code class="lang-js">/* 验证自定义可读流 */
const myRead = new MyRead();

myRead.on(&#39;data&#39;, data =&gt; {
  console.log(data);
});

myRead.on(&#39;end&#39;, function () {
  console.log(&#39;读取完成&#39;);
});

// &lt;Buffer 31&gt;
// &lt;Buffer 32&gt;
// &lt;Buffer 33&gt;
// 读取完成
</code></pre><h2 id="实现一个自定义可写流-Writable"><a href="#实现一个自定义可写流-Writable" class="headerlink" title="实现一个自定义可写流 Writable"></a>实现一个自定义可写流 Writable</h2><h3 id="创建自定义可写流的类-MyWrite"><a href="#创建自定义可写流的类-MyWrite" class="headerlink" title="创建自定义可写流的类 MyWrite"></a>创建自定义可写流的类 MyWrite</h3><p>创建一个名为 <code>MyWrite</code> 的自定义可写流，并继承 <code>stream</code> 中的 <code>Writable</code> 类，重写 <code>_write</code> 方法。</p><pre><code class="lang-js">/* 创建自定义可写流 */
const { Writable } = require(&#39;stream&#39;);

// 创建自定义可写流的类
class MyWrite extends Writable {
  // 重写自定义的可写流的 _write 方法
  _write(chunk, encoding, callback)) {
    callback(); // 将缓存区写入文件
  }
}
</code></pre><p>写入内容时默认第一次写入直接写入文件，后面的写入都写入缓存区，如果不调用 <code>callback</code> 只能默认第一次写入文件，调用 <code>callback</code> 会将缓存区清空并写入文件。</p><h3 id="验证自定义可写流"><a href="#验证自定义可写流" class="headerlink" title="验证自定义可写流"></a>验证自定义可写流</h3><pre><code class="lang-js">/* 验证自定义可写流 */
const myWrite = new MyWrite();

myWrite.write(&#39;hello&#39;, &#39;utf8&#39;, () =&gt; {
  console.log(&#39;hello ok&#39;);
});

myWrite.write(&#39;world&#39;, &#39;utf8&#39;, () =&gt; {
  console.log(&#39;world ok&#39;);
});

// hello ok
// world ok
</code></pre><h2 id="实现一个自定义双工流-Duplex"><a href="#实现一个自定义双工流-Duplex" class="headerlink" title="实现一个自定义双工流 Duplex"></a>实现一个自定义双工流 Duplex</h2><h3 id="创建自定义可双工流的类-MyDuplex"><a href="#创建自定义可双工流的类-MyDuplex" class="headerlink" title="创建自定义可双工流的类 MyDuplex"></a>创建自定义可双工流的类 MyDuplex</h3><p>双工流的可以理解为即可读又可写的流，创建一个类名为 <code>MyDuplex</code>，并继承 <code>stream</code> 中的 <code>Duplex</code> 类，由于双工流即可读又可写，需重写 <code>_read</code> 和 <code>_write</code> 方法。</p><pre><code class="lang-js">/* 创建自定双工流 */
const { Duplex } = require(&#39;stream&#39;);

// 创建自定义双工流的类
class MyDuplex extends Duplex {
  // 重写自定义的双工流的 _read 方法
  _read() {
    this.push(&#39;123&#39;);
    this.push(null);
  }

  // 重写自定义的双工流的 _write 方法
  _write(chunk, encoding, callback)) {
    callback();
  }
}
</code></pre><p>双工流分别具备 <code>Readable</code> 和 <code>Writable</code> 的功能，但是读和写互不影响，互不关联。</p><h3 id="验证自定义双工流"><a href="#验证自定义双工流" class="headerlink" title="验证自定义双工流"></a>验证自定义双工流</h3><pre><code class="lang-js">/* 验证自定义双工流 */
const myDuplex = new MyDuplex();

myDuplex.on(&#39;readable&#39;, () =&gt; {
  console.log(myDuplex.read(1), &#39;----&#39;);
});

setTimeout(() =&gt; {
  myDuplex.on(&#39;data&#39;, data =&gt; {
    console.log(data, &#39;xxxx&#39;);
  });
}, 3000);

// &lt;Buffer 31&gt; ----
// &lt;Buffer 32&gt; xxxx
// &lt;Buffer 32&gt; ----
// &lt;Buffer 33&gt; xxxx
</code></pre><p>如果 <code>readable</code> 和 <code>data</code> 两种读取方式都使用默认先通过 <code>data</code> 事件读取，所以一般只选择一个，不要同时使用，可读流的特点是读取数据被消耗掉后就丢失了（缓存区被清空），如果非要两个都用可以加一个定时器（绝对不要这样写）。</p><h2 id="实现一个自定义转化流-Transform"><a href="#实现一个自定义转化流-Transform" class="headerlink" title="实现一个自定义转化流 Transform"></a>实现一个自定义转化流 Transform</h2><h3 id="创建自定义可转化流的类-MyTransform"><a href="#创建自定义可转化流的类-MyTransform" class="headerlink" title="创建自定义可转化流的类 MyTransform"></a>创建自定义可转化流的类 MyTransform</h3><p>转化流的意思是即可以当作可读流，又可以当作可写流，与双工流的区别是读和写可以相关联，创建一个类名为 <code>MyTransform</code>，并继承 <code>stream</code> 中的 <code>Transform</code> 类，重写 <code>_transform</code> 方法，该方法的参数和 <code>_write</code> 相同。</p><pre><code class="lang-js">/* 创建自定义转化流 */
const { Transform } = require(&#39;stream&#39;);

// 创建自定义转化流的类
class MyTransform extends Transform {
  // 重写自定义的转化流的 _transform 方法
  _transform(chunk, encoding, callback)) {
    console.log(chunck.toString.toUpperCase());
    callback();
    this.push(&#39;123&#39;);
  }
}
</code></pre><p>在自定义转化流的 <code>_transform</code> 方法中，读取数据的 <code>push</code> 方法和 写入数据的 <code>callback</code> 都可以使用。</p><blockquote class="pullquote info"><p><em><strong>由此可以看出，<code>Transform</code> 类型可以将可读流转化为可写流，也可以将可写流转化成可读流，他的主要目的不是像其他类型的流一样负责数据的读写，而是既作为可读流又作为可写流，实现流的转化，即实现对数据的特殊处理，如 <code>zib</code> 模块实现的压缩流，<code>cropo</code> 模块实现的加密流，本质都是转化流，将转化流作为可写流，将存储文件内容的可写流通过 <code>pipe</code> 方法写入转化流，再将转化流作为可读流通过 <code>pipe</code> 方法将处理后的数据响应给浏览器。</strong></em></p></blockquote><h3 id="验证自定义转化流"><a href="#验证自定义转化流" class="headerlink" title="验证自定义转化流"></a>验证自定义转化流</h3><pre><code class="lang-js">/* 验证自定义转化流 */
const myTransForm = new MyTransform();

// 使用标准输入
process.stdin.pipe(myTransForm).pipe(process.stdin);
</code></pre><p>打开命令行窗口执行 <code>node demo.js</code>，然后输入 <code>abc</code>，会在命令窗口输出 <code>ABC</code> 和 <code>123</code>，其实转换流先作为一个可写流被写入到标准输入中，而此时 <code>stdin</code> 的作用是读流，即读取用户的输入，读取后转换流作为一个可读流调用 <code>pipe</code>，将用户输入的信息通过标准输出写到命令行窗口，此时 <code>stdout</code> 的作用是写流。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>自定义流最常见的种类在上面都已经涵盖了，真正的在开发中用到的不多，如果需要写一个自定义流应该比上面的复杂很多，本文主要目的是认识什么是自定义流，并了通过 <code>Node.js</code> 解实现一个自定义流的基本流程。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js —— 流的原理分析与简易实现</title>
    <url>/20180704175217/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180704175217/stream.png" title="流的实现原理"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>在之前的文章中有一篇讲解了流的基本用法，本篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 <code>Stream</code>，而并非流的使用，下面代码中依赖了 <code>fs</code> 的很多基本操作和流的基本使用知识，可以看下面两篇：</strong></p><ul><li><a href="/20180630172601/" target="_blank">Node.js 文件操作 —— fs 基本使用</a>。</li><li><a href="/20180703231032/" target="_blank">Node.js —— Stream 的基本使用</a>。</li></ul></blockquote><a id="more"></a><h2 id="可读流的实现（流动模式）"><a href="#可读流的实现（流动模式）" class="headerlink" title="可读流的实现（流动模式）"></a>可读流的实现（流动模式）</h2><h3 id="ReadStream-类创建"><a href="#ReadStream-类创建" class="headerlink" title="ReadStream 类创建"></a>ReadStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createReadStream</code> 创建可读流时，返回了 <code>ReadStream</code> 对象，上面存在着一些事件和方法，其实我们在创建这个可读流的时候创建了某一个类的实例，这个实例可以调用类原型上的方法，我们这里将这个类命名为 <code>ReadStream</code>。</p><p>类的原型方法内部可能会创建一些事件，在 <code>Node.js</code> 中，事件是依赖 <code>events</code> 模块的，即 <code>EventEmitter</code> 类，同时类的方法可能会操作文件，会用到 <code>fs</code> 模块，所以也提前引入 <code>fs</code>。</p><pre><code class="lang-js">/* 创建 ReadStream 类 */
// 引入依赖模块
const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

// 创建 ReadStream 类
class ReadStream extends EventEmitter {
  constructor(path, options = {}) {
    super();
    // 创建可读流参数传入的属性
    this.path = path; // 读取文件的路径
    this.flags = options.flags || &#39;r&#39;; // 文件标识位
    this.encoding = options.encoding || null; // 字符编码
    this.fd = options.fd || null; // 文件描述符
    this.mode = options.mode || 0o666; // 权限位
    this.autoClose = options.autoClose || true; // 是否自动关闭
    this.start = options.start || 0; // 读取文件的起始位置
    this.end = options.end || null; // 读取文件的结束位置（包含）

    // 每次读取文件的字节数
    this.highWaterMark = options.highWaterMark || 64 * 1024;
    this.flowing = false; // 控制当前是否是流动状态，默认为暂停状态

    // 存储读取内容的 Buffer
    this.buffer = Buffer.alloc(this.highWaterMark);
    this.pos = this.start; // 下次读取文件的位置（变化的）

    // 创建可读流要打开文件
    this.open();

    // 如果监听了 data 事件，切换为流动状态
    this.on(&#39;newListener&#39;, type =&gt; {
      if (type === &#39;data&#39;) {
        this.flowing = true;

        // 开始读取文件
        this.read();
      }
    });
  }
}

// 导出模块
module.exports = ReadStream;
</code></pre><p>使用 <code>fs.createReadStream</code> 时传入了两个参数，读取文件的路径和一个 <code>options</code> 选项，<code>options</code> 上有 <code>8</code> 个参数，我们在创建 <code>ReadStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p><p>创建可读流的时候有两种状态，流动状态和暂停状态，默认创建可读流是暂停状态，只有在触发 <code>data</code> 事件时才会变为流动状态，所以在 <code>this</code> 上挂载了 <code>flowing</code> 存储当前的状态是否为流动状态，值默认为 <code>false</code>。</p><blockquote class="pullquote warning"><p><em><strong>注意：这里说的暂停状态不是暂停模式，暂停模式是 <code>readable</code>，是可读流的另一种模式，我们这小节讨论的可读流为流动模式。</strong></em></p></blockquote><p>在读取文件时其实是操作 <code>Buffer</code> 进行读取的，需要有一个 <code>Buffer</code> 实例用来存储每次读取的数据，所以在 <code>this</code> 上挂载了一个新创建的 <code>Buffer</code>，长度等于 <code>highWaterMark</code>。</p><p>当从 <code>start</code> 值的位置开始读取文件，下一次读取文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次读取文件的位置。</p><p>在创建 <code>ReadStream</code> 的实例（可读流）时，应该打开文件并进行其他操作，所以在 <code>this</code> 上挂载了 <code>open</code> 方法并执行。</p><p>创建实例的同时监听了 <code>newListener</code> 事件，回调在每次使用 <code>on</code> 监听事件时触发，回调内部逻辑是为了将默认的暂停状态切换为流动状态，因为在使用时，流动状态是通过监听 <code>data</code> 事件触发的，在 <code>newListener</code> 的回调中判断事件类型为 <code>data</code> 的时候将 <code>flowing</code> 标识的值更改为 <code>true</code>，并调用读取文件的 <code>read</code> 方法。</p><blockquote class="pullquote info"><p><strong>在使用 <code>ES6</code> 的类编程时，原型上的方法都是写在 <code>class</code> 内部，我们下面为了把原型上的方法拆分出来成为单独的代码块，都使用 <code>ReadStream.prototype.open = function...</code> 直接给原型添加属性的方式，但这样的方式和直接写在 <code>class</code> 内有一点区别，就是 <code>class</code> 内部的书写的原型方法都是不可遍历的，添加属性的方式创建的方法都是可遍历的，但是这点区别对我们代码的执行没有任何影响。</strong></p></blockquote><h3 id="打开文件方法-open-的实现"><a href="#打开文件方法-open-的实现" class="headerlink" title="打开文件方法 open 的实现"></a>打开文件方法 open 的实现</h3><p>在使用可读流时，打开时默认是暂停状态，会触发 <code>open</code> 事件，如果打开文件出错会触发 <code>error</code> 事件。</p><pre><code class="lang-js">/* open 方法 */
// 打开文件
ReadStream.prototype.open = function () {
  fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; {
    if (err) {
      this.emit(&#39;error&#39;, err);

      // 如果文件打开了出错，并配置自动关闭，则关掉文件
      if (this.autoClose) {
        // 关闭文件（触发 close 事件）
        this.destroy();

        // 不再继续执行
        return;
      }
    }
    // 存储文件描述符
    this.fd = fd;

    // 成功打开文件后触发 open 事件
    this.emit(&#39;open&#39;);
  });
}
</code></pre><p><code>open</code> 方法的逻辑就是在打开文件的时候，将文件描述符存储在实例上方便后面使用，并使用 <code>EventEmitter</code> 的原型方法 <code>emit</code> 触发 <code>open</code> 事件，如果出错就使用 <code>emit</code> 触发 <code>error</code> 事件，如果配置 <code>autoClose</code> 参数为 <code>true</code>，就关闭文件并触发 <code>close</code>。</p><p>我们将关闭文件的逻辑抽取出来封装在了 <code>ReadStream</code> 类的 <code>destroy</code> 方法中，下面来实现 <code>destroy</code>。</p><h3 id="关闭文件方法-destroy-的实现"><a href="#关闭文件方法-destroy-的实现" class="headerlink" title="关闭文件方法 destroy 的实现"></a>关闭文件方法 destroy 的实现</h3><p>文件出错分为两种，第一种文件打开出错，第二种是文件不存在出错（没打开文件，系统不会分配文件描述符 <code>fd</code>）。</p><pre><code class="lang-js">/* detroy 方法 */
// 关闭文件
ReadStream.prototype.detroy = function () {
  // 判断是否存在文件描述符
  if (typeof this.fd === &#39;number&#39;) {
    // 存在则关闭文件并触发 close 事件
    fs.close(fd, () =&gt; {
      this.emit(&#39;close&#39;);
    });
    return;
  }

  // 不存在文件描述符直接触发 close 事件
  this.emit(&#39;close&#39;);
}
</code></pre><p>如果是打开文件后出错需要关闭文件，并触发 <code>close</code> 事件，如果是没打开文件，则直接触发 <code>close</code> 事件，所以上面通过文件描述符来判断该如何处理。</p><h3 id="读取文件方法-read-的实现"><a href="#读取文件方法-read-的实现" class="headerlink" title="读取文件方法 read 的实现"></a>读取文件方法 read 的实现</h3><p>还记得在 <code>ReadStream</code> 类中，监听的 <code>newListener</code> 事件的回调中如果监听了 <code>data</code> 事件则会执行 <code>read</code> 读取文件，接下来就实现读取文件的核心逻辑。</p><pre><code class="lang-js">/* read 方法 */
// 读取文件
ReadStream.prototype.read = function () {
  // 由于 open 异步执行，read 是在创建实例时同步执行，read 执行可能早于 open，此时不存在文件描述符
  if (typeof this.fd !== &#39;number&#39;) {
    // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 read
    return this.once(&#39;open&#39;, () =&gt; this.read());
  }

  // 如过设置了结束位置，读到结束为止就不能再读了，最后一次读取真实读取数应该小于 highWaterMark
  // 所以每次读取的字节数应该和 highWaterMark 取最小值
  const howMuchToRead = this.end ?
    Math.min(this.highWaterMark, this.end - this.pos + 1) :
    this.highWaterMark;

  // 读取文件
  fs.read(this.fd, this.buffer, 0, howMuchToRead, this.pos, (err, bytesRead) =&gt; {
    // 如果读到内容执行下面代码，读不到则触发 end 事件并关闭文件
    if (bytesRead &gt; 0) {
      // 维护下次读取文件位置
      this.pos += bytesRead;

      // 保留有效的 Buffer
      let realBuf = this.buffer.slice(0, bytesRead);

      // 根据编码处理 data 回调返回的数据
      realBuf = this.encoding ? realBuf.toString(this.encoding) : realBuf;

      // 触发 data 事件并传递数据
      this.emit(&#39;data&#39;, realBuf);

      // 递归读取
      if (this.flowing) {
        this.read();
      }
    } else {
      this.isEnd = true;
      this.emit(&#39;end&#39;); // 触发 end 事件
      this.detroy(); // 关闭文件
    }
  });
}
</code></pre><p>创建 <code>ReadStream</code> 的实例时，执行的 <code>open</code> 方法内部是使用 <code>fs.open</code> 打开文件的，是异步操作，而读取文件方法 <code>read</code> 是在 <code>newListener</code> 回调中同步执行的，这样很可能触发 <code>read</code> 的时候文件还没有被打开（不存在文件描述符），所以在 <code>read</code> 方法中判断了文件描述符是否存在，并在不存在时候使用 <code>once</code> 添加了 <code>open</code> 事件，回调中重新执行了 <code>read</code>。</p><p>由于在 <code>open</code> 方法中使用 <code>emit</code> 触发了 <code>open</code> 事件，所以 <code>read</code> 内用 <code>once</code> 添加的 <code>open</code> 事件的回调也会跟着执行一次，并在回调中重新调用了 <code>read</code> 方法，保证了 <code>read</code> 读取文件的逻辑在文件真正打开后才执行，为了文件打开前执行 <code>read</code> 而不执行读取文件的逻辑，用 <code>once</code> 添加 <code>open</code> 事件时别忘记 <code>return</code>。</p><p>在使用 <code>fs.read</code> 读取文件的时候有一个参数为本次读取几个字符到 <code>Buffer</code> 中，如果在创建可读流的时候设置了读取文件的结束位置 <code>end</code> 参数，则读到 <code>end</code> 位置就不应该再继续读取了，所以在存在 <code>end</code> 参数的时候每次都计算一下读取个数和 <code>highWaterMark</code> 取最小值，保证读取内容小于 <code>highWaterMark</code> 的时候不会多读，因为读取时是包括 <code>end</code> 值作为 <code>Buffer</code> 的索引这一项的，所以计算时多减去的要 <code>+1</code> 加回来，再一次读取这个读取个数计算结果变成了 <code>0</code>，也就结束了读取。</p><p>因为 <code>end</code> 参数的情况，所以在内部读取逻辑前判断了 <code>bytesRead</code> （实际读取字节数）是否大于 <code>0</code>，如果不满足条件则在实例添加是否读取结束标识 <code>isEnd</code>（后面使用），触发 <code>end</code> 事件并关闭文件，如果满足条件，也是通过 <code>bytesRead</code> 对 <code>Buffer</code> 进行截取，保留了有用的 <code>Buffer</code>，并且通过 <code>encoding</code> 编码对 <code>Buffer</code> 进行处理后，触发 <code>data</code> 事件，并将处理后的数据传递给 <code>data</code> 事件的回调。</p><h3 id="暂停、恢复读取-pause-和-resume"><a href="#暂停、恢复读取-pause-和-resume" class="headerlink" title="暂停、恢复读取 pause 和 resume"></a>暂停、恢复读取 pause 和 resume</h3><p><code>pause</code> 的目的就是暂停读取，其实就是阻止 <code>read</code> 方法在读取时进行递归，所以只需要更改 <code>flowing</code> 的值即可。</p><pre><code class="lang-js">/* pause 方法 */
// 暂停读取
ReadStream.prototype.pause = function () {
  this.flowing = false;
};
</code></pre><p><code>resume</code> 的目的是恢复读取，在更改 <code>flowing</code> 值得基础上重新执行 <code>read</code> 方法，由于在 <code>pause</code> 调用时 <code>read</code> 内部还是执行得读取文件得分支，文件并没有关闭，读取文件位置的参数也是通过实例上的当前的属性值进行计算的，所以重新执行 <code>read</code> 会继续上一次的位置读取。</p><pre><code class="lang-js">/* resume 方法 */
// 恢复读取
ReadStream.prototype.resume = function () {
  this.flowing = true;
  if (!this.isEnd) this.read();
};
</code></pre><p>上面在重新执行 <code>read</code> 之前使用 <code>isEnd</code> 标识做了判断，防止在 <code>setInterval</code> 中调用 <code>resume</code> 在读取完成后不断的触发 <code>end</code> 和 <code>close</code> 事件。</p><h2 id="验证可读流（流动模式）ReadStream"><a href="#验证可读流（流动模式）ReadStream" class="headerlink" title="验证可读流（流动模式）ReadStream"></a>验证可读流（流动模式）ReadStream</h2><p>接下来我们使用自己实现的 <code>ReadStream</code> 类来创建可读流，并按照 <code>fs.createReadStream</code> 的用法进行使用并验证。</p><pre><code class="lang-js">/* 验证 ReadStream */
// 文件 1.txt 内容为 0123456789
const fs = require(&#39;fs&#39;);
const ReadStream = require(&#39;./ReadStream&#39;);

// 创建可读流
const rs = new ReadStream(&#39;1.txt&#39;, {
  encoding: &#39;utf8&#39;,
  start: 0,
  end: 5,
  highWaterMark: 2
});

rs.on(&#39;open&#39;, () =&gt; console.log(&#39;open&#39;));

rs.on(&#39;data&#39;, data =&gt; {
  console.log(data, new Date());
  rs.pause();
});

rs.on(&#39;end&#39;, () =&gt; console.log(&#39;end&#39;));
rs.on(&#39;close&#39;, () =&gt; console.log(&#39;close&#39;));
rs.on(&#39;error&#39;, err =&gt; console.log(err));

setInterval(() =&gt; rs.resume(), 1000);

// open
// 01 2018-07-04T10:44:20.384Z
// 23 2018-07-04T10:44:21.384Z
// 45 2018-07-04T10:44:22.384Z
// end
// close
</code></pre><p>执行上面的代码正常的执行逻辑是先触发 <code>open</code> 事件，然后触发 <code>data</code> 事件，读取一次后暂停，每隔一秒恢复读取一次，再读取完成后触发 <code>end</code> 和 <code>close</code> 事件，通过运行代码结果和我们希望的一样。</p><h2 id="可读流的实现（暂停模式）"><a href="#可读流的实现（暂停模式）" class="headerlink" title="可读流的实现（暂停模式）"></a>可读流的实现（暂停模式）</h2><h3 id="在-fs-中的暂停模式的真正用法"><a href="#在-fs-中的暂停模式的真正用法" class="headerlink" title="在 fs 中的暂停模式的真正用法"></a>在 fs 中的暂停模式的真正用法</h3><p>在 <code>fs</code> 模块中用 <code>createReadStream</code> 创建的可读流中通过监听 <code>readable</code> 事件触发暂停模式（监听 <code>data</code> 事件触发流动模式），通过下面例子感受暂停模式与流动模式的不同，现在读取文件 <code>1.txt</code>，内容为 <code>0~9</code> 十个数字。</p><pre><code class="lang-js">/* 暂停模式的用法 */
// 文件 1.txt 内容为 0123456789
const fs = require(&#39;fs&#39;);

// 创建可读流
const rs = fs.createReadStream(&#39;1.txt&#39;, {
  encoding: &#39;utf8&#39;,
  start: 0,
  highWaterMark: 3
});

rs.on(&#39;readable&#39;, () =&gt; {
  // read 参数为本次读取的个数
  const r = rs.read(3);
  // 打印读取的数据
  console.log(&#39;data:&#39;, r);
  // 打印容器剩余空间
  console.log(rs._readableState.length);
});

// data:012
// 0
// data:345
// 0
// data:678
// 0
// data:null
// 1
// data:9
// 0
</code></pre><p>通俗的解释，暂停模式的 <code>readable</code> 事件默认会触发一次，监听 <code>readable</code> 事件后就像创建了一个 “容器”，容量为 <code>highWaterMark</code>，文件中的数据会自动把容器注满，调用可读流的 <code>read</code> 方法读取时，会从容器中取出数据，如果 <code>read</code> 方法读取的数据小于 <code>highWaterMark</code>，则直接暂停，不再继续读取，如果大于等于 <code>highWaterMark</code> ，说明 “容器” 空了，则会触发 <code>readable</code> 事件，无论读取字节数与 <code>highWaterMark</code> 关系如何，只要 “容器” 内容量剩余小于 <code>highWaterMark</code> 就会进行 “续杯”，再次向 “容器” 中填入 <code>highWaterMark</code> 个，所以有些时候真实的容量会大于 <code>highWaterMark</code>。</p><p><code>read</code> 方法读取的内容会返回 <code>null</code> 是因为容器内真实的数据数小于了读取数，如果不是最后一次读取，会在多次读取后将值一并返回，如果是最后一次读取，会把剩余不足的数据返回。</p><blockquote class="pullquote success"><p><strong>可读流暂停模式的特点：</strong></p><ul><li><em><strong><code>readable</code> 事件的触发条件：“容器” 空了；</strong></em></li><li><em><strong>“续杯” 条件：读取后 “容器” 内剩余量小于 <code>highWaterMark</code>；</strong></em></li><li><em><strong><code>read</code> 返回 <code>null</code>：“容器” 容器内可悲读取数据无法满足一次读取字节数。</strong></em></li></ul></blockquote><h3 id="ReadableStream-类的实现"><a href="#ReadableStream-类的实现" class="headerlink" title="ReadableStream 类的实现"></a>ReadableStream 类的实现</h3><p>同为可读流，暂停模式与流动模式相同，都依赖 <code>fs</code> 模块和 <code>events</code> 模块的 <code>EventEmitter</code> 类，参数依然为读取文件的路径和 <code>options</code>。</p><pre><code class="lang-js">/* 创建 ReadableStream 类 */
// 引入依赖
const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

class ReadableStream extends EventEmitter {
  constructor(path, options = {}) {
    super();
    this.path = path; // 读取文件的路径
    this.flags = options.flags || &#39;r&#39;; // 文件标识位
    this.encoding = options.encoding || null; // 字符编码
    this.fd = options.fd || null; // 文件描述符
    this.mode = options.mode || 0o666; // 权限位
    this.autoClose = options.autoClose || true; // 是否自动关闭
    this.start = options.start || 0; // 读取文件的起始位置

    // 每次读取文件的字节数
    this.highWaterMark = options.highWaterMark || 64 * 1024;
    this.reading = false; // 如果正在读取，则不再读取

    // 当缓存区的长度等于 0 的时候， 触发 readable
    this.emitReadable = false;
    this.cache = []; // 缓存区
    this.len = 0; // 缓存区的长度
    this.pos = this.start; // 下次读取文件的位置（变化的）

    // 创建可读流要打开文件
    this.open();

    this.on(&#39;newListener&#39;, type =&gt; {
      if (type === &#39;readable&#39;) {
        this.read(); // 监听readable就开始读取
      }
    });
  }
}

// 导出模块
module.exports = ReadableStream;
</code></pre><p>在类的添加了 <code>newListener</code> 事件，在回调中判断是否监听了 <code>readable</code> 事件，如果监听了开始从 “容器” 中读取。</p><h3 id="打开、关闭文件-open-和-detroy"><a href="#打开、关闭文件-open-和-detroy" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>打开和关闭文件的方法和流动模式的套路基本相似。</p><pre><code class="lang-js">/* open 方法 */
// 打开文件
ReadableStream.prototype.open = function () {
  fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; {
    if (err) {
      this.emit(&#39;error&#39;, err);

      // 如果文件打开了出错，并配置自动关闭，则关掉文件
      if (this.autoClose) {
        // 关闭文件（触发 close 事件）
        this.destroy();

        // 不再继续执行
        return;
      }
    }
    // 存储文件描述符
    this.fd = fd;

    // 成功打开文件后触发 open 事件
    this.emit(&#39;open&#39;);
  });
}
</code></pre><pre><code class="lang-js">/* detroy 方法 */
// 关闭文件
ReadableStream.prototype.detroy = function () {
  // 判断是否存在文件描述符
  if (typeof this.fd === &#39;number&#39;) {
    // 存在则关闭文件并触发 close 事件
    fs.close(fd, () =&gt; {
      this.emit(&#39;close&#39;);
    });
    return;
  }

  // 不存在文件描述符直接触发 close 事件
  this.emit(&#39;close&#39;);
}
</code></pre><h3 id="从-“容器”-中读取-read-方法的实现"><a href="#从-“容器”-中读取-read-方法的实现" class="headerlink" title="从 “容器” 中读取 read 方法的实现"></a>从 “容器” 中读取 read 方法的实现</h3><p><code>read</code> 方法的参数不传时就相当于从 “容器” 读取 <code>highWaterMart</code> 个字节，如果传参表示读取参数数量的字节数。</p><pre><code class="lang-js">/* read 方法 */
ReadableStream.prototype.read = function (n) {
  // 如果读取大于了 highWaterMark，重新计算 highWaterMark，并重新读取
  if (n &gt; this.len) {
    // 计算新的 highWaterMark，方法摘自 Node.js 源码
    this.highWaterMark = computeNewHighWaterMark(n);
    this.reading = true;
    this._read();
  }

  // 将要返回的数据
  let buffer;

  // 如果读取的字节数大于 0 小于等于当前缓存 Buffer 的总长度
  if (n &gt; 0 &amp;&amp; n &lt;= this.len) {
    // 则从缓存中取出
    buffer = Buffer.alloc(n);

    let current; // 存储每次从缓存区读出的第一个 Buffer
    let index = 0; // 每次读取缓存 Buffer 的索引
    let flag = true; // 是否结束整个 while 循环的标识

    // 开始读取
    while ((current = this.cache.shift()) &amp;&amp; flag) {
      for (let i = 0; i &lt; current.length; i++) {
        // 将缓存中取到的 Buffer 的内容读到自己定义的 Buffer 中
        buffer[index++] = current[i];

        // 如果当前索引值已经等于了读取个数，结束 for 循环
        if (index === n) {
          flag = false;

          // 取出当前 Buffer 没有消耗的
          const residue = current.slice(i + 1);

          // 在读取后维护缓存的长度
          this.len -= n;

          // 如果 BUffer 真的有剩下的就给塞回到缓存中
          if (residue.length) {
            this.cache.unshift(residue);
          }
          break;
        }
      }
    }
  }

  // 如果当前 读取的 Buffer 为 0，将触发 readable 事件
  if (this.len === 0) {
    this.emitReadable = true;
  }

  // 如果当前的缓存区大小小于 highWaterMark，就要读取
  if (this.len &lt; this.highWaterMark) {
    // 如果不是正在读取才开始读取
    if (!this.read) {
      this.reading = true;
      this._read(); // 正真读取的方法
    }
  }

  // 将 buffer 转回创建可读流设置成的编码格式
  if (buffer) {
    buffer = this.encoding ? buffer.toString(this.encoding) : buffer;
  }

  return buffer;
}
</code></pre><p>上面的 <code>read</code> 方法的参数大小对比缓存区中取出的 <code>Buffer</code> 长度有两种情况，一种是小于当前缓存区内取出 <code>Buffer</code> 的长度，一种是大于了整个缓存区的 <code>len</code> 的长度。</p><p>小于当前缓存区总长度通过循环取出需要的 <code>Buffer</code> 存储了我们要返回创建的 <code>Buffer</code> 中，剩余的 <code>Buffer</code> 会丢失，所以我们做了一个小小的处理，将剩下的 <code>Buffer</code> 作为第一个 <code>Buffer</code> 塞回到了缓存区中，在处理这个问题时与流动模式不相同，流动模式处理后直接跳出了，而暂停模式相当于从 “容器” 中读取，如果第一次读取后还有剩余还要接着从容器中继续读取。</p><p>大于 <code>len</code> 属性时，规定需要重新计算 <code>highWaterMark</code>，遵循的原则是将当前 <code>highWaterMark</code> 设定为当前读取字节个数距离最接近的 <code>2</code> 的 <code>n</code> 次方的数值，<code>Node.js</code> 源码中方法名称为 <code>computeNewHighWaterMark</code>，为了提高性能是使用位运算的方式进行计算的，源码如下。</p><pre><code class="lang-js">/* 重新计算 highWaterMark */
function computeNewHighWaterMark(n) {
  n--;
  n |= n &gt;&gt;&gt; 1;
  n |= n &gt;&gt;&gt; 2;
  n |= n &gt;&gt;&gt; 4;
  n |= n &gt;&gt;&gt; 8;
  n |= n &gt;&gt;&gt; 16;
  n++;
  return n;
}
</code></pre><p>在调用该方法重新计算 <code>highWaterMark</code> 后更改正在读取状态，重新读取，由于读取逻辑的重复，所以真正读取文件的逻辑抽取成一个 <code>_read</code> 方法来实现，下面呢就来看看 <code>_read</code> 内部都做了什么。</p><h3 id="真正读取文件的-read"><a href="#真正读取文件的-read" class="headerlink" title="真正读取文件的 _read"></a>真正读取文件的 _read</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_read</code> 方法读取时，是在 <code>newListener</code> 中同步执行 <code>_read</code>，所以为了保证 <code>_read</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p><pre><code class="lang-js">/* _read 方法 */
ReadableStream.prototype._read = function () {
  if (typeof this.fd !== &#39;number&#39;) {
    return this.once(&#39;open&#39;, () =&gt; _read());
  }

  // 创建本次读取的 Buffer
  let buffer = Buffer.alloc(this.highWaterMark);

  // 读取文件
  fs.read(this.fd, buffer, 0, this.highWaterMark, this.pos, (err, bytesRead) =&gt; {
    if (bytesRead &gt; 0) {
      this.cache.push(buffer); // 缓存
      this.len += bytesRead; // 维护缓存区长度
      this.pos += bytesRead; // 维护下一次读取位置
      this.reading = false; // 读取完毕

      // 触发 readable 事件
      if (this.emitReadable) {
        // 触发后更改触发状态为 false
        this.emitReadable = false;
        this.emit(&#39;readable&#39;);
      }
    } else {
      // 如果读完触发结束事件
      this.emit(&#39;end&#39;);
    }
  });
}
</code></pre><p>由于缓存区是一个数组，存储的每一个 <code>Buffer</code> 是独立存在的，所以不能挂载在实例上共用，如果挂在实例上则引用相同，一动全动，这不是我们想要的，所以每一次执行 <code>_read</code> 方法时都创建新的 <code>Buffer</code> 实例存入读取的数据后存储在缓存区中，如果读取完成 <code>bytesRead</code> 为 <code>0</code>，则触发 <code>end</code> 事件。</p><blockquote class="pullquote warning"><p><em><strong>注意：在 <code>Node.js</code> 源码中，可读流两种模式代码都是通过一个类 <code>ReadStream</code> 实现的，使用 <code>fs.createReadStream</code> 创建一个可读流就具备两种模式，通过监听 <code>data</code> 和 <code>readable</code> 两种不同的事件来触发两种不同的模式，而我们为了更清晰的模拟两种模式的实现，把两种模式拆开成了两个类来实现的，在测试时需要创建不同类的实例。</strong></em></p></blockquote><h2 id="验证可读流（暂停模式）ReadableStream"><a href="#验证可读流（暂停模式）ReadableStream" class="headerlink" title="验证可读流（暂停模式）ReadableStream"></a>验证可读流（暂停模式）ReadableStream</h2><p>为了统一我们依然读取真正用法中 <code>1.txt</code> 文件，内容为 <code>0~9</code> 十个数字。</p><pre><code class="lang-js">/* 验证 ReadableStream */
// 引入依赖
const fs = require(&#39;fs&#39;);
const ReadableStream = require(&#39;./ReadableStream&#39;);

const rs = new ReadableStream(&#39;1.txt&#39;, {
  encoding: &#39;utf8&#39;,
  start: 0,
  highWaterMark: 3
});

rs.on(&#39;readable&#39;, () =&gt; {
  let r = rs.read(3);
  console.log(r);
  console.log(rs.len);
});
</code></pre><p>在打印 “容器” 剩余容量时，我们使用在 <code>ReadableStream</code> 上构造的 <code>len</code> 属性，源码中的属性是 <code>_readableState.length</code>。</p><blockquote class="pullquote info"><p><strong>流动模式和暂停模式分别有不同的应用场景：</strong></p><ul><li><strong>如果只是希望读取一个文件，并最快的获得结果使用流动模式是很好的选择；</strong></li><li><strong>如果希望了解读取文件的具体内容，并进行精细的处理，使用暂停模式更好一些。</strong></li></ul></blockquote><h2 id="可写流的实现"><a href="#可写流的实现" class="headerlink" title="可写流的实现"></a>可写流的实现</h2><h3 id="WriteStream-类创建"><a href="#WriteStream-类创建" class="headerlink" title="WriteStream 类创建"></a>WriteStream 类创建</h3><p>在使用 <code>fs</code> 的 <code>createWriteStream</code> 创建可写流时，返回了 <code>WriteStream</code> 对象，上面也存在事件和方法，创建可写流的时也是创建类的实例，我们将这个类命名为 <code>WriteStream</code>，事件同样依赖 <code>events</code> 模块的 <code>EventEmitter</code> 类，文件操作同样依赖 <code>fs</code> 模块，所以需提前引入。</p><pre><code class="lang-js">/* 创建 WriteStream 类 */
// 引入依赖模块
const EventEmitter = require(&#39;events&#39;);
const fs = require(&#39;fs&#39;);

// 创建 WriteStream 类
class WriteStream extends EventEmitter {
  constructor(path, options = {}) {
    super();
    // 创建可写流参数传入的属性
    this.path = path; // 写入文件的路径
    this.flags = options.flags || &#39;w&#39;; // 文件标识位
    this.encoding = options.encoding || &#39;utf8&#39;; // 字符编码
    this.fd = options.fd || null; // 文件描述符
    this.mode = options.mode || 0o666; // 权限位
    this.autoClose = options.autoClose || true; // 是否自动关闭
    this.start = options.start || 0; // 写入文件的起始位置

    // 对比写入字节数的标识
    this.highWaterMark = options.highWaterMark || 16 * 1024;
    this.writing = false; // 是否正在写入
    this.needDrain = false; // 是否需要触发 drain 事件
    this.buffer = []; // 缓存，正在写入就存入缓存中
    this.len = 0; // 当前缓存的个数
    this.pos = this.start; // 下次写入文件的位置（变化的）

    // 创建可写流要打开文件
    this.open();
  }
}

// 导出模块
module.exports = WriteStream;
</code></pre><p>使用 <code>fs.createWriteStream</code> 创建可写流时传入了两个参数，写入的文件路径和一个 <code>options</code> 选项，<code>options</code> 上有 <code>7</code> 个参数，我们在创建 <code>WriteStream</code> 类的时候将这些参数初始化到了 <code>this</code> 上。</p><p>创建可写流后需要使用 <code>write</code> 方法进行写入，写入时第一次会真的通过内存写入到文件中，而再次写入则会将内容写到缓存中，注意这里的 “内存” 和 “缓存”，内存是写入文件是的系统内存，缓存是我们自己创建的数组，第一次写入以后要写入文件的 <code>Buffer</code> 都会先存入这个数组中，这个数组名为 <code>buffer</code>，挂载在实例上，实例上同时挂载了 <code>len</code> 属性用来存储当前缓存中 <code>Buffer</code> 总共的字节数（长度）。</p><p>我们在可读流上挂载了是否正在写入的状态 <code>writing</code> 属性，只要缓存区中存在未写入的 <code>Buffer</code>，<code>writing</code> 的状态就是正在写入，当写入的字节数大于了 <code>highWaterMark</code> 需要触发 <code>drain</code> 事件，所以又挂载了是否需要触发 <code>drain</code> 事件的标识 <code>needDrain</code> 属性。</p><p>当从文件的 <code>start</code> 值对应的位置开始写入，下一次写入文件的位置会发生变化，所以在 <code>this</code> 上挂载了 <code>pos</code> 属性，用于存储下次写入文件的位置。</p><blockquote class="pullquote primary"><p><strong>在 <code>Node.js</code> 流的源码中缓存是用链表实现的，通过指针来操作缓存中的 <code>Buffer</code>，而我们为了简化逻辑就使用数组来作为缓存，虽然性能相对链表要差，但更容易理解整个可读流的写入机制。</strong></p></blockquote><h3 id="打开、关闭文件-open-和-detroy-1"><a href="#打开、关闭文件-open-和-detroy-1" class="headerlink" title="打开、关闭文件 open 和 detroy"></a>打开、关闭文件 open 和 detroy</h3><p>在 <code>WriteStream</code> 中，写入文件之前也应该打开文件，在打开文件过程中出错时也应该触发 <code>error</code> 事件并关闭文件，打开和关闭文件的方法 <code>open</code> 和 <code>detroy</code> 与 <code>ReadStream</code> 的 <code>open</code> 和 <code>detroy</code> 方法的逻辑如出一辙，所以这里为了方便查看直接贴在下面。</p><pre><code class="lang-js">/* open 方法 */
// 打开文件
WriteStream.prototype.open = function () {
  fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; {
    if (err) {
      this.emit(&#39;error&#39;, err);

      // 如果文件打开了出错，并配置自动关闭，则关掉文件
      if (this.autoClose) {
        // 关闭文件（触发 close 事件）
        this.destroy();

        // 不再继续执行
        return;
      }
    }
    // 存储文件描述符
    this.fd = fd;

    // 成功打开文件后触发 open 事件
    this.emit(&#39;open&#39;);
  });
}
</code></pre><pre><code class="lang-js">/* detroy 方法 */
// 关闭文件
WriteStream.prototype.detroy = function () {
  // 判断是否存在文件描述符
  if (typeof this.fd === &#39;number&#39;) {
    // 存在则关闭文件并触发 close 事件
    fs.close(fd, () =&gt; {
      this.emit(&#39;close&#39;);
    });
    return;
  }

  // 不存在文件描述符直接触发 close 事件
  this.emit(&#39;close&#39;);
}
</code></pre><h3 id="写入文件方法-write-的实现"><a href="#写入文件方法-write-的实现" class="headerlink" title="写入文件方法 write 的实现"></a>写入文件方法 write 的实现</h3><blockquote class="pullquote default"><p><strong><code>write</code> 方法默认支持传入三个参数：</strong></p><ul><li><strong><code>chunk</code>：写入文件的内容；</strong></li><li><strong><code>encoding</code>：写入文件的编码格式；</strong></li><li><strong><code>callback</code>：写入成功后执行的回调。</strong></li></ul></blockquote><pre><code class="lang-js">/* write 方法 */
// 写入文件的方法，只要逻辑为写入前的处理
WriteStream.prototype.write = function (chunk, encoding = this.encoding, callback) {
  // 为了方便操作将要写入的数据转换成 Buffer
  chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);

  // 维护缓存的长度
  this.len += chunk.lenth;

  // 维护是否触发 drain 事件的标识
  this.needDrain = this.highWaterMark &lt;= this.len;

  // 如果正在写入
  if (this.writing) {
    this.buffer.push({
      chunk,
      encoding,
      callback
    });
  } else {
    // 更改标识为正在写入，再次写入的时候走缓存
    this.writing = true;
    // 如果已经写入清空缓存区的内容
    this._write(chunk, encoding, () =&gt; this.clearBuffer());
  }

  return !this.needDrain;
}
</code></pre><p>与可写流的 <code>read</code> 一样，我们在使用 <code>write</code> 方法将数据写入文件时，也是操作 Buffer，在 <code>write</code> 方法中，首先将接收到的要写入的数据转换成了 <code>Buffer</code>，因为是多次写入，要知道缓存中 <code>Buffer</code> 字节数的总长度，所以维护了 <code>len</code> 变量。</p><p>我们的 <code>WriteStream</code> 构造函数中，<code>this</code> 挂载了 <code>needDrain</code> 属性，在使用 <code>fs.createWriteStream</code> 创建的可读流时，是写入的字节长度超过 <code>highWaterMark</code> 才会触发 <code>drain</code> 事件，而 <code>needDrain</code> 与 <code>write</code> 的返回值正好相反，所以我们用 <code>needDrain</code> 取反来作为 <code>write</code> 方法的返回值。</p><p>在写入的逻辑中第一次是直接通过内存写入到文件，但是再次写入就需要将数据存入缓存，将数据写入到文件中写入状态 <code>writing</code> 默认为 <code>false</code>，通过缓存再写入证明应该正在写入中，所以在第一次写入后应更改 <code>writing</code> 的状态为 <code>true</code>，写入缓存其实就是把转换的 <code>Buffer</code>、编码以及写入成功后要执行的回调挂在一个对象上存入缓存的数组 <code>buffer</code> 中。</p><p>我们把真正写入文件的逻辑抽取成一个单独的方法 <code>_write</code>，并传入 <code>chunk</code>（要写入的内容，已经处理成 Buffer）、<code>encoding</code>（字符编码）、回调函数，在回调函数中执行了原型方法 <code>clearBuffer</code>，接下来就来实现 <code>_write</code> 和 <code>clearBuffer</code>。</p><blockquote class="pullquote warning"><p><strong>注意：方法使用 <code>_</code> 开头代表私有方法，轻易不要在外部调用或修改，这是一个开发者之间约定俗成的不成文规定。</strong></p></blockquote><h3 id="真正的文件操作-write"><a href="#真正的文件操作-write" class="headerlink" title="真正的文件操作 _write"></a>真正的文件操作 _write</h3><p>对比可读流（流动模式）的 <code>read</code> 方法，在调用 <code>_write</code> 方法写入时，是在创建可写流之后的同步代码中执行的，与可读流在 <code>newListener</code> 中同步执行 <code>read</code> 的情况类似，所以为了保证 <code>_write</code> 的逻辑是在 <code>open</code> 方法打开文件以后执行，使用了与 <code>read</code> 相同的处理方式。</p><pre><code class="lang-js">/* _write 方法 */
// 真正的写入文件操作的方法
WriteStream.prototype._write = function (chunk, encoding, callback) {
  // 由于 open 异步执行，write 是在创建实例时同步执行，write 执行可能早于 open，此时不存在文件描述符
  if (typeof this.fd !== &#39;number&#39;) {
    // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 write
    return this.once(&#39;open&#39;, () =&gt; this._write(chunk, encoding, callback));
  }

  // 读取文件
  fs.write(this.fd, chunk, 0, chunk.length, this.pos, (err, bytesWritten) =&gt; {
    // 维护下次写入的位置和缓存区 Buffer 的总字节数
    this.pos += bytesWritten;
    this.len -= bytesWritten;
    callback();
  });
}
</code></pre><p>在打开文件并写入的时候需要维护两个变量，下次写入的位置 <code>pos</code> 和当前缓存区内 <code>Buffer</code> 所占总字节数 <code>len</code>，本次写入了多少个字节，下次写入需要在写入位置的基础上加多少个字节，而 <code>len</code> 恰恰相反，本次写入了多少个字节，缓存区中的总长度应该对应的减少多少个字节。</p><p>在维护两个变量的值以后调用 <code>callback</code>，其实 <code>callback</code> 内执行的是 <code>clearBuffer</code> 方法，就如方法名，译为 “清空缓存”，其实就是一次一次的将数据写入文件并从缓存中移除，很明显需要递归调用 <code>_write</code> 方法，我们将这个递归的逻辑统一放在 <code>clearBuffer</code> 方法中实现。</p><h3 id="清空缓存操作-clearBuffer"><a href="#清空缓存操作-clearBuffer" class="headerlink" title="清空缓存操作 clearBuffer"></a>清空缓存操作 clearBuffer</h3><pre><code class="lang-js">/* clearBuffer 方法 */
// 清空缓存方法
WriteStream.prototype.clearBuffer = function () {
  // 先写入的在数组前面，从前面取出缓存中的 Buffer
  const buf = this.buffer.shift();

  // 如果存在 buf，证明缓存还有 Buffer 需要写入
  if (buf) {
    // 递归 _write 按照编码将数据写入文件
    this._write(buf.chunk, buf.encoding, () =&gt; this.clearBuffer);
  } else {
    // 如果没有 buf，说明缓存内的内容已经完全写入文件并清空，需要触发 drain 事件
    this.emit(&#39;drain&#39;);

    // 更改正在写入状态
    this.writing = false;

    // 更改是否需要触发 drain 事件状态
    this.needDrain = false;
  }
}
</code></pre><p><code>clearBuffer</code> 方法中获取了缓存区数组的最前面的 <code>Buffer</code>（最前面的是先写入缓存的，也应该先取出来写入文件），存在这个 <code>Buffer</code> 时，递归 <code>_write</code> 方法按照编码将数据写入文件，如果不存在说明缓存区已经清空了，代表内容完全写入文件中，所以触发 <code>drain</code> 事件，最后更改了 <code>writing</code> 和 <code>needDrain</code> 的状态。</p><p>更正 <code>writing</code> 是为了 <code>WriteStream</code> 创建的可读流在下次调用 <code>write</code> 方法时默认第一次真正写入文件，而更正 <code>needDrain</code> 的状态是在缓存区要清空的最后一个 <code>Buffer</code> 的长度小于了 <code>highWaterMark</code> 时，保证 <code>write</code> 方法的返回值是正确的。</p><blockquote class="pullquote info"><p><strong>第一次通过内存真正写入文件，其他的都写入缓存，再一个一个的将缓存中存储的 <code>Buffer</code> 写入并从缓存清空，之所以这样设计是为了把写入的内容排成一个队列，假如有 <code>3</code> 个人同时操作一个文件写入内容，只有第一个人是真的写入，其他的人都写在缓存中，再按照写入缓存的顺序依次写入文件，避免冲突和写入顺序出错。</strong></p></blockquote><h2 id="验证可写流-WriteStream"><a href="#验证可写流-WriteStream" class="headerlink" title="验证可写流 WriteStream"></a>验证可写流 WriteStream</h2><p>接下来我们使用自己实现的 <code>WriteStream</code> 类来创建可写流，并按照 <code>fs.createWriteStream</code> 的用法进行使用并验证。</p><pre><code class="lang-js">/* 验证 WriteStream */
// 向 2.txt 文件中写入 012345
const fs = require(&#39;fs&#39;);
const WriteStream = require(&#39;./WriteStream&#39;);

// 创建可写流
const ws = new WriteStream(&#39;2.txt&#39;, {
  highWaterMark: 3
});

let i = 0;

function write() {
  let flag = true;
  while (i &lt;= 6 &amp;&amp; flag) {
    i++;
    flag = ws.write(i + &#39;&#39;, &#39;utf8&#39;);
  }
}

ws.on(&#39;drain&#39;, function () {
  console.log(&#39;写入成功&#39;);
  write();
});
write();

// true
// true
// false
// 写入成功
// true
// true
// false
// 写入成功
</code></pre><p>可以使用 <code>fs.createWriteStream</code> 和 <code>WriteStream</code> 类分别执行上面的代码，对比结果，看看是否相同。</p><h2 id="可读流和可写流的桥梁-pipe"><a href="#可读流和可写流的桥梁-pipe" class="headerlink" title="可读流和可写流的桥梁 pipe"></a>可读流和可写流的桥梁 pipe</h2><p>可写流和可读流一般是通过 <code>pipe</code> 配合来使用的，<code>pipe</code> 方法是可读流 <code>ReadStream</code> 的原型方法，参数为一个可写流。</p><pre><code class="lang-js">/* pipe 方法 */
// 连接可读流和可写流的方法 pipe
ReadStream.prototype.pipe = function (dest) {
  // 开始读取
  this.on(&#39;data&#39;, data =&gt; {
    // 如果超出可写流的 highWaterMark，暂停读取
    const flag = dest.write(data);
    if (!flag) this.pause();
  });

  dest.on(&#39;drain&#39;, () =&gt; {
    // 当可写流清空内存时恢复读取
    this.resume();
  });

  this.on(&#39;end&#39;, () =&gt; {
    // 在读取完毕后关闭文件
    this.destroy();
  });
}
</code></pre><p><code>pipe</code> 方法其实就是通过可读流的 <code>data</code> 事件触发流动状态，并用可写流接收读出的数据进行写入，当写入数据超出 <code>highWaterMark</code>，则暂停可读流的读取，直到可写流的缓存被清空并把内容写进文件后，恢复可读流的读取，当读取结束后关闭文件。</p><p>下面我们实现一个将 <code>1.txt</code> 的内容拷贝 <code>2.txt</code> 中的例子。</p><pre><code class="lang-js">/* 验证 pipe */
// pipe 的使用
const fs = require(&#39;fs&#39;);

// 引入自己的 ReadStream 类和 WriteStream 类
const ReadStream = rquire(&#39;./ReadStream&#39;);
const WriteStream = rquire(&#39;./WriteStream&#39;);

// 创建可读流和可写流
const rs = new ReadStream(&#39;1.txt&#39;, {
  highWaterMark: 3
});
const ws = new WriteStream(&#39;2.txt&#39;, {
  highWaterMark: 2
});

// 使用 pipe 实现文件内容复制
rs.pipe(ws);
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>Node.js</code> 源码中，可读流和可写流的内容要比本篇内容多很多，本篇是将源码精简，抽出核心逻辑并针对流的使用方式进行实现，主要目的是帮助理解流的原理和使用，争取做到 “知其然知其所以然”，了解了一些流的底层机制再使用也能游刃有余。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js —— Stream 的基本使用</title>
    <url>/20180703231032/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180703231032/stream-use.jpg" title="流的基本使用"><p><br></p><h2 id="流的介绍"><a href="#流的介绍" class="headerlink" title="流的介绍"></a>流的介绍</h2><blockquote class="pullquote info"><p><strong>在 <code>Node.js</code> 中，我们对文件的操作需要依赖核心模块 <code>fs</code>，<code>fs</code> 中有很基本 <code>API</code> 可以帮助我们读写占用内存较小的文件，如果是大文件或内存不确定也可以通过 <code>open</code>、<code>read</code>、<code>write</code>、<code>close</code> 等方法对文件进行操作，但是这样操作文件每一个步骤都要关心，非常繁琐，<code>fs</code> 中提供了可读流和可写流，让我们通过流来操作文件，方便我们对文件的读取和写入。</strong></p></blockquote><a id="more"></a><h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><h3 id="createReadStream-创建可读流"><a href="#createReadStream-创建可读流" class="headerlink" title="createReadStream 创建可读流"></a>createReadStream 创建可读流</h3><blockquote class="pullquote primary"><p><strong><code>createReadStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有 <code>8</code> 个参数：</strong></p><ul><li><strong><code>flags</code>：标识位，默认为 <code>r</code>；</strong></li><li><strong><code>encoding</code>：字符编码，默认为 <code>null</code>；</strong></li><li><strong><code>fd</code>：文件描述符，默认为 <code>null</code>；</strong></li><li><strong><code>mode</code>：权限位，默认为 <code>0o666</code>；</strong></li><li><strong><code>autoClose</code>：是否自动关闭文件，默认为 <code>true</code>；</strong></li><li><strong><code>start</code>：读取文件的起始位置；</strong></li><li><strong><code>end</code>：读取文件的（包含）结束位置；</strong></li><li><strong><code>highWaterMark</code>：最大读取文件的字节数，默认 <code>64 * 1024</code>。</strong></li></ul></blockquote><p><code>createReadStream</code> 的返回值为 <code>fs.ReadStream</code> 对象，读取文件的数据在不指定 <code>encoding</code> 时，默认为 <code>Buffer</code>。</p><pre><code class="lang-js">// 创建可读流
const fs = require(&#39;fs&#39;);

// 创建可读流，读取 1.txt 文件
const rs = fs.creatReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});
</code></pre><p>在创建可读流后默认是不会读取文件内容的，读取文件时，可读流有两种状态，暂停状态和流动状态。</p><blockquote class="pullquote warning"><p><em><strong>注意：本篇的可写流为流动模式，流动模式中有暂停状态和流动状态，而不是暂停模式，暂停模式是另一种可读流 <code>readable</code>。</strong></em></p></blockquote><h3 id="流动状态"><a href="#流动状态" class="headerlink" title="流动状态"></a>流动状态</h3><p>流动状态的意思是，一旦开始读取文件，会按照 <code>highWaterMark</code> 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 <code>data</code> 事件触发。</p><p>假如现在 <code>1.txt</code> 文件中的内容为 <code>0~9</code> 十个数字，我们现在创建可读流并用流动状态读取。</p><pre><code class="lang-js">// 流动状态
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});

// 读取文件
rs.on(&#39;data&#39;, data =&gt; {
  console.log(data);
});

// 监听读取结束
rs.on(&#39;end&#39;, () =&gt; {
  console.log(&#39;读完了&#39;);
});

// &lt;Buffer 30 31&gt;
// &lt;Buffer 32 33&gt;
// 读完了
</code></pre><blockquote class="pullquote default"><p><strong>在上面代码中，返回的 <code>rs</code> 对象监听了两个事件：</strong></p><ul><li><strong><code>data</code>：每次读取 <code>highWaterMark</code> 个字节，触发一次 <code>data</code> 事件，直到读取完成，回调的参数为每次读取的 <code>Buffer</code>；</strong></li><li><strong><code>end</code>：当读取完成时触发并执行回调函数。</strong></li></ul></blockquote><p>我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 <code>data</code> 事件触发时进行拼接，以前我们可能使用下面这种方式。</p><pre><code class="lang-js">/* 错误拼接数据的方式 */
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});

let str = &#39;&#39;;

rs.on(&#39;data&#39;, data =&gt; {
  str += data;
});

rs.on(&#39;end&#39;, () =&gt; {
  console.log(str);
});

// 0123
</code></pre><blockquote class="pullquote danger"><p><strong>在上面代码中如果读取的文件内容是中文，每次读取的 <code>highWaterMark</code> 为两个字节，不能组成一个完整的汉字，在每次读取时进行 <code>+=</code> 操作会默认调用 <code>toString</code> 方法，这样会导致最后读取的结果是乱码。</strong></p></blockquote><p>在以后通过流操作文件时，大部分情况下都是在操作 <code>Buffer</code>，所以应该用下面这种方式来获取最后读取到的结果。</p><pre><code class="lang-js">/* 正确拼接数据的方式 */
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});

// 存储每次读取回来的 Buffer
const bufArr = [];

rs.on(&#39;data&#39;, data =&gt; {
  bufArr.push(data);
});

rs.on(&#39;end&#39;, () =&gt; {
  console.log(Buffer.concat(bufArr).toString());
});

// 0123
</code></pre><h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p>在流动状态中，一旦开始读取文件，会不断的触发 <code>data</code> 事件，直到读完，暂停状态是我们每读取一次就直接暂停，不再继续读取，即不再触发 <code>data</code> 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。</p><p>类似于开关水龙头的动作，也就是暂停和恢复读取的动作，在可读流返回的 <code>rs</code> 对象上有两个对应的方法，<code>pause</code> 和 <code>resume</code>。</p><p>在下面的场景中我们把创建可读流的结尾位置更改成 <code>9</code>，在每次读两个字节并暂停一秒后恢复读取，直到读完 <code>0~9</code> 十个数字。</p><pre><code class="lang-js">/* 暂停状态 */
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 9,
  highWaterMark: 2
});

const bufArr = [];

rs.on(&#39;data&#39;, data =&gt; {
  bufArr.push(data);
  rs.pause(); // 暂停读取
  console.log(&#39;暂停&#39;, new Date());

  setTimeout(() =&gt; {
    rs.resume(); // 恢复读取
  }, 1000)
});

rs.on(&#39;end&#39;, () =&gt; {
  console.log(Buffer.concat(bufArr).toString());
});

// 暂停 2018-07-03T23:52:52.436Z
// 暂停 2018-07-03T23:52:53.439Z
// 暂停 2018-07-03T23:52:54.440Z
// 暂停 2018-07-03T23:52:55.442Z
// 暂停 2018-07-03T23:52:56.443Z
// 0123456789
</code></pre><h3 id="错误监听"><a href="#错误监听" class="headerlink" title="错误监听"></a>错误监听</h3><p>通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 <code>rs</code> 对象可以通过 <code>error</code> 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 <code>err</code>，即错误对象。</p><pre><code class="lang-js">/* 错误监听 */
const fs = require(&#39;fs&#39;);

// 读取一个不存在的文件
const rs = fs.createReadStream(&#39;xxx.js&#39;, {
  highWarterMark: 2
});

const bufArr = [];

rs.on(&#39;data&#39;, data =&gt; {
  bufArr.push(data);
});

rs.on(&#39;err&#39;, err =&gt; {
  console.log(err);
});

rs.on(&#39;end&#39;, () =&gt; {
  console.log(Buffer.concat(bufArr).toString());
});

// { Error: ENOENT: no such file or directory, open &#39;......xxx.js&#39; ......}
</code></pre><h3 id="打开和关闭文件的监听"><a href="#打开和关闭文件的监听" class="headerlink" title="打开和关闭文件的监听"></a>打开和关闭文件的监听</h3><p>流的适用性非常广，不只是文件读写，也可以用在 <code>http</code> 中数据的请求和响应上，但是在针对文件读取返回的 <code>rs</code> 上有两个专有的事件用来监听文件的打开与关闭。</p><p><code>open</code> 事件用来监听文件的打开，回调函数在打开文件后执行，<code>close</code> 事件用来监听文件的关闭，如果创建的可读流的 <code>autoClose</code> 为 <code>true</code>，在自动关闭文件时触发，回调函数在关闭文件后执行。</p><pre><code class="lang-js">/* 打开和关闭可读流的监听 */
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});

rs.on(&#39;open&#39;, () =&gt; {
  console.log(&#39;open&#39;);
});

rs.on(&#39;close&#39;, () =&gt; {
  console.log(&#39;close&#39;);
});

// open
</code></pre><p>在上面代码我们看出只要创建了可读流就会打开文件触发 <code>open</code> 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 <code>close</code> 事件。</p><pre><code class="lang-js">/* 暂停状态 */
const fs = require(&#39;fs&#39;);

const rs = fs.createReadStream(&#39;1.txt&#39;, {
  start: 0,
  end: 3,
  highWaterMark: 2
});

rs.on(&#39;open&#39;, () =&gt; {
  console.log(&#39;open&#39;);
});

rs.on(&#39;data&#39;, data =&gt; {
  console.log(data);
});

rs.on(&#39;end&#39;, () =&gt; {
  console.log(&#39;end&#39;);
});

rs.on(&#39;close&#39;, () =&gt; {
  console.log(&#39;close&#39;);
});

// open
// &lt;Buffer 30 31&gt;
// &lt;Buffer 32 33&gt;
// end
// close
</code></pre><p>从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 <code>close</code> 事件，<code>end</code> 事件的触发要早于 <code>close</code>。</p><h2 id="可写流"><a href="#可写流" class="headerlink" title="可写流"></a>可写流</h2><h3 id="createWriteStream-创建可写流"><a href="#createWriteStream-创建可写流" class="headerlink" title="createWriteStream 创建可写流"></a>createWriteStream 创建可写流</h3><blockquote class="pullquote info"><p><strong><code>createWriteStream</code> 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 <code>options</code> 选项，其中有 <code>7</code> 个参数：</strong></p><ul><li><strong><code>flags</code>：标识位，默认为 <code>w</code>；</strong></li><li><strong><code>encoding</code>：字符编码，默认为 <code>utf8</code>；</strong></li><li><strong><code>fd</code>：文件描述符，默认为 <code>null</code>；</strong></li><li><strong><code>mode</code>：权限位，默认为 <code>0o666</code>；</strong></li><li><strong><code>autoClose</code>：是否自动关闭文件，默认为 <code>true</code>；</strong></li><li><strong><code>start</code>：写入文件的起始位置；</strong></li><li><strong><code>highWaterMark</code>：一个对比写入字节数的标识，默认 <code>16 * 1024</code>。</strong></li></ul></blockquote><p><code>createWriteStream</code> 返回值为 <code>fs.WriteStream</code> 对象，第一次写入时会真的写入文件中，继续写入，会写入到缓存中。</p><pre><code class="lang-js">/* 创建可写流 */
const fs = require(&#39;fs&#39;);

// 创建可写流，写入 2.txt 文件
const ws = fs.createWriteStream(&#39;2.txt&#39;, {
  start: 0,
  highWaterMark: 3
});
</code></pre><h3 id="可写流的-write-方法"><a href="#可写流的-write-方法" class="headerlink" title="可写流的 write 方法"></a>可写流的 write 方法</h3><p>在可写流中将内容写入文件需要使用 <code>ws</code> 的 <code>write</code> 方法，参数为写入的内容，返回值是一个布尔值，代表 <code>highWaterMark</code> 的值是否足够当前的写入，如果足够，返回 <code>true</code>，否则返回 <code>false</code>，换种说法就是写入内容的长度是否超出了 <code>highWaterMark</code>，超出返回 <code>false</code>。</p><pre><code class="lang-js">/* write 方法写入 */
const fs = require(&#39;fs&#39;);

const ws = fs.createWriteSteam(&#39;2.txt&#39;, {
  start: 0,
  highWaterMark: 3
});

const flag1 = ws.write(&#39;1&#39;);
console.log(flag1);

const flag2 = ws.write(&#39;2&#39;);
console.log(flag2);

const flag3 = ws.write(&#39;3&#39;);
console.log(flag3);

// true
// true
// false
</code></pre><blockquote class="pullquote warning"><p><em><strong>写入不存在的文件时会自动创建文件，如果 <code>start</code> 的值不是 <code>0</code>，在写入不存在的文件时默认找不到写入的位置。</strong></em></p></blockquote><h3 id="可写流的-drain-事件"><a href="#可写流的-drain-事件" class="headerlink" title="可写流的 drain 事件"></a>可写流的 drain 事件</h3><p><code>drain</code> 意为 “吸干”，当前写入的内容已经大于等于了 <code>highWaterMark</code>，会触发 <code>drain</code> 事件，当内容全部从缓存写入文件后，会执行回调函数。</p><pre><code class="lang-js">/* drain 事件 */
const fs = require(&#39;fs&#39;);

const ws = fs.createWriteStream(&#39;2.txt&#39;, {
  start: 0,
  highWaterMark: 3
});

const flag1 = ws.write(&#39;1&#39;);
console.log(flag1);

const flag2 = ws.write(&#39;2&#39;);
console.log(flag2);

const flag3 = ws.write(&#39;3&#39;);
console.log(flag3);


ws.on(&#39;drain&#39;, () =&gt; {
  console.log(&#39;吸干&#39;);
});

// true
// true
// false
// 吸干
</code></pre><h3 id="可写流的-end-方法"><a href="#可写流的-end-方法" class="headerlink" title="可写流的 end 方法"></a>可写流的 end 方法</h3><p><code>end</code> 方法传入的参数为最后写入的内容，<code>end</code> 会将缓存未写入的内容清空写入文件，并关闭文件。</p><pre><code class="lang-js">/* end 方法 */
const fs = require(&#39;fs&#39;);

const ws = fs.createWriteStream(&#39;2.txt&#39;, {
  start: 0,
  highWaterMark: 3
});

const flag1 = ws.write(&#39;1&#39;);
console.log(flag1);

const flag2 = ws.write(&#39;2&#39;);
console.log(flag2);

const flag3 = ws.write(&#39;3&#39;);
console.log(flag3);

ws.on(&#39;drain&#39;, () =&gt; {
  console.log(&#39;吸干&#39;);
});

ws.end(&#39;写完了&#39;);

// true
// true
// false
</code></pre><p>在调用 <code>end</code> 方法后，即使再次写入的值超出了 <code>highWaterMark</code> 也不会再触发 <code>drain</code> 事件了，此时打开 <code>2.txt</code> 后发现文件中的内容为 ‘123写完了’。</p><pre><code class="lang-js">/* 常见报错 */
const fs = require(&#39;fs&#39;);

const ws = fs.createWriteStream(&#39;2.txt&#39;, {
  start: 0,
  highWaterMark: 3
});

ws.write(&#39;1&#39;);
ws.end(&#39;写完了&#39;);
ws.write(&#39;2&#39;);

// Error [ERR_STREAM_WRITE_AFTER_END]: write after end...
</code></pre><blockquote class="pullquote warning"><p><em><strong>在调用 <code>end</code> 方法后，不可以再调用 <code>write</code> 方法写入，否则会报一个很常见的错误 <code>write after end</code>，文件原有内容会被清空，而且不会被写入新内容。</strong></em></p></blockquote><h2 id="可写流与可读流混合使用"><a href="#可写流与可读流混合使用" class="headerlink" title="可写流与可读流混合使用"></a>可写流与可读流混合使用</h2><p>可写流和可读流一般配合来使用，读来的内容如果超出了可写流的 <code>highWaterMark</code>，则调用可读流的 <code>pause</code> 暂停读取，等待内存中的内容写入文件，未写入的内容小于 <code>highWaterMark</code> 时，调用可写流的 <code>resume</code> 恢复读取，创建可写流返回值 <code>rs</code> 上的 <code>pipe</code> 方法是专门用来连接可读流和可写流的，可以将一个文件读来的内容通过流写到另一个文件中。</p><pre><code class="lang-js">/* pipe 方法使用 */
const fs = require(&#39;fs&#39;);

// 创建可读流和可写流
const rs = fs.createReadStream(&#39;1.txt&#39;, {
  highWaterMark: 3
});
const ws = fs.createWriteStream(&#39;2.txt&#39;, {
  highWaterMark: 2
});

// 将 1.txt 的内容通过流写入 2.txt 中
rs.pipe(ws);
</code></pre><p>通过上面的这种类似于管道的方式，将一个流从一个文件输送到了另一个文件中，而且会根据读流和写流的 <code>highWaterMark</code> 自由的控制写入的 “节奏”，不用担心内存的消耗。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>这篇是关于读流和写流的基本用法，在平时的开发当中，大多数 <code>API</code> 都用的不多，<code>pipe</code> 用的较多，无论是在文件的读写还是请求的响应，其他的 <code>API</code> 虽然用的少，但是确实很多底层的实现，作为一个合格的程序员一定要有所了解。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 树结构遍历 —— 深度优先和广度优先</title>
    <url>/20180702122923/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180702122923/traversal-tree.png" title="树结构遍历"><p><br></p><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><blockquote class="pullquote info"><p><strong>树（<code>Tree</code>）是 <code>n</code> 个结点的有限集，<code>n</code> 为 <code>0</code> 时，称为空树，在任意一棵非空树中有且仅有一个特定的被称为根（<code>Root</code>）的结点，当 <code>n</code> 大于 <code>1</code> 时，其余结点可分为 <code>m</code> 个互不相交的有限集 <code>T1</code>、<code>T2</code>、<code>......</code>、<code>Tm</code>，其中每一个集合本身又是一棵树，并且称为 <code>SubTree</code>，即根的子树。</strong></p></blockquote><p>需要强调的是，<code>n&gt;0</code> 时根结点是唯一的，不可能存在多个根结点，<code>m&gt;0</code> 时，子树的个数没有限制，但它们一定是互不相交的。</p><p>从根开始定义起，根为第一层，根的第一级子节点为第二层，若某结点在第 <code>l</code> 层，则其子树就在第 <code>l+1</code> 层，其双亲在同一层的结点互为 “堂兄弟”，树中结点的最大层级数称为树的深度（<code>Depth</code>）或高度。</p><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180702122923/tree-detials.jpg" alt="树结构的组成"></div><div class="image-caption">树结构的组成</div></figure><p><br></p><p>在对树结构进行遍历时，按顺序可分为先序、中序和后续，按遍历的方式可分为深度优先和广度优先，我们这篇文章就通过使用先序深度优先和先序广度优先来实现递归删除目录结构，体会对树结构遍历的应用，文章中会大量用到 <code>Node.js</code> 核心模块 <code>fs</code>，可以通过 <a href="https://www.overtaking.top/20180630172601/" target="_blank">Node.js 文件操作 —— fs 基本使用</a> 来了解文中用到的 <code>fs</code> 模块的方法及用法。</p><h2 id="先序深度优先实现递归删除文件目录"><a href="#先序深度优先实现递归删除文件目录" class="headerlink" title="先序深度优先实现递归删除文件目录"></a>先序深度优先实现递归删除文件目录</h2><blockquote class="pullquote default"><p><strong>深度优先的意思就是在遍历当前文件目录的时候，如果子文件夹内还有内容，就继续遍历子文件夹，直到遍历到最深层不再有文件夹，则删除其中的文件，再删除这个文件夹，然后继续遍历它的 “兄弟”，直到内层文件目录都被删除，再删除上一级，最后根文件夹为空，删除根文件夹。</strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180702122923/depth-first-traversal.png" alt="先序深度优先"></div><div class="image-caption">先序深度优先</div></figure><p><br></p><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><p>我们要实现的函数参数为要删除的根文件夹的路径，执行函数后会删除这个根文件夹。</p><pre><code class="lang-js">/* 深度优先 —— 同步 */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 先序深度优先同步删除文件夹
function rmDirDepSync(p) {
  // 获取根文件夹的 Stats 对象
  const statObj = fs.statSync(p);

  // 检查该文件夹的是否是文件夹
  if (statObj.isDirectory()) {
    // 查看文件夹内部
    let dirs = fs.readdirSync(p);

    // 将内部的文件和文件夹拼接成正确的路径
    dirs = dirs.map(dir =&gt; path.join(p, dir));

    // 循环递归处理 dirs 内的每一个文件或文件夹
    for (let i = 0; i &lt; dirs.length; i++) {
      rmDirDepSync(dirs[i]);
    }

    // 等待都处理完后删除该文件夹
    fs.rmdirSync(p);
  } else {
    // 若是文件则直接删除
    fs.unlinkSync(p);
  }
}

// 调用
rmDirDepSync(&#39;a&#39;);
</code></pre><p>上面代码在调用 <code>rmDirDepSync</code> 时传入 <code>a</code>，先判断 <code>a</code> 是否是文件夹，不是则直接删除文件，是则查看文件目录，使用 <code>map</code> 将根文件路径拼接到每一个成员的名称前，并返回合法的路径集合，循环这个集合并对每一项进行递归，重复执行操作，最终实现删除根文件夹内所有的文件和文件夹，并删除根文件夹。</p><h3 id="异步回调的实现"><a href="#异步回调的实现" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><p>同步的实现会阻塞代码的执行，每次执行一个文件操作，必须在执行完毕之后才能执行下一行代码，相对于同步，异步的方式性能会更好一些，我们下面使用异步回调的方式来实现递归删除文件目录的函数。</p><p>函数有两个参数，第一个参数同样为根文件夹的路径，第二个参数为一个回调函数，在文件目录被全部删除后执行。</p><pre><code class="lang-js">/* 深度优先 —— 异步回调 */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 先序深度优先异步（回调函数）删除文件夹
function rmDirDepCb(p, callback) {
  // 获取传入路径的 Stats 对象
  fs.stat(p, (err, statObj) =&gt; {
    // 判断路径下是否为文件夹
    if (statObj.isDirectory()) {
      // 是文件夹则查看内部成员
      fs.readdir(p, (err, dirs) =&gt; {
        // 将文件夹成员拼接成合法路径的集合
        dirs = dirs.map(dir =&gt; path.join(p, dir));

        // next 方法用来检查集合内每一个路径
        function next(index) {
          // 如果所有成员检查并删除完成则删除上一级目录
          if (index === dirs.length) return fs.rmdir(p, callback);

          // 对路径下每一个文件或文件夹执行递归，回调为递归 next 检查路径集合中的下一项
          rmDirDepCb(dirs[index], () =&gt; next(index + 1));
        }
        next(0);
      });
    } else {
      // 是文件则直接删除
      fs.unlink(p, callback);
    }
  });
}

// 调用
rmDirDepCb(&#39;a&#39;, () =&gt; {
  console.log(&#39;删除完成&#39;);
});

// 删除完成
</code></pre><p>上面方法也遵循深度优先，与同步相比较主要思路是相同的，异步回调的实现更为抽象，并不是通过循环去处理的文件夹下的每个成员的路径，而是通过调用 <code>next</code> 函数和在成功删除文件时递归执行 <code>next</code> 函数并维护 <code>index</code> 变量实现的。</p><h3 id="异步-Promise-的实现"><a href="#异步-Promise-的实现" class="headerlink" title="异步 Promise 的实现"></a>异步 Promise 的实现</h3><p>在异步回调函数的实现方式中，回调嵌套层级非常多，这在对代码的可读性和维护性上都造成困扰，在 <code>ES6</code> 规范中，<code>Promise</code> 的出现就是用来解决 “回调地狱” 的问题，所以我们也使用 <code>Promise</code> 来实现。</p><p>函数的参数为要删除的根文件夹的路径，这次之所以不需要传 <code>callback</code> 参数是因为 <code>callback</code> 中的逻辑可以在调用函数之后链式调用 <code>then</code> 方法来执行。</p><pre><code class="lang-js">/* 深度优先 —— 异步 Promise */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 先序深度优先异步（Promise）删除文件夹
function rmDirDepPromise(p) {
  return new Promise((resolve, reject) =&gt; {
    // 获取传入路径的 Stats 对象
    fs.stat(p, (err, statObj) =&gt; {
      // 判断路径下是否为文件夹
      if (statObj.isDirectory()) {
        // 是文件夹则查看内部成员
        fs.readdir(p, (err, dirs) =&gt; {
          // 将文件夹成员拼接成合法路径的集合
          dirs = dirs.map(dir =&gt; path.join(p, dir));

          // 将所有的路径都转换成 Promise
          dirs = dirs.map(dir =&gt; rmDirDepPromise(dir));

          // 数组中路径下所有的 Promise 都执行了 resolve 时，删除上级目录
          Promise.all(dirs).then(() =&gt; fs.rmdir(p, resolve));
        });
      } else {
        // 是文件则直接删除
        fs.unlink(p, resolve);
      }
    });
  });
}

// 调用
rmDirDepPromise(&#39;a&#39;).then(() =&gt; {
  console.log(&#39;删除完成&#39;);
});

// 删除完成
</code></pre><p>与异步回调函数的方式不同的是在调用 <code>rmDirDepPromise</code> 时直接返回了一个 <code>Promise</code> 实例，而在删除文件成功或在删除文件夹成功时直接调用了 <code>resolve</code>，在一个子文件夹下直接将这些成员通过递归 <code>rmDirDepPromise</code> 都转换为 <code>Promise</code> 实例，则可以用 <code>Promise.all</code> 来监听这些成员删除的状态，如果都成功再调用 <code>Promise.all</code> 的 <code>then</code> 直接删除上一级目录。</p><h3 id="异步-async-await-的实现"><a href="#异步-async-await-的实现" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p><code>Promise</code> 版本相对于异步回调版本从代码的可读性上有所提升，但是实现逻辑还是比较抽象，没有同步代码的可读性好，如果想要 “鱼” 和 “熊掌” 兼得，既要性能又要可读性，可以使用 <code>ES7</code> 标准中的 <code>async/await</code> 来实现，由于 <code>async</code> 函数的返回值为一个 <code>Promise</code> 实例，所以参数只需要传被删除的根文件夹的路径即可。</p><pre><code class="lang-js">/* 深度优先 —— 异步 async/await */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const { promisify } = require(&#39;util&#39;);

// 将用到 fs 模块的异步方法转换成 Promise
const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);
const rmdir = promisify(fs.rmdir);
const unlink = promisify(fs.unlink);

// 先序深度优先异步（async/await）删除文件夹
async function rmDirDepAsync(p) {
  // 获取传入路径的 Stats 对象
  const statObj = await stat(p);

  // 判断路径下是否为文件夹
  if (statObj.isDirectory()) {
    // 是文件夹则查看内部成员
    let dirs = await readdir(p);

    // 将文件夹成员拼接成合法路径的集合
    dirs = dirs.map(dir =&gt; path.join(p, dir));

    // 循环集合递归 rmDirDepAsync 处理所有的成员
    dirs = dirs.map(dir =&gt; rmDirDepAsync(dir));

    // 当所有的成员都成功
    await Promise.all(dirs);

    // 删除该文件夹
    await rmdir(p);
  } else {
    // 是文件则直接删除
    await unlink(p);
  }
}

// 调用
rmDirDepAsync(&#39;a&#39;).then(() =&gt; {
  console.log(&#39;删除完成&#39;);
});

// 删除完成
</code></pre><p>在递归 <code>rmDirDepAsync</code> 时，所有子文件夹内部的成员必须都删除成功，才删除这个子文件夹，在使用 <code>unlink</code> 删除文件时，必须等待文件删除结束才能让 <code>Promise</code> 执行完成，所以也需要 <code>await</code>，所有递归之前的异步 <code>Promise</code> 都需要在递归内部的异步 <code>Promise</code> 执行完成后才能执行完成，所以涉及到异步的操作都使用了 <code>await</code> 进行等待。</p><h2 id="先序广度优先实现递归删除文件目录"><a href="#先序广度优先实现递归删除文件目录" class="headerlink" title="先序广度优先实现递归删除文件目录"></a>先序广度优先实现递归删除文件目录</h2><blockquote class="pullquote success"><p><strong>广度优先的意思是遍历文件夹目录的时候，先遍历根文件夹，将内部的成员路径一个一个的存入数组中，再继续遍历下一层，再将下一层的路径都存入数组中，直到遍历到最后一层，此时数组中的路径顺序为第一层的路径，第二层的路径，直到最后一层的路径，由于要删除的文件夹必须为空，所以删除时，倒序遍历这个数组取出路径进行文件目录的删除。</strong></p></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180702122923/breadth-first-traversal.png" alt="先序广度优先"></div><div class="image-caption">先序广度优先</div></figure><p><br></p><p>在广度优先的实现方式中同样按照同步、异步回调、和 <code>async/await</code> 这几种方式分别来实现，因为在拼接存储路径数组的时候没有异步操作，所以单纯使用 <code>Promise</code> 没有太大的意义。</p><h3 id="同步的实现-1"><a href="#同步的实现-1" class="headerlink" title="同步的实现"></a>同步的实现</h3><p>参数为根文件夹的路径，内部的 <code>fs</code> 方法同样都使用同步方法。</p><pre><code class="lang-js">/* 广度优先 —— 同步 */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 先序广度优先同步删除文件夹
function rmDirBreSync(p) {
  let pathArr = [p]; // 创建存储路径的数组，默认存入根路径
  let index = 0; // 用于存储取出数组成员的索引
  let current; // 用于存储取出的成员，即路径

  // 如果数组中能找到当前指定索引的项，则执行循环体，并将该项存入 current
  while ((current = arr[index++])) {
    // 获取当前从数组中取出的路径的 Stats 对象
    const statObj = fs.statSync(current);

    // 如果是文件夹，则读取内容
    if (statObj.isDirectory()) {
      let dirs = fs.readdirSync(current);

      // 将获取到的成员路径处理为合法路径
      dirs = dirs.map(dir =&gt; path.join(current, dir));

      // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中
      pathArr = [...pathArr, ...dirs];
    }
  }

  // 逆序循环 pathArr
  for (let i = pathArr.length - 1; i &gt;= 0; i--) {
    const pathItem = pathArr[i]; // 当前循环项
    const statObj = fs.statSync(pathItem); // 获取 Stats 对象

    // 如果是文件夹则删除文件夹，是文件则删除文件
    if (statObj.isDirectory()) {
      fs.rmdirSync(pathItem);
    } else {
      fs.unlinkSync(pathItem);
    }
  }
}

// 调用
rmDirBreSync(&#39;a&#39;);
</code></pre><p>通过 <code>while</code> 循环广度遍历，将所有的路径按层级顺序存入 <code>pathArr</code> 数组中，在通过 <code>for</code> 反向遍历数组，对遍历到的路径进行判断并调用对应的删除方法，<code>pathArr</code> 后面的项存储的都是最后一层的路径，从后向前路径的层级逐渐减小，所以反向遍历不会导致删除非空文件夹的操作。</p><h3 id="异步回调的实现-1"><a href="#异步回调的实现-1" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><p>函数有两个参数，第一个参数为根文件夹的路径，第二个为 <code>callback</code>，在删除结束后执行。</p><pre><code class="lang-js">/* 广度优先 —— 异步回调 */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 先序广度优先异步（回调函数）删除文件夹
function rmDirBreCb(p, callback) {
  let pathArr = [p]; // 创建存储路径的数组，默认存入根路径

  function next(index) {
    // 如果已经都处理完，则调用删除的函数
    if (index === pathArr.length) return remove();

    // 取出数组中的文件路径
    const current = arr[index];

    // 获取取出路径的 Stats 对象
    fs.stat(currrent, (err, statObj) =&gt; {
      // 判断是否是文件夹
      if (statObj.isDirectory()) {
        // 是文件夹读取内部成员
        fs.readdir(current, (err, dirs) =&gt; {
          // 将数组中成员名称修改为合法路径
          dirs = dirs.map(dir =&gt; path.join(current, dir));

          // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中
          pathArr = [...pathArr, ...dirs];

          // 递归取出数组的下一项进行检测
          next(index + 1);
        });
      } else {
        // 如果是文件则直接递归获取数组的下一项进行检测
        next(index + 1);
      }
    });
  }
  next(0);

  // 删除的函数
  function remove() {
    function next(index) {
      // 如果全部删除完成，执行回调函数
      if (index &lt; 0) return callback();

      // 获取数组的最后一项
      const current = pathArr[index];

      // 获取该路径的 Stats 对象
      fs.stat(current, (err, statObj) =&gt; {
        // 不管是文件还是文件夹都直接删除
        if (statObj.isDirectory()) {
          fs.rmdir(current, () =&gt; next(index - 1));
        } else {
          fs.unlink(current, () =&gt; next(index - 1));
        }
      });
    }
    next(arr.length - 1);
  }
}

// 调用
rmDirBreCb(&#39;a&#39;, () =&gt; {
  console.log(&#39;删除完成&#39;);
});

// 删除完成
</code></pre><p>在调用 <code>rmDirBreCb</code> 时主要执行两个步骤，第一个步骤是构造存储路径的数组，第二个步骤是逆序删除数组中对应的文件或文件夹，为了保证性能，两个过程都是通过递归 <code>next</code> 函数并维护存储索引的变量来实现的，而非循环。</p><p>在构造数组的过程中如果构造数组完成后，调用的删除函数 <code>remove</code>，在 <code>remove</code> 中在删除完成后，调用的 <code>callback</code>，实现思路是相同的，都是在递归时设置判断条件，如果构造数组或删除结束以后不继续递归，而是直接执行对应的函数并跳出。</p><h3 id="异步-async-await-的实现-1"><a href="#异步-async-await-的实现-1" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p>参数为删除根文件夹的路径，因为 <code>async</code> 最后返回的是 Promise 实例，所以不需要 <code>callback</code>，删除后的逻辑可以通过调用返回 Promise 实例的 <code>then</code> 来实现。</p><pre><code class="lang-js">/* 广度优先 —— 异步 async/await */
// 引入依赖模块
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const { promisify } = require(&#39;util&#39;);

// 将用到 fs 模块的异步方法转换成 Promise
const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);
const rmdir = promisify(fs.rmdir);
const unlink = promisify(fs.unlink);

// 先序广度优先异步（async/await）删除文件夹
async function rmDirBreAsync(p) {
  let pathArr = [p]; // 创建存储路径的数组，默认存入根路径
  let index = 0; // 去数组中取出路径的索引
  let delCurrent; // 删除的路径

  // 如果存在该项则继续循环
  while (index !== pathArr.length) {
    // 取出当前的路径
    const current = pathArr[index];

    // 获取 Stats 对象
    const statObj = await stat(current);

    // 判断是否是文件夹
    if (statObj.isDirectory()) {
      // 查看文件夹成员
      let dirs = await readdir(current);

      // 将路径集合更改为合法路径集合
      dirs = dirs.map(dir =&gt; path.join(current, dir));

      // 合并存储路径的数组
      pathArr = [...pathArr, ...dirs];
    }
    index++;
  }

  // 循环取出路径
  while ((delCurrent = pathArr.pop())) {
    // 获取 Stats 对象
    const statObj = await stat(delCurrent);

    // 不管是文件还是文件夹都直接删除
    if (statObj.isDirectory()) {
      await rmdir(delCurrent);
    } else {
      await unlink(delCurrent);
    }
  }
}

// 调用
rmDirBreAsync(&#39;a&#39;).then(() =&gt; {
  console.log(&#39;删除完成&#39;);
});

// 删除完成
</code></pre><p>上面的写法都是使用同步的写法，但对文件的操作都是异步的，并使用 <code>await</code> 进行等待，在创建路径集合的数组和倒序删除的过程都是通过 <code>while</code> 循环实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>深度优先和广度优先的两种遍历方式应该是考虑具体场景选择最适合的方式使用，上面这么多实现递归删除文件目录的方法中，重点在于体会深度遍历和广度遍历的不同，其实在类似于递归删除文件目录的这种功能使用深度优先更适合一些。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>Node.js</tag>
        <tag>ES6</tag>
        <tag>ES7</tag>
        <tag>async/await</tag>
        <tag>fs</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 文件操作 —— fs 基本使用</title>
    <url>/20180630172601/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180630172601/fs.jpg" title="fs 文件操作"><p><br></p><h2 id="fs-概述"><a href="#fs-概述" class="headerlink" title="fs 概述"></a>fs 概述</h2><blockquote class="pullquote info"><p><strong>在 <code>Node.js</code> 中，所有与文件操作都是通过 <code>fs</code> 核心模块来实现的，包括文件目录的创建、删除、查询以及文件的读取和写入，在 <code>fs</code> 模块中，所有的方法都分为同步和异步两种实现，具有 <code>sync</code> 后缀的方法为同步方法，不具有 <code>sync</code> 后缀的方法为异步方法，在了解文件操作的方法之前有一些关于系统和文件的前置知识需要先明确，如文件的权限位 <code>mode</code>、标识位 <code>flag</code>、文件描述符 <code>fd</code> 等。</strong></p></blockquote><a id="more"></a><h2 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h2><p>因为 <code>fs</code> 模块需要对文件进行操作，会涉及到操作权限的问题，所以需要先清楚文件权限是什么，都有哪些权限。</p><p><strong>文件权限表：</strong></p><table><thead><tr><th>权限分配</th><th colspan="3">文件所有者</th><th colspan="3">文件所属组</th><th colspan="3">其他用户</th></tr></thead><tbody><tr><td>权限项</td><td>读</td><td>写</td><td>执行</td><td>读</td><td>写</td><td>执行</td><td>读</td><td>写</td><td>执行</td></tr><tr><td>字符表示</td><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td><td>r</td><td>w</td><td>x</td></tr><tr><td>数字表示</td><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><p>在上面表格中，我们可以看出系统中针对三种类型进行权限分配，即文件所有者（自己）、文件所属组（家人）和其他用户（陌生人），文件操作权限又分为三种，读、写和执行，数字表示为八进制数，具备权限的八进制数分别为 <code>4</code> 、<code>2</code>、<code>1</code>，不具备权限为 <code>0</code>。</p><p>为了更容易理解，我们可以随便在一个目录中打开命令行，使用 <code>Linux</code> 命令 <code>ls -al</code> 来查目录中文件和文件夹的权限位，如果对 <code>Linux</code> 基本命令不熟悉，可以看 <a href="https://www.overtaking.top/20171214024101/" target="_blank">Git 命令总结，从零到熟悉</a> 的前一小节。</p><pre><code class="lang-bash">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md
</code></pre><p>在上面的目录信息当中，很容易看出用户名、创建时间和文件名等信息（十位的字符），但最重要的是开头第一项。</p><p>第一位代表是文件还是文件夹，<code>d</code> 开头代表文件夹，<code>-</code> 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（<code>r</code>）、写（<code>w</code>）和执行（<code>x</code>），<code>-</code> 代表没有当前位对应的权限。</p><blockquote class="pullquote warning"><p><strong>权限参数 <code>mode</code> 主要针对 <code>Linux</code> 和 <code>Unix</code> 操作系统，<code>Window</code> 的权限默认是可读、可写、不可执行，所以权限位数字表示为 <code>0o666</code>，转换十进制表示为 <code>438</code>。</strong></p></blockquote><table><thead><tr><th>r</th><th>w</th><th>—</th><th>r</th><th>—</th><th>—</th><th>r</th><th>—</th><th>—</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>0</td><td>4</td><td>0</td><td>0</td><td>4</td><td>0</td><td>0</td></tr><tr><td colspan="3">6</td><td colspan="3">4</td><td colspan="3">4</td></tr></tbody></table><p><br></p><h2 id="标识位-flag"><a href="#标识位-flag" class="headerlink" title="标识位 flag"></a>标识位 flag</h2><p><code>Node.js</code> 中，标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，下面用一张表来表示文件操作的标识位和其对应的含义。</p><table><thead><tr><th style="width:20%">符号</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读取文件，如果文件不存在则抛出异常。</td></tr><tr><td>r+</td><td>读取并写入文件，如果文件不存在则抛出异常。</td></tr><tr><td>rs</td><td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td></tr><tr><td>w</td><td>写入文件，文件不存在会被创建，存在则清空后写入。</td></tr><tr><td>wx</td><td>写入文件，排它方式打开。</td></tr><tr><td>w+</td><td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td></tr><tr><td>wx+</td><td>和 w+ 类似，排他方式打开。</td></tr><tr><td>a</td><td>追加写入，文件不存在则创建文件。</td></tr><tr><td>ax</td><td>与 a 类似，排他方式打开。</td></tr><tr><td>a+</td><td>读取并追加写入，不存在则创建。</td></tr><tr><td>ax+</td><td>与 a+ 类似，排他方式打开。</td></tr></tbody></table><blockquote class="pullquote danger"><p><strong>上面表格就是这些标识位的具体字符和含义，但是 <code>flag</code> 是不经常使用的，不容易被记住，所以总结了一个加速记忆的方：</strong></p><ul><li><strong><code>r</code>：读取</strong></li><li><strong><code>w</code>：写入</strong></li><li><strong><code>s</code>：同步</strong></li><li><strong><code>+</code>：增加相反操作</strong></li><li><strong><code>x</code>：排他方式</strong></li></ul></blockquote><p><code>r+</code> 和 <code>w+</code> 的区别，当文件不存在时，<code>r+</code> 不会创建文件，而会抛出异常，但 <code>w+</code> 会创建文件；如果文件存在，<code>r+</code> 不会自动清空文件，但 <code>w+</code> 会自动把已有文件的内容清空。</p><h2 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h2><blockquote class="pullquote success"><p><strong>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，<code>Windows</code> 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>Node.js</code> 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</strong></p></blockquote><p>在 <code>Node.js</code> 中，每操作一个文件，文件描述符递增，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code> 三个比较特殊的描述符被占用了，分别为 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）。</p><h2 id="文件操作的基本方法"><a href="#文件操作的基本方法" class="headerlink" title="文件操作的基本方法"></a>文件操作的基本方法</h2><blockquote class="pullquote primary"><p><strong>文件操作中的基本方法都是对文件进行整体操作，即整个文件数据直接放在内存中操作，如读取、写入、拷贝和追加，由于计算机的内存容量有限，对文件操作需要考虑性能，所以这些方法只针对操作占用内存较小的文件。</strong></p></blockquote><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><h4 id="同步读取方法-readFileSync"><a href="#同步读取方法-readFileSync" class="headerlink" title="同步读取方法 readFileSync"></a>同步读取方法 readFileSync</h4><blockquote class="pullquote default"><p><strong><code>readFileSync</code> 有两个参数：</strong></p><ul><li><strong>第一个参数为读取文件的路径或文件描述符；</strong></li><li><strong>第二个参数为 <code>options</code> 对象，默认值为 <code>null</code>，对象属性有 <code>encoding</code>（编码，默认为 <code>null</code>）和 <code>flag</code>（标识位，默认为 <code>r</code>），该参数也可直接传入 <code>encoding</code>；</strong></li><li><strong>返回值为文件的内容，如果没有 <code>encoding</code>，返回的文件内容为 <code>Buffer</code>，如果有按照传入的编码解析。</strong></li></ul></blockquote><p>若现在有一个文件名为 <code>1.txt</code>，内容为 “Hello”，现在使用 <code>readFileSync</code> 读取。</p><pre><code class="lang-js">/* 同步读取 readFileSync */
const fs = require(&#39;fs&#39;);

const buf = fs.readFileSync(&#39;1.txt&#39;);
const data = fs.readFileSync(&#39;1.txt&#39;, &#39;utf8&#39;);

console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;
console.log(data); // Hello
</code></pre><h4 id="异步读取方法-readFile"><a href="#异步读取方法-readFile" class="headerlink" title="异步读取方法 readFile"></a>异步读取方法 readFile</h4><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行。</p><p>依然读取 <code>1.txt</code> 文件：</p><pre><code class="lang-js">/* 异步读取 readFile */
const fs = require(&#39;fs&#39;);

fs.readFile(&#39;1.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
  console.log(err); // null
  console.log(data); // Hello
});
</code></pre><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><h4 id="同步写入方法-writeFileSync"><a href="#同步写入方法-writeFileSync" class="headerlink" title="同步写入方法 writeFileSync"></a>同步写入方法 writeFileSync</h4><blockquote class="pullquote info"><p><strong><code>writeFileSync</code> 有三个参数：</strong></p><ul><li><strong>第一个参数为写入文件的路径或文件描述符；</strong></li><li><strong>第二个参数为写入的数据，类型为 <code>String</code> 或 <code>Buffer</code>；</strong></li><li><strong>第三个参数为 <code>options</code> 对象，默认值为 <code>null</code>，对象属性有 <code>encoding</code>（编码，默认为 <code>utf8</code>）、 <code>flag</code>（标识位，默认为 <code>w</code>）和 <code>mode</code>（权限位，默认为 <code>0o666</code>），该参数也可直接传入 <code>encoding</code>。</strong></li></ul></blockquote><p>若现在有一个文件名为 <code>2.txt</code>，内容为 “12345”，现在使用 <code>writeFileSync</code> 写入。</p><pre><code class="lang-js">/* 同步写入 writeFileSync */
const fs = require(&#39;fs&#39;);

fs.writeFileSync(&#39;2.txt&#39;, &#39;Hello world&#39;);
const data = fs.readFileSync(&#39;2.txt&#39;, &#39;utf8&#39;);

console.log(data); // Hello world
</code></pre><h4 id="异步写入方法-writeFile"><a href="#异步写入方法-writeFile" class="headerlink" title="异步写入方法 writeFile"></a>异步写入方法 writeFile</h4><p>异步写入方法 <code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行。</p><pre><code class="lang-js">/* 异步写入 writeFile */
const fs = require(&#39;fs&#39;);

fs.writeFile(&#39;2.txt&#39;, &#39;Hello world&#39;, err =&gt; {
  if (!err) {
    fs.readFile(&#39;2.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
      console.log(data); // Hello world
    });
  }
});
</code></pre><h3 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h3><h4 id="同步追加写入方法-appendFileSync"><a href="#同步追加写入方法-appendFileSync" class="headerlink" title="同步追加写入方法 appendFileSync"></a>同步追加写入方法 appendFileSync</h4><blockquote class="pullquote warning"><p><strong><code>appendFileSync</code> 有三个参数：</strong></p><ul><li><strong>第一个参数为写入文件的路径或文件描述符；</strong></li><li><strong>第二个参数为写入的数据，类型为 <code>String</code> 或 <code>Buffer</code>；</strong></li><li><strong>第三个参数为 <code>options</code> 对象，默认值为 <code>null</code>，对象属性有 <code>encoding</code>（编码，默认为 <code>utf8</code>）、 <code>flag</code>（标识位，默认为 <code>a</code>）和 <code>mode</code>（权限位，默认为 <code>0o666</code>），该参数也可直接传入 <code>encoding</code>。</strong></li></ul></blockquote><p>若现在有一个文件名为 <code>3.txt</code>，内容为 “Hello”，现在使用 <code>appendFileSync</code> 追加写入 “ world”。</p><pre><code class="lang-js">/* 同步追加 appendFileSync */
const fs = require(&#39;fs&#39;);

fs.appendFileSync(&#39;3.txt&#39;, &#39; world&#39;);
const data = fs.readFileSync(&#39;3.txt&#39;, &#39;utf8&#39;);

console.log(data); // Hello world
</code></pre><h4 id="异步追加写入方法-appendFile"><a href="#异步追加写入方法-appendFile" class="headerlink" title="异步追加写入方法 appendFile"></a>异步追加写入方法 appendFile</h4><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行。</p><pre><code class="lang-js">/* 异步追加 appendFile */
const fs = require(&#39;fs&#39;);

fs.appendFile(&#39;3.txt&#39;, &#39; world&#39;, err =&gt; {
  if (!err) {
    fs.readFile(&#39;3.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
      console.log(data); // Hello world
    });
  }
});
</code></pre><h3 id="文件拷贝写入"><a href="#文件拷贝写入" class="headerlink" title="文件拷贝写入"></a>文件拷贝写入</h3><h4 id="同步拷贝写入方法-copyFileSync"><a href="#同步拷贝写入方法-copyFileSync" class="headerlink" title="同步拷贝写入方法 copyFileSync"></a>同步拷贝写入方法 copyFileSync</h4><p>同步拷贝写入方法 <code>copyFileSync</code> 有两个参数，第一个参数为被拷贝的源文件路径，第二个参数为拷贝到的目标文件路径，如果目标文件不存在，则会创建并拷贝。</p><p>现在将上面 <code>3.txt</code> 的内容拷贝到 <code>4.txt</code> 中：</p><pre><code class="lang-js">/* 同步拷贝 copyFileSync */
const fs = require(&#39;fs&#39;);

fs.copyFileSync(&#39;3.txt&#39;, &#39;4.txt&#39;);
const data = fs.readFileSync(&#39;4.txt&#39;, &#39;utf8&#39;);

console.log(data); // Hello world
</code></pre><h4 id="异步拷贝写入方法-copyFile"><a href="#异步拷贝写入方法-copyFile" class="headerlink" title="异步拷贝写入方法 copyFile"></a>异步拷贝写入方法 copyFile</h4><p>异步拷贝写入方法 <code>copyFile</code> 和 <code>copyFileSync</code> 前两个参数相同，最后一个参数为回调函数，在拷贝完成后执行。</p><pre><code class="lang-js">/* 异步拷贝 copyFile */
const fs = require(&#39;fs&#39;);

fs.copyFile(&#39;3.txt&#39;, &#39;4.txt&#39;, () =&gt; {
  fs.readFile(&#39;4.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
    console.log(data); // Hello world
  });
});
</code></pre><h4 id="模拟同步、异步拷贝写入文件"><a href="#模拟同步、异步拷贝写入文件" class="headerlink" title="模拟同步、异步拷贝写入文件"></a>模拟同步、异步拷贝写入文件</h4><p>使用 <code>readFileSync</code> 和 <code>writeFileSync</code> 可以模拟同步拷贝写入文件，使用 <code>readFile</code> 和 <code>writeFile</code> 可以模拟异步写入拷贝文件，代码如下：</p><pre><code class="lang-js">/* 模拟同步拷贝 */
const fs = require(&#39;fs&#39;);

function copy(src, dest) {
  const data = fs.readFileSync(src);
  fs.writeFileSync(dest, data);
}

// 拷贝
copy(&#39;3.txt&#39;, &#39;4.txt&#39;);

const data = fs.readFileSync(&#39;4.txt&#39;, &#39;utf8&#39;);
console.log(data); // Hello world
</code></pre><pre><code class="lang-js">/* 模拟异步拷贝 */
const fs = require(&#39;fs&#39;);

function copy(src, dest, cb) {
  fs.readFile(src, (err, data) =&gt; {
    // 没错误就正常写入
    if (!err) fs.writeFile(dest, data, cb);
  });
}

// 拷贝
copy(&#39;3.txt&#39;, &#39;4.txt&#39;, () =&gt; {
  fs.readFile(&#39;4.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
    console.log(data); // Hello world
  });
});
</code></pre><h2 id="文件操作的高级方法"><a href="#文件操作的高级方法" class="headerlink" title="文件操作的高级方法"></a>文件操作的高级方法</h2><h3 id="打开文件-open"><a href="#打开文件-open" class="headerlink" title="打开文件 open"></a>打开文件 open</h3><blockquote class="pullquote default"><p><strong><code>open</code> 方法有四个参数：</strong></p><ul><li><strong><code>path</code>：文件的路径；</strong></li><li><strong><code>flag</code>：标识位；</strong></li><li><strong><code>mode</code>：权限位，默认 <code>0o666</code>；</strong></li><li><strong><code>callback</code>：回调函数，有两个参数 <code>err</code>（错误）和 <code>fd</code>（文件描述符），打开文件后执行。</strong></li></ul></blockquote><pre><code class="lang-js">/* 异步打开文件 */
const fs = require(&#39;fs&#39;);

fs.open(&#39;4.txt&#39;, &#39;r&#39;, (err, fd) =&gt; {
  console.log(fd);
  fs.open(&#39;5.txt&#39;, &#39;r&#39;, (err, fd) =&gt; {
    console.log(fd);
  });
});

// 3
// 4
</code></pre><h3 id="关闭文件-close"><a href="#关闭文件-close" class="headerlink" title="关闭文件 close"></a>关闭文件 close</h3><p><code>close</code> 方法有两个参数，第一个参数为关闭文件的文件描述符 <code>fd</code>，第二参数为回调函数，回调函数有一个参数 <code>err</code>（错误），关闭文件后执行。</p><pre><code class="lang-js">/* 异步关闭文件 */
const fs = require(&#39;fs&#39;);

fs.open(&#39;4.txt&#39;, &#39;r&#39;, (err, fd) =&gt; {
  fs.close(fd, err =&gt; {
    console.log(&#39;关闭成功&#39;);
  });
});

// 关闭成功
</code></pre><h3 id="读取文件-read"><a href="#读取文件-read" class="headerlink" title="读取文件 read"></a>读取文件 read</h3><blockquote class="pullquote danger"><p><strong><code>read</code> 方法与 <code>readFile</code> 不同，一般针对于文件太大，无法一次性读取全部内容到缓存中或文件大小未知的情况，都是多次读取到 <code>Buffer</code> 中，想了解 <code>Buffer</code> 可以看</strong> <a href="https://www.overtaking.top/20180629115313/" target="_blank">Node.js —— Buffer 解读</a>。</p></blockquote><blockquote class="pullquote success"><p><strong><code>read</code> 方法中有六个参数：</strong></p><ul><li><strong><code>fd</code>：文件描述符，需要先使用 <code>open</code> 打开文件获取；</strong></li><li><strong><code>buffer</code>：要将内容读取到的 <code>Buffer</code>；</strong></li><li><strong><code>offset</code>：整数，向 <code>Buffer</code> 写入的初始位置；</strong></li><li><strong><code>length</code>：整数，读取文件多少个字节长度；</strong></li><li><strong><code>position</code>：整数，读取文件初始位置；</strong></li><li><strong><code>callback</code>：回调函数，有三个参数 <code>err</code>（错误），<code>bytesRead</code>（实际读取的字节数），<code>buffer</code>（被写入的缓存区对象），读取执行完成后执行。</strong></li></ul></blockquote><p>下面读取一个 <code>6.txt</code> 文件，内容为 “你好”。</p><pre><code class="lang-js">/* 异步读取文件 */
const fs = require(&#39;fs&#39;);
const buf = Buffer.alloc(6);

// 打开文件
fs.open(&#39;6.txt&#39;, &#39;r&#39;, (err, fd) =&gt; {
  // 读取文件
  fs.read(fd, buf, 0, 3, 0, (err, bytesRead, buffer) =&gt; {
    console.log(bytesRead);
    console.log(buffer);

    // 继续读取
    fs.read(fd, buf, 3, 3, 3, (err, bytesRead, buffer) =&gt; {
      console.log(bytesRead);
      console.log(buffer);
      console.log(buffer.toString());
    });
  });
});

// 3
// &lt;Buffer e4 bd a0 00 00 00&gt;

// 3
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
// 你好
</code></pre><h3 id="同步磁盘缓存-fsync"><a href="#同步磁盘缓存-fsync" class="headerlink" title="同步磁盘缓存 fsync"></a>同步磁盘缓存 fsync</h3><p><code>fsync</code> 方法有两个参数，第一个参数为文件描述符 <code>fd</code>，第二个参数为回调函数，回调函数中有一个参数 <code>err</code>（错误），在同步磁盘缓存后执行。</p><blockquote class="pullquote warning"><p><strong>在使用 <code>write</code> 方法向文件写入数据时，由于不是一次性写入，所以最后一次写入在关闭文件之前应先同步磁盘缓存，<code>fsync</code> 方法将在后面配合 <code>write</code> 一起使用。</strong></p></blockquote><h3 id="写入文件-write"><a href="#写入文件-write" class="headerlink" title="写入文件 write"></a>写入文件 write</h3><blockquote class="pullquote info"><p><strong><code>write</code> 方法与 <code>writeFile</code> 不同，是将 <code>Buffer</code> 中的数据写入文件，<code>Buffer</code> 的作用是一个数据中转站，可能数据的源占用内存太大或内存不确定，无法一次性放入内存中写入，所以分段写入，多与 <code>read</code> 方法配合。</strong></p></blockquote><blockquote class="pullquote primary"><p><strong><code>write</code> 方法中有六个参数：</strong></p><ul><li><strong><code>fd</code>：文件描述符，需要先使用 <code>open</code> 打开文件获取；</strong></li><li><strong><code>buffer</code>：存储将要写入文件数据的 <code>Buffer</code>；</strong></li><li><strong><code>offset</code>：整数，从 <code>Buffer</code> 读取数据的初始位置；</strong></li><li><strong><code>length</code>：整数，读取 <code>Buffer</code> 数据的字节数；</strong></li><li><strong><code>position</code>：整数，写入文件初始位置；</strong></li><li><strong><code>callback</code>：回调函数，有三个参数 <code>err</code>（错误），<code>bytesWritten</code>（实际写入的字节数），<code>buffer</code>（被读取的缓存区对象），写入完成后执行。</strong></li></ul></blockquote><p>下面将一个 Buffer 中间的两个字写入文件 <code>6.txt</code>，原内容为 “你好”。</p><pre><code class="lang-js">/* 选择范围写入 */
const fs = require(&#39;fs&#39;);
const buf = Buffer.from(&#39;你还好吗&#39;);

// 打开文件
fs.open(&#39;6.txt&#39;, &#39;r+&#39;, (err, fd) =&gt; {
  // 读取 buf 向文件写入数据
  fs.write(fd, buf, 3, 6, 3, (err, bytesWritten, buffer) =&gt; {
    // 同步磁盘缓存
    fs.fsync(fd, err =&gt; {
      // 关闭文件
      fs.close(fd, err =&gt; {
        console.log(&#39;关闭文件&#39;);
      });
    });
  });
});

// 这里为了看是否写入成功简单粗暴的使用 readFile 方法
fs.readFile(&#39;6.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
  console.log(data);
});

// 你还好
</code></pre><p>上面代码将 “你还好吗” 中间的 “还好” 从 Buffer 中读取出来写入到 <code>6.txt</code> 的 “你” 字之后，但是最后的 “好” 并没有被保留，说明先清空了文件中 “你” 字之后的内容再写入。</p><h3 id="针对大文件实现-copy"><a href="#针对大文件实现-copy" class="headerlink" title="针对大文件实现 copy"></a>针对大文件实现 copy</h3><p>之前我们使用 <code>readFile</code> 和 <code>writeFile</code> 实现了一个 <code>copy</code> 函数，那个 <code>copy</code> 函数是将被拷贝文件的数据一次性读取到内存，一次性从内存写入到目标文件中，主要针对小文件。</p><p>如果是一个大文件一次性读取到内存再写入非常占用计算机的内存，所以需要多次读取多次写入，也就是一边读一边写，接下来使用上面的这些高级方法针对大文件和文件大小未知的情况实现一个 <code>copy</code> 函数。</p><pre><code class="lang-js">/* 大文件拷贝 */
// copy 方法
function copy(src, dest, size = 16 * 1024, callback) {
  // 打开源文件
  fs.open(src, &#39;r&#39;, (err, readFd) =&gt; {
    // 打开目标文件
    fs.open(dest, &#39;w&#39;, (err, writeFd) =&gt; {
      const buf = Buffer.alloc(size);
      let readed = 0; // 下次读取文件的位置
      let writed = 0; // 下次写入文件的位置

      function next() {
        // 读取
        fs.read(readFd, buf, 0, size, readed, (err, bytesRead) =&gt; {
          readed += bytesRead;

          // 如果读不到内容关闭文件
          if (!bytesRead) fs.close(readFd, err =&gt; console.log(&#39;关闭源文件&#39;));

          // 写入
          fs.write(writeFd, buf, 0, bytesRead, writed, (err, bytesWritten) =&gt; {
            // 如果没有内容了同步缓存，并关闭文件后执行回调
            if (!bytesWritten) {
              fs.fsync(writeFd, err =&gt; {
                fs.close(writeFd, err =&gt; return !err &amp;&amp; callback());
              });
            }
            writed += bytesWritten;

            // 继续读取、写入
            next();
          });
        });
      };

      // 第一次执行读取写入
      next()
    });
  });
}
</code></pre><p>在上面的 <code>copy</code> 方法中，我们手动维护的下次读取位置和下次写入位置，其实参数 <code>readed</code> 和 <code>writed</code> 的位置传入 <code>null</code>，<code>Node.js</code> 会自动帮我们维护这两个值。</p><p>现在有一个文件 <code>6.txt</code> 内容为 “你好”，一个空文件 <code>7.txt</code>，我们将 <code>6.txt</code> 的内容写入 <code>7.txt</code> 中。</p><pre><code class="lang-js">/* 验证大文件拷贝 */
const fs = require(&#39;fs&#39;);

// buffer 的长度
const BUFFER_SIZE = 3;

// 拷贝文件内容并写入
copy(&#39;6.txt&#39;, &#39;7.txt&#39;, BUFFER_SIZE, () =&gt; {
  fs.readFile(&#39;7.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
    // 拷贝完读取 7.txt 的内容
    console.log(data); // 你好
  });
});
</code></pre><blockquote class="pullquote default"><p><strong>在 <code>Node.js</code> 中进行文件操作，多次读取和写入时，一般一次读取数据大小为 <code>64k</code>，写入数据大小为 <code>16k</code>。</strong></p></blockquote><h2 id="文件目录操作方法"><a href="#文件目录操作方法" class="headerlink" title="文件目录操作方法"></a>文件目录操作方法</h2><blockquote class="pullquote info"><p><strong>下面的这些操作文件目录的方法有一个共同点，就是传入的第一个参数都为文件的路径，如：<code>a/b/c/d</code>，也分为同步和异步两种实现。</strong></p></blockquote><h3 id="查看文件目录操作权限"><a href="#查看文件目录操作权限" class="headerlink" title="查看文件目录操作权限"></a>查看文件目录操作权限</h3><h4 id="同步查看操作权限方法-accessSync"><a href="#同步查看操作权限方法-accessSync" class="headerlink" title="同步查看操作权限方法 accessSync"></a>同步查看操作权限方法 accessSync</h4><p><code>accessSync</code> 方法传入文件路径，检查传入路径下的目录是否可读可写，当有操作权限的时候没有返回值，没有权限或路径非法时抛出一个 <code>Error</code> 对象，所以使用时多用 <code>try...catch...</code> 进行异常捕获。</p><pre><code class="lang-js">/* 同步查看操作权限 */
const fs = require(&#39;fs&#39;);

try {
  fs.accessSync(&#39;a/b/c&#39;);
  console.log(&#39;可读可写&#39;);
} catch (err) {
  console.error(&#39;不可访问&#39;);
}
</code></pre><h4 id="异步查看操作权限方法-access"><a href="#异步查看操作权限方法-access" class="headerlink" title="异步查看操作权限方法 access"></a>异步查看操作权限方法 access</h4><p><code>access</code> 方法与第一个参数为文件路径，最后一个参数为一个回调函数，回调函数有一个参数为 <code>err</code>（错误），在权限检测后触发，如果有权限 <code>err</code> 为 <code>null</code>，没有权限或路径非法 <code>err</code> 是一个 <code>Error</code> 对象。</p><pre><code class="lang-js">/* 异步查看操作权限 */
const fs = require(&#39;fs&#39;);

fs.access(&#39;a/b/c&#39;, err =&gt; {
  if (err) {
    console.error(&#39;不可访问&#39;);
  } else {
    console.log(&#39;可读可写&#39;);
  }
});
</code></pre><h3 id="获取文件目录的-Stats-对象"><a href="#获取文件目录的-Stats-对象" class="headerlink" title="获取文件目录的 Stats 对象"></a>获取文件目录的 Stats 对象</h3><p>文件目录的 <code>Stats</code> 对象存储着关于这个文件或文件夹的一些元信息，如创建时间、最后一次访问的时间、最后一次修改的时间、文章所占字节和判断文件类型的多个方法等等。</p><h4 id="同步获取-Stats-对象方法-statSync"><a href="#同步获取-Stats-对象方法-statSync" class="headerlink" title="同步获取 Stats 对象方法 statSync"></a>同步获取 Stats 对象方法 statSync</h4><p><code>statSync</code> 方法参数为文件路径，返回值为当前目录路径的 <code>Stats</code> 对象，现在通过 <code>Stats</code> 对象获取 <code>a</code> 目录下的 <code>b</code> 目录下的 <code>c.txt</code> 文件的字节大小，文件内容为 “你好”。</p><pre><code class="lang-js">/* 同步获取 Stats 对象 */
const fs = require(&#39;fs&#39;);

const statObj = fs.statSync(&#39;a/b/c.txt&#39;);
console.log(statObj.size); // 6
</code></pre><h4 id="异步获取-Stats-对象方法-stat"><a href="#异步获取-Stats-对象方法-stat" class="headerlink" title="异步获取 Stats 对象方法 stat"></a>异步获取 Stats 对象方法 stat</h4><p><code>stat</code> 方法的第一个参数为文件路径，最后一个参数为回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>Stats</code> 对象，在读取 <code>Stats</code> 后执行，同样实现上面的读取文件字节数的例子。</p><pre><code class="lang-js">/* 异步获取 Stats 对象 */
const fs = require(&#39;fs&#39;);

fs.stat(&#39;a/b/c.txt&#39;, (err, statObj) =&gt; {
  console.log(statObj.size); // 6
});
</code></pre><h3 id="创建文件目录"><a href="#创建文件目录" class="headerlink" title="创建文件目录"></a>创建文件目录</h3><h4 id="同步创建目录方法-mkdirSync"><a href="#同步创建目录方法-mkdirSync" class="headerlink" title="同步创建目录方法 mkdirSync"></a>同步创建目录方法 mkdirSync</h4><p><code>mkdirSync</code> 方法参数为文件路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。</p><pre><code class="lang-js">/* 同步创建文件目录 */
const fs = require(&#39;fs&#39;);

// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync(&#39;a/b/c&#39;);
</code></pre><h4 id="异步创建目录方法-mkdir"><a href="#异步创建目录方法-mkdir" class="headerlink" title="异步创建目录方法 mkdir"></a>异步创建目录方法 mkdir</h4><p><code>mkdir</code> 方法的第一个参数为文件路径，最后一个参数为回调函数，回调函数有一个参数 <code>err</code>（错误），在执行创建操作后执行，同样需要路径前部分的文件夹都存在。</p><pre><code class="lang-js">/* 异步创建文件目录 */
const fs = require(&#39;fs&#39;);

// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdir(&#39;a/b/c&#39;, err =&gt; {
  if (!err) console.log(&#39;创建成功&#39;);
});

// 创建成功
</code></pre><h3 id="读取文件目录"><a href="#读取文件目录" class="headerlink" title="读取文件目录"></a>读取文件目录</h3><h4 id="同步读取目录方法-readdirSync"><a href="#同步读取目录方法-readdirSync" class="headerlink" title="同步读取目录方法 readdirSync"></a>同步读取目录方法 readdirSync</h4><blockquote class="pullquote default"><p><strong><code>readdirSync</code> 方法有两个参数：</strong></p><ul><li><strong>第一个参数为文件路径，传入的路径前部分的目录必须存在，否则会报错；</strong></li><li><strong>第二个参数为 <code>options</code>，其中有 <code>encoding</code>（编码，默认值为 <code>utf8</code>），该参数也可直接传入 <code>encoding</code>；</strong></li><li><strong>返回值为一个存储文件目录中成员名称的数组。</strong></li></ul></blockquote><p>假设现在已经存在了 <code>a</code> 目录和 <code>a</code> 下的 <code>b</code> 目录，<code>b</code> 目录中有 <code>c</code> 目录和 <code>index.js</code> 文件，下面读取文件目录结构。</p><pre><code class="lang-js">/* 同步读取目录 */
const fs = require(&#39;fs&#39;);

const data = fs.readdirSync(&#39;a/b&#39;);
console.log(data); // [ &#39;c&#39;, &#39;index.js&#39; ]
</code></pre><h4 id="异步读取目录方法-readdir"><a href="#异步读取目录方法-readdir" class="headerlink" title="异步读取目录方法 readdir"></a>异步读取目录方法 readdir</h4><p><code>readdir</code> 方法的前两个参数与 <code>readdirSync</code> 相同，第三个参数为一个回调函数，回调函数有两个参数 <code>err</code>（错误）和 <code>data</code>（存储文件目录中成员名称的数组），在读取文件目录后执行。</p><p>上面案例异步的写法：</p><pre><code class="lang-js">/* 异步读取目录 */
const fs = require(&#39;fs&#39;);

fs.readdir(&#39;a/b&#39;, (err, data) =&gt; {
  if (!err) console.log(data);
});

// [ &#39;c&#39;, &#39;index.js&#39; ]
</code></pre><h3 id="删除文件目录"><a href="#删除文件目录" class="headerlink" title="删除文件目录"></a>删除文件目录</h3><blockquote class="pullquote warning"><p><strong>无论同步还是异步，删除文件目录时必须同时满足两个条件：</strong></p><ul><li><strong>保证文件目录的路径存在；</strong></li><li><strong>且被删除的文件目录为空，即不存在任何文件夹和文件。</strong></li></ul></blockquote><h4 id="同步删除目录方法-rmdirSync"><a href="#同步删除目录方法-rmdirSync" class="headerlink" title="同步删除目录方法 rmdirSync"></a>同步删除目录方法 rmdirSync</h4><p><code>rmdirSync</code> 的参数为要删除目录的路径，现在存在 <code>a</code> 目录和 <code>a</code> 目录下的 <code>b</code> 目录，删除 <code>b</code> 目录。</p><pre><code class="lang-js">/* 同步删除目录 */
const fs = require(&#39;fs&#39;);

fs.rmdirSync(&#39;a/b&#39;);
</code></pre><h4 id="异步删除目录方法-rmdir"><a href="#异步删除目录方法-rmdir" class="headerlink" title="异步删除目录方法 rmdir"></a>异步删除目录方法 rmdir</h4><p><code>rmdir</code> 方法的第一个参数与 <code>rmdirSync</code> 相同，最后一个参数为回调函数，函数中存在一个参数 <code>err</code>（错误），在删除目录操作后执行。</p><pre><code class="lang-js">/* 异步删除目录 */
const fs = require(&#39;fs&#39;);

fs.rmdir(&#39;a/b&#39;, err =&gt; {
  if (!err) console.log(&#39;删除成功&#39;);
});

// 删除成功
</code></pre><h3 id="删除文件操作"><a href="#删除文件操作" class="headerlink" title="删除文件操作"></a>删除文件操作</h3><h4 id="同步删除文件方法-unlinkSync"><a href="#同步删除文件方法-unlinkSync" class="headerlink" title="同步删除文件方法 unlinkSync"></a>同步删除文件方法 unlinkSync</h4><p><code>unlinkSync</code> 的参数为要删除文件的路径，现在存在 <code>a</code> 目录和 <code>a</code> 目录下的 <code>index.js</code> 文件，删除 <code>index.js</code> 文件。</p><pre><code class="lang-js">/* 同步删除文件 */
const fs = require(&#39;fs&#39;);

fs.unlinkSync(&#39;a/inde.js&#39;);
</code></pre><h4 id="异步删除文件方法-unlink"><a href="#异步删除文件方法-unlink" class="headerlink" title="异步删除文件方法 unlink"></a>异步删除文件方法 unlink</h4><p><code>unlink</code> 方法的第一个参数与 <code>unlinkSync</code> 相同，最后一个参数为回调函数，函数中存在一个参数 <code>err</code>（错误），在删除文件操作后执行。</p><pre><code class="lang-js">/* 异步删除文件 */
const fs = require(&#39;fs&#39;);

fs.unlink(&#39;a/index.js&#39;, err =&gt; {
  if (!err) console.log(&#39;删除成功&#39;);
});

// 删除成功
</code></pre><h2 id="实现递归创建目录"><a href="#实现递归创建目录" class="headerlink" title="实现递归创建目录"></a>实现递归创建目录</h2><blockquote class="pullquote success"><p><strong>我们创建一个函数，参数为一个路径，按照路径逐级的创建文件夹目录。</strong></p></blockquote><h3 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h3><pre><code class="lang-js">/* 递归删除文件目录 —— 同步 */
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 同步创建文件目录
function mkPathSync(dirPath) {
  // path.sep 文件路径分隔符（mac 与 windows 系统不同），转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
  const parts = dirPath.split(path.sep);
  for (let i = 1; i &lt;= parts.length; i++) {
    // 重新拼接成 a a/b a/b/c
    const current = parts.slice(0, i).join(path.sep);

    // accessSync 路径不存在则抛出错误在 catch 中创建文件夹，否则直接创建下一级
    try {
      fs.accessSync(current);
    } catch(e) {
      fs.mkdirSync(current);
    }
  }
}

// 创建文件目录
mkPathSync(path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;));
</code></pre><p>同步代码就是利用 <code>accessSync</code> 方法检查文件路径是否存在，利用 <code>try...catch...</code> 进行错误捕获，如果路径不存在，则会报错，会进入 <code>catch</code> 完成文件夹的创建。</p><h3 id="异步回调的实现"><a href="#异步回调的实现" class="headerlink" title="异步回调的实现"></a>异步回调的实现</h3><pre><code class="lang-js">/* 递归删除文件目录 —— 异步回调 */
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

function mkPathAsync(dirPath, callback) {
  // 转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
  const parts = dirPath.split(path.sep);

  // 创建文件夹方法
  function next(index) {
    // 重新拼接成 a a/b a/b/c
    const current = parts.slice(0, index).join(path.sep);

    // 如果路径检查成功说明已经有该文件目录，则继续创建下一级, 失败则创建目录，成功后递归 next 创建下一级
    fs.access(current, err =&gt; {
      if (err) {
        fs.mkdir(current, () =&gt; next(++index));
      } else {
        next(++index);
      }
    });
  }

  // 第一次调用 index 值为 1，因为 slice 截取包前不包后
  next(1);
}

// 创建文件目录
mkPathAsync(path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), () =&gt; {
  console.log(&#39;创建文件目录完成&#39;)
});

// 创建文件目录完成
</code></pre><p>上面方法中没有通过循环实现每次目录的拼接，而是通过递归内部函数 <code>next</code> 的方式并维护 <code>index</code> 变量来实现的，在使用 <code>access</code> 的时候成功说明文件目录已经存在，就继续递归创建下一级，如果存在 <code>err</code> 说明不存在，则创建文件夹。</p><h3 id="异步-async-await-的实现"><a href="#异步-async-await-的实现" class="headerlink" title="异步 async/await 的实现"></a>异步 async/await 的实现</h3><p>上面两种方式，同步会阻塞代码，性能不好，异步回调函数性能好，但嵌套多维护性差，我们想要具备性能好，代码可读性又好可以使用现在 <code>Node.js</code> 中正流行的 <code>async/await</code> 的方式进行异步编程，想了解 <code>async/await</code> 可以看 <a href="https://www.overtaking.top/20180615212040/" target="_blank">异步发展流程 —— 异步编程的终极大招 async/await</a> 这篇文章。</p><p>使用 <code>async</code> 函数中 <code>await</code> 等待的异步操作必须转换成 <code>Promise</code> 实例，<code>util</code> 模块下的 <code>promisify</code> 方法可以进行转换，其实 <code>promisify</code> 方法的原理也很简单，我们在实现递归创建文件目录之前先实现 <code>promisify</code> 方法。</p><pre><code class="lang-js">/* promisify 原理 */
// 将一个异步方法转换成 Promise
function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) =&gt; {
      fn.call(null, ...args, (err, data) =&gt; {
        err ? reject(err) : resolve(data);
      });
    });
  }
}
</code></pre><p>其实 <code>promisify</code> 方法就是利用闭包来实现的，调用时传入一个需要转换成 <code>Promise</code> 的函数 <code>fn</code>，返回一个闭包函数，在闭包函数中返回一个 <code>Promise</code> 实例，并同步执行了 <code>fn</code>，通过 <code>call</code> 将闭包函数中的参数和回调函数作为参数传入了 <code>fn</code> 中，该回调存在错误的时候调用了 <code>Promise</code> 实例的 <code>reject</code>，否则调用 <code>resolve</code>；</p><pre><code class="lang-js">/* 递归删除文件目录 —— 异步 async/await */
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 将 fs 中用到的方法转换成 Promise
const access = promisify(fs.access);
const mkdir = promisify(fs.mkdir);

// async/await 实现递归创建文件目录
async function mkPath(dirPath) {
  // 转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
  const parts = dirPath.split(path.sep);

  for (let i = 1; i &lt;= parts.length; i++) {
    // 重新拼接成 a a/b a/b/c
    const current = parts.slice(0, i).join(path.sep);

    // accessSync 路径不存在则抛出错误在 catch 中创建文件夹
    try {
      await access(current);
    } catch(e) {
      await mkdir(current);
    }
  }
}

// 创建文件目录
mkPath(path.(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)).then(() =&gt; {
  console.log(&#39;创建文件目录完成&#39;);
});

// 创建文件目录完成
</code></pre><p>使用 <code>async/await</code> 的写法，代码更像同步的实现方式，却是异步执行，所以同时兼顾了性能和代码的可读性，优势显而易见，在使用 <code>Node.js</code> 框架 <code>Koa 2.x</code> 版本时大量使用这种方式进行异步编程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>fs</code> 所有模块都有同步异步两种实现，同步方法的特点就是阻塞代码，性能差，异步代码的特点就是回调函数嵌套多，在使用 <code>fs</code> 应尽量使用异步方式编程来保证性能，如果觉得回调函数嵌套不好维护，可以使用 <code>Promise</code> 或 <code>async/await</code> 的方式解决。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js —— Buffer 解读</title>
    <url>/20180629115313/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180629115313/buffer.png" title="Buffer"><p><br></p><h2 id="Buffer-概述"><a href="#Buffer-概述" class="headerlink" title="Buffer 概述"></a>Buffer 概述</h2><blockquote class="pullquote warning"><p><strong>在 <code>ES6</code> 引入</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank">TypedArray</a> <strong>之前，<code>JavaScript</code> 语言没有读取或操作二进制数据流的机制，<code>Node.js</code> 实现了 <code>Buffer</code> 相关的 <code>API</code>，使其可以在 <code>TCP</code> 流或文件系统操作等场景中处理二进制数据流，<code>Buffer</code> 属于 <code>Global</code> 对象，使用时不需引入，且 <code>Buffer</code> 的大小在创建时确定，无法调整。</strong></p></blockquote><a id="more"></a><h2 id="创建-Buffer"><a href="#创建-Buffer" class="headerlink" title="创建 Buffer"></a>创建 Buffer</h2><p>在 <code>Node.js</code> <code>v6.0.0</code> 版本之前，<code>Buffer</code> 实例是通过 <code>Buffer</code> 构造函数创建的，即使用 <code>new</code> 关键字创建，它根据提供的参数返回不同的 <code>Buffer</code>，但在之后的版本中这种声明方式就被废弃了，替代 <code>new</code> 的创建方式主要有以下几种。</p><h3 id="Buffer-alloc-和-Buffer-allocUnsafe"><a href="#Buffer-alloc-和-Buffer-allocUnsafe" class="headerlink" title="Buffer.alloc 和 Buffer.allocUnsafe"></a>Buffer.alloc 和 Buffer.allocUnsafe</h3><p>用 <code>Buffer.alloc</code> 和 <code>Buffer.allocUnsafe</code> 创建 <code>Buffer</code> 的传参方式相同，参数为创建 <code>Buffer</code> 的长度，数值类型。</p><pre><code class="lang-js">/* Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer */
// Buffer.alloc 创建 Buffer
const buf1 = Buffer.alloc(6);

// Buffer.allocUnsafe 创建 Buffer
const buf2 = Buffer.allocUnsafe(6);

console.log(buf1); // &lt;Buffer 00 00 00 00 00 00&gt;
console.log(buf2); // &lt;Buffer 00 e7 8f a0 00 00&gt;
</code></pre><p>通过打印结果可以看出，用 <code>Buffer.alloc</code> 和 <code>Buffer.allocUnsafe</code> 创建 <code>Buffer</code> 是有区别的，<code>Buffer.alloc</code> 创建的 <code>Buffer</code> 是被初始化过的，<code>Buffer</code> 的每一项都用 <code>00</code> 填充，而 <code>Buffer.allocUnsafe</code> 创建的 <code>Buffer</code> 并没有经过初始化，在内存中只要有闲置的 <code>Buffer</code> 就直接 “抓过来” 使用。</p><p><code>Buffer.allocUnsafe</code> 创建 <code>Buffer</code> 使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感数据，有明显性能优势的同时又是不安全的，所以需谨慎使用。</p><h3 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from"></a>Buffer.from</h3><blockquote class="pullquote info"><p><strong><code>Buffer.from</code> 支持三种传参方式：</strong></p><ul><li><strong>第一个参数为字符串，第二个参数为字符编码，如 <code>ASCII</code>、<code>UTF-8</code>、<code>Base64</code> 等等;</strong></li><li><strong>传入一个数组，数组的每一项会以十六进制存储为 Buffer 的每一项;</strong></li><li><strong>传入一个 Buffer，会将 Buffer 的每一项作为新返回 Buffer 的每一项。</strong></li></ul></blockquote><p><strong>传入字符串和字符编码：</strong></p><pre><code class="lang-js">/* 传入字符串和字符编码 */
const buf = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;);

console.log(buf); // &lt;Buffer 68 65 6c 6c 6f&gt;
</code></pre><p><strong>传入数组：</strong></p><pre><code class="lang-js">/* 数组成员为十进制数 */
const buf = Buffer.from([1, 2, 3]);

console.log(buf); // &lt;Buffer 01 02 03&gt;
</code></pre><pre><code class="lang-js">/* 数组成员为十六进制数 */
let buf = Buffer.from([0xe4, 0xbd, 0xa0, 0xe5, 0xa5, 0xbd]);

console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;
console.log(buf.toString(&#39;utf8&#39;)); // 你好
</code></pre><blockquote class="pullquote success"><p><strong>在 <code>Node.js</code> 中不支持 <code>GB2312</code> 编码，默认支持 <code>UTF-8</code>，在 <code>GB2312</code> 中，一个汉字占两个字节，而在 <code>UTF-8</code> 中，一个汉字占三个字节，所以上面 “你好” 的 <code>Buffer</code> 为 <code>6</code> 个十六进制数组成。</strong></p></blockquote><pre><code class="lang-js">/* 数组成员为字符串类型的数字 */
const buf = Buffer.from([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]);

console.log(buf); // &lt;Buffer 01 02 03&gt;
</code></pre><p>传入的数组成员可以是任何进制的数值，当成员为字符串的时候，如果值是数字会被自动识别成数值类型，如果值不是数字或成员为是其他非数值类型的数据，该成员会被初始化为 <code>00</code>。</p><p>创建的 <code>Buffer</code> 可以通过 <code>toString</code> 方法直接指定编码进行转换，默认编码为 <code>UTF-8</code>。</p><p><strong>传入 Buffer：</strong></p><pre><code class="lang-js">/* 传入一个 Buffer */
const buf1 = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;);

const buf2 = Buffer.from(buf1);

console.log(buf1); // &lt;Buffer 68 65 6c 6c 6f&gt;
console.log(buf2); // &lt;Buffer 68 65 6c 6c 6f&gt;
console.log(buf1 === buf2); // true
console.log(buf1[0] === buf2[0]); // false
</code></pre><p>当传入的参数为一个 <code>Buffer</code> 的时候，会创建一个新的 <code>Buffer</code> 并复制上面的每一个成员。</p><blockquote class="pullquote warning"><p><strong><code>Buffer</code> 为引用类型，一个 <code>Buffer</code> 复制了另一个 <code>Buffer</code> 的成员，当其中一个 <code>Buffer</code> 复制的成员有更改，另一个 <code>Buffer</code> 对应的成员会跟着改变，因为指向同一个引用，类似于 “二维数组”。</strong></p></blockquote><pre><code class="lang-js">/* Buffer 类比二维数组 */
const arr1 = [1, 2, [3]];
const arr2 = arr1.slice();

arr2[2][0] = 5;
console.log(arr1); // [1, 2, [5]]
</code></pre><h2 id="Buffer-的常用方法"><a href="#Buffer-的常用方法" class="headerlink" title="Buffer 的常用方法"></a>Buffer 的常用方法</h2><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><blockquote class="pullquote primary"><p><strong><code>Buffer</code> 的 <code>fill</code> 方法可以向一个 <code>Buffer</code> 中填充数据，支持传入三个参数：</strong></p><ul><li><strong><code>value</code>：将要填充的数据；</strong></li><li><strong><code>start</code>：填充数据的开始位置，不指定默认为 <code>0</code>；</strong></li><li><strong><code>end</code>：填充数据的结束位置，不指定默认为 <code>Buffer</code> 的长度。</strong></li></ul></blockquote><pre><code class="lang-js">const buf = Buffer.alloc(3);

buf.fill(1);
console.log(buf); // &lt;Buffer 01 01 01&gt;
</code></pre><pre><code class="lang-js">const buf = Buffer.alloc(6);

buf.fill(1, 2, 4);
console.log(buf); // &lt;Buffer 00 00 01 01 00 00&gt;
</code></pre><p>上面代码可以看出填充数据是 “包前不包后的”，<code>fill</code> 的第一个参数也支持是多个字节，从被填充 <code>Buffer</code> 的起始位置开始，一直到结束，会循环填充这些字节，剩余的位置不够填充这几个字节，会填到哪算哪，有可能不完整，如果 <code>fill</code> 指定的结束位置大于了 <code>Buffer</code> 的长度，会抛出 <code>RangeError</code> 的异常。</p><pre><code class="lang-js">const buf = Buffer.alloc(6);

buf.fill(&#39;abc&#39;, 1, 5);
console.log(buf); // &lt;Buffer 00 61 62 63 61 00&gt;
</code></pre><pre><code class="lang-js">const buf = Buffer.alloc(3);

buf.fill(&#39;abc&#39;, 4, 8);
console.log(buf); // throw new errors.RangeError(&#39;ERR_INDEX_OUT_OF_RANGE&#39;);
</code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><code>Buffer</code> 的 <code>slice</code> 方法与数组的 <code>slice</code> 方法用法完全相同，相信数组的 <code>slice</code> 已经足够熟悉了，这里就不多赘述了，<code>Buffer</code> 中截取出来的都是 <code>Buffer</code>。</p><pre><code class="lang-js">const buf = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;);

const a = buf.slice(0, 2);
const b = buf.slice(2);
const c = buf.slice(-2);

console.log(a.toString()); // he
console.log(b.toString()); // llo
console.log(c.toString()); // lo
</code></pre><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><code>Buffer</code> 的 <code>indexOf</code> 用法与数组和字符串的 <code>indexOf</code> 类似，第一个参数为查找的项，第二个参数为查找的起始位置，不同的是，对于 <code>Buffer</code> 而言，查找的可能是一个字符串，代表多个字节，查找的字节在 <code>Buffer</code> 中必须有连续相同的字节，返回连续的字节中第一个字节的索引，没查找到返回 <code>-1</code>。</p><pre><code class="lang-js">const buf = Buffer.from(&#39;你*好*吗&#39;, &#39;utf8&#39;);

console.log(buf); // &lt;Buffer e4 bd a0 2a e5 a5 bd 2a e5 90 97&gt;
console.log(buf.indexOf(&#39;*&#39;)); // 3
console.log(buf.indexOf(&#39;好&#39;)); // 4
console.log(buf.indexOf(&#39;*&#39;, 4)); // 7
</code></pre><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><blockquote class="pullquote default"><p><strong><code>Buffer</code> 的 <code>copy</code> 方法用于将一个 <code>Buffer</code> 的字节复制到另一个 <code>Buffer</code> 中去，有四个参数：</strong></p><ul><li><strong><code>target</code>：目标 <code>Buffer</code>；</strong></li><li><strong><code>targetStart</code>：目标 <code>Buffer</code> 的起始位置；</strong></li><li><strong><code>sourceStart</code>：源 <code>Buffer</code> 的起始位置；</strong></li><li><strong><code>sourceEnd</code>：源 <code>Buffer</code> 的结束位置。</strong></li></ul></blockquote><pre><code class="lang-js">/* 容器 Buffer 长度充足 */
const targetBuf = Buffer.alloc(6);
const sourceBuf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);

// 将 “你好” 复制到 targetBuf 中
sourceBuf.copy(targetBuf, 0, 0, 6);

console.log(targetBuf.toString()); // 你好
</code></pre><pre><code class="lang-js">/* 容器 Buffer 长度不足 */
const targetBuf = Buffer.alloc(3);
const sourceBuf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);

sourceBuf.copy(targetBuf, 0, 0, 6);
console.log(targetBuf.toString()); // 你
</code></pre><p>上面第二个案例中虽然要把整个源 <code>Buffer</code> 都复制进目标 <code>Buffer</code> 中，但是由于目标 <code>Buffer</code> 的长度只有 <code>3</code>，所以最终只能复制进去一个 “你” 字。</p><blockquote class="pullquote warning"><p><strong><code>Buffer</code> 与数组不同，不能通过操作 <code>length</code> 和索引改变 <code>Buffer</code> 的长度，<code>Buffer</code> 一旦被创建，长度将保持不变。</strong></p></blockquote><pre><code class="lang-js">/* 数组对比 Buffer —— 操作 length */
// 数组
const arr = [1, 2, 3];
arr[3] = 4;
console.log(arr); // [1, 2, 3, 4]

arr.length = 5;
console.log(arr); // [1, 2, 3, 4, empty]

// Buffer
const buf = Buffer.alloc(3);
buf[3] = 0x00;
console.log(buf); // &lt;Buffer 00 00 00&gt;

buf.length = 5;
console.log(buf); // &lt;Buffer 00 00 00&gt;
console.log(buf.length); // 3
</code></pre><p>通过上面代码可以看出数组可以通过 <code>length</code> 和索引对数组的长度进行改变，但是 <code>Buffer</code> 中类似的操作都是不生效的。</p><p><strong><code>copy</code> 方法的 <code>Polyfill</code>：</strong></p><pre><code class="lang-js">/* 模拟 copy 方法 */
Buffer.prototype.myCopy = function (target, targetStart, sourceStart, sourceEnd) {
  for (let i = 0; i &lt; sourceEnd - sourceStart; i++) {
    target[targetStart + i] = this[sourceStart + i];
  }
}
</code></pre><h3 id="Buffer-concat"><a href="#Buffer-concat" class="headerlink" title="Buffer.concat"></a>Buffer.concat</h3><p>与数组类似，<code>Buffer</code> 也存在用于拼接多个 <code>Buffer</code> 的方法 <code>concat</code>，不同的是 <code>Buffer</code> 中的 <code>concat</code> 不是实例方法，而是静态方法，通过 <code>Buffer.concat</code> 调用，且传入的参数不同。</p><blockquote class="pullquote primary"><p><strong><code>Buffer.concat</code> 有两个参数，返回值是一个新的 <code>Buffer</code>：</strong></p><ul><li><strong>第一个参数为一个数组，数组中的每一个成员都是一个 <code>Buffer</code>；</strong></li><li><strong>第二个参数代表新 <code>Buffer</code> 的长度，默认值为数组中每个 <code>Buffer</code> 长度的总和。</strong></li></ul></blockquote><p><code>Buffer.concat</code> 会将数组中的 <code>Buffer</code> 进行拼接，存入新 <code>Buffer</code> 并返回，如果传入第二个参数规定了返回 <code>Buffer</code> 的长度，那么返回值存储拼接到规定长度个字节。</p><pre><code class="lang-js">const buf1 = Buffer.from(&#39;你&#39;, &#39;utf8&#39;);
const buf2 = Buffer.from(&#39;好&#39;, &#39;utf8&#39;);

const result1 = Buffer.concat([buf1, buf2]);
const result2 = Buffer.concat([buf1, buf2], 3);

console.log(result1); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;
console.log(result1.toString()); // 你好

console.log(result2); // &lt;Buffer e4 bd a0&gt;
console.log(result2.toString()); // 你
</code></pre><p><strong><code>Buffer.concat</code> 方法的 <code>Polyfill</code>：</strong></p><pre><code class="lang-js">/* 模拟 Buffer.concat */
Buffer.myConcat = function (bufferList, len) {
  // 新 Buffer 的长度
  len = len || bufferList.reduce((prev, next) =&gt; prev + next.length, 0);

  let index = 0; // 下次开始的索引
  const newBuf = Buffer.alloc(len); // 创建新 Buffer

  // 循环存储 Buffer 的数组进行复制
  bufferList.forEach(buf =&gt; {
    buf.myCopy(newBuf, index, 0, buf.length);
    index += buf.length;
  });

  return newBuf;
}
</code></pre><h3 id="Buffer-isBuffer"><a href="#Buffer-isBuffer" class="headerlink" title="Buffer.isBuffer"></a>Buffer.isBuffer</h3><p><code>Buffer.isBuffer</code> 是用来判断一个对象是否是一个 <code>Buffer</code>，返回布尔值。</p><pre><code class="lang-js">const obj = {};
const buf = Buffer.alloc(6);

console.log(Buffer.isBuffer(obj)); // false
console.log(Buffer.isBuffer(buf)); // true
</code></pre><h2 id="封装一个-split"><a href="#封装一个-split" class="headerlink" title="封装一个 split"></a>封装一个 split</h2><p>字符串的 <code>split</code> 是经常使用的方法，可以用分隔符将字符串切成几部分存储在数组中，<code>Buffer</code> 本身没有 <code>split</code> 方法，但是也会有类似的使用场景，所以我们在 <code>Buffer</code> 上自己实现一个 <code>split</code>。</p><blockquote class="pullquote warning"><p><strong>功能：<code>Buffer</code> 的 <code>split</code> 方法参数为一个分隔符，这个分隔符可能是一个或多个字节的内容，返回值为一个数组，分隔开的部分作为独立的 <code>Buffer</code> 存储在返回的数组中。</strong></p></blockquote><pre><code class="lang-js">/* 封装 Buffer 的 split 方法 */
Buffer.prototype.split = function (sep) {
  const len = Buffer.from(sep).length; // 分隔符所占的字节数
  const result = []; // 返回的数组
  let start = 0; // 查找 Buffer 的起始位置
  let offset = 0; // 偏移量

  // 循环查找分隔符
  while ((offset = this.indexOf(sep, start)) !== -1) {
    // 将分隔符之前的部分截取出来存入
    result.push(this.slice(start, offset));
    start = offset + len;
  }

  // 处理剩下的部分
  result.push(this.slice(start));

  // 返回结果
  return result;
}
</code></pre><p><strong>验证 <code>split</code> 方法：</strong></p><pre><code class="lang-js">/* 验证 split */
const buf = Buffer.from(&#39;哈登爱篮球爱夜店&#39;, &#39;utf8&#39;);
const bufs = buf.split(&#39;爱&#39;);

console.log(bufs);
// [ &lt;Buffer e5 93 88 e7 99 bb&gt;,
//   &lt;Buffer e7 af ae e7 90 83&gt;,
//   &lt;Buffer e5 a4 9c e5 ba 97&gt; ]

const newBufs = bufs.map(buf =&gt; buf.toString());
console.log(newBufs); // [ &#39;哈登&#39;, &#39;篮球&#39;, &#39;夜店&#39; ]
</code></pre><h2 id="Buffer-的编码转换"><a href="#Buffer-的编码转换" class="headerlink" title="Buffer 的编码转换"></a>Buffer 的编码转换</h2><p>我们知道 <code>Node.js</code> 中的默认编码为 <code>UTF-8</code>，且不支持 <code>GB2312</code> 编码，假如现在有一个编码格式为 <code>GB2312</code> 的 <code>txt</code> 文件，内容为 “你好”，现在我们使用 <code>Node.js</code> 去读取它，由于在 <code>UTF-8</code> 与 <code>GB2312</code> 编码中汉字所占字节数不同，所以读出的内容无法解析，即为乱码。</p><pre><code class="lang-js">// 引入依赖
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);
const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;));

console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;
console.log(buf.toString()); // 你好
console.log(result); // &lt;Buffer c4 e3 ba c3&gt;
console.log(result.toString()); // ���
</code></pre><p>如果一定要在 <code>Node.js</code> 中来正确解析这样的内容，这样的问题还是有办法解决的，我们需要借助 <code>iconv-lite</code> 模块，这个模块可以将一个 <code>Buffer</code> 按照指定的编码格式进行编码或解码。</p><p>由于 <code>iconv-lite</code> 是第三方提供的模块，在使用前需要安装，安装命令如下：</p><pre><code class="lang-bash">$ npm install iconv-lite
</code></pre><p><strong>如果想正确的读出其他编码格式文件的内容，上面代码应该更改为：</strong></p><pre><code class="lang-js">// 引入依赖
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const iconvLite = require(&#39;iconv-lite&#39;);

const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;));

console.log(iconvLite.decode(result, &#39;gb2312&#39;)); // 你好
</code></pre><h2 id="去掉-BOM-头"><a href="#去掉-BOM-头" class="headerlink" title="去掉 BOM 头"></a>去掉 BOM 头</h2><p>上面读取 <code>GB2312</code> 编码的 <code>txt</code> 文件也可以通过打开文件重新保存为 <code>UTF-8</code> 或用编辑器直接将编码手动修改为 <code>UTF-8</code>，此时读取的文件不需要进行编码转换，但是会产生新的问题。</p><pre><code class="lang-js">/* 产生 BOM 头 */
// 引入依赖
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);
const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;));

console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt;
console.log(result); // &lt;Buffer ef bb bf e4 bd a0 e5 a5 bd&gt;
</code></pre><p>在手动修改 <code>txt</code> 文件编码后执行上面代码，发现读取的 <code>Buffer</code> 与正常情况相比前面多出了三个字节，只要存在文件编码的修改就会在这个文件的前面产生多余的字节，叫做 <code>BOM</code> 头。</p><blockquote class="pullquote info"><p><strong><code>BOM</code> 头是用来判断文本文件是哪一种 <code>Unicode</code> 编码的标记，其本身是一个 <code>Unicode</code> 字符，位于文本文件头部。</strong></p></blockquote><p>虽然 <code>BOM</code> 头起到了标记文件编码的作用，但是它并不属于文件的内容部分，因此会产生一些问题，如文件编码发生变化后无法正确读取文件的内容，或者多个文件在合并的过程中，中间会夹杂着这些多余内容，所以在 <code>Node.js</code> 文件操作的源码中，<code>Buffer</code> 编码转换的模块 <code>iconv-lite</code> 中，以及 <code>Webpack</code> 对项目文件进行打包编译时都进行了去掉 <code>BOM</code> 头的操作。</p><p>为了让上面的代码可以正确的读取并解析编码被手动修改过的文件内容，我们这里也需要进行去掉 <code>BOM</code> 头的操作。</p><pre><code class="lang-js">/* 去掉 BOM 头的方法 */
function BOMStrip(result) {
  if (Buffer.isBuffer(result)) {
    // 如果读取的内容为 Buffer
    if (result[0] === 0xef &amp;&amp; result[1] === 0xbb &amp;&amp; result[2] === 0xbf) {
      // 若前三个字节是否和 BOM 头的前三字节相同，去掉 BOM 头
      return Buffer.slice(3);
    }
  } else {
    // 如果不是 Buffer
    if (result.charCodeAt(0) === 0xfeff) {
      // 判断第一项是否和 BOM 头的十六进制相同，去掉 BOM 头
      return result.slice(1);
    }
  }
}
</code></pre><p><strong>使用去掉 <code>BOM</code> 头的方法并验证上面读文件的案例：</strong></p><pre><code class="lang-js">/* 验证去 BOM 头的方法 */
// 引入依赖
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);

// 两种方式读文件
const result1 = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;));
const result2 = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;), &#39;utf8&#39;);

console.log(BOMStrip(result1).toString()); // 你好
console.log(BOMStrip(result2)); // 你好
</code></pre><h2 id="缓存-Buffer"><a href="#缓存-Buffer" class="headerlink" title="缓存 Buffer"></a>缓存 Buffer</h2><pre><code class="lang-js">/* 产生乱码问题 */
const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);

const a = buf.slice(0, 2);
const b = buf.slice(2, 6);

console.log(a.toString()); // �
console.log(b.toString()); // �好
</code></pre><p><code>UTF-8</code> 编码，一个汉字三个字节，使用 <code>slice</code> 方法对一个表达汉字的 <code>Buffer</code> 进行截取，如果截取长度不是 <code>3</code> 的整数倍，此时无法正确解析，会显示乱码，这种情况可以使用模块 <code>string_decoder</code> 对不能组成汉字的 <code>Buffer</code> 进行缓存，<code>string_decoder</code> 是核心模块，不需要安装。</p><pre><code class="lang-js">/* 缓存 Buffer */
// 引入依赖
const { StringDecoder } = require(&#39;string_decoder&#39;);

const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;);

const a = buf.slice(0, 2);
const b = buf.slice(2, 6);

// 创建 StringDecoder 实例
const sd = new StringDecoder();

console.log(sd.write(a));
console.log(sd.write(b)); // 你好
</code></pre><p>上面代码中使用了 <code>string_decoder</code> 后，截取的 <code>Buffer</code> 不能组成一个汉字的时候不打印，进行缓存，等到可以正确解析时取出缓存，重新拼接后打印。</p>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>EventEmitter 源码分析与简易实现</title>
    <url>/20180628204755/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180628204755/event-emitter.png" title="EventEmitter"><p><br></p><h2 id="EventEmitter-简介"><a href="#EventEmitter-简介" class="headerlink" title="EventEmitter 简介"></a>EventEmitter 简介</h2><blockquote class="pullquote danger"><p><strong><code>EventEmitter</code> 是 <code>Node.js</code> 的核心模块 <code>events</code> 中的类，用于对 <code>Node.js</code> 中的事件进行统一管理，用 <code>events</code> 特定的 <code>API</code> 对事件进行添加、触发和移除等等，核心方法的模式类似于发布订阅。</strong></p></blockquote><a id="more"></a><h2 id="实现-EventEmitter"><a href="#实现-EventEmitter" class="headerlink" title="实现 EventEmitter"></a>实现 EventEmitter</h2><h3 id="EventEmitter-构造函数的实现"><a href="#EventEmitter-构造函数的实现" class="headerlink" title="EventEmitter 构造函数的实现"></a>EventEmitter 构造函数的实现</h3><pre><code class="lang-js">/* 文件：events.js */
function EventEmitter () {
  this._events = Object.create(null);
}

/*
* 其他方法
*/

// 导出自定义模块
module.export = EventEmitter;
</code></pre><p>在构造函数 <code>EventEmitter</code> 上有一个属性 <code>_events</code>，类型为对象，用于存储和统一管理所有类型的事件，在创建构造函数的时候导出了 <code>EventEmitter</code>，后面实现其他方法的代码将放在构造函数与导出中间。</p><h3 id="事件最大监听个数"><a href="#事件最大监听个数" class="headerlink" title="事件最大监听个数"></a>事件最大监听个数</h3><p>在 <code>EventEmitter</code> 中监听的每一类事件都有最大监听个数，超过了这个数值，事件虽然可以正常执行，但是会发出警告信息，其目的是为了防止内存泄露。</p><pre><code class="lang-js">/* 默认事件最大监听个数 */
EventEmitter.defaultMaxListeners = 10;
</code></pre><p>这个同类型事件最大个数默认是 <code>10</code>，EventEmitter 当然也有方法设置和获取这个值，下面是设置和获取同类型事件最大监听个数的方法实现。</p><pre><code class="lang-js">/* 操作最大事件监听个数 */
// 设置同类型事件监听最大个数
EventEmitter.prototype.setMaxListeners = function (count) {
  this._count = count;
}

// 获取同类型事件监听最大个数
EventEmitter.prototype.getMaxListeners = function () {
  return this._count || EventEmitter.defaultMaxListeners;
}
</code></pre><p>在设置这个值的时候其实就是给 EventEmitter 实例添加了一个 <code>_count</code> 的属性用来存储设置的新值来作为这个类型事件的最大监听个数，在获取的时候就是获取 <code>_count</code>，如果没有设置过就获取默认值。</p><h3 id="添加事件监听"><a href="#添加事件监听" class="headerlink" title="添加事件监听"></a>添加事件监听</h3><p>在给 <code>EventEmitter</code> 的实例添加事件监听时，在 <code>_event</code> 对象中会以事件的类型作为属性名，值为一个数组，每次添加这个类型事件的时候，会将要执行的函数存入这个数组中进行统一管理。</p><blockquote class="pullquote info"><p><strong>添加事件监听的方法有 <code>on</code>、<code>once</code>、<code>addListener</code>、<code>prependListener</code> 和 <code>prependOnceListener</code>：</strong></p><ul><li><strong><code>on</code> 等同于 <code>addListener</code> 将函数正常添加到 <code>_event</code> 对应事件类型的数组中；</strong></li><li><strong><code>once</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中，但是只能执行一次；</strong></li><li><strong><code>prependListener</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中的前面；</strong></li><li><strong><code>prependOnceListener</code> 将函数添加到 <code>_event</code> 对应事件类型的数组中的前面，但只能执行一次。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>在 <code>EventEmitter</code> 中正常添加事件有四点需要注意：</strong></p><ul><li><strong>如果其他的类使用 <code>util</code> 模块的 <code>inherits</code> 方法继承 EventEmitter 时是无法继承实例属性的，在调用操作 <code>_events</code> 的方法中因为无法获取到 <code>_events</code> 导致报错，为了兼容这种继承的情况，在获取不到 <code>_events</code> 时应添加一个 <code>_events</code> 到继承 EventEmitter 的类的实例上；</strong></li><li><strong>如果添加事件的类型为 <code>newListener</code>，传入要执行的函数会有一个参数 <code>type</code> ，是事件的类型，之后再添加事件的时候，就会执行 <code>newListener</code> 的函数，对添加的事件的事件类型进行处理；</strong></li><li><strong><code>on</code> 方法表面上有两个参数，实际上有第三个参数，为布尔值，代表是否从 <code>_events</code> 对应事件类型的数组前面追加函数成员；</strong></li><li><strong>在添加事件的时候需要判断是否超出这个类型事件的最大监听个数，如果超出要打印警告信息。</strong></li></ul></blockquote><p><strong>on 方法和 addListener 方法的实现：</strong></p><pre><code class="lang-js">/* on 和 addListener 方法 */
// 添加事件监听
EventEmitter.prototype.on = EventEmitter.prototype.addListener = function (type, callback, flag) {
  // 兼容继承不存在 _events 的情况
  if (!this._events) this._events = Object.create(null);

  // 如果 type 不是 newListener 就去执行 newListener 的回调
  if (type !== &#39;newListener&#39;) {
    // 如果没添加过 newListener 事件就忽略此处的逻辑
    if (this._events[&#39;newListener&#39;] &amp;&amp; this._events[&#39;newListener&#39;].length) {
      this._events[&#39;newListener&#39;].forEach(fn =&gt; fn(type));
    }
  }

  // 如果不是第一次添加 callback 存入数组中
  if (this._events[type]) {
    // 是否从数组前面添加 callback
    if (flag) {
      this._events[type].unshift(callback);
    } else {
      this._events[type].push(callback);
    }
  } else {
    // 第一次添加，在 _events 中创建数组并添加 callback 到数组中
    this._events[type] = [callback];
  }

  // 获取事件最大监听个数
  const maxListeners = this.getMaxListeners();

  // 判断 type 类型的事件是否超出最大监听个数，超出打印警告信息
  if (this._events[type].length - 1 === maxListeners) {
    console.error(&#39;MaxListenersExceededWarning: &#39; + (maxListeners + 1) + &#39; &#39; + type + &#39; listeners added&#39;);
  }
}
</code></pre><p>通过上面代码可以看出 <code>on</code> 方法的第三个参数其实是服务于 <code>prependListener</code> 方法的，其他添加事件的方法都是基于 <code>on</code> 来实现的，只是在调用 <code>on</code> 的外层做了不同的处理，而我们平时调这些添加事件监听的方法时都只传入 <code>type</code> 和 <code>callback</code>。</p><p><strong>prependListener 方法的实现：</strong></p><pre><code class="lang-js">/* prependListener 方法 */
// 添加事件监听，从数组的前面追加
EventEmitter.prototype.prependListener = function (type, callback) {
  // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback
  this.on(type, callback, true);
}
</code></pre><p><strong>once 方法的实现：</strong></p><pre><code class="lang-js">/* once 方法 */
// 添加事件监听，只能执行一次
EventEmitter.prototype.once = function (type, callback, flag) {
  const wrap =&gt; (...args) {
    callback(...args);

    // 执行 callback 后立即从数组中移除 callback
    this.removeListener(type, wrap);
  }

  // 存储 callback，确保单独使用 removeListener 删除传入的 callback 时可以被删除掉
  wrap.realCallback = callback;

  // 调用 on 添加事件监听
  this.on(type, wrap, flag);
}
</code></pre><p>想让事件只执行一次，需要在执行 <code>callback</code> 之后就立即在数组中移除这个函数，由于是同步执行，直接操作 <code>callback</code> 是很难实现的，添加事件其实就是添加 <code>callback</code> 到 <code>_events</code> 对应类型的数组中，我们在使用 <code>once</code> 的时候将 <code>callback</code> 包一层函数名为 <code>wrap</code>，将这个外层函数存入数组，<code>wrap</code> 的内部逻辑就是真正 <code>callback</code> 的调用和移除 <code>wrap</code>，这里涉及到事件监听的移除方法 <code>removeListener</code> 在后面来详细说明。</p><p><code>once</code> 的第三个参数是为了 <code>prependOnceListener</code> 服务的，<code>prependOnceListener</code> 与 <code>prependListener</code> 实现方式类似，不同的是 <code>prependOnceListener</code> 是基于 <code>once</code> 实现的。</p><p><strong>prependOnceListener 方法的实现：</strong></p><pre><code class="lang-js">/* prependOnceListener 方法 */
// 添加事件监听，从数组的前面追加，只执行一次
EventEmitter.prototype.prependOnceListener = function (type, callback) {
  // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback
  this.once(type, callback, true);
}
</code></pre><h3 id="移除事件监听"><a href="#移除事件监听" class="headerlink" title="移除事件监听"></a>移除事件监听</h3><p>移除事件监听有两个方法，分别是 <code>removeListener</code> 和 <code>removeAllListeners</code>，前者的作用是移除某个类型数组中的某个回调函数，后者的作用是移除某个类型数组的所有成员，如果类型参数为空，则清空整个 <code>_events</code>。</p><p><strong>removeListener 方法的实现：</strong></p><pre><code class="lang-js">/* removeListener 方法 */
// 移除事件执行程序
EventEmitter.prototype.removeListener = function (type, callback) {
  if (this._events[type]) {
    // 过滤掉当前传入的要移除的 callback
    this._events[type] = this._events[type].filter(fn =&gt; {
      return fn !== callback &amp;&amp; fn !== callback.realCallback;
    });
  }
}
</code></pre><p>由于 <code>once</code> 中在真正的 <code>callback</code> 包了一层 <code>wrap</code>，只有在触发事件时才能执行 <code>wrap</code> 并执行 <code>removeListener</code> 删掉函数，如果在事件触发之前使用 <code>removeListener</code> 删除，传入的是真正的回调 <code>callback</code> 将不存在，无法执行，所以在 <code>once</code> 方法中对真正的 <code>callback</code> 进行了存储，在 <code>removeListener</code> 中调用 <code>filter</code> 时的返回条件的逻辑中做了处理。</p><p><strong>removeAllListeners 方法的实现：</strong></p><pre><code class="lang-js">/* removeAllListeners 方法 */
// 移除全部事件执行程序
EventEmitter.prototype.removeAllListeners = function (type) {
  // 存在 type 清空 _events 对应的数组，否则直接清空 _events
  if (type) {
    this._events[type] = [];
  } else {
    this._events = Object.create(null);
  }
}
</code></pre><h3 id="触发事件监听"><a href="#触发事件监听" class="headerlink" title="触发事件监听"></a>触发事件监听</h3><p>执行事件就比较简单了，取出 <code>_events</code> 中对应类型的数组进行循环，执行内部的每一个函数，第一个参数为 <code>type</code>，后面参数会作为数组中函数执行传入的参数。</p><pre><code class="lang-js">/* emit 方法 */
// 触发事件w
EventEmitter.prototype.emit = function (type, ...args) {
  if (this._events[type]) {
    // 循环执行函数，并将 this 指回 EventEmitter 实例
    this._events[type].forEach(fn =&gt; fn.call(this, ...args));
  }
}
</code></pre><h3 id="获取事件类型名称集合"><a href="#获取事件类型名称集合" class="headerlink" title="获取事件类型名称集合"></a>获取事件类型名称集合</h3><pre><code class="lang-js">/* eventNames 方法 */
// 获取监听的所有事件类型
EventEmitter.prototype.eventNames = function () {
  return Object.keys(this._events);
}
</code></pre><h3 id="按事件类型获取执行程序的集合"><a href="#按事件类型获取执行程序的集合" class="headerlink" title="按事件类型获取执行程序的集合"></a>按事件类型获取执行程序的集合</h3><pre><code class="lang-js">/* listeners 方法 */
// 获取事件类型对应的数组
EventEmitter.prototype.listeners = function (type) {
  return this._events[type];
}
</code></pre><h2 id="EventEmitter-的基本使用"><a href="#EventEmitter-的基本使用" class="headerlink" title="EventEmitter 的基本使用"></a>EventEmitter 的基本使用</h2><p><code>EventEmitter</code> 的核心逻辑已经实现，由于上面大多数方法需要组合使用，所以在没有一一验证，下面让我们通过一些案例来了解 <code>EventEmitter</code> 的用法。</p><p>我们在这里引入自己自定义的 <code>events</code> 模块，并使用 <code>util</code> 模块的 <code>inherits</code> 继承 <code>EventEmitter</code>，下面是前置代码，后面将不在重复。</p><pre><code class="lang-js">/* 文件：events-demo.js */
// 引入依赖
const EventEmitter = require(&#39;./events&#39;);
const util = require(&#39;util&#39;);

function Girl() {}

// 使 Girl 继承 EventEmitter
util.inherits(Girl, EventEmitter);

// 创建 Girl 的实例
const girl = new Girl();
</code></pre><p><strong>案例 1：设置和获取同类型事件的最大监听个数</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
// 获取事件最大监听个数
console.log(girl.getMaxListeners()); // 10

// 设置事件最大监听个数
girl.setMaxListeners(2);
console.log(girl.getMaxListeners()); // 2
</code></pre><p><strong>案例 2：使用 <code>on</code> 添加事件并执行</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));

girl.emit(&#39;失恋&#39;);

// 哭了
// 喝酒
</code></pre><p><strong>案例 3：使用 <code>prependListener</code> 添加事件并执行</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.prependListener(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));

girl.emit(&#39;失恋&#39;);

// 喝酒
// 哭了
</code></pre><p><strong>案例 4：添加 <code>newListener</code> 类型的事件</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;newListener&#39;, (type) =&gt; console.log(type));

girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;));

// 失恋
// 和好
</code></pre><p><strong>案例 5：添加同类型事件超出最大个数并执行事件</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
// 设置事件最大监听个数
girl.setMaxListeners(2);

girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;));

girl.emit(&#39;失恋&#39;);

// MaxListenersExceededWarning: 3 失恋 listeners added
// 哭了
// 喝酒
// 吸烟
</code></pre><p><strong>案例 6：对比 <code>on</code> 和 <code>once</code></strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.once(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));

girl.emit(&#39;失恋&#39;);
girl.emit(&#39;失恋&#39;);

// 哭了
// 喝酒
// 哭了
</code></pre><p><strong>案例 7：移除 <code>on</code> 和 <code>once</code> 添加的事件监听</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
const cry = () =&gt; console.log(&#39;哭了&#39;);
const drink = () =&gt; console.log(&#39;喝酒&#39;);

girl.on(&#39;失恋&#39;, cry);
girl.once(&#39;失恋&#39;, drink);
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;));

girl.removeListener(&#39;失恋&#39;, cry);
girl.removeListener(&#39;失恋&#39;, drink);
girl.emit(&#39;失恋&#39;);

// 吸烟
</code></pre><p><strong>案例 8：使用 <code>prependOnceListener</code> 添加事件监听</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.prependOnceListener(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));

girl.emit(&#39;失恋&#39;);
girl.emit(&#39;失恋&#39;);

// 喝酒
// 哭了
// 哭了
</code></pre><p><strong>案例 9：获取某个事件类型执行程序的集合</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
const cry = () =&gt; console.log(&#39;哭了&#39;);
const drink = () =&gt; console.log(&#39;喝酒&#39;);

girl.on(&#39;失恋&#39;, cry);
girl.once(&#39;失恋&#39;, drink);
girl.once(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;));

console.log(girl.listeners(&#39;失恋&#39;));

// [ [Function: cry], [Function: drink], [Function] ]
</code></pre><p><strong>案例 10：获取所有事件类型名称</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;));

console.log(girl.eventNames());

// [ &#39;失恋&#39;, &#39;和好&#39; ]
</code></pre><p><strong>案例 11：使用 <code>removeAllListeners</code> 按类型移除事件监听</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));
girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;));

// 移除 “失恋” 类型事件监听
girl.removeAllListeners(&#39;失恋&#39;);

console.log(girl.listeners(&#39;失恋&#39;));

// []
</code></pre><p><strong>案例 12：使用 <code>removeAllListeners</code> 移除全部事件监听</strong></p><pre><code class="lang-js">/* 文件：events-demo.js */
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;));
girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;));
girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;));

// 移除全部事件监听
girl.removeAllListeners();

console.log(girl._events);

// {}
</code></pre><h2 id="EventEmitter-总结"><a href="#EventEmitter-总结" class="headerlink" title="EventEmitter 总结"></a>EventEmitter 总结</h2><blockquote class="pullquote success"><p><strong><code>events</code> 模块在 <code>Node.js</code> 中的使用率非常高，很多其他模块的事件执行机制都是通过继承该模块的 <code>EventEmitter</code> 类来实现的，比如 <code>ReadStream</code>（可读流）、<code>WriteStream</code>（可写流）、<code>net</code>（tcp）和 <code>http</code> 等等，包括 <code>Vue</code> 事件机制的 <code>on</code> 和 <code>emit</code> 的实现与 <code>EventEmitter</code> 也非常相似，我们也可以通过上面案例的方式创建自己的类去继承 <code>EventEmitter</code> 来实现事件的管理。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>EventEmitter</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS 模块化简易实现</title>
    <url>/20180626142825/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Node.js/20180626142825/commonjs.png" title="Commonjs"><p><br></p><h2 id="CommonJS-概述"><a href="#CommonJS-概述" class="headerlink" title="CommonJS 概述"></a>CommonJS 概述</h2><blockquote class="pullquote warning"><p><strong><code>CommonJS</code> 是一种模块化的标准，而 <code>Node.js</code> 是这种标准的实现，每个文件就是一个模块，有自己的作用域，在一个模块里面定义的变量、函数、类，都是私有的，不会和其他模块相互污染。</strong></p></blockquote><a id="more"></a><h2 id="Node-js-模块化的简易实现"><a href="#Node-js-模块化的简易实现" class="headerlink" title="Node.js 模块化的简易实现"></a>Node.js 模块化的简易实现</h2><blockquote class="pullquote info"><p><strong>在实现模块加载之前，我们需要清除模块的加载过程：</strong></p><ul><li><strong>假设 <code>A</code> 文件夹下有一个 <code>a.js</code>，我们要解析出一个绝对路径来；</strong></li><li><strong>我们写的路径可能没有后缀名 <code>.js</code>、<code>.json</code>；</strong></li><li><strong>得到一个真实的加载路径（模块会被缓存）先去缓存中看一下这个文件是否存在，如果存在返回缓存 没有则创建一个模块；</strong></li><li><strong>得到对应文件的内容，加一个闭包，把内容塞进去，之后执行即可。</strong></li></ul></blockquote><h3 id="提前加载需要用到的模块"><a href="#提前加载需要用到的模块" class="headerlink" title="提前加载需要用到的模块"></a>提前加载需要用到的模块</h3><p>因为我们只是实现 <code>CommonJS</code> 的模块加载方法，并不会去实现整个 <code>Node.js</code>，但在这里我们需要依赖一些 <code>Node.js</code> 的模块，所以我们就暂且使用 <code>Node</code> 自带的 <code>require</code> 方法把模块加载进来（忽略引入核心模块的 <code>require</code>）。</p><pre><code class="lang-js">/* 依赖模块 */
// 操作文件的模块
const fs = require(&#39;fs&#39;);

// 处理路径的模块
const path = require(&#39;path&#39;);

// 虚拟机，帮我们创建一个黑箱执行代码，防止变量污染
const vm = require(&#39;vm&#39;);
</code></pre><h3 id="创建-Module-构造函数"><a href="#创建-Module-构造函数" class="headerlink" title="创建 Module 构造函数"></a>创建 Module 构造函数</h3><p>其实 <code>CommonJS</code> 中引入的每一个模块我们都需要通过 <code>Module</code> 构造函数创建一个实例。</p><pre><code class="lang-js">/* 创建 Module 构造函数 */
/*
* @param {String} p
*/
function Module(p) {
  this.id = p; // 当前文件的表示（绝对路径）
  this.exports = {}; // 每个模块都有一个 exports 属性，用来存储模块的内容
  this.loaded = false; // 标记是否被加载过
}
</code></pre><h3 id="定义静态属性存储我们需要使用的一些值"><a href="#定义静态属性存储我们需要使用的一些值" class="headerlink" title="定义静态属性存储我们需要使用的一些值"></a>定义静态属性存储我们需要使用的一些值</h3><pre><code class="lang-js">/* Module 静态变量 */
// 函数后面需要使用的闭包的字符串
Module.wrapper = [
  &#39;(function (exports, require, module, __dirname, __filename) {&#39;,
  &#39;\n})&#39;
];

// 根据绝对路径进行缓存的模块的对象
Module._cacheModule = {};

// 处理不同文件后缀名的方法
Module._extensions = {
  &#39;.js&#39;: function () {},
  &#39;.json&#39;: function () {}
};
</code></pre><h3 id="创建引入模块的-req-方法"><a href="#创建引入模块的-req-方法" class="headerlink" title="创建引入模块的 req 方法"></a>创建引入模块的 req 方法</h3><p>为了防止和 <code>Node.js</code> 自带的 <code>require</code> 方法重名，我们将模拟的方法重命名为 <code>req</code>。</p><pre><code class="lang-js">/* 引入模块方法 req */
/*
* @param {String} moduleId
*/
function req(moduleId) {
  // 将 req 传入的参数处理成绝对路径
  const p = Module._resolveFileName(moduleId);

  // 生成一个新的模块
  const module = new Module(p);
}
</code></pre><p>在上面代码中，我们先把传入的参数通过 <code>Module._resolveFileName</code> 处理成了一个绝对路径，并创建模块实例把绝对路径作为参数传入，我们现在实现一下 <code>Module._resolveFileName</code> 方法。</p><h3 id="返回文件绝对路径-Module-resolveFileName-方法的实现"><a href="#返回文件绝对路径-Module-resolveFileName-方法的实现" class="headerlink" title="返回文件绝对路径 Module._resolveFileName 方法的实现"></a>返回文件绝对路径 Module._resolveFileName 方法的实现</h3><p>这个方法的功能就是将 <code>req</code> 方法的参数根据是否有后缀名两种方式处理成带后缀名的文件绝对路径，如果 <code>req</code> 的参数没有后缀名，会去按照 <code>Module._extensions</code> 的键的后缀名顺序进行查找文件，直到找到后缀名对应文件的绝对路径，优先 <code>.js</code>，然后是 <code>.json</code>，这里我们只实现这两种文件类型的处理。</p><pre><code class="lang-js">/* 处理绝对路径 _resolveFileName 方法 */
/*
* @param {String} moduleId
*/
Module._resolveFileName = function (moduleId) {
  // 将参数拼接成绝对路径
  const p = path.resolve(moduleId);

  // 判断是否含有后缀名
  if (!/\.\w+$/.test(p)) {
    // 创建规范规定查找文件后缀名顺序的数组 .js .json
    const arr = Object.keys(Module._extensions);

    // 循环查找
    for (let i = 0; i &lt; arr.length; i++) {
      // 将绝对路径与后缀名进行拼接
      const file = p + arr[i];
      // 查找不到文件时捕获异常
      try {
        // 并通过 fs 模块同步查找文件的方法对改路径进行查找
        // 文件未找到会直接进入 catch 语句
        fs.accessSync(file);

        // 如果找到文件将该文件绝对路径返回
        return file;
      } catch (e) {
        // 当后缀名循环完毕都没有找到对应文件时，抛出异常
        if (i &gt;= arr.length) throw new Error(&#39;not found module&#39;);
      }
    }
  } else {
    // 有后缀名直接返回该绝对路径
    return p;
  }
};
</code></pre><h3 id="加载模块的-load-方法"><a href="#加载模块的-load-方法" class="headerlink" title="加载模块的 load 方法"></a>加载模块的 load 方法</h3><pre><code class="lang-js">/* 完善 req 方法 */
/*
* @param {String} moduleId
*/
function req(moduleId) {
  // 将 req 传入的参数处理成绝对路径
  const p = Module._resolveFileName(moduleId);

  // 生成一个新的模块
  const module = new Module(p);

  // ********** 下面为新增代码 **********
  // 加载模块
  const content = module.load(p);

  // 将加载后返回的内容赋值给模块实例的 exports 属性上
  module.exports = content;

  // 最后返回 模块实例的 exports 属性，即加载模块的内容
  return module.exports;
  // ********** 上面为新增代码 **********
}
</code></pre><p>上面代码实现了一个实例方法 <code>load</code>，传入文件的绝对路径，为模块加载文件的内容，在加载后将值存入模块实例的 <code>exports</code> 属性上最后返回，其实 <code>req</code> 函数返回的就是模块加载回来的内容。</p><pre><code class="lang-js">/* load 方法 */
// 模块加载的方法
Module.prototype.load = function (filepath) {
  // 判断加载的文件是什么后缀名
  const ext = path.extname(filepath);

  // 根据不同的后缀名处理文件内容，参数是当前实例
  const content = Moudule._extensions[ext](this);

  // 将处理后的结果返回
  return content;
};
</code></pre><h3 id="实现加载-js-文件和-json-文件的方法"><a href="#实现加载-js-文件和-json-文件的方法" class="headerlink" title="实现加载 .js 文件和 .json 文件的方法"></a>实现加载 .js 文件和 .json 文件的方法</h3><p>还记得前面准备的静态属性中有 <code>Module._extensions</code> 就是用来存储这两个方法的，下面我们来完善这两个方法。</p><pre><code class="lang-js">/* 处理后缀名方法的 _extensions 对象 */
Module._extensions = {
  &#39;.js&#39;: function (module) {
    // 读取 js 文件，返回文件的内容
    const script = fs.readFileSync(module.id, &#39;utf8&#39;);

    // 给 js 文件的内容增加一个闭包环境
    const fn = Module.wrap(script);

    // 创建虚拟机，将我们创建的 js 函数执行，将 this 指向模块实例的 exports 属性
    vm.runInThisContext(fn).call(
      module.exports,
      module.exports,
      req,
      module
    );

    // 返回模块实例上的 exports 属性（即模块的内容）
    return module.exports;
  },
  &#39;.json&#39;: function (module) {
    // .json 文件的处理相对简单，将读出的字符串转换成对象即可
    return JSON.parse(fs.readFileSync(module.id, &#39;utf8&#39;));
  }
};
</code></pre><p>我们这里使用了 <code>Module.wrap</code> 方法，代码如下，其实帮助我们加了一个闭包环境（即套了一层函数并传入了我们需要的参数），里面所有的变量都是私有的。</p><pre><code class="lang-js">/* 创建闭包 wrap 方法 */
Module.wrap = function (content) {
  return Module.wrapper[0] + content + Module.wrapper[1];
};
</code></pre><p><code>Module.wrapper</code> 的两个值其实就是我们需要在外层包了一个函数的前半段和后半段。</p><blockquote class="pullquote warning"><p><strong>这里我们要划重点了，非常重要：</strong></p><ul><li><strong>我们在虚拟机中执行构建的闭包函数时利用执行上/下文 <code>call</code> 将 <code>this</code> 指向了模块实例的 <code>exports</code> 属性上，所以这也是为什么我们用 <code>node</code> 启动一个 <code>js</code> 文件，打印 <code>this</code> 时，不是全局对象 <code>global</code>，而是一个空对象，这个空对象就是我们的 <code>module.exports</code>，即当前模块实例的 <code>exports</code> 属性。</strong></li><li><strong>还是第一条的函数执行，我们传入的第一个参数是改变 <code>this</code> 指向，那第二个参数是 <code>module.exports</code>，所以在每个模块导出的时候，使用 <code>module.exports = xxx</code>，其实直接替换了模块实例的值，即直接把模块的内容存放在了模块实例的 <code>exports</code> 属性上，而 <code>req</code> 最后返回的就是我们模块导出的内容。</strong></li><li><strong>第三个参数之所以传入 <code>req</code> 是因为我们还可能在一个模块中导入其他模块，而 <code>req</code> 会返回其他模块的导出在当前模块使用，这样整个 <code>CommonJS</code> 的规则就这样建立起来了。</strong></li></ul></blockquote><h3 id="对加载过的模块进行缓存"><a href="#对加载过的模块进行缓存" class="headerlink" title="对加载过的模块进行缓存"></a>对加载过的模块进行缓存</h3><p>我们现在的程序是有问题的，当重复加载了一个已经加载过得模块，当执行 <code>req</code> 方法的时候会发现，又创建了一个新的模块实例，这是不合理的，所以我们下面来实现一下缓存机制。</p><p>还记得之前的一个静态属性 <code>Module._cacheModule</code>，它的值是一个空对象，我们会把所有加载过的模块的实例存储到这个对象上。</p><pre><code class="lang-js">/* 完善 req 方法（处理缓存） */
/*
* @param {String} moduleId
*/
function req(moduleId) {
  // 将 req 传入的参数处理成绝对路径
  const p = Module._resolveFileName(moduleId);

  // ********** 下面为新增代码 **********
  // 判断是否已经加载过
  if (Module._cacheModule[p]) {
    // 模块存在，如果有直接把 exports 对象返回即可
    return Module._cacheModule[p].exprots;
  }
  // ********** 上面为新增代码 **********

  // 生成一个新的模块
  const module = new Module(p);

  // 加载模块
  const content = module.load(p);

  // ********** 下面为新增代码 **********
  // 存储时是拿模块的绝对路径作为键与模块内容相对应的
  Module._cacheModule[p] = module;

  // 是否缓存表示改为 true
  module.loaded = true;
  // ********** 上面为新增代码 **********

  // 将加载后返回的内容赋值给模块实例的 exports 属性上
  module.exports = content;

  // 最后返回 模块实例的 exports 属性，即加载模块的内容
  return module.exports;
}
</code></pre><h3 id="试用-req-加载模块"><a href="#试用-req-加载模块" class="headerlink" title="试用 req 加载模块"></a>试用 req 加载模块</h3><p>在同级目录下新建一个文件 <code>a.js</code>，使用 <code>module.exports</code> 随便导出一些内容，在我们实现模块加载的最下方尝试引入并打印内容。</p><pre><code class="lang-js">/* 导出自定义模块 */
// a.js
module.exports = &#39;Hello world&#39;;
</code></pre><pre><code class="lang-js">/* 检测 req 方法 */
const a = req(&#39;./a&#39;);
console.log(a); // Hello world
</code></pre><h2 id="CommonJS-模块查找规范"><a href="#CommonJS-模块查找规范" class="headerlink" title="CommonJS 模块查找规范"></a>CommonJS 模块查找规范</h2><blockquote class="pullquote primary"><p><strong>其实我们只实现了 <code>CommonJS</code> 规范的一部分，即自定义模块的加载，其实在 <code>CommonJS</code> 的规范当中关于模块查找的规则还有很多，具体的我们就用下面的流程图来表示。</strong></p></blockquote><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Node.js/20180626142825/commonjs-arrow.jpg" alt="CommonJS 模块加载流程图"></div><div class="image-caption">CommonJS 模块加载流程图</div></figure><blockquote class="pullquote success"><p><strong>这篇文章让我们了解了 <code>CommonJS</code> 是什么，主要目的在于理解 <code>Node.js</code> 模块化的实现思路，想要更深入的了解 <code>CommonJS</code> 的实现细节，建议看一看 <code>Node.js</code> 源码对应的部分，如果觉得源码比较多，不容易找到模块化实现的代码，也可以在 <code>VSCode</code> 中通过调用 <code>require</code> 方法引入模块时，打断点调试，一步一步的跟进到 <code>Node.js</code> 源码中查看。</strong></p></blockquote>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>源码分析</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶函数应用 —— 柯里化与反柯里化</title>
    <url>/20180623084025/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20180623084025/curring.png" title="函数柯里化与反柯里化"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>在 <code>JavaScript</code> 中，柯里化和反柯里化是高阶函数的一种应用，在这之前我们应该清楚什么是高阶函数，通俗的说，函数可以作为参数传递到函数中，这个作为参数的函数叫回调函数，而拥有这个参数的函数就是高阶函数，回调函数在高阶函数中调用并传递相应的参数，在高阶函数执行时，由于回调函数的内部逻辑不同，高阶函数的执行结果也不同，非常灵活，也被叫做函数式编程。</strong></p></blockquote><a id="more"></a><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在 <code>JavaScript</code> 中，函数柯里化是函数式编程的重要思想，也是高阶函数中一个重要的应用，其含义是给函数分步传递参数，每次传递部分参数，并返回一个更具体的函数接收剩下的参数，这中间可嵌套多层这样的接收部分参数的函数，直至返回最后结果。</p><h3 id="最基本的柯里化拆分"><a href="#最基本的柯里化拆分" class="headerlink" title="最基本的柯里化拆分"></a>最基本的柯里化拆分</h3><pre><code class="lang-js">/* 柯里化拆分 */
// 原函数
function add(a, b, c) {
  return a + b + c;
}

// 柯里化函数
function addCurrying(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    }
  }
}

// 调用原函数
add(1, 2, 3); // 6

// 调用柯里化函数
addCurrying(1)(2)(3) // 6
</code></pre><p>被柯里化的函数 <code>addCurrying</code> 每次的返回值都为一个函数，并使用下一个参数作为形参，直到三个参数都被传入后，返回的最后一个函数内部执行求和操作，其实是充分的利用了闭包的特性来实现的。</p><h3 id="柯里化通用式"><a href="#柯里化通用式" class="headerlink" title="柯里化通用式"></a>柯里化通用式</h3><p>上面的柯里化函数没涉及到高阶函数，也不具备通用性，无法转换形参个数任意或未知的函数，我们接下来封装一个通用的柯里化转换函数，可以将任意函数转换成柯里化。</p><pre><code class="lang-js">/* 柯里化通用式 ES5 */
function currying(func, args) {
  // 形参个数
  var arity = func.length;
  // 上一次传入的参数
  var args = args || [];

  return function () {
    // 将参数转化为数组
    var _args = [].slice.call(arguments);

    // 将上次的参数与当前参数进行组合并修正传参顺序
    Array.prototype.unshift.apply(_args, args);

    // 如果参数不够，返回闭包函数继续收集参数
    if (_args.length &lt; arity) {
      return currying.call(null, func, _args);
    }

    // 参数够了则直接执行被转化的函数
    return func.apply(null, _args);
  }
}
</code></pre><p>上面主要使用的是 <code>ES5</code> 的语法来实现，大量的使用了 <code>call</code> 和 <code>apply</code>，下面我们通过 <code>ES6</code> 的方式实现功能完全相同的柯里化转换通用式。</p><pre><code class="lang-js">/* 柯里化通用式 ES6 */
function currying(func, args = []) {
  const arity = func.length;

  return function (..._args) {
    _args.unshift(...args);

    if (_args.length &lt; arity) {
      return currying(func, _args);
    }

    return func(..._args);
  }
}
</code></pre><p>函数 <code>currying</code> 算是比较高级的转换柯里化的通用式，可以随意拆分参数，假设一个被转换的函数有多个形参，我们可以在任意环节传入任意个数的参数进行拆分，举一个例子，假如 <code>5</code> 个参数，第一次可以传入 <code>2</code> 个，第二次可以传入 <code>1</code> 个, 第三次可以传入剩下的，也有其他的多种传参和拆分方案，因为在 <code>currying</code> 内部收集参数的同时按照被转换函数的形参顺序进行了更正。</p><p>柯里化的一个很大的好处是可以帮助我们基于一个被转换函数，通过对参数的拆分实现不同功能的函数，如下面的例子。</p><pre><code class="lang-js">/* 柯里化通用式应用 —— 普通函数 */
// 被转换函数，用于检测传入的字符串是否符合正则表达式
function checkFun(reg, str) {
  return reg.test(str);
}

// 转换柯里化
const check = currying(checkFun);

// 产生新的功能函数
const checkPhone = check(/^1[34578]\d{9}$/);
const checkEmail = check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);
</code></pre><p>上面的例子根据一个被转换的函数通过转换变成柯里化函数，并用 <code>check</code> 变量接收，以后每次调用 <code>check</code> 传递不同的正则就会产生一个检测不同类型字符串的功能函数。</p><p>这种使用方式同样适用于被转换函数是高阶函数的情况，比如下面的例子。</p><pre><code class="lang-js">/* 柯里化通用式应用 —— 高阶函数 */
// 被转换函数，按照传入的回调函数对传入的数组进行映射
function mapFun(func, array) {
  return array.map(func);
}

// 转换柯里化
const getNewArray = currying(mapFun);

// 产生新的功能函数
const createPercentArr = getNewArray(item =&gt; item * 100 + &#39;%&#39;);
const createDoubleArr = getNewArray(item =&gt; item * 2);

// 使用新的功能函数
let arr = [1, 2, 3, 4, 5];

let percentArr = createPercentArr(arr);
// [&#39;100%&#39;, &#39;200%&#39;, &#39;300%&#39;, &#39;400%&#39;, &#39;500%&#39;,]

let doubleArr = createDoubleArr(arr);
// [2, 4, 6, 8, 10]
</code></pre><h3 id="柯里化与-bind"><a href="#柯里化与-bind" class="headerlink" title="柯里化与 bind"></a>柯里化与 bind</h3><p><code>bind</code> 方法是经常使用的一个方法，它的作用是帮我们将调用 <code>bind</code> 函数内部的上下文对象 <code>this</code> 替换成我们传递的第一个参数，并将后面其他的参数作为调用 <code>bind</code> 函数的参数。</p><pre><code class="lang-js">/* bind 方法原理模拟 */
Function.prototype.bind = function (context) {
  var self = this;
  var args = [].slice.call(arguments, 1);

  return function () {
    return self.apply(context, args);
  }
}
</code></pre><p>通过上面代码可以看出，其实 <code>bind</code> 方法就是一个柯里化转换函数，将调用 <code>bind</code> 方法的函数进行转换，即通过闭包返回一个柯里化函数，执行该柯里化函数的时候，借用 <code>apply</code> 将调用 <code>bind</code> 的函数的执行上下文转换成了 <code>context</code> 并执行，只是这个转换函数没有那么复杂，没有进行参数拆分，而是函数在调用的时候传入了所有的参数。</p><h2 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h2><p>反柯里化的思想与柯里化正好相反，如果说柯里化的过程是将函数拆分成功能更具体化的函数，那反柯里化的作用则在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。</p><h3 id="反柯里化通用式"><a href="#反柯里化通用式" class="headerlink" title="反柯里化通用式"></a>反柯里化通用式</h3><p>反柯里化通用式的参数为一个希望可以被其他对象调用的方法或函数，通过调用通用式返回一个函数，这个函数的第一个参数为要执行方法的对象，后面的参数为执行这个方法时需要传递的参数。</p><pre><code class="lang-js">/* 反柯里化通用式 ES5 */
function uncurring(fn) {
  return function () {
    // 取出要执行 fn 方法的对象，同时从 arguments 中删除
    var obj = [].shift.call(arguments);
    return fn.apply(obj, arguments);
  }
}
</code></pre><pre><code class="lang-js">/* 反柯里化通用式 ES6 */
function uncurring(fn) {
  return function (...args) {
    return fn.call(...args);
  }
}
</code></pre><p>下面我们通过一个例子来感受一下反柯里化的应用。</p><pre><code class="lang-js">/* 反柯里化通用式应用 */
// 构造函数 F
function F() {}

// 拼接属性值的方法
F.prototype.concatProps = function () {
  let args = Array.from(arguments);
  return args.reduce((prev, next) =&gt; this[prev] + &#39;&amp;&#39; + this[next]);
}

// 使用 concatProps 的对象
const obj = {
  name: &#39;Panda&#39;,
  age: 16
};

// 使用反柯里化进行转化
const concatProps = uncurring(F.prototype.concatProps);

concatProps(obj, &#39;name&#39;, &#39;age&#39;); // Panda&amp;16
</code></pre><p>反柯里化还有另外一个应用，用来代替直接使用 <code>call</code> 和 <code>apply</code>，比如检测数据类型的 <code>Object.prototype.toString</code> 等方法，以往我们使用时是在这个方法后面直接调用 <code>call</code> 更改上下文并传参，如果项目中多处需要对不同的数据类型进行验证是很麻的，常规的解决方案是封装成一个检测数据类型的模块。</p><pre><code class="lang-js">/* 检测数据类型常规方案 */
function checkType(val) {
  return Object.prototype.toString.call(val);
}
</code></pre><p>如果需要这样封装的功能很多就麻烦了，代码量也会随之增大，其实我们也可以使用另一种解决方案，就是利用反柯里化通用式将这个函数转换并将返回的函数用变量接收，这样我们只需要封装一个 <code>uncurring</code> 通用式就可以了。</p><pre><code class="lang-js">/* 反柯里化创建检测类型函数 */
const checkType = uncurring(Object.prototype.toString);

checkType(1); // [object Number]
checkType(&#39;hello&#39;); // [object String]
checkType(true); // [object Boolean]
</code></pre><h3 id="通过函数调用生成反柯里化函数"><a href="#通过函数调用生成反柯里化函数" class="headerlink" title="通过函数调用生成反柯里化函数"></a>通过函数调用生成反柯里化函数</h3><p>在 <code>JavaScript</code> 我们经常使用面向对象的编程方式，在两个类或构造函数之间建立联系实现继承，如果我们对继承的需求仅仅是希望一个构造函数的实例能够使用另一个构造函数原型上的方法，那进行繁琐的继承很浪费，简单的继承父子类的关系又不那么的优雅，还不如之间不存在联系。</p><pre><code class="lang-js">/* 将反柯里化方法扩展到函数原型 */
Function.prototype.uncurring = function () {
  var self = this;
  return function () {
    return Function.prototype.call.apply(self, arguments);
  }
}
</code></pre><p>之前的问题通过上面给函数扩展的 <code>uncurring</code> 方法完全得到了解决，比如下面的例子。</p><pre><code class="lang-js">/* 函数应用反柯里化原型方法 */
// 构造函数
function F() {}

F.prototype.sayHi = function () {
  return &quot;I&#39;m &quot; + this.name + &quot;, &quot; + this.age + &quot; years old.&quot;;
}

// 希望 sayHi 方法被任何对象使用
sayHi = F.prototype.sayHi.uncurring();

sayHi({ name: &#39;Panda&#39;, age: 20}); // I&#39;m Panda, 20 years old.
</code></pre><p>在 <code>Function</code> 的原型对象上扩展的 <code>uncurring</code> 中，难点是理解 <code>Function.prototype.call.apply</code>，我们知道在 <code>call</code> 的源码逻辑中 <code>this</code> 指的是调用它的函数，在 <code>call</code> 内部用第一个参数替换了这个函数中的 <code>this</code>，其余作为形参执行了函数。</p><p>而在 <code>Function.prototype.call.apply</code> 中 <code>apply</code> 的第一个参数更换了 <code>call</code> 中的 <code>this</code>，这个用于更换 <code>this</code> 的就是例子中调用 <code>uncurring</code> 的方法 <code>F.prototype.sayHi</code>，所以等同于 <code>F.prototype.sayHi.call</code>，<code>arguments</code> 内的参数会传入 <code>call</code> 中，而 <code>arguments</code> 的第一项正是用于修改 <code>F.prototype.sayHi</code> 中 <code>this</code> 的对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>高阶函数</tag>
        <tag>柯里化</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas + WebSocket + Redis 实现一个视频弹幕</title>
    <url>/20180621113025/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20180621113025/barrage.png" title="弹幕"><p><br></p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><blockquote class="pullquote info"><p><strong>首先，我们需要实现页面布局，在根目录创建 <code>index.html</code> 布局中需要有一个 <code>video</code> 多媒体标签引入本地视频，添加输入弹幕的输入框、确认发送的按钮、颜色选择器、字体大小滑动条，创建一个 <code>style.css</code> 来调整页面布局的样式，顺便创建一个 <code>index.js</code> 文件用于后续实现核心逻辑，先引入到页面当中。</strong></p></blockquote><a id="more"></a><p><strong>HTML 布局代码如下：</strong></p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
  &lt;title&gt;视频弹幕&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;cantainer&quot;&gt;
    &lt;h2&gt;Canvas + WebSocket + Redis 实现视频弹幕&lt;/h2&gt;
    &lt;div id=&quot;content&quot;&gt;
        &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
        &lt;video id=&quot;video&quot; src=&quot;./barrage.mp4&quot; controls&gt;&lt;/video&gt;
    &lt;/div&gt;
    &lt;!-- 输入弹幕内容 --&gt;
    &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;
    &lt;!-- 添加弹幕按钮 --&gt;
    &lt;button id=&quot;add&quot;&gt;发送&lt;/button&gt;
    &lt;!-- 选择文字颜色 --&gt;
    &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt;
    &lt;!-- 调整字体大小 --&gt;
    &lt;input type=&quot;range&quot; max=&quot;40&quot; min=&quot;20&quot; id=&quot;range&quot;&gt;
  &lt;/div&gt;
  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>CSS 样式代码如下：</strong></p><pre><code class="lang-css">/* 文件：style.css */
#cantainer {
  text-align: center;
}
#content {
  width: 640px;
  margin: 0 auto;
  position: relative;
}
#canvas {
  position: absolute;
}
video {
  width: 640px;
  height: 360px;
}
input {
  vertical-align: middle;
}
</code></pre><p><strong>布局效果如下图：</strong></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/JavaScript/20180621113025/barrage-html.png" alt="弹幕布局"></div><div class="image-caption">弹幕布局</div></figure><h2 id="定义接口，构造假数据"><a href="#定义接口，构造假数据" class="headerlink" title="定义接口，构造假数据"></a>定义接口，构造假数据</h2><p>弹幕中的弹幕数据正常情况下应该是通过与后台数据交互请求回来，所以我们需要先定义数据接口，并构造假数据来实现前端逻辑。</p><blockquote class="pullquote default"><p><strong>数据字段定义：</strong></p><ul><li><strong><code>value</code>：表示弹幕的内容（必填）</strong></li><li><strong><code>time</code>：表示弹幕出现的时间（必填）</strong></li><li><strong><code>speed</code>：表示弹幕移动的速度（选填）</strong></li><li><strong><code>color</code>：表示弹幕文字的颜色（选填）</strong></li><li><strong><code>fontSize</code>：表示弹幕的字体大小（选填）</strong></li><li><strong><code>opacity</code>：表示弹幕文字的透明度（选填）</strong></li></ul></blockquote><p>上面的 <code>value</code> 和 <code>time</code> 是必填参数，其他的选填参数可以在前端设置默认值。</p><p><strong>前端定义的假数据如下：</strong></p><pre><code class="lang-js">/* 文件：index.js */
const data = [
  {
    value: &#39;这是第一条弹幕&#39;,
    speed: 2,
    time: 0,
    color: &#39;red&#39;,
    fontSize: 20
  },
  {
    value: &#39;这是第二条弹幕&#39;,
    time: 1
  }
];
</code></pre><h2 id="实现前端弹幕的逻辑"><a href="#实现前端弹幕的逻辑" class="headerlink" title="实现前端弹幕的逻辑"></a>实现前端弹幕的逻辑</h2><p>我们希望是把弹幕封装成一个功能，只要有需要的地方就可以使用，从而实现复用，那么不同的地方使用这个功能通常的方式是 <code>new</code> 一个实例，传入当前使用该功能对应的参数，我们也使用这种方式来实现，所以我们需要封装一个统一的构造函数或者类，参数为当前的 <code>canvas</code> 元素、<code>video</code> 元素和一个 <code>options</code> 对象，<code>options</code> 里面的 <code>data</code> 属性为我们的弹幕数据，之所以不直接传入 <code>data</code> 是为了后续参数的扩展，严格遵循开放封闭原则，这里我们就统一使用 <code>ES6</code> 的 <code>class</code> 类来实现。</p><h3 id="创建弹幕功能的类及基本参数处理"><a href="#创建弹幕功能的类及基本参数处理" class="headerlink" title="创建弹幕功能的类及基本参数处理"></a>创建弹幕功能的类及基本参数处理</h3><blockquote class="pullquote warning"><p><strong>布局时需要注意 <code>Canvas</code> 的默认宽为 <code>300px</code>，高为 <code>150px</code>，我们要保证 <code>Canvas</code> 完全覆盖整个视频，需要让 <code>Canvas</code> 与 <code>video</code> 宽高相等。</strong><br><strong>因为我们不确定每一个使用该功能的视频的宽高都是一样的，所以 <code>Canvas</code> 画布的宽高并没有通过 CSS 来设置，而是通过 JS 在类创建实例初始化属性的时候动态设置。</strong></p></blockquote><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);
  }
}
</code></pre><p>应该挂在实例上的属性除了有当前的 <code>canvas</code> 元素、<code>video</code> 元素、弹幕数据的默认选项以及弹幕数据之外，还应该有一个代表当前是否渲染弹幕的参数，因为视频暂停的时候，弹幕也是暂停的，所以没有重新渲染，因为是否暂停与弹幕是否渲染的状态是一致的，所以我们这里就用 <code>isPaused</code> 参数来代表当前是否暂停或重新渲染弹幕，值类型为布尔值。</p><h3 id="创建构造每一条弹幕的类"><a href="#创建构造每一条弹幕的类" class="headerlink" title="创建构造每一条弹幕的类"></a>创建构造每一条弹幕的类</h3><p>我们知道，后台返回给我们的弹幕数据是一个数组，这个数组里的每一个弹幕都是一个对象，而对象上有着这条弹幕的信息，如果我们需要在每一个弹幕对象上再加一些新的信息或者在每一个弹幕对象的处理时用到了当前弹幕功能类 <code>CanvasBarrage</code> 实例的一些属性值，取值显然是不太方便的，这样为了后续方便扩展，遵循开放封闭原则，我们把每一个弹幕的对象转变成同一个类的实例，所以我们创建一个名为 <code>Barrage</code> 的类，让我们每一条弹幕的对象进入这个类里面走一遭，挂上一些扩展的属性。</p><pre><code class="lang-js">/* 文件：index.js */
class Barrage {
  constructor(item, ctx) {
    this.value = item.value; // 弹幕的内容
    this.time = item.time; // 弹幕出现的时间
    this.item = item; // 每一个弹幕的数据对象
    this.ctx = ctx; // 弹幕功能类的执行上下文
  }
}
</code></pre><p>在我们的 <code>CanvasBarrage</code> 类上有一个存储弹幕数据的数组 <code>data</code>，此时我们需要给 <code>CanvasBarrage</code> 增加一个属性用来存放 “加工” 后的每条弹幕对应的实例。</p><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // ********** 以下为新增代码 **********
    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));
    // ********** 以上为新增代码 **********
  }
}
</code></pre><p>其实通过上面操作以后，我们相当于把 <code>data</code> 里面的每一条弹幕对象转换成了一个 <code>Barrage</code> 类的一个实例，把当前的上下文 <code>this</code> 传入后可以随时在每一个弹幕实例上获取 <code>CanvasBarrage</code> 类实例的属性，也方便我们后续扩展方法，遵循这种开放封闭原则的方式开发，意义是不言而喻的。</p><h3 id="在-CanvasBarrage-类实现渲染所有弹幕的-render-方法"><a href="#在-CanvasBarrage-类实现渲染所有弹幕的-render-方法" class="headerlink" title="在 CanvasBarrage 类实现渲染所有弹幕的 render 方法"></a>在 CanvasBarrage 类实现渲染所有弹幕的 render 方法</h3><p><code>CanvasBarrage</code> 的 <code>render</code> 方法是在创建弹幕功能实例的时候应该渲染 <code>Canvas</code> 所以应该在 <code>CanvasBarrage</code> 中调用，在 <code>render</code> 内部，每一次渲染之前都应该先将 <code>Canvas</code> 画布清空，所以需要给当前的 <code>CanvasBarrage</code> 类新增一个属性用于存储 <code>Canvas</code> 画布的内容。</p><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));

    // ********** 以下为新增代码 **********
    // Canvas 画布的内容
    this.context = canvas.getContext(&quot;2d&quot;);

    // 渲染所有的弹幕
    this.render();
    // ********** 以上为新增代码 **********
  }

  // ********** 以下为新增代码 **********
  render() {
    // 渲染整个弹幕
    // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 渲染弹幕
    this.renderBarrage();
    if (this.isPaused == false) {
      // 递归渲染
      requestAnimationFrame(this.render.bind(this));
    }
  }
  // ********** 以上为新增代码 **********
}
</code></pre><p>在上面的 <code>CanvasBarrage</code> 的 <code>render</code> 函数中，清空时由于 <code>Canvas</code> 性能比较好，所以将整个画布清空，所以从坐标 <code>(0, 0)</code> 点，清空的宽高为整个 <code>Canvas</code> 画布的宽高。</p><p>只要视频是在播放状态应该不断的调用 <code>render</code> 方法实现清空画布、渲染弹幕、判断是否暂停，如果非暂停状态继续渲染，所以我们用到了递归调用 <code>render</code> 去不断的实现渲染，但是递归时如果直接调用 <code>render</code>，性能特别差，程序甚至会挂掉，以往这种情况我们会在递归外层加一个 <code>setTimeout</code> 来定义一个短暂的递归时间，但是这个过程类似于动画效果，如果使用 <code>setTimeout</code> 其实是将同步代码转成了异步执行，会增加不确定性导致画面出现卡顿的现象。</p><p>这里我们使用 H5 的新 API <code>requestAnimationFrame</code>，可以在平均 <code>1/60 S</code> 内帮我执行一次该方法传入的回调，我们直接把 <code>render</code> 函数作为回调函数传入 <code>requestAnimationFrame</code>，该方法是按照帧的方式执行，动画流畅，需要注意的是，<code>render</code> 函数内使用了 <code>this</code>，所以应该处理一下 <code>this</code> 指向问题。</p><p>由于我们使用面向对象的方式，所以渲染弹幕的具体细节，我们抽离出一个单独的方法 <code>renderBarrage</code>，接下来看一下 <code>renderBarrage</code> 的实现。</p><h3 id="CanvasBarrage-类-render-内部-renderBarrage-的实现"><a href="#CanvasBarrage-类-render-内部-renderBarrage-的实现" class="headerlink" title="CanvasBarrage 类 render 内部 renderBarrage 的实现"></a>CanvasBarrage 类 render 内部 renderBarrage 的实现</h3><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));

    // Canvas 画布的内容
    this.context = canvas.getContext(&#39;2d&#39;);

    // 渲染所有的弹幕
    this.render();
  }
  render() {
    // 渲染整个弹幕
    // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 渲染弹幕
    this.renderBarrage();
    if (this.isPaused == false) {
      // 递归渲染
      requestAnimationFrame(this.render.bind(this));
    }
  }

  // ********** 以下为新增代码 **********
  renderBarrage() {
    // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕
    let time = this.video.currentTime;
    this.barrages.forEach(barrage =&gt; {
      // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）
      if (time &gt;= barrage.time) {
        // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化
        // 节省性能，初始化后再进行绘制
        // 如果没有初始化，先去初始化一下
        if (!barrage.isInited) {
          // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited
          barrage.init();
          barrage.isInited = true;
        }
      }
    });
  }
  // ********** 以上为新增代码 **********
}
</code></pre><p>此处的 <code>renderBarrage</code> 方法内部主要对每一条弹幕实例所设置的出现时间和视频的播放时间做对比，如果视频的播放时间大于等于了弹幕出现的时间，说明弹幕需要绘制在 <code>Canvas</code> 画布内。</p><p>之前我们的每一条弹幕实例的属性可能不全，弹幕的其他未传参数并没有初始化，所以为了最大限度的节省性能，我们在弹幕该第一次绘制的时候去初始化参数，等到视频播放的时间变化再去重新绘制时，不再初始化参数，所以初始化参数的方法放在了判断弹幕出现时间的条件里面执行，又设置了代表弹幕实例是不是初始化了的参数 <code>isInited</code>，初始化函数 <code>init</code> 执行过一次后，马上修改 <code>isInited</code> 的值，保证只初始化参数一次。</p><p>在 <code>renderBarrage</code> 方法中我们可以看出来，其实我们是循环了专门存放每一条弹幕实例（<code>Barrage</code> 类的实例）的数组，我们在内部用实例去调用的方法 <code>init</code> 应该是在 <code>Barrage</code> 类的原型上，下面我们去 <code>Barrage</code> 类上实现 <code>init</code> 的逻辑。</p><h3 id="Barrage-类-init-的实现"><a href="#Barrage-类-init-的实现" class="headerlink" title="Barrage 类 init 的实现"></a>Barrage 类 init 的实现</h3><pre><code class="lang-js">/* 文件：index.js */
class Barrage {
  constructor(item, ctx) {
    this.value = item.value; // 弹幕的内容
    this.time = item.time; // 弹幕出现的时间
    this.item = item; // 每一个弹幕的数据对象
    this.ctx = ctx; // 弹幕功能类的执行上下文
  }

  // ********** 以下为新增代码 **********
  init() {
    this.opacity = this.item.opacity || this.ctx.opacity;
    this.color = this.item.color || this.ctx.color;
    this.fontSize = this.item.fontSize || this.ctx.fontSize;
    this.speed = this.item.speed || this.ctx.speed;

    // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断）
    let span = document.createElement(&#39;span&#39;);

    // 能决定宽度的只有弹幕的内容和文字的大小，和字体
    // 字体默认为微软雅黑，我们就不做设置了
    span.innerText = this.value;
    span.style.font = this.fontSize + &#39;px &quot;Microsoft YaHei&quot;&#39;;

    // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素
    span.style.position = &#39;absolute&#39;;

    document.body.appendChild(span); // 放入页面
    this.width = span.clientWidth; // 记录弹幕的宽度
    document.body.removeChild(span); // 从页面移除

    // 存储弹幕出现的横纵坐标
    this.x = this.ctx.canvas.width;
    this.y = this.ctx.canvas.height;

    // 处理弹幕纵向溢出的边界处理
    if (this.y &lt; this.fontSize) {
      this.y = this.fontSize;
    }
    if (this.y &gt; this.ctx.canvas.height - this.fontSize) {
      this.y = this.ctx.canvas.height - this.fontSize;
    }
  }
  // ********** 以上为新增代码 **********
}
</code></pre><p>在上面代码的 <code>init</code> 方法中我们其实可以看出，每条弹幕实例初始化的时候初始的信息除了之前说的弹幕的基本参数外，还获取了每条弹幕的宽度（用于后续做弹幕是否已经完全移出屏幕的边界判断）和每一条弹幕的 <code>x</code> 和 <code>y</code> 轴方向的坐标并为了防止弹幕在 <code>y</code> 轴显示不全做了边界处理。</p><h3 id="实现每条弹幕的渲染和弹幕移除屏幕的处理"><a href="#实现每条弹幕的渲染和弹幕移除屏幕的处理" class="headerlink" title="实现每条弹幕的渲染和弹幕移除屏幕的处理"></a>实现每条弹幕的渲染和弹幕移除屏幕的处理</h3><p>我们当时在 <code>CanvasBarrage</code> 类的 <code>render</code> 方法中的渲染每个弹幕的方法 <code>renderBarrage</code>中（原谅这么啰嗦，因为到现在内容已经比较多，说的具体一点方便知道是哪个步骤，哈哈）只做了对每一条弹幕实例的初始化操作，并没有渲染在 <code>Canvas</code> 画布中，这时我们主要做两部操作，实现每条弹幕渲染在画布中和左侧移出屏幕不再渲染的边界处理。</p><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));

    // Canvas 画布的内容
    this.context = canvas.getContext(&#39;2d&#39;);

    // 渲染所有的弹幕
    this.render();
  }
  render() {
    // 渲染整个弹幕
    // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 渲染弹幕
    this.renderBarrage();
    if (this.isPaused == false) {
      // 递归渲染
      requestAnimationFrame(this.render.bind(this));
    }
  }
  renderBarrage() {
    // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕
    let time = this.video.currentTime;
    this.barrages.forEach(barrage =&gt; {
      // ********** 以下为改动的代码 **********
      // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）
      if (!barrage.flag &amp;&amp; time &gt;= barrage.time) {
        // ********** 以上为改动的代码 **********

        // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化
        // 节省性能，初始化后再进行绘制
        // 如果没有初始化，先去初始化一下
        if (!barrage.isInited) {
          // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited
          barrage.init();
          barrage.isInited = true;
        }

        // ********** 以下为新增代码 **********
        barrage.x -= barrage.speed;
        barrage.render(); // 渲染该条弹幕
        if (barrage.x &lt; barrage.width * -1) {
          barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作
        }
        // ********** 以上为新增代码 **********
      }
    });
  }
}
</code></pre><p>每个弹幕实例都有一个 <code>speed</code> 属性，该属性代表着弹幕移动的速度，换个说法其实就是每次减少的 <code>x</code> 轴的差值，所以我们其实是通过改变 <code>x</code> 轴的值再重新渲染而实现弹幕的左移，我们创建了一个标识 <code>flag</code> 挂在每个弹幕实例下，代表是否已经离开屏幕，如果离开则更改 <code>flag</code> 的值，使外层的 <code>CanvasBarrage</code> 类的 <code>render</code> 函数再次递归时不进入渲染程序。</p><p>每一条弹幕具体是怎么渲染的，通过代码可以看出每个弹幕实例在 <code>x</code> 坐标改变后都调用了实例方法 <code>render</code> 函数，注意此 <code>render</code> 非彼 <code>render</code>，该 <code>render</code> 函数属于 <code>Barrage</code> 类，目的是为了渲染每一条弹幕，而 <code>CanvasBarrage</code> 类下的 <code>render</code>，是为了在视频时间变化时清空并重新渲染整个 <code>Canvas</code> 画布。</p><h3 id="Barrage-类下的-render-方法的实现"><a href="#Barrage-类下的-render-方法的实现" class="headerlink" title="Barrage 类下的 render 方法的实现"></a>Barrage 类下的 render 方法的实现</h3><pre><code class="lang-js">/* 文件：index.js */
class Barrage {
  constructor(item, ctx) {
    this.value = item.value; // 弹幕的内容
    this.time = item.time; // 弹幕出现的时间
    this.item = item; // 每一个弹幕的数据对象
    this.ctx = ctx; // 弹幕功能类的执行上下文
  }
  init() {
    this.opacity = this.item.opacity || this.ctx.opacity;
    this.color = this.item.color || this.ctx.color;
    this.fontSize = this.item.fontSize || this.ctx.fontSize;
    this.speed = this.item.speed || this.ctx.speed;

    // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断）
    let span = document.createElement(&#39;span&#39;);

    // 能决定宽度的只有弹幕的内容和文字的大小，和字体
    // 字体默认为微软雅黑，我们就不做设置了
    span.innerText = this.value;
    span.style.font = this.fontSize + &#39;px &quot;Microsoft YaHei&#39;;

    // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素
    span.style.position = &#39;absolute&#39;;

    document.body.appendChild(span); // 放入页面
    this.width = span.clientWidth; // 记录弹幕的宽度
    document.body.removeChild(span); // 从页面移除

    // 存储弹幕出现的横纵坐标
    this.x = this.ctx.canvas.width;
    this.y = this.ctx.canvas.height;

    // 处理弹幕纵向溢出的边界处理
    if (this.y &lt; this.fontSize) {
      this.y = this.fontSize;
    }
    if (this.y &gt; this.ctx.canvas.height - this.fontSize) {
      this.y = this.ctx.canvas.height - this.fontSize;
    }
  }

  // ********** 以下为新增代码 **********
  render() {
    this.ctx.context.font = this.fontSize + &#39;px &quot;Microsoft YaHei&quot;&#39;;
    this.ctx.context.fillStyle = this.color;
    this.ctx.context.fillText(this.value, this.x, this.y);
  }
  // ********** 以上为新增代码 **********
}
</code></pre><p>从上面新增代码我们可以看出，其实 <code>Barrage</code> 类的 <code>render</code> 方法只是将每一条弹幕的字号、颜色、内容、坐标等属性通过 <code>Canvas</code> 的 <code>API</code> 添加到了画布上。</p><h3 id="实现播放、暂停事件"><a href="#实现播放、暂停事件" class="headerlink" title="实现播放、暂停事件"></a>实现播放、暂停事件</h3><p>还记得我们的 <code>CanvasBarrage</code> 类里面有一个属性 <code>isPaused</code>，属性值控制了我们是否递归渲染，这个属性与视频暂停的状态是一致的，我们在播放的时候，弹幕不断的清空并重新绘制，当暂停的时候弹幕也应该跟着暂停，说白了就是不在调用 <code>CanvasBarrage</code> 类的 <code>render</code> 方法，其实就是在暂停、播放的过程中不断的改变 <code>isPaused</code> 的值即可。</p><p>还记得我们之前构造的两条假数据 <code>data</code> 吧，接下来我们添加播放、暂停事件，来尝试使用一下我们的弹幕功能。</p><pre><code class="lang-js">/* 文件：index.js */
// 实现一个简易选择器，方便获取元素，后面获取元素直接调用 $
const $ = document.querySelector.bind(document);

// 获取 Canvas 元素和 Video 元素
const canvas = $(&#39;#canvas&#39;);
const video = $(&#39;#video&#39;);

const canvasBarrage = new CanvasBarrage(canvas, video, {
  data
});

// 添加播放事件
video.addEventListener(&#39;play&#39;, function () {
  canvasBarrage.isPaused = false;
  canvasBarrage.render();
});

// 添加暂停事件
video.addEventListener(&#39;pause&#39;, function () {
  canvasBarrage.isPaused = true;
});
</code></pre><h3 id="实现发送弹幕事件"><a href="#实现发送弹幕事件" class="headerlink" title="实现发送弹幕事件"></a>实现发送弹幕事件</h3><pre><code class="lang-js">/* 文件：index.js */
$(&#39;#add&#39;).addEventListener(&#39;click&#39;, function () {
  let time = video.currentTime; // 发送弹幕的时间
  let value = $(&#39;#text&#39;).value; // 发送弹幕的文字
  let color = $(&#39;#color&#39;).value; // 发送弹幕文字的颜色
  let fontSize = $(&#39;#range&#39;).value; // 发送弹幕的字体大小
  let sendObj = { time, value, color, fontSize }; //发送弹幕的参数集合
  canvasBarrage.add(sendObj); // 发送弹幕的方法
});
</code></pre><p>其实我们发送弹幕时，就是向 <code>CanvasBarrage</code> 类的 <code>barrages</code> 数组里添加了一条弹幕的实例，我们单独封装了一个 <code>add</code> 的实例方法。</p><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));

    // Canvas 画布的内容
    this.context = canvas.getContext(&#39;2d&#39;);

    // 渲染所有的弹幕
    this.render();
  }
  render() {
    // 渲染整个弹幕
    // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 渲染弹幕
    this.renderBarrage();
    if (this.isPaused == false) {
      // 递归渲染
      requestAnimationFrame(this.render.bind(this));
    }
  }
  renderBarrage() {
    // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕
    let time = this.video.currentTime;
    this.barrages.forEach(barrage =&gt; {
    // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）
    if (!barrage.flag &amp;&amp; time &gt;= barrage.time) {
        // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化
        // 节省性能，初始化后再进行绘制
        // 如果没有初始化，先去初始化一下
        if (!barrage.isInited) {
          // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited
          barrage.init();
          barrage.isInited = true;
        }

        barrage.x -= barrage.speed;
        barrage.render(); // 渲染该条弹幕
        if (barrage.x &lt; barrage.width * -1) {
          barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作
        }
      }
    });
  }

  // ********** 以下为新增代码 **********
  add(item) {
    this.barrages.push(new Barrage(item, this));
  }
  // ********** 以上为新增代码 **********
}
</code></pre><h3 id="拖动进度条实现弹幕的前进和后退"><a href="#拖动进度条实现弹幕的前进和后退" class="headerlink" title="拖动进度条实现弹幕的前进和后退"></a>拖动进度条实现弹幕的前进和后退</h3><p>其实我们发现，弹幕虽然实现了正常的播放、暂停以及发送，但是当我们拖动进度条的时候弹幕应该是跟着视频时间同步播放的，现在的弹幕一旦播放过无论怎样拉动进度条弹幕都不会再出现，我们现在就来解决这个问题。</p><pre><code class="lang-js">/* 文件：index.js */
// 拖动进度条事件
video.addEventListener(&#39;seeked&#39;, function () {
  canvasBarrage.reset();
});
</code></pre><p>我们在事件内部其实只是调用了一下 <code>CanvasBarrage</code> 类的 <code>reset</code> 方法，这个方法就是在拖动进度条的时候来帮我们初始化弹幕的状态。</p><pre><code class="lang-js">/* 文件：index.js */
class CanvasBarrage {
  constructor(canvas, video, options = {}) {
    // 如果没有传入 canvas 或者 video 直接跳出
    if (!canvas || !video) return;
    this.canvas = canvas; // 当前的 canvas 元素
    this.video = video; // 当前的 video 元素

    // 设置 canvas 与 video 等高
    this.canvas.width = video.clientWidth;
    this.canvas.height = video.clientHeight;

    // 默认暂停播放，表示不渲染弹幕
    this.isPaused = true;

    // 没传参数的默认值
    const defaultOptions = {
      fontSize: 20,
      color: &#39;gold&#39;,
      speed: 2,
      opacity: 0.3,
      data: []
    };

    // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上
    Object.assign(this, defaultOptions, options);

    // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类
    this.barrages = this.data.map(item =&gt; new Barrage(item, this));

    // Canvas 画布的内容
    this.context = canvas.getContext(&#39;2d&#39;);

    // 渲染所有的弹幕
    this.render();
  }
  render() {
    // 渲染整个弹幕
    // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 渲染弹幕
    this.renderBarrage();
    if (this.isPaused == false) {
      // 递归渲染
      requestAnimationFrame(this.render.bind(this));
    }
  }
  renderBarrage() {
    // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕
    let time = this.video.currentTime;
    this.barrages.forEach(barrage =&gt; {
      // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位）
      if (!barrage.flag &amp;&amp; time &gt;= barrage.time) {
        // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化
        // 节省性能，初始化后再进行绘制
        // 如果没有初始化，先去初始化一下
        if (!barrage.isInited) {
          // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited
          barrage.init();
          barrage.isInited = true;
        }

        barrage.x -= barrage.speed;
        barrage.render(); // 渲染该条弹幕
        if (barrage.x &lt; barrage.width * -1) {
          barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作
        }
      }
    });
  }
  add(item) {
    this.barrages.push(new Barrage(item, this));
  }

  // ********** 以下为新增代码 **********
  reset() {
    // 先清空 Canvas 画布
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    let time = this.video.currentTime;
    // 循环每一条弹幕实例
    this.barrages.forEach(barrage =&gt; {
      // 更改已经移出屏幕的弹幕状态
      barrage.flag = false;
      // 当拖动到的时间小于等于当前弹幕时间是，重新初始化弹幕的数据，实现渲染
      if (time &lt;= barrage.time) {
        barrage.isInited = false;
      } else {
        barrage.flag = true; // 否则将弹幕的状态设置为以移出屏幕
      }
    });
  }
  // ********** 以上为新增代码 **********
}
</code></pre><blockquote class="pullquote danger"><p><strong>其实 <code>reset</code> 方法中值做了几件事，从而实现了拖动进度条弹幕的 “前进” 和 “后退” 功能。</strong></p><ul><li><strong>清空 <code>Canvas</code> 画布；</strong></li><li><strong>获取当前进度条拖动位置的时间；</strong></li><li><strong>循环存储弹幕实例的数组；</strong></li><li><strong>将所有弹幕更改为未移出屏幕；</strong></li><li><strong>判断拖动时间和每条弹幕的时间；</strong></li><li><strong>在当前时间以后的弹幕重新初始化数据；</strong></li><li><strong>以前的弹幕更改为已移出屏幕。</strong></li></ul></blockquote><h2 id="使用-WebSocket-和-Redis-实现前后端通信及数据存储"><a href="#使用-WebSocket-和-Redis-实现前后端通信及数据存储" class="headerlink" title="使用 WebSocket 和 Redis 实现前后端通信及数据存储"></a>使用 WebSocket 和 Redis 实现前后端通信及数据存储</h2><h3 id="服务器代码的实现"><a href="#服务器代码的实现" class="headerlink" title="服务器代码的实现"></a>服务器代码的实现</h3><p>要使用 <code>WebSocket</code> 和 <code>Redis</code> 首先需要去安装 <code>ws</code>、<code>redis</code> 依赖，在项目根目录执行下面命令：</p><pre><code class="lang-bash">$ npm install ws redis
</code></pre><p>我们创建一个 <code>server.js</code> 文件，用来写服务端的代码：</p><pre><code class="lang-js">/* 文件：index.js */
const WebSocket = require(&#39;ws&#39;); // 引入 WebSocket
const redis = require(&#39;redis&#39;); // 引入 redis

// 初始化 WebSocket 服务器，端口号为 3000
const wss = new WebSocket.Server({
  port: 3000
});

// 创建 redis 客户端
const client = redis.createClient(); // key value

// 原生的 websocket 就两个常用的方法 on(&#39;message&#39;)、on(&#39;send&#39;)
wss.on(&#39;connection&#39;, function (ws) {
  // 监听连接
  // 连接上需要立即把 redis 数据库的数据取出返回给前端
  client.lrange(&#39;barrages&#39;, 0, -1, function (err, applies) {
    // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象
    applies = applies.map(item =&gt; JSON.parse(item));

    // 使用 websocket 服务器将 redis 数据库的数据发送给前端
    // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串
    ws.send(JSON.stringify({
      type: &#39;INIT&#39;,
      data: applies
    }));
  });

  // 当服务器收到消息时，将数据存入 redis 数据库
  ws.on(&#39;message&#39;, function (data) {
    // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库
    client.rpush(&#39;barrages&#39;, data, redis.print);

    // 再将当前这条数据返回给前端
    // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串
    ws.send(JSON.stringify({
      type: &#39;ADD&#39;,
      data: JSON.parse(data)
    }));
  });
});
</code></pre><p>服务器的逻辑很清晰，在 <code>WebSocket</code> 连接上时，立即获取 <code>Redis</code> 数据库的所有弹幕数据返回给前端，当前端点击发送弹幕按钮发送数据时，接收数据存入 <code>Redis</code> 数据库中并打印验证数据是否成功存入，再通过 <code>WebSocket</code> 服务把当前这一条数返回给前端，需要注意一下几点：</p><blockquote class="pullquote info"><ul><li><strong>从 <code>Redis</code> 数据库中取出全部弹幕数据的数组内部都存储的是字符串，需要使用 <code>JSON.parse</code> 方法进行解析；</strong></li><li><strong>将数据发送前端时，最外层要使用 <code>JSON.stringify</code> 重新转换成字符串发送；</strong></li><li><strong>在初始化阶段 <code>WebSocket</code> 发送所有数据和前端添加新弹幕 <code>WebSocket</code> 将弹幕的单条数据重新返回时，需要添加对应的 <code>type</code> 值告诉前端，当前的操作行为。</strong></li></ul></blockquote><h3 id="前端代码的修改"><a href="#前端代码的修改" class="headerlink" title="前端代码的修改"></a>前端代码的修改</h3><p>在没有实现后端代码之前，前端使用的是 <code>data</code> 的假数据，是在添加弹幕事件中，将获取的新增弹幕信息通过 <code>CanvasBarrage</code> 类的 <code>add</code> 方法直接创建 <code>Barrage</code> 类的实例，并加入到存放弹幕实例的 <code>barrages</code> 数组中。</p><p>现在我们需要更正一下交互逻辑，在发送弹幕事件触发时，我们应该先将获取的单条弹幕数据通过 <code>WebSocket</code> 发送给后端服务器，在服务器重新将消息返还给我们的时候，去将这条数据通过 <code>CanvasBarrage</code> 类的 <code>add</code> 方法加入到存放弹幕实例的 <code>barrages</code> 数组中。</p><p>还有在页面初始化时，我们之前在创建 <code>CanvasBarrage</code> 类实例的时候直接传入了 <code>data</code> 假数据，现在需要通过 <code>WebSocket</code> 的连接事件，在监听到连接 <code>WebSocket</code> 服务时，去创建 <code>CanvasBarrage</code> 类的实例，并直接把服务端返回 Redis 数据库真实的数据作为参数传入，前端代码修改如下：</p><pre><code class="lang-js">/* 文件：index.js */
// ********** 下面代码被删掉了 **********
// let canvasBarrage = new CanvasBarrage(canvas, video, {
//     data
// });
// ********** 上面代码被删掉了 **********

// ********** 以下为新增代码 **********
let canvasBarrage;

// 创建 WebSocket 连接
const socket = new WebSocket(&#39;ws://localhost:3000&#39;);

// 监听连接事件
socket.onopen = function () {
  // 监听消息
  socket.onmessage = function (e) {
    // 将收到的消息从字符串转换成对象
    let message = JSON.parse(e.data);

    // 根据不同情况判断是初始化还是发送弹幕
    if (message.type === &#39;INIT&#39;) {
      // 创建 CanvasBarrage 的实例添加弹幕功能，传入真实的数据
      canvasBarrage = new CanvasBarrage(canvas, video, {
        data: message.data
      });
    } else if (message.type === &#39;ADD&#39;) {
      // 如果是添加弹幕直接将 WebSocket 返回的单条弹幕存入 barrages 中
      canvasBarrage.add(message.data);
    }
  }
}
// ********** 以上为新增代码 **********

$(&#39;#add&#39;).addEventListener(&#39;click&#39;, function () {
  let time = video.currentTime; // 发送弹幕的时间
  let value = $(&#39;#text&#39;).value; // 发送弹幕的文字
  let color = $(&#39;#color&#39;).value; // 发送弹幕文字的颜色
  let fontSize = $(&#39;#range&#39;).value; // 发送弹幕的字体大小
  let sendObj = { time, value, color, fontSize }; //发送弹幕的参数集合

  // ********** 以下为新增代码 **********
  socket.send(JSON.stringify(sendObj));
  // ********** 以上为新增代码 **********

  // ********** 下面代码被删掉了 **********
  // canvasBarrage.add(sendObj); // 发送弹幕的方法
  // ********** 上面代码被删掉了 **********
});
</code></pre><p>现在我们可以打开 <code>index.html</code> 文件并启动 <code>server.js</code> 服务器，就可以实现真实的视频弹幕操作了，但是我们还是差了最后一步，当前的服务只能同时服务一个人，但真实的场景是同时看视频的有很多人，而且发送的弹幕是共享的。</p><h3 id="实现多端通信、弹幕共享"><a href="#实现多端通信、弹幕共享" class="headerlink" title="实现多端通信、弹幕共享"></a>实现多端通信、弹幕共享</h3><blockquote class="pullquote warning"><p><strong>我们需要处理两件事情：</strong></p><ul><li><strong>第一件事情是实现多端通信共享数据库信息；</strong></li><li><strong>第二件事情是当有人离开的时候清除关闭的 WebSocket 对象。</strong></li></ul></blockquote><pre><code class="lang-js">/* 文件：server.js */
const WebSocket = require(&#39;ws&#39;); // 引入 WebSocket
const redis = require(&#39;redis&#39;); // 引入 redis

// 初始化 WebSocket 服务器，端口号为 3000
const wss = new WebSocket.Server({
    port: 3000
});

// 创建 redis 客户端
const client = redis.createClient(); // key value

// ********** 以下为新增代码 **********
// 存储所有 WebSocket 用户
const clientsArr = [];
// ********** 以上为新增代码 **********

// 原生的 websocket 就两个常用的方法 on(&#39;message&#39;)、on(&#39;send&#39;)
wss.on(&#39;connection&#39;, function (ws) {
  // ********** 以下为新增代码 **********
  // 将所有通过 WebSocket 连接的用户存入数组中
  clientsArr.push(ws);
  // ********** 以上为新增代码 **********

  // 监听连接
  // 连接上需要立即把 redis 数据库的数据取出返回给前端
  client.lrange(&#39;barrages&#39;, 0, -1, function (err, applies) {
    // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象
    applies = applies.map(item =&gt; JSON.parse(item));

    // 使用 websocket 服务器将 redis 数据库的数据发送给前端
    // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串
    ws.send(JSON.stringify({
      type: &#39;INIT&#39;,
      data: applies
    }));
  });

  // 当服务器收到消息时，将数据存入 redis 数据库
  ws.on(&#39;message&#39;, function (data) {
    // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库
    client.rpush(&#39;barrages&#39;, data, redis.print);

    // ********** 以下为修改后的代码 **********
    // 循环数组，将某一个人新发送的弹幕在存储到 Redis 之后返回给所有用户
    clientsArr.forEach(w =&gt; {
      // 再将当前这条数据返回给前端
      // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串
      w.send(JSON.stringify({
        type: &#39;ADD&#39;,
        data: JSON.parse(data)
      }));
    });
    // ********** 以上为修改后的代码 **********
  });

  // ********** 以下为新增代码 **********
  // 监听关闭连接事件
  ws.on(&#39;close&#39;, function () {
    // 当某一个人关闭连接离开时，将这个人从当前存储用户的数组中移除
    clientsArr = clientsArr.filter(client =&gt; client != ws);
  });
  // ********** 以上为新增代码 **********
});
</code></pre><blockquote class="pullquote success"><p><strong>上面就是 <code>Canvas + WebSocket + Redis</code> 视频弹幕的实现，实现过程可能有些复杂，但整个过程写的还是比较详细，可能需要一定的耐心慢慢的读完，并最好一步一步跟着写一写，希望这篇文章可以让读到的人解决视频弹幕类似的需求，真正理解整个过程和开放封闭原则，认识到前端面向对象编程思想的美。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>Canvas</tag>
        <tag>WebSocket</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>异步发展流程 —— 异步编程 async/await</title>
    <url>/20180615212040/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Async/20180615212040/async-await.jpg" title="async&#x2F;await"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这篇文章是异步发展流程系列的最后一篇，可能会涉及 <code>Promise</code>、<code>Generators</code>、<code>co</code> 等前置知识，如果对这些不是很了解可以看这个系列的前三篇：</strong></p><ul><li><a href="/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a></li><li><a href="/20180613193626/" target="_blank">异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</a></li><li><a href="/20180614161413/" target="_blank">异步发展流程 —— Generators + co 让异步更优雅</a></li></ul><p><strong>如果已经具备这些前置知识，那我们继续看看今天的主角，<code>JavaScript</code> 异步编程的终极大招 <code>async/await</code>。</strong></p></blockquote><a id="more"></a><h2 id="async-await-简介"><a href="#async-await-简介" class="headerlink" title="async/await 简介"></a>async/await 简介</h2><blockquote class="pullquote danger"><p><strong><code>async/await</code> 指的是两个关键字，是 <code>ES7</code> 引入的新标准，<code>async</code> 关键字用于声明 <code>async</code> 函数，<code>await</code> 关键字用来等待异步（必须是 <code>Promise</code> 实例）操作，说白了 <code>async/await</code> 就是 <code>Generators + co</code> 的语法糖。</strong></p></blockquote><p><code>async/await</code> 和 <code>Generators + co</code> 的写法非常的相似，只是把用于声明 <code>Generator</code> 函数的 <code>*</code> 关键字替换成了 <code>async</code> 并写在了 <code>function</code> 关键字的前面，把 <code>yield</code> 关键字替换成了 <code>await</code>；另外，<code>async</code> 函数是基于 <code>Promise</code> 的，<code>await</code> 关键字后面等待的异步操作必须是一个 <code>Promise</code> 实例或基本类型的值，基本类型值的执行效果等同于同步，与 <code>Generator</code> 不同的是，<code>await</code> 关键字前可以使用变量去接收这个正在等待的 <code>Promise</code> 实例执行后的结果。</p><h2 id="async-函数的基本用法"><a href="#async-函数的基本用法" class="headerlink" title="async 函数的基本用法"></a>async 函数的基本用法</h2><blockquote class="pullquote info"><p><strong><code>async</code> 函数返回一个 <code>Promise</code> 实例，可以使用 <code>then</code> 方法添加回调函数。当函数执行的时候，只要遇到 <code>await</code> 就会等待，直到 <code>await</code> 后面的同步或异步操作完成，再接着执行函数体内后面的语句。</strong></p></blockquote><h3 id="async-函数声明"><a href="#async-函数声明" class="headerlink" title="async 函数声明"></a>async 函数声明</h3><p><code>async</code> 的声明方式大概有以下几种：</p><pre><code class="lang-js">/* async 函数声明 */
// 函数声明
async function fn() {}

// 函数表达式
const fn = async function () {};

// 箭头函数
const fn = async () =&gt; {};

// 作为对象的方法
const obj = {
  async fn() {}
};

// 作为 class 的方法
class Person(name) {
  constructor () {
    this.name = name;
  }
  async getName() {
    const name = await this.name;
    return name;
  }
}
</code></pre><p>在上一篇介绍 <code>Generators + co</code> 的文章中我们举了一个例子，使用 <code>Node.js</code> 的 <code>fs</code> 模块连续异步读文件，第一个文件名为 <code>a.txt</code>，读到的内容为 <code>b.txt</code>，作为要读的第二个文件的文件名，继续读 <code>b.txt</code> 后将读到的内容 “Hello world” 打印出来。</p><p>我们来使用 <code>async/await</code> 的方式来实现一下：</p><pre><code class="lang-js">/* async 函数实现文件读取 */
// 引入依赖
const fs = require(&#39;fs&#39;);
const util = require(&#39;util&#39;);

// 将 fs.readFile 转换成 Promise
const readFile = util.promisify(fs.readFile);

// 声明 async 函数
async function read(file) {
  const aData = await readFile(file, &#39;utf8&#39;);
  const bData = await readFile(aData, &#39;utf8&#39;);
  return bData;
}

// 调用 async 函数
read(&#39;a.txt&#39;).then(data =&gt; {
  console.log(data); // Hello world
});
</code></pre><p>其实对比上一篇文章 <code>Generator</code> 的案例，与 <code>Generator</code> 函数一样，写法像同步，执行是异步，不同的是我们即没有手动调用 <code>next</code> 方法，也没有借助 <code>co</code> 库，其实是 <code>async</code> 函数内部集成了类似于 <code>co</code> 的执行器，帮我们在异步完成后自动向下执行代码，所以说 <code>async/await</code> 是 <code>Generators + co</code> 的语法糖。</p><h3 id="async-函数错误处理"><a href="#async-函数错误处理" class="headerlink" title="async 函数错误处理"></a>async 函数错误处理</h3><blockquote class="pullquote success"><p><strong><code>async</code> 函数内部如果执行错误可以有三种方式进行错误处理：</strong></p><ul><li><strong>在 <code>await</code> 后面的 <code>Promise</code> 实例使用 <code>then</code> 方法错误回调或 <code>catch</code> 方法进行错误处理；</strong></li><li><strong>如果有多个 <code>await</code>，可以在 <code>async</code> 函数执行完后使用 <code>catch</code> 方法统一处理；</strong></li><li><strong>由于 <code>async</code> 内部代码是同步的写法，多个 <code>await</code> 的情况也可以使用 <code>try...catch...</code> 进行处理。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>需要注意的是，如果在 <code>async</code> 函数内部使用了 <code>try...catch...</code> 又在函数执行完后使用了 <code>catch</code>，错误会优先被同步的 <code>try...catch...</code> 捕获到，后面的 <code>catch</code> 就不会再捕获了。</strong></p></blockquote><pre><code class="lang-js">/* async 函数异常捕获 */
// 第一种
async function fn() {
  const result = await Promise.reject(&#39;error&#39;).catch(err =&gt; {
    console.log(err);
  });
}

fn(); // error

// 第二种
async function fn() {
  try {
    const val1 = await Promise.reject(&#39;error&#39;);
    const val2 = await Promise.resolve(&#39;success&#39;);
  } catch (e) {
    console.log(e);
  }
}

fn(); // error

// 第三种
async function fn() {
  const val1 = await Promise.resolve(&#39;success&#39;);
  const val2 = await Promise.reject(&#39;error&#39;);
}

fn().catch((err =&gt; console.log(err))); // error
</code></pre><h3 id="await-异步并发"><a href="#await-异步并发" class="headerlink" title="await 异步并发"></a>await 异步并发</h3><p>在 <code>async</code> 函数中，如果有多个 <code>await</code> 互不依赖，这种情况下如果执行一个，等待一个完成，再执行一个，再等待完成，这样是很浪费性能的，所以我们要把这些异步操作同时触发。</p><p>假设我们异步读取两个文件，且这两个文件不相关，我可以使用下面的方式来实现：</p><pre><code class="lang-js">/* await 异步并发 */
// 前置
const fs = require(&#39;fs&#39;);
const util = require(&#39;util&#39;);
const readFile = util.promisify(fs.readFile);

// 需要改进的 async 函数
async function fn() {
  const aData = await readFile(&#39;a.txt&#39;, &#39;utf8&#39;);
  const bData = await readFile(&#39;b.txt&#39;, &#39;utf8&#39;);
  return [aData, bData];
}

fn();

// 在 async 函数外部触发异步
const aDataPromise = readFile(&#39;a.txt&#39;, &#39;utf8&#39;);
const bDataPromise = readFile(&#39;b.txt&#39;, &#39;utf8&#39;);

async function fn() {
  const aData = await aDataPromise;
  const bData = await bDataPromise;
  return [aData, bData];
}

fn();

// 使用 Promise.all
async function fn() {
  const dataArr = await Promise.all(
    readFile(&#39;a.txt&#39;, &#39;utf8&#39;),
    readFile(&#39;a.txt&#39;, &#39;utf8&#39;)
  );
  return dataArr;
}

fn();
</code></pre><h3 id="使用-async-await-的注意点"><a href="#使用-async-await-的注意点" class="headerlink" title="使用 async/await 的注意点"></a>使用 async/await 的注意点</h3><blockquote class="pullquote info"><p><strong>使用 <code>async/await</code> 应注意以下几点：</strong></p><ul><li><strong>对 <code>await</code> 习惯性错误处理；</strong></li><li><strong><code>await</code> 命令后互不依赖的异步应同时触发；</strong></li><li><strong><code>async</code> 函数中，函数的执行上/下文发生变化时，不能使用 <code>await</code>（如使用 <code>forEach</code> 循环的回调中）。</strong></li></ul></blockquote><p>针对第一点，在 <code>async</code> 函数中 <code>await</code> 命令后面大多情况下是 <code>Promise</code> 异步操作，运行结果可能出现错误并调用 <code>reject</code> 函数，最好对这个 <code>await</code> 语句进行错误处理，具体方式参照 <code>async</code> 函数基本用法中关于错误处理的内容。</p><p>针对第二点，如果两个或多个 <code>await</code> 命令后的异步操作没有依赖关系，执行时，需先触发第一个，等待异步完成，再触发第二个，再等异步完成，依次类推，这样比较耗时，性能不好，所以应该将这些异步操作同时触发，触发方式参照 <code>async</code> 函数基本用法中的 <code>await</code> 异步并发的内容。</p><p>针对第三点，如果声明一个 <code>async</code> 函数并传入一个数组，数组里面存储的都是 <code>Promise</code> 实例，若使用 <code>forEach</code> 循环数组，由于函数的执行上/下文发生了变化，此时使用 <code>await</code> 命令会报错。</p><pre><code class="lang-js">/* 循环内使用 await */
// 创建 Promise 实例
const p1 = Promise.resolve(&#39;p1 success&#39;);
const p2 = Promise.resolve(&#39;p2 success&#39;);
const p3 = Promise.resolve(&#39;p3 success&#39;);

// async 函数
async function fn(promises) {
  promise.forEach(function (promise) {
    await promise;
  });
}

fn([p1, p2, p3]); // 执行时报错

// 修改方式
async function fn(promises) {
  for (let i = 0; i &lt; promises.length; i++) {
    await pormises[i];
  }
}

fn([p1, p2, p3]); // 正常执行
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>async/await</code> 的实现原理，其实就是在 <code>async</code> 函数内部逻辑映射成了 <code>Generator</code> 函数并集成了一个类似于 <code>co</code> 的执行器，所以我们使用 <code>async/await</code> 的时候，代码更简洁，没有了自己触发遍历器的 <code>next</code> 或调用 <code>co</code> 充当执行器的过程，只需要关心 <code>async</code> 函数的内部逻辑就可以了，因为写法与同步相同，更提高了代码的可读性，所以说 <code>async/await</code> 是异步编程的终极大招。</p><blockquote class="pullquote warning"><p><strong>由于 <code>async/await</code> 是 <code>ES7</code> 规范，在浏览器端的支持并不是那么的友好，所以现在这种写法多用在 <code>Node.js</code> 的异步操作当中，在 <code>Node.js</code> 框架 <code>Koa 2.x</code> 版本得到广泛应用。</strong></p></blockquote><blockquote class="pullquote success"><p><strong>最后希望大家在读过异步发展流程这个系列之后，对 <code>JavaScript</code> 异步已经有了较深的认识，并可以在不同情况下游刃有余的使用这些处理异步的编程手段。</strong></p></blockquote>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>Node.js</tag>
        <tag>ES7</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>异步发展流程 —— Generators + co 让异步更优雅</title>
    <url>/20180614161413/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Async/20180614161413/generators.png" title="Generators + Co"><p><br></p><h2 id="Generators-简介"><a href="#Generators-简介" class="headerlink" title="Generators 简介"></a>Generators 简介</h2><blockquote class="pullquote warning"><p><strong><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案，是一个生成器，用于生成一个遍历器的函数，语法行为与传统函数完全不同。</strong></p></blockquote><a id="more"></a><h2 id="Iterator-遍历器"><a href="#Iterator-遍历器" class="headerlink" title="Iterator 遍历器"></a>Iterator 遍历器</h2><p><code>JavaScript</code> 原有的表示 “集合” 的数据结构，主要有 <code>Array</code> 和 <code>Object</code>，在 <code>ES6</code> 中又加入了 <code>Set</code> 和 <code>Map</code>，这样就有了四种数据集合，还可以组合使用它们，如数组的成员是 <code>Map</code> 或 <code>Object</code>，这样就需要一种统一的接口机制，用来处理所有不同的数据结构。</p><p>遍历器 <code>Iterator</code> 就是这样一种机制，它是一种接口，为不同的数据结构提供统一的、简便的访问机制，任何数据结构只要部署了 <code>Iterator</code> 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员。</p><p><code>Iterator</code> 遍历器其实就是一个指针对象，上面有 <code>next</code> 方法，第一次调用 <code>next</code> 指针指向数据结构的第一个成员，第二次 <code>next</code> 调用指针指向第二个成员，直到指针指向最后一个成员。</p><p>我们可以使用 <code>ES6</code> 的展开运算符 <code>...</code> 和 <code>for...of...</code> 去遍历带有 <code>Iterator</code> 接口的数据结构，需要注意的是，<code>Object</code> 本身不具备 <code>Iterator</code> 接口，所以我们无法通过 <code>...</code> 把一个对象扩展到一个数组中，并且会报错，我们可以通过代码手动将 <code>Object</code> 类型实现 <code>Iterator</code> 接口。</p><pre><code class="lang-js">/* 给对象扩展 Iterator 接口 */
// 通过 Generator 函数给 Object 扩展 Iterator 接口
Object.prototype[Symbol.iterator] = function* () {
  for (var key in this) {
    yield this[key];
  }
}

// 测试 Iterator 接口
const obj = {
  a: 1,
  b: 2,
  c: 3
};

const arr = [...obj];

console.log(arr); // [1, 2, 3]
</code></pre><p>上面我们其实是通过 <code>ES6</code> 的 <code>Generator</code> 函数简单粗暴的给 <code>Object</code> 类型实现了 <code>Iterator</code> 接口，后面我们会简单模拟 <code>Generator</code> 生成器。</p><h2 id="模拟-Generator"><a href="#模拟-Generator" class="headerlink" title="模拟 Generator"></a>模拟 Generator</h2><p><code>Generator</code> 函数是一个生成器，调用后会返回给我们一个 <code>Iterator</code> 遍历器对象，在对象中有一个 <code>next</code> 方法，调用一次 <code>next</code>，帮我遍历一次，返回值为一个对象，内部有 <code>value</code> 和 <code>done</code> 两个属性，<code>value</code> 属性代表当前遍历的值，<code>done</code> 属性代表是否遍历完成，如果遍历完成后继续调用 <code>next</code>，返回的对象中 <code>value</code> 属性值为 <code>undefined</code>，<code>done</code> 属性值为 <code>true</code>，这个遍历器在进行数据遍历时更像给我们提供了一个暂停功能，每次都需要手动调用 <code>next</code> 去进行下一次遍历。</p><p>我们根据 <code>Generator</code> 的特性用 <code>ES5</code> 简单模拟一个遍历器生成函数：</p><pre><code class="lang-js">/* 模拟遍历器生成函数 */
function iterator(arr) {
  var i = 0;

  return {
    next: function () {
      var done = i &gt;= arr.length;
      var value = !done ? arr[i++] : undefined;

      return {
        value: value,
        done: done
      };
    }
  };
}
</code></pre><p>测试一下模拟的遍历器生成函数：</p><pre><code class="lang-js">/* 测试 iterator 函数 */
var arr = [1, 3, 5];

// 遍历器
var result = iterator(arr);

result.next(); // {value: 1, done: false}
result.next(); // {value: 3, done: false}
result.next(); // {value: 5, done: false}
result.next(); // {value: undefined, done: true}
</code></pre><h2 id="Generator-的基本使用"><a href="#Generator-的基本使用" class="headerlink" title="Generator 的基本使用"></a>Generator 的基本使用</h2><p>在普通的函数 <code>function</code> 关键字后加一个 <code>*</code> 就代表声明了一个生成器函数，执行后返回一个遍历器对象，每次调用遍历器的 <code>next</code> 方法时，遇到 <code>yield</code> 关键字暂停执行，并将 <code>yield</code> 关键字后面的值会作为返回对象中 <code>value</code> 的值，如果函数有返回值，会把返回值作为调用 <code>next</code> 方法进行遍历完成后返回的对象中 <code>value</code> 的值，果已经遍历完成，再次 <code>next</code> 调用这个 <code>value</code> 的值会变成 <code>undefined</code>。</p><pre><code class="lang-js">// 生成器函数
function* gen() {
  yield 1;
  yield 2;
  return 3;
}

// 遍历器
const it = gen();

it.next(); // {value: 1, done: false}
it.next(); // {value: 2, done: false}
it.next(); // {value: 3, done: true}
it.next(); // {value: undefined, done: true}
</code></pre><blockquote class="pullquote info"><p><strong>在 <code>Generator</code> 函数中可以使用变量接收 <code>yield</code> 关键字执行后的返回值，只是接收的值并不是 <code>yield</code> 关键字后面表达式执行的结果，而是遍历器在下一次调用 <code>next</code> 方法时传入的参数。</strong></p></blockquote><p>也就是说我们第一次调用 <code>next</code> 方法进行遍历时是不需要传递参数的，因为上面并没有变量来接收它，即使传参也会被忽略掉，我们用一个例子感受一下这种比较特殊的执行机制：</p><pre><code class="lang-js">// 生成器函数
function* gen() {
  const a = yield 1;
  const b = yield a;
  const c = yield b;
  return c;
}

// 遍历器
const it = gen();

it.next(); // {value: 1, done: false}
it.next(2); // {value: 2, done: false}
it.next(3); // {value: 3, done: false}
it.next(4); // {value: 4, done: true}
it.next(5); // {value: undefined, done: true}
</code></pre><p>如果已经遍历完成，并把上次遍历接收到的值作为返回值传递给返回对象 <code>value</code> 属性的值，后面再次调用 <code>next</code> 传入的参数也会被忽略，返回对象的 <code>value</code> 值为 <code>undefined</code>。</p><blockquote class="pullquote warning"><p><strong>在 <code>Generator</code> 函数中，如果在其他函数或方法调用的回调内部（函数的执行上/下文发生变化）不能直接使用 <code>yield</code> 关键字。</strong></p></blockquote><pre><code class="lang-js">/* 循环中使用 yield */
// 错误的写法
function* gen(arr) {
  arr.forEach(*item =&gt; {
    yield* item;
  });
}

// 正确的写法
function* gen(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    yield arr[i];
  }
}
</code></pre><p>如果在一个 <code>Generator</code> 函数中调用了另一个 <code>Generator</code> 函数，在调用外层函数返回遍历器的 <code>next</code> 方法时是不会遍历内部函数返回的遍历器的。</p><pre><code class="lang-js">/* 合并生成器 —— 错误 */
// 外层的生成器函数
function* genOut() {
  yield &#39;a&#39;;
  yield genIn();
  yield &#39;c&#39;;
}

// 内层的生成器函数
function* genIn() {
  yield &#39;b&#39;;
}

// 遍历器
const it = genOut();

it.next(); // {value: &#39;a&#39;, done: false}
it.next(); // 返回 genIn 的遍历器对象
it.next(); // {value: &#39;c&#39;, done: false}
it.next(); // {value: undefined, done: true}
</code></pre><p>上面代码如果想在调用 <code>genOut</code> 返遍历器的 <code>next</code> 方法时，同时遍历 <code>genIn</code> 调用后返回的遍历器，需要使用 <code>yield*</code> 表达式。</p><pre><code class="lang-js">/* 合并生成器 —— yield* */
// 外层的生成器函数
function* genOut() {
  yield &#39;a&#39;;
  yield* genIn();
  yield &#39;c&#39;;
}

// 内层的生成器函数
function* genIn() {
  yield &#39;b&#39;;
}

// 遍历器
const it = genOut();

it.next(); // {value: &#39;a&#39;, done: false}
it.next(); // {value: &#39;b&#39;, done: false}
it.next(); // {value: &#39;c&#39;, done: false}
it.next(); // {value: undefined, done: true}
</code></pre><p>在 <code>genOut</code> 返回的遍历器调用 <code>next</code> 遇到 <code>yield*</code> 表达式时帮我们去遍历了 <code>genIn</code> 返回的遍历器，其实 <code>yield*</code> 内部做了处理，等同于下面代码：</p><pre><code class="lang-js">/* 合并生成器 —— for of */
// 外层的生成器
function* genOut() {
  yield &#39;a&#39;;
  for (let v of genIn()) {
    yield v;
  }
  yield &#39;c&#39;;
}

// 内层的生成器
function* genIn() {
  yield &#39;b&#39;;
}

// 遍历器
const it = genOut();

it.next(); // {value: &#39;a&#39;, done: false}
it.next(); // {value: &#39;b&#39;, done: false}
it.next(); // {value: &#39;c&#39;, done: false}
it.next(); // {value: undefined, done: true}
</code></pre><h2 id="Generators-与-Promise-结合"><a href="#Generators-与-Promise-结合" class="headerlink" title="Generators 与 Promise 结合"></a>Generators 与 Promise 结合</h2><blockquote class="pullquote primary"><p><strong><code>Promise</code> 也是 <code>ES6</code> 的规范，同样是解决异步的一种手段，如果对 <code>Promise</code> 还不了解，可以阅读下面两篇文章：</strong></p><ul><li><a href="/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a></li><li><a href="/20180613193626/" target="_blank">异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</a></li></ul></blockquote><p>因为 <code>Generator</code> 函数在执行时遇到 <code>yield</code> 关键字会暂停执行，那么 <code>yield</code> 后面可以是异步操作的代码，比如 <code>Promise</code>，需要继续执行，就手动调用返回遍历器的 <code>next</code> 方法，因为中间有一个等待的过程，所以在执行异步代码的时候避免了回调函数的嵌套，在写法上更像同步，更容易理解。</p><p>我们来设计一个 <code>Generator</code> 函数与 <code>Promise</code> 异步操作结合的使用场景，假设我们需要使用 <code>Node.js</code> 的 <code>fs</code> 模块读取一个文件 <code>a.txt</code> 的内容，而 <code>a.txt</code> 的内容是另一个需要读取文件 <code>b.txt</code> 的文件名，读取 <code>b.txt</code> 最后打印读取到的内容 “Hello world”。</p><p><strong>回调函数的实现：</strong></p><pre><code class="lang-js">/* 连续读取文件 —— 异步回调 */
// 引入依赖
const fs = require(&#39;fs&#39;);

fs.readFile(&#39;a.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; {
  if (!err) {
    fs.readFile(data, &#39;utf8&#39;, (err, data) =&gt; {
      if (!err) {
        console.log(data); // Hello world
      }
    });
  }
});
</code></pre><p>上面代码因为只有两层回调函数嵌套，所以感觉没那么复杂，但是嵌套的回调函数多了，代码就不那么的优雅了，我们接下来使用 <code>Generator</code> 结合 <code>Promise</code> 来实现，为了方便将 <code>fs</code> 异步的方法转换成 <code>Promise</code>，我们引入 <code>util</code> 模块，并转换 <code>readFile</code> 方法。</p><pre><code class="lang-js">/* 连续读取文件 —— Generator + Promise */
// 引入依赖
const fs = require(&#39;fs&#39;);
const util = require(&#39;util&#39;);

// 将 readFile 方法转换成 Promise
const read = util.promisify(fs.readFile);

// 生成器函数
function* gen() {
  const aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;);
  const bData = yield read(aData, &#39;utf8&#39;);
  return bData;
}

// 遍历器
const it = gen();

it.next().value.then(data =&gt; {
  it.next(data).then(data =&gt; {
    console.log(data); // Hello world
  });
});
</code></pre><p>我们只看 <code>Generator</code> 函数 <code>gen</code> 内部的执行，虽然是异步操作，但是在写法上几乎和同步没有区别，理解起来更容易，唯一美中不足的是，我们需要自己手动的调用遍历器的 <code>next</code> 和 <code>Promise</code> 实例的 <code>then</code>，这个问题 <code>co</code> 库可以帮我们解决。</p><h2 id="co-库的使用"><a href="#co-库的使用" class="headerlink" title="co 库的使用"></a>co 库的使用</h2><blockquote class="pullquote info"><p><strong><code>co</code> 库的作者是著名的 <code>Node.js</code> 大神 <code>tj</code>，是基于 <code>Generator</code> 和 <code>Promise</code> 的，这个库能帮我们实现自动调用 <code>Generator</code> 函数返回遍历器的 <code>next</code> 方法，并执行 <code>yield</code> 后面 <code>Promise</code> 实例的 <code>then</code> 方法，所以每次 <code>yield</code> 后面的异步操作返回的必须是一个 <code>Promise</code> 实例，代码看起来像同步，执行其实是异步，不用自己手动进行下一次遍历，这更是我们想要的。</strong></p></blockquote><p>由于 <code>co</code> 是一个第三方的模块，所以在使用时需要我们提前下载：</p><pre><code class="lang-bash">$ npm install co
</code></pre><p>我们使用 <code>co</code> 来实现之前异步连续读文件的案例：</p><pre><code class="lang-js">/* 连续读取文件 —— Generator + co */
// 引入依赖
const fs = require(&#39;fs&#39;);
const util = require(&#39;util&#39;);
const co = require(&#39;co&#39;);

// 将 readFile 方法转换成 Promise
const read = util.promisify(fs.readFile);

// 生成器函数
function* gen() {
  const aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;);
  const bData = yield read(aData, &#39;utf8&#39;);
  return bData;
}

// 使用 co 库代替手动调用 next
co(gen()).then(data =&gt; {
  console.log(data); // Hello world
});
</code></pre><p>从上面代码可以看出，<code>co</code> 库的 <code>co</code> 函数参数是一个遍历器，即 <code>Generator</code> 函数执行后的返回结果，在 <code>co</code> 内部操作遍历器并遍历完成后返回了一个 <code>Promise</code> 实例，遍历器最终的返回结果的 <code>value</code> 值作为 <code>then</code> 方法回调的参数，所以我们可以使用 <code>then</code> 对结果进行后续的处理。</p><h2 id="co-库的实现原理"><a href="#co-库的实现原理" class="headerlink" title="co 库的实现原理"></a>co 库的实现原理</h2><p>我们其实在上面使用 <code>co</code> 的过程中对于 <code>co</code> 函数的内部做了什么已经有所了解，主要就是帮助我们调用遍历器的 <code>next</code> 和调用 <code>yield</code> 后面代码执行后返回 Promise 实例的 <code>then</code>，并在整个遍历结束后，返回一个新的 <code>Promise</code> 实例。</p><p>下面我们根据上面分析的 <code>co</code> 函数的原理来模拟一个简易版的 <code>co</code> 库：</p><pre><code class="lang-js">/* 文件：myCo.js —— co 原理 */
// co 函数，it 为遍历器对象
function co(it) {
  // 返回 Promise 实例
  return new Promise((resolve, reject) =&gt; {
    // 异步递归
    function next(data) {
      // 第一次调用 next 不需要传参
      let { value, done } = it.next(data);

      if (!done) {
        // 如果没完成遍历，调用返回 Promise 的 then 方法
        value.then(data =&gt; {
          // 如果 Promise 成功，继续递归，如果失败直接执行 reject
          next(data);
        }, reject);
      } else {
        // 如果遍历完成直接执行 resolve 并传入 value
        resolve(value);
      }
    }
    next();
  });
}

// 导出模块
module.exports = co;
</code></pre><p>验证 <code>myCo.js</code> 实现的 <code>co</code> 函数：</p><pre><code class="lang-js">/* 验证 myCo */
// 引入依赖
const fs = require(&#39;fs&#39;);
const util = require(&#39;util&#39;);
const myCo = require(&#39;./myCo&#39;);

// 将 readFile 方法转换成 Promise
const read = util.promisify(fs.readFile);

// 生成器函数
function* gen() {
  let aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;);
  let bData = yield read(aData, &#39;utf8&#39;);
  return bData;
}

// 使用 co 库代替手动调用 next
myCo(gen()).then(data =&gt; {
  console.log(data); // Hello world
});
</code></pre><p>我们将引入的 <code>co</code> 库替换成了自己实现的简易版 <code>myCo</code> 模块，上面读取文件的案例依然生效，这说明我们模拟的 <code>co</code> 库核心逻辑是没问题的，跟原版不同的是并没有处理很多细节，并定义指针，如果对 <code>co</code> 库感兴趣建议看看 <code>tj</code> 大神的源码，整个库写的非常精简，值得学习。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>Generators</code> 相当于把一个函数拆分成若干个部分执行，执行一次时将指针指向下一段要执行的代码，直到结束位置，<code>Generators</code> 配合 <code>co</code> 库的使用场景多在 <code>Node.js</code> 当中，并在 <code>Koa 1.x</code> 版本中居多，现在已经升级到 <code>Koa 2.x</code> 版本，使用更多的是基于 <code>Generators</code> 和 <code>co</code> 库衍生出来的 <code>ES7</code> 新标准 <code>async/await</code>，我们在下一篇异步发展流程系列的文章中来详细介绍。</strong></p></blockquote>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>Node.js</tag>
        <tag>ES6</tag>
        <tag>Generators</tag>
      </tags>
  </entry>
  <entry>
    <title>异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise</title>
    <url>/20180613193626/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Async/20180613193626/promise-A+.png" title="Promise 原理"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote default"><p><strong><code>Promise</code> 是 <code>js</code> 异步编程的一种解决方案，避免了 “回调地狱” 给编程带来的麻烦，在 <code>ES6</code> 中成为了标准，这篇文章重点不是叙述 <code>Promise</code> 的基本用法，而是从零开始，手写一版符合 <code>Promise/A+</code> 规范的 Promise，如果想了解更多 <code>Promise</code> 的基本用法，可以看</strong> <a href="/20180612045005/" target="_blank">异步发展流程 —— Promise 的基本使用</a> <strong>这篇文章。</strong></p></blockquote><h2 id="Promise-构造函数的实现"><a href="#Promise-构造函数的实现" class="headerlink" title="Promise 构造函数的实现"></a>Promise 构造函数的实现</h2><p>我们在使用 <code>Promise</code> 的时候其实是使用 <code>new</code> 关键字创建了一个 <code>Promise</code> 的实例，其实 <code>Promise</code> 是一个类，即构造函数，下面来实现 <code>Promise</code> 构造函数。</p><a id="more"></a><blockquote class="pullquote info"><p><strong><code>Promise/A+</code> 规范的内容比较多，详情查看</strong> <a>https://promisesaplus.com/</a>，<strong>我们在实现 <code>Promise</code> 逻辑时会根据实现的部分介绍相关的 <code>Promise/A+</code> 规范内容。</strong></p></blockquote><blockquote class="pullquote primary"><p><strong>在 <code>Promise/A+</code> 规范中规定:</strong></p><ul><li><strong>构造函数的参数为一个名为 <code>executor</code> 的执行器，即函数，在创建实例时该函数内部逻辑为同步，即立即执行；</strong></li><li><strong><code>executor</code> 执行时的参数分别为 <code>resolve</code> 和 <code>reject</code>，一个为成功时执行的函数，一个为失败时执行的函数；</strong></li><li><strong>在 <code>executor</code> 执行时，一旦出现错误立即调用 <code>reject</code> 函数，并设置错误信息给 <code>reason</code> 属性；</strong></li><li><strong>每个 Promise 实例有三个状态 <code>pending</code>、<code>fulfilled</code> 和 <code>rejected</code>，默认状态为 <code>pending</code>；</strong></li><li><strong>状态只能从 <code>pending</code> 到 <code>fulfilled</code> 或从 <code>pending</code> 到 <code>rejected</code>，不可逆；</strong></li><li><strong>执行 <code>resolve</code> 函数会使状态从 <code>pending</code> 变化到 <code>fulfilled</code> 并将参数存入实例的 <code>value</code> 属性中；</strong></li><li><strong>执行 <code>reject</code> 函数会使状态从 <code>pending</code> 变化到 <code>rejected</code> 并将错误信息存入实例的 <code>reason</code> 属性中。</strong></li></ul></blockquote><p><strong>针对上面的 <code>Promise/A+</code> 规范，<code>Promise</code> 构造函数代码实现如下：</strong></p><pre><code class="lang-js">/* promise.js -- Promise 构造函数 */
function Promise(executor) {
  var self = this;
  self.status = &#39;pending&#39;; // 当前 Promise 实例的状态
  self.value = undefined; // 当前 Promise 实例成功状态下的值
  self.reason = undefined; // 当前 Promise 实例失败状态的错误信息
  self.onFulfilledCallbacks = []; // 存储成功的回调函数的数组
  self.onRejectedCallbacks = []; // 存储失败的回调函数的数组

  // 成功的执行的函数
  function resolve(value) {
    // 处理 executor 执行时，调用 resolve 将一个新的 Promise 实例作为结果返回
    if (value instanceof Promise) {
      return value.then(function (data) {
        resolve(data);
      }, function (err) {
        reject(err);
      });
    }

    if (self.status === &#39;pending&#39;) {
      self.status = &#39;fulfilled&#39;;
      self.value = value;

      // 每次调用 resolve 时
      // 执行 onFulfilledCallbacks 内部存储的所有的函数
      // 在实现 then 方法中详细说明
      self.onFulfilledCallbacks.forEach(function (fn) {
        fn();
      });
    }
  }

  // 失败执行的函数
  function reject(reason) {
    if (self.status === &#39;pending&#39;) {
      self.status = &#39;rejected&#39;;
      self.reason = reason;

      // 每次调用 reject 时
      // 执行 onRejectedCallbacks 内部存储的所有的函数
      // 在实现 then 方法中详细说明
      self.onRejectedCallbacks.forEach(function (fn) {
        fn();
      });
    }
  }

  // 调用执行器函数
  try {
    executor(resolve, reject);
  } catch (e) {
    // 如果执行器执行时出现错误，直接调用失败的函数
    reject(e);
  }
}

// 将自己的 Promise 导出
module.exports = Promise;
</code></pre><p>上面构造函数中的 <code>resolve</code> 和 <code>reject</code> 方法在执行的时候都进行了当前状态的判断，只有状态为 <code>pending</code> 时，才能执行判断内部逻辑，当两个函数有一个执行后，此时状态发生变化，再执行另一个函数时就不会通过判断条件，即不会执行判断内部的逻辑，从而实现了两个函数只有一个执行判断内部逻辑的效果，使用如下：</p><pre><code class="lang-js">/* verify-promise.js -- 验证 promise.js 的代码 */
// 引入自己的 Promise 模块
// 因为都验证代码都写在 verify-promise.js 文件中，后面就不再引入了
const Promise = require(&#39;./promise.js&#39;);

const p = new Promise((resolve, reject) =&gt; {
  // ...同步代码
  resolve();
  reject();
  // 上面两个函数只有先执行的 resolve 生效
});
</code></pre><h2 id="实例方法的实现"><a href="#实例方法的实现" class="headerlink" title="实例方法的实现"></a>实例方法的实现</h2><h3 id="then-方法的实现"><a href="#then-方法的实现" class="headerlink" title="then 方法的实现"></a>then 方法的实现</h3><p>没有 <code>Promise</code> 之前在一个异步操作的回调函数中返回一个结果在输入给下一个异步操作，下一个异步操作结束后需要继续执行回调，就形成回调函数的嵌套，在 <code>Promise</code> 中，原来回调函数中的逻辑只需要调用当前 Promise 实例的 <code>then</code> 方法，并在 <code>then</code> 方法的回调中执行，改变了原本异步的书写方式。</p><blockquote class="pullquote success"><p><strong>在 then 方法中涉及到的 <code>Promise/A+</code> 规范：</strong></p><ul><li><strong><code>Promise</code> 实例的 <code>then</code> 方法中有两个参数，都为函数，第一个参数为成功的回调 <code>onFulfilled</code>，第二个参数为失败的回调 <code>onRejected</code>；</strong></li><li><strong>当 <code>Promise</code> 内部执行 <code>resolve</code> 时，调用实例的 <code>then</code> 方法执行成功的回调 <code>onFulfilled</code>，当 <code>Promise</code> 内部执行 <code>reject</code> 或执行出错时，调用实例的 <code>then</code> 方法执行错误的回调 <code>onRejected</code>；</strong></li><li><strong><code>then</code> 方法需要支持异步，即如果 <code>resovle</code> 或 <code>reject</code> 执行为异步时，<code>then</code> 方法的回调 <code>onFulfilled</code> 或 <code>onRejected</code> 需要在后面执行；</strong></li><li><strong><code>Promise</code> 需要支持链式调用，<code>Promise</code> 实例调用 <code>then</code> 方法后需要返回一个新的 <code>Promise</code> 实例。如果 <code>then</code> 的回调中有返回值且是一个 <code>Promise</code> 实例，则该 <code>Promise</code> 实例执行后成功或失败的结果传递给下一个 <code>Promise</code> 实例的 <code>then</code> 方法 <code>onFulfilled</code> （成功的回调）或 <code>onRejected</code>（失败的回调）的参数，如果返回值不是 <code>Promise</code> 实例，直接将这个值传递给下一个 <code>Promise</code> 实例 <code>then</code> 方法回调的参数，<code>then</code> 的回调如果没有返回值相当于返回 <code>undefined</code>；</strong></li><li><strong><code>Promise</code> 实例链式调用 <code>then</code> 时，当任何一个 <code>then</code> 执行出错，链式调用下一个 <code>then</code> 时会执行错误的回调，错误的回调没有返回值相当于返回了 <code>undefined</code>，再次链式调用 <code>then</code> 时会执行成功的回调；</strong></li><li><strong><code>Promise</code> 实例的链式调用支持值的穿透，即当上一个 <code>then</code> 没有传递回调函数，或参数不是一个函数时（<code>null</code>），参数要被忽略，需要后面调用的 <code>then</code> 的回调函数来接收之前执行成功或失败的结果；</strong></li><li><strong><code>executor</code> 在 <code>Promise</code> 构造函数中执行时使用 <code>try...catch...</code> 捕获异常，但是内部执行的代码有可能是异步的，所以需要在 <code>then</code> 方法中使用 <code>try...catch...</code> 再次捕获；</strong></li><li><strong><code>Promise</code> 实例的 <code>then</code> 方法中的回调为 <code>micro-tasks</code>（微任务），回调内的代码应晚于同步代码执行，在浏览器内部调用微任务接口，我们这里模拟使用宏任务代替。</strong></li></ul></blockquote><p><strong>针对上面的 <code>Promise/A+</code> 规范，then 方法代码实现如下：</strong></p><pre><code class="lang-js">/* promise.js -- then 方法 */
Promise.prototype.then = function (onFulfilled, onRejected) {
  // 实现值的穿透
  if (typeof onFulfilled !== &#39;function&#39;) {
    onFulfilled = function (data) {
      return data;
    }
  }

  if (typeof onRejected !== &#39;function&#39;) {
    onRejected = function (err) {
      throw err;
    }
  }

  var self = this;

  // 返回新的 Promise，规范中规定这个 Promise 实例叫 promise2
  var promise2 = new Promise(function (resolve, reject) {
    if (self.status === &#39;fulfilled&#39;) {
      // 用宏任务替代模拟微任务，目的是使 `then` 的回调晚于同步代码执行
      // 并保证执行 resolvePromise 时可以获取到 promise2 作为参数
      setTimeout(function () {
        try {  // 捕获异步的异常
          // onFulfilled 执行完返回值的处理，x 为成功回调的返回值
          var x = onFulfilled(self.value);

          // 处理返回值单独封装一个方法
          resolvePromise(promise2, x, resolve, reject);
        } catch (e) {
          reject(e);
        }
      }, 0);
    }

    if (self.status === &#39;rejected&#39;) {
      setTimeout(function () {
        try {
          // onRejected 执行完返回值的处理，x 为失败回调的返回值
          var x = onRejected(self.reason);
          resolvePromise(promise2, x, resolve, reject);
        } catch (e) {
          reject(e);
        }
      }, 0);
    }

    // 如果在 Promise 执行 resolve 或 renject 为异步
    // 将 then 的执行程序存储在实例对应的
    // onFulfilledCallbacks 或 onRejectedCallbacks 中
    if (self.status === &#39;pending&#39;) {
      self.onFulfilledCallbacks.push(function () {
        setTimeout(function () {
          try {
            var x = onFulfilled(self.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      });

      self.onRejectedCallbacks.push(function () {
        setTimeout(function () {
          try {
            var x = onRejected(self.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      });
    }
  });

  return promise2;
};
</code></pre><blockquote class="pullquote warning"><p><strong>在处理 <code>then</code> 回调的返回值时，其实就是在处理该返回值与 <code>then</code> 方法在执行后返回的新 <code>Promise</code> 实例（即 <code>promise2</code>）之间的关系，因为无论 <code>Promise</code> 的执行器在执行 <code>resolve</code> 还是 <code>reject</code> 是同步或是异步，都需要进行处理，所以我们单独封装一个函数 <code>resolvePromise</code> 来处理。</strong></p></blockquote><blockquote class="pullquote default"><p><strong><code>resolvePromise</code> 函数有四个参数：</strong></p><ul><li><strong><code>promise2</code>：<code>then</code> 执行后返回的 <code>Promise</code> 实例；</strong></li><li><strong><code>x</code>：<code>then</code> 的回调返回的结果；</strong></li><li><strong><code>resolve</code>：<code>promise2</code> 的 <code>resolve</code> 函数；</strong></li><li><strong><code>reject</code>：<code>promise2</code> 的 <code>reject</code> 函数。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>在 <code>resolvePromise</code> 函数中涉及到的 <code>Promise/A+</code> 规范：</strong></p><ul><li><strong>将每个 <code>Promise</code> 实例调用 <code>then</code> 后返回的新 <code>Promise</code> 实例称为 <code>promise2</code>，将 <code>then</code> 回调返回的值称为 <code>x</code>；</strong></li><li><strong>如果 <code>promise2</code> 和 <code>x</code> 为同一个对象，由于 <code>x</code> 要将执行成功或失败的结果传递 <code>promise2</code> 的 <code>then</code> 方法回调的参数，因为是同一个 <code>Promise</code> 实例，此时既不能成功也不能失败（自己不能等待自己完成），造成循环引用，这种情况下规定应该抛出一个类型错误来回绝；</strong></li><li><strong>如果 <code>x</code> 是一个对象或者函数且不是 <code>null</code>，就去取 <code>x</code> 的 <code>then</code> 方法，如果 <code>x</code> 是对象，防止 <code>x</code> 是通过 <code>Object.defineProperty</code> 添加 <code>then</code> 属性，并添加 <code>get</code> 和 <code>set</code> 监听，如果在监听中抛出异常，需要被捕获到，<code>x.then</code> 是一个函数，就当作 <code>x</code> 是一个 <code>Promise</code> 实例，直接执行<code>x</code> 的 <code>then</code> 方法，执行成功就让 <code>promise2</code> 成功，执行失败就让 <code>promise2</code> 失败，如果 <code>x.then</code> 不是函数，则说明 <code>x</code> 为普通值，直接调用 <code>promise2</code> 的 <code>resolve</code> 方法将 <code>x</code> 传入，不满足条件说明该返回值就是一个普通值，直接执行 <code>promise2</code> 的 <code>resolve</code> 并将 <code>x</code> 作为参数传入；</strong></li><li><strong>如果每次执行 <code>x</code> 的 <code>then</code> 方法，回调中传入的参数还是一个 <code>Promise</code> 实例，循环往复，需要递归 <code>resolvePromise</code> 进行解析；</strong></li><li><strong>在递归的过程中如果返回的 <code>Promise</code> 是其他人通过 <code>Promise/A+</code> 规范实现的，并且实现 <code>Promise</code> 的 <code>then</code> 方法中同时调用了 <code>resolve</code> 和 <code>reject</code> 的情况（未严格按照规范，有坑的 <code>Promise</code>），应该声明一个标识变量 <code>called</code> 做判断来避免这种情况，第一次调用 <code>resolve</code> 或 <code>reject</code> 生效，然后更改标识来忽略其他的调用。</strong></li></ul></blockquote><p><strong>针对上面的 <code>Promise/A+</code> 规范，<code>resolvePromise</code> 函数代码实现如下：</strong></p><pre><code class="lang-js">/* promise.js -- resolvePromise 方法 */
function resolvePromise(promise2, x, resolve, reject) {
  // 判断 x 和 promise2 是不是同一个函数
  if (promise2 === x) {
    reject(new TypeError(&#39;循环引用&#39;));
  }

  // x 是对象或者函数并且不是 null，如果不满足该条件说明 x 只是一个普通的值
  if (x !== null &amp;&amp; (typeof x === &#39;object&#39; || typeof x === &#39;function&#39;)) {
    // 标识变量，防止递归内外层 resolve 和 reject 同时调用
    // 针对 Promise，x 为普通值的时候可以放行
    var called;

    // 为了捕获 Object.defineProperty 创建的 then 属性时添加监听所抛出的异常
    try {
      // then 只取一次，防止 Object.defineProperty getter 内，用次数控制报错
      var then = x.then;

      // then 为一个方法，就当作 x 为一个 promise
      if (typeof then === &#39;function&#39;) {
        // 执行 then，第一个参数为 this（即 x）
        // 第二个参数为成功的回调，第三个参数为失败的回调
        then.call(x, function (y) {
          if (called) return;
          called = true;

          // 如果 y 是 Promise 就继续递归解析
          resolvePromise(promise2, y, resolve, reject);
        }, function (err) {
          if (called) return;
          called = true;
          reject(err);
        });
      } else { // x 是一个普通对象，直接成功即可
        resolve(x);
      }
    } catch(e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    resolve(x);
  }
}
</code></pre><blockquote class="pullquote primary"><p><strong>注意：<code>Promise</code> 是一套规范，是通用的，每个人都可以实现一个符合 <code>Promise/A+</code> 规范的 <code>Promise</code>，其他人实现的 <code>Promise</code> 可能会在我们的 <code>Promise</code> 的 <code>then</code> 方法中被返回，所以当我们取出这个对象查看是否含有 <code>then</code> 方法，如果有则认为这个对象是一个 <code>Promise</code> 的实例。</strong></p></blockquote><p>上面我们按照 <code>Promise/A+</code> 规范实现了 <code>Promise</code> 的 <code>then</code> 方法，接下来针对上面的规范，用一些有针对行的案例来对 <code>then</code> 方法一一进行验证。</p><p>验证异步调用 <code>resolve</code> 或 <code>reject</code>：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 异步调用 resolve 或 reject
const p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(), 1000);
});

p.then(() =&gt; console.log(&#39;执行了&#39;));

// 执行了
</code></pre><p>验证链式调用 <code>then</code> 返回 <code>Promise</code> 实例：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js then 回调返回 Promise 实例
const p1 = new Promise((resolve, reject) =&gt; resolve());
const p2 = new Promise((resolve, reject) =&gt; resolve(&#39;hello&#39;));

p1.then(() =&gt; p2).then(data =&gt; console.log(data));

// hello
</code></pre><p>验证链式调用 <code>then</code> 返回普通值：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js then 回调返回普通值
const p = new Promise((resolve, reject) =&gt; resolve());

p.then(() =&gt; &#39;hello&#39;).then(data =&gt; console.log(data));

// hello
</code></pre><p>验证链式调用 <code>then</code> 中执行出错链式调用 <code>then</code> 执行错误的回调后，再次链式调用 <code>then</code>：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 链式调用 then 中执行出错
// 链式调用 then 执行错误的回调后，再次链式调用 then
const p = new Promise((resolve, reject) =&gt; resolve());

p.then(() =&gt; {
  throw new Error(&#39;error&#39;);
}).then(() =&gt; {
  console.log(&#39;success&#39;);
}, err =&gt; {
  console.log(err);
}).then(() =&gt; {
  console.log(&#39;成功&#39;);
}, () =&gt; {
  console.log(&#39;失败&#39;);
});

// Error: error  at p.then...
// 成功
</code></pre><p>验证 <code>then</code> 的参数穿透：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 then 的参数穿透
const p1 = new Promise((resolve, reject) =&gt; resolve(&#39;ok&#39;));

const p2 = p1.then().then(data =&gt; {
  console.log(data);
  throw new Error(&#39;出错了&#39;);
});

p2.then().then(null, err =&gt; console.log(err));

// ok
// 出错了
</code></pre><p>验证 <code>then</code> 方法是否晚于同步代码执行：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 then 方法是否晚于同步代码执行
const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

p.then(data =&gt; console.log(data));
console.log(2);

// 2
// 1
</code></pre><p>验证循环引用：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 循环引用
const p1 = new Promise((resolve, reject) =&gt; resolve());

// 让 p1 then 方法的回调返回自己
var p2 = p1.then(() =&gt; {
  return p2;
});

p2.then(() =&gt; {
  console.log(&#39;成功&#39;);
}, err =&gt; {
  console.log(err);
});

// TypeError: 循环引用  at resolvePromise...
</code></pre><p>验证 <code>then</code> 回调返回对象通过 <code>Object.definePropertype</code> 添加 <code>then</code> 属性并添加 <code>get</code> 监听，在触发监听时抛出异常：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js then 回调
// 返回对象通过 Object.definePropertype 添加 then 和 get 监听，捕获异常
let obj = {};
let index = 0;
Object.defineProperty(obj, &#39;then&#39;, {
  get () {
    index++;
    if (index === 2) {
      throw new Error();
    }
  }
});

let p = new Promise((resolve, reject) =&gt; resolve());
p.then(() =&gt; {
  return obj;
}).then(() =&gt; {
  console.log(&#39;成功&#39;);
}, () =&gt; {
  console.log(&#39;出错了&#39;);
});

// 出错了
</code></pre><p>验证每次执行 <code>resolve</code> 都传入 <code>Promise</code> 实例，需要将最终的执行结果传递给下一个 <code>Promise</code> 实例 <code>then</code> 的回调中：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 每次执行 resolve 都传入 Promise 实例
const p = new Promise((resolve, reject) =&gt; resolve());

p.then(() =&gt; {
  return new Promise((resolve, reject) =&gt; {
    resolve(new Promise(resolve, reject) =&gt; {
      resolve(new Promise(resolve, reject) =&gt; {
        resolve(200);
      });
    });
  });
}).then(data =&gt; {
  console.log(data);
});

// 200
</code></pre><h3 id="catch-方法的实现"><a href="#catch-方法的实现" class="headerlink" title="catch 方法的实现"></a>catch 方法的实现</h3><pre><code class="lang-js">/* promise.js -- catch 方法 */
Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
}
</code></pre><blockquote class="pullquote info"><p><strong><code>catch</code> 方法可以理解为是 <code>then</code> 方法的一个简写，只是参数中少了成功的回调，所以利用 <code>Promise/A+</code> 规范中参数穿透的特性，很容易就实现了 <code>catch</code> 方法，<code>catch</code> 方法的真相就是这么的简单。</strong></p></blockquote><p>验证 <code>catch</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 catch 方法
const p = new Promise((resolve, reject) =&gt; reject(&#39;err&#39;));

p.then().catch(err =&gt; {
  console.log(err);
}).then(() =&gt; {
  console.log(&#39;成功了&#39;);
});

// err
// 成功了
</code></pre><h3 id="finally-方法的实现"><a href="#finally-方法的实现" class="headerlink" title="finally 方法的实现"></a>finally 方法的实现</h3><pre><code class="lang-js">/* promise.js -- finally 方法 */
Promise.prototype.finally = function (callback) {
  return this.then(
    value =&gt; Promise.resolve(callback()).then(() =&gt; value),
    reason =&gt; Promise.resolve(callback()).then(() =&gt; { throw reason })
  );
}
</code></pre><blockquote class="pullquote warning"><p><strong><code>finally</code> 方法是在 <code>ES9</code> 的规范中实现的，特点是无论成功或者失败都会执行传入的回调函数，并且回调函数没有任何参数，而在 <code>finally</code> 后可以再链式调用 <code>then</code> 或 <code>catch</code> 去处理后续逻辑或捕获异常，因为参数不是在 <code>finally</code> 方法传入的回调中返回的，所以借助了静态方法 <code>Promise.resolve</code>（该方法实现方式在静态方法中会说明），在 <code>finally</code> 内部调用 <code>then</code> 返回 <code>Promise</code> 实例，并传入成功和失败的回调用来返回最初成功或失败的结果，<code>finally</code> 的回调中执行的返回结果不生效。</strong></p></blockquote><p>验证 <code>finally</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 finally 方法
const p = new Promise((resolve, reject) =&gt; resolve(&#39;nihao&#39;));

p.finally(() =&gt; { // node版本的问题 8以上
  console.log(&#39;hello&#39;);
  throw &#39;error&#39;
}).catch(err =&gt; {
  console.log(&#39;err&#39;, err);
});

p.finally(() =&gt; {
  console.log(&#39;hello&#39;);
  return 100;
}).then(data =&gt; {
  console.log(&#39;data&#39;, data);
});

// hello
// hello
// err error
// data nihao
</code></pre><h2 id="静态方法的实现"><a href="#静态方法的实现" class="headerlink" title="静态方法的实现"></a>静态方法的实现</h2><h3 id="Promise-resolve-方法的实现"><a href="#Promise-resolve-方法的实现" class="headerlink" title="Promise.resolve 方法的实现"></a>Promise.resolve 方法的实现</h3><blockquote class="pullquote success"><p><strong><code>Promise.resolve</code> 方法传入一个参数，并返回一个新的 <code>Promise</code> 实例，这个参数作为新 <code>Promise</code> 实例 <code>then</code> 方法成功回调的参数，在调用时感觉直接成功了，其实是直接执行了返回 <code>Promise</code> 实例的 <code>resolve</code>。</strong></p></blockquote><pre><code class="lang-js">/* promise.js -- Promise.resolve 方法 */
Promise.resolve = function (val) {
  return new Promise(function (resolve, reject) {
    resolve(val);
  });
}
</code></pre><p>验证 <code>Promise.resolve</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 Promise.resolve 方法
Promise.resolve(&#39;成功了&#39;).then(data =&gt; console.log(data));

// 成功了
</code></pre><h3 id="Promise-reject-方法的实现"><a href="#Promise-reject-方法的实现" class="headerlink" title="Promise.reject 方法的实现"></a>Promise.reject 方法的实现</h3><blockquote class="pullquote default"><p><strong><code>Promise.reject</code> 方法与 <code>Promise.resolve</code> 的实现思路相同，不同的是，直接调用了返回新 Promise 实例的 <code>reject</code>。</strong></p></blockquote><pre><code class="lang-js">/* promise.js -- Promise.reject 方法 */
Promise.reject = function (reason) {
  return new Promise(function (resolve, reject) {
    reject(reason);
  });
}
</code></pre><p>验证 <code>Promise.reject</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 Promise.reject 方法
Promise.reject(&#39;失败了&#39;).then(err =&gt; console.log(err));

// 失败了
</code></pre><h3 id="Promise-all-方法的实现"><a href="#Promise-all-方法的实现" class="headerlink" title="Promise.all 方法的实现"></a>Promise.all 方法的实现</h3><blockquote class="pullquote primary"><p><strong><code>Promise.all</code> 方法可以实现多个 <code>Promise</code> 实例的并行，返回值为一个新的 <code>Promise</code> 实例，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 <code>Promise</code> 实例的返回结果，这些 <code>Promise</code> 实例的返回顺序先后不确定，但是返回值的数组内存储的返回结果是按照数组中 <code>Promise</code> 实例最初顺序进行排列的，返回的数组作为返回 <code>Promise</code> 实例成功回调的参数，当其中一个失败，直接返回失败实例的错误信息，并作为返回 <code>Promise</code> 实例失败回调的参数。</strong></p></blockquote><pre><code class="lang-js">/* promise.js -- Promise.all 方法 */
Promise.all = function (promises) {
  return new Promise(function (resolve, reject) {
    // 存储返回值
    var result = [];

    // 代表存入的个数，因为 Promise 为异步
    // 不知道哪个 Promise 先成功，不能用数组的长度来判断
    var idx = 0;

    // 用来构建全部成功的返回值
    function processData(index, data) {
      result[index] = data; // 将返回值存入数组
      idx++;

      if (idx === promises.length) {
        resolve(result);
      }
    }

    for (var i = 0; i &lt; promises.length; i++) {
      var current = promises[i];
      // 因为 Promise 为异步，保证 i 值是顺序传入
      (function (i) {
        if (current &amp;&amp; current.then &amp;&amp; typeof current.then === &#39;function&#39;) {
          current.then(function (data) {
            processData(i, data);
          }, reject);
        } else {
          processData(i, current);
        }
      })(i);
    }
  });
}
</code></pre><p>验证 <code>Promise.all</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 Promise.all 方法
const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 2000);
});
const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(2), 1000);
});

Promise.all([p1, p2, 3]).then(data =&gt; console.log(data));

// [1, 2, 3]

const p3 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 2000);
});
const p4 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; reject(2), 1000)
});

Promise.all([p3, p4]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
});

// 2
</code></pre><h3 id="Promise-race-方法的实现"><a href="#Promise-race-方法的实现" class="headerlink" title="Promise.race 方法的实现"></a>Promise.race 方法的实现</h3><blockquote class="pullquote info"><p><strong><code>Promise.race</code> 方法与 <code>Promise.all</code> 类似，同样可以实现多个 <code>Promise</code> 实例的并行，同样返回值为一个新的 <code>Promise</code> 实例，参数同样为一个存储多个 <code>Promise</code> 实例的数组，区别是只要有一个 <code>Promise</code> 实例返回结果，无论成功或失败，则直接返回这个结果，并作为新 <code>Promise</code> 实例 <code>then</code> 方法中成功或失败的回调函数的参数。</strong></p></blockquote><pre><code class="lang-js">/* promise.js -- Promise.race 方法 */
Promise.race = function (promises) {
  return new Promise(function (resolve, reject) {
    for (var i = 0; i &lt; promises.length; i++) {
      var current = promises[i];

      if (current &amp;&amp; current.then &amp;&amp; typeof current.then === &#39;function&#39;) {
        current.then(resolve, reject);
      } else {
        resolve(current);
      }
    }
  });
}
</code></pre><p>验证 <code>Promise.race</code> 方法：</p><pre><code class="lang-js">/* 文件：verify-promise.js */
// 验证 promise.js 的 Promise.race 方法
const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 2000);
});
const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(2), 1000);
});

Promise.race([p1, p2]).then(data =&gt; console.log(data));

// 2

const p3 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 2000);
});
const p4 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; reject(2), 1000);
});

Promise.all([p3, p4]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
});

// 2
</code></pre><h2 id="测试-Promise-是否符合-Promise-A-规范"><a href="#测试-Promise-是否符合-Promise-A-规范" class="headerlink" title="测试 Promise 是否符合 Promise/A+ 规范"></a>测试 Promise 是否符合 Promise/A+ 规范</h2><p><code>promises-aplus-test</code> 是专门用来验证 <code>Promise</code> 代码（构造函数和 <code>then</code> 方法）是否符合 <code>Promise/A+</code> 规范的模块，需要通过 <code>npm</code> 下载。</p><pre><code class="lang-bash">$ npm install promises-aplus-test -g
</code></pre><p><strong>测试方法：</strong></p><ul><li>在 <code>promise.js</code> 中写入测试代码；</li><li>在命令行中输入命令 <code>promises-aplus-test</code> + <code>fileName</code>。</li></ul><p><strong>测试代码：</strong></p><pre><code class="lang-js">/* promise.js -- 测试方法 Promise.derfer */
// Promise 语法糖
// 好处：解决 Promise 嵌套问题
// 坏处：错误处理不方便
Promise.derfer = Promise.deferred = function () {
  const dfd = {};

  dfd.promise = new Promise((resolve, reject) =&gt; {
    dfd.resolve = resolve;
    dfd.reject = reject;
  });

  return dfd;
}
</code></pre><p><strong>输入命令：</strong></p><pre><code class="lang-bash">$ promises-aplus-test promise.js
</code></pre><blockquote class="pullquote success"><p><strong>执行上面命令后，会根据 <code>Promise/A+</code> 规范一条一条进行极端的验证，当验证通过后会在窗口中这一条对应的执行项前打勾，验证不通过打叉，直到所有的规范都验证完毕。</strong></p></blockquote>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>ES6</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>异步发展流程 —— Promise 的基本使用</title>
    <url>/20180612045005/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Async/20180612045005/promise.png" title="Promise 基本用法"><p><br></p><h2 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h2><blockquote class="pullquote info"><p><strong><code>Promise</code> 是 <code>ES6</code> 的新特性，提供了对 <code>js</code> 异步编程控制的新的解决方案，在过去书写异步代码时要靠回调函数，当异步操作依赖于其他异步操作的返回值时，会出现一种现象，被程序员们称为 “回调地狱”，即多层回调函数嵌套，这种代码的可读性、维护性都很差，因此诞生了 <code>Promise</code>，当然 <code>Promise</code> 并不是完全摆脱回调，而只是改变了传递回调的位置，大大减少了回调函数嵌套。</strong></p></blockquote><a id="more"></a><h2 id="Promise-的使用"><a href="#Promise-的使用" class="headerlink" title="Promise 的使用"></a>Promise 的使用</h2><h3 id="实例方法-then"><a href="#实例方法-then" class="headerlink" title="实例方法 then"></a>实例方法 then</h3><p><code>Promise</code> 中的代码默认是同步执行的，<code>then</code> 方法中的回调在微任务队列中执行，在 <code>Promise</code> 的 <code>then</code> 方法中支持传入两个参数，一个是成功的回调，一个是失败的回调，在 <code>Promise</code> 中调用了 <code>resolve</code> 方法，就会在 <code>then</code> 中执行成功的回调，调用了 <code>reject</code> 方法，就会在 <code>then</code> 中执行失败的回调，成功的回调和失败的回调只能执行一个，<code>resolve</code> 和 <code>reject</code> 方法调用时传入的参数会传递给 <code>then</code> 方法中对应的回调函数。</p><pre><code class="lang-js">/* 执行 resolve */
const p = new Promise((resolve, reject) =&gt; {
  console.log(1);
  resolve(3);
});

console.log(2);

p.then(data =&gt; {
  console.log(data);
}, err =&gt; {
  console.log(err);
});

// 1
// 2
// 3
</code></pre><pre><code class="lang-js">/* 执行 reject */
const p = new Promise((resolve, reject) =&gt; {
  reject();
});

p.then(() =&gt; {
  console.log(1);
}, () =&gt; {
  console.log(2);
});

// 2
</code></pre><p>如果 <code>Promise</code> 中发生错误，就会在 <code>then</code> 中执行失败的回调。</p><pre><code class="lang-js">/* 失败的回调 */
const p = new Promise((resolve, reject) =&gt; {
  throw new Error();
});

p.then(() =&gt; {
  console.log(1);
}, () =&gt; {
  console.log(&#39;报错啦&#39;);
});

// 报错啦
</code></pre><p>当同一个 <code>Promise</code> 实例的 <code>then</code> 方法多次调用时，就会多次执行。</p><pre><code class="lang-js">/* 多次调用 then */
const p = new Promise((resolve, reject) =&gt; {
  resolve(&#39;成功&#39;);
});

p.then(data =&gt; {
  console.log(data);
});

p.then(data =&gt; {
  console.log(data);
});

// 成功
// 成功
</code></pre><p><code>Promise</code> 支持链式调用，每次调用一次 <code>then</code> 方法都会返回一个新的 <code>Promise</code> 实例，如果该 <code>then</code> 方法中执行的回调函数有返回值，并且这个返回值会作为返回的下一个 <code>Promise</code> 实例的 <code>then</code> 方法回调的参数，如果 <code>then</code> 方法的返回值是一个 <code>Promise</code> 实例，那就返回一个新的 <code>Promise</code> 实例，将 <code>then</code> 返回的 <code>Promise</code> 实例执行后的结果作为返回 <code>Promise</code> 实例回调的参数。</p><pre><code class="lang-js">/* 链式调用 then */
function read(url) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(url, &#39;utf8&#39;, (err, data) =&gt; {
      if (err) reject(err);
      resolve(data);
    });
  });
}

read(&#39;1.txt&#39;).then(data =&gt; {
  // 假设此时读到的内容为 Hello world
  return data;
}, err =&gt; {
  console.log(err);
}).then(data =&gt; {
  console.log(data);
  // Hello world
}, err =&gt; {
  console.log(err);
});

read(&#39;1.txt&#39;).then(data =&gt; {
  // 假如此时读到的 1.txt 的内容为 2.txt 的字符串，2.txt 的内容为 Hello world
  return read(data);
}, err =&gt; {
  console.log(err);
}).then(data =&gt; {
  console.log(data);
  // Hello world
}, err =&gt; {
  console.log(err);
});
</code></pre><p>在 <code>Promise</code> 实例的 <code>then</code> 中如果有错误产生，在返回的新的 <code>Promise</code> 实例中的 <code>then</code> 方法中会执行错误的回调。</p><pre><code class="lang-js">/* 链式调用 then 出错 */
const p = new Promise((resolve, reject) =&gt; {
  resolve();
});

p.then(() =&gt; {
  console.log(&#39;success&#39;, 1);
  throw new Error();
}, () =&gt; {
  console.log(&#39;error&#39;, 1);
}).then(() =&gt; {
  console.log(&#39;success&#39;, 2);
}, () =&gt; {
  console.log(&#39;error&#39;, 2)
});

// success 1
// error 2
</code></pre><blockquote class="pullquote info"><p><strong>在 Promise 中有三个状态：</strong></p><ul><li><strong><code>pending</code>：等待态</strong></li><li><strong><code>fulfilled</code>：成功态</strong></li><li><strong><code>rejected</code>：失败态</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong><code>Promise</code> 实例的状态只能从 <code>pending</code> 到 <code>fulfilled</code> 或从 <code>pending</code> 到 <code>rejected</code>，状态一旦发生变化就不可逆，所以 <code>Promise</code> 实现链式调用与 <code>jQuery</code> 不同，返回的不是 <code>this</code>，只能是一个新的 <code>Promise</code>。</strong></p></blockquote><h3 id="实例方法-catch"><a href="#实例方法-catch" class="headerlink" title="实例方法 catch"></a>实例方法 catch</h3><p>在 <code>Promise</code> 中实例的 <code>catch</code> 方法可以捕获创建 <code>Promise</code> 过程中和链式调用中的异常，不需要每次调用 <code>then</code> 方法中都传入错误的回调，在链式调用的过程中只要有任何一个 <code>then</code> 中出现错误，都会被 <code>catch</code> 方法捕获到。</p><pre><code class="lang-js">/* 创建 Promise 实例时出错 */
const p = new Promise((resolve, reject) =&gt; {
  throw new Error();
});

p.then(() =&gt; {
  console.log(&#39;success&#39;);
}).catch(() =&gt; {
  console.log(&#39;error&#39;);
});

// error
</code></pre><pre><code class="lang-js">/* 调用 then 方法时出错 */
const p = new Promise((resolve, reject) =&gt; {
  resolve();
});

p.then(() =&gt; {
  throw new Error();
  console.log(&#39;success&#39;, 1);
}).then(() =&gt; {
  console.log(&#39;success&#39;, 2);
}).catch(() =&gt; {
  console.log(&#39;出错了&#39;);
});

// 出错了

p.then(() =&gt; {
  console.log(&#39;success&#39;, 1);
}).then(() =&gt; {
  throw new Error();
  console.log(&#39;success&#39;, 2);
}).catch(() =&gt; {
  console.log(&#39;出错了&#39;);
});

// success 1
// 出错了
</code></pre><h3 id="实例方法-finally"><a href="#实例方法-finally" class="headerlink" title="实例方法 finally"></a>实例方法 finally</h3><p><code>Promise</code> 的实例方法 <code>finally</code> 是 <code>ES7</code> 标准引入的，不管最后 <code>Promise</code> 实例的状态是成功还是失败出传入的回调都会执行，回调函数没有参数，这说明 <code>finally</code> 方法里的操作与 <code>Promise</code> 实例状态无关，不依赖于 <code>Promise</code> 的执行结果。</p><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; {
  resolve();
});

p.finally(() =&gt; {
  console.log(&#39;执行了&#39;);
});

// 执行了
</code></pre><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; {
  reject();
});

p.finally(() =&gt; {
  console.log(&#39;执行了&#39;);
});

// 未使用 catch 捕获错误，finally 不执行
</code></pre><p><code>finally</code> 方法执行后返回一个新的 <code>Promise</code>，继续调用 <code>then</code> 方法，返回值为执行 <code>finally</code> 之前的结果。</p><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

p.finally(() =&gt; {
  console.log(&#39;fanilly&#39;);
}).then(data =&gt; {
  console.log(data);
});

// fanilly
// 1
</code></pre><pre><code class="lang-js">const p = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

p.then(data =&gt; {
  return data;
}).finally(() =&gt; {
  console.log(&#39;执行了&#39;);
  return 2;
}).then(data =&gt; {
  console.log(&#39;data: &#39;, data);
});

// 执行了
// 1
// data: Promise {&lt;resolved&gt;: undefined}
</code></pre><h3 id="静态方法-Promise-all"><a href="#静态方法-Promise-all" class="headerlink" title="静态方法 Promise.all"></a>静态方法 Promise.all</h3><p><code>Promise</code> 中的静态方法 <code>all</code> 可以实现多个 <code>Promise</code> 实例的并行，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 <code>Promise</code> 实例的返回结果，每一个 <code>Promise</code> 实例的返回顺序先后不固定，但是返回值的数组内存储每一个 <code>Promise</code> 的返回值的结果按照最初传入的顺序排列，<code>all</code> 方法的返回值为一个新的 <code>Promise</code> 实例，返回的数组作为返回新 <code>Promise</code> 的 <code>then</code> 方法成功回调的参数。</p><p>当 <code>all</code> 传入的参数数组中的 <code>Promise</code> 实例执行时，只要有一个失败，则直接返回该 <code>Promise</code> 实例失败的结果或错误信息。</p><pre><code class="lang-js">/* Promise.all 方法 */
const p1 = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

const p2 = new Promise((resolve, reject) =&gt; {
  resolve(2);
});

Promise.all([p1, p2]).then(data =&gt; {
  console.log(data);
});

// [1, 2]
</code></pre><pre><code class="lang-js">/* Promise.all 错误捕获 */
const p1 = new Promise((resolve, reject) =&gt; {
  resolve(1);
});

const p2 = new Promise((resolve, reject) =&gt; {
  reject(2);
});

Promise.all([p1, p2]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
});

// 2
</code></pre><h3 id="静态方法-Promise-race"><a href="#静态方法-Promise-race" class="headerlink" title="静态方法 Promise.race"></a>静态方法 Promise.race</h3><p><code>Promise</code> 的静态方法 <code>race</code> 的用法和 <code>all</code> 类似，参数同为一个存储 <code>Promise</code> 实例的数组，返回值同样是一个新的 <code>Promise</code> 的实例，不同的是，数组中的 <code>Promise</code> 实例只有一个结果为成功，那就直接返回这个结果（只取出最快返回的结果），在没有成功的结果之前有一个出错，就直接返回这个错误。</p><pre><code class="lang-js">/* Promise.race 方法 */
const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(1), 2000);
});

const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(2), 1000);
});

Promise.race([p1, p2]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
});

// 2
</code></pre><pre><code class="lang-js">/* Promise.race 错误捕获 */
const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; reject(1), 1000);
});

const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(2), 2000);
});

Promise.race([p1, p2]).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
});

// 1
</code></pre><h3 id="静态方法-Promise-resolve"><a href="#静态方法-Promise-resolve" class="headerlink" title="静态方法 Promise.resolve"></a>静态方法 Promise.resolve</h3><p><code>Promise</code> 的静态方法 <code>resolve</code> 可以直接将 <code>Promise</code> 的状态变为成功并返回一个新的 <code>Promise</code> 实例，<code>resolve</code> 的参数会传递给返回的新 <code>Promise</code> 实例 <code>then</code> 中成功回调。</p><pre><code class="lang-js">/* Promise.resolve 方法 */
Promise.resolve(&#39;hello&#39;).then(data =&gt; {
  console.log(data);
});

// hello
</code></pre><h3 id="静态方法-Promise-reject"><a href="#静态方法-Promise-reject" class="headerlink" title="静态方法 Promise.reject"></a>静态方法 Promise.reject</h3><p><code>Promise</code> 的静态方法 <code>reject</code> 与 <code>resolve</code> 使用完全相同，都返回一个新的 <code>Promise</code> 实例，不同的是 <code>reject</code> 的参数会传递给新 <code>Promise</code> 实例的 <code>then</code> 方法失败回调。</p><pre><code class="lang-js">/* Promise.reject 方法 */
Promise.reject(&#39;出错了&#39;).then(null, err =&gt; {
  console.log(err);
});

// 出错了
</code></pre><p>当成功的回调不传递时，可以使用 <code>null</code> 代替，因为 <code>null</code> 作为参数会被忽略掉，将参数穿透到下一个 <code>then</code> 的回调中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>Promise</code> 是异步编程的一大趋势，也是当前更先进的异步解决方案的基础，下一篇我们着重讨论一下 <code>Promise</code> 的实现原理以及 <code>A+</code> 规范。</strong></p></blockquote>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>九种 “姿势” 让你彻底解决跨域问题</title>
    <url>/20180611010638/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/HTTP/20180611010638/browser.png" title="跨域"><p><br></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote class="pullquote info"><p><strong>同源策略 <code>SOP</code>（Same origin policy）是一种约定，由 <code>Netscape</code> 公司 <code>1995</code> 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <code>XSS</code>、<code>CSRF</code> 等攻击。所谓同源是指 “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 <code>ip</code> 地址，也非同源。</strong></p></blockquote><a id="more"></a><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 都是不支持跨域的。</p><p>假设 <code>cookie</code> 支持了跨域，<code>http</code> 协议无状态，当用户访问了一个银行网站登录后，银行网站的服务器给返回了一个 <code>sessionId</code>，当通过当前浏览器再访问一个恶意网站，如果 <code>cookie</code> 支持跨域，恶意网站将获取 <code>sessionId</code> 并访问银行网站，出现安全性问题；<code>IndexDB</code>、<code>localStorage</code> 等数据存储在不同域的页面切换时是获取不到的；假设 <code>Dom</code> 元素可以跨域，在自己的页面写入一个 <code>iframe</code> 内部嵌入的地址是 <a href="javascript:;">www.baidu.com</a>，当在百度页面登录账号密码时就可以在自己的页面获取百度的数据信息，这显然是不合理的。</p><p>这就是为什么 <code>cookie</code>、<code>localStorage</code>、<code>dom</code>、<code>ajax</code>、<code>IndexDB</code> 会受到同源策略会限制，下面还有一点对跨域理解的误区：</p><blockquote class="pullquote warning"><ul><li><strong>误区：同源策略限制下，访问不到后台服务器的数据，或访问到后台服务器的数据后没有返回；</strong></li><li><strong>正确：同源策略限制下，可以访问到后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。</strong></li></ul></blockquote><h2 id="实现跨域的方式"><a href="#实现跨域的方式" class="headerlink" title="实现跨域的方式"></a>实现跨域的方式</h2><h3 id="使用-jsonp-跨域"><a href="#使用-jsonp-跨域" class="headerlink" title="使用 jsonp 跨域"></a>使用 jsonp 跨域</h3><p><strong>使用场景：当自己的项目前端资源和后端部署在不同的服务器地址上，或者其他的公司需要访问自己对外公开的接口，需要实现跨域获取数据，如百度搜索。</strong></p><pre><code class="lang-js">/* 封装 jsonp */
// 封装 jsonp 跨域请求的方法
function jsonp({ url, params, cb }) {
  return new Promise((resolve, reject) =&gt; {
    // 创建一个 script 标签帮助我们发送请求
    let script = document.createElement(&#39;script&#39;);
    const arr = [];
    params = { ...params, cb };

    // 循环构建键值对形式的参数
    for (let key in params) {
      arr.push(key + &#39;=&#39; + params[key]);
    }

    // 创建全局函数
    window[cb] = function (data) {
      resolve(data);
      // 在跨域拿到数据以后将 script 标签销毁
      document.body.removeChild(script);
    };

    // 拼接发送请求的参数并赋值到 src 属性
    script.src = url + &#39;?&#39; arr.join(&#39;&amp;&#39;);
    document.body.appendChild(script);
  });
}

// 调用方法跨域请求百度搜索的接口
json({
  url: &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#39;,
  params: {
    wd: &#39;jsonp&#39;
  },
  cb: &#39;show&#39;
}).then(data =&gt; {
  // 打印请求回的数据
  console.log(data);
});
</code></pre><blockquote class="pullquote danger"><p><strong>缺点：</strong></p><ul><li><strong>只能发送 <code>get</code> 请求，不支持 <code>post</code>、<code>put</code>、<code>delete</code> 等；</strong></li><li><strong>不安全，容易引发 <code>xss</code> 攻击，会把别人的脚本引入到自己的页面中执行，如：弹窗、广告等，甚至更危险的脚本程序，如在返回的结果中返回了下面代码。</strong></li></ul></blockquote><pre><code class="lang-vim">`let script = document.createElement(&#39;script&#39;);
script.src = &#39;http://192.168.0.57:8080/xss.js&#39;;
document.body.appendChild(script);`;
</code></pre><h3 id="使用-CORS-跨域"><a href="#使用-CORS-跨域" class="headerlink" title="使用 CORS 跨域"></a>使用 CORS 跨域</h3><blockquote class="pullquote info"><p><strong>跨源资源共享 <code>CORS</code>（Cross-Origin Resource Sharing）是 <code>W3C</code> 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。<code>CORS</code> 背后的基本思想，就是使用自定义的 <code>HTTP</code> 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</strong></p></blockquote><p><strong>使用场景：多用于开发时，前端与后台在不同的 <code>ip</code> 地址下进行数据访问。</strong></p><p>现在启动两个端口号不同的服务器，创建跨域条件，服务器（<code>Node.js</code>）代码如下：</p><pre><code class="lang-js">/* 服务端代码 */
// 服务器1
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(3000);

// 服务器2
const express = require(&#39;express&#39;);
const app = express();
app.get(&#39;/getDate&#39;, function (req, res) {
  res.end(&#39;I love you&#39;);
});
app.use(express.static(__dirname));
app.listen(4000);
</code></pre><p>由于我们的 <code>Node.js</code> 服务器使用 <code>express</code> 框架，在我们的项目根目录下的命令行中输入下面代码进行安装：</p><pre><code class="lang-bash">$ npm install express --save
</code></pre><p>通过访问 <a href="javascript:;">http://localhost:3000/index.html</a> 获取 <code>index.html</code> 文件并执行其中的 <code>Ajax</code> 请求 <a href="javascript:;">http://localhost:4000/getDate</a> 接口去获取数据，<code>index.html</code> 文件内容如下：</p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;CORS 跨域&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    const xhr = new XMLHttpRequest();

    // 正常 cookie 是不允许跨域的
    document.cookie = &#39;name=hello&#39;;

    // cookie 想要实现跨域必须携带凭证
    xhr.withCredentials = true;

    // xhr.open(&#39;GET&#39;, &#39;http://localhost:4000/getDate&#39;, true);
    xhr.open(&#39;PUT&#39;, &#39;http://localhost:4000/getDate&#39;, true);

    // 设置名为 name 的自定义请求头
    xhr.setRequestHeader(&#39;name&#39;, &#39;hello&#39;);

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) {
          // 打印返回的数据
          console.log(xhr.response);

          // 打印后台设置的自定义头信息
          console.log(xhr.getResponseHeader(&#39;name&#39;));
        }
      }
    }
    xhr.send();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>上面 <code>index.html</code> 代码中发送请求访问不在同源的服务器 <code>2</code>，此时会在控制台给出错误信息，告诉我们缺少了哪些响应头，我们对应报错信息去修改访问的服务器 <code>2</code> 的代码，添加对应的响应头，实现 <code>CORS</code> 跨域。</p><pre><code class="lang-js">/* 服务端代码 */
// 服务器2
const express = require(&#39;express&#39;);
const app = express();

// 允许访问域的白名单
const whiteList = [&#39;http://localhost:3000&#39;];

app.use(function (req, res, next) {
  let origin = req.header.origin;
  if (whiteList.includes(origin)) {
    // 设置那个源可以访问我，参数为 * 时
    // 允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin);

    // 想要获取 ajax 的头信息，需设置响应头
    res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;name&#39;);

    // 处理复杂请求的头
    res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT&#39;);

    // 允许发送 cookie 凭证的响应头
    res.setHeader(&#39;Access-Control-Allow-Credentials&#39;, true);

    // 允许前端获取哪个头信息
    res.setHeader(&#39;Access-Control-Expose-Headers&#39;, &#39;name&#39;);

    // 处理 OPTIONS 预检的存活时间，单位 s
    res.setHeader(&#39;Access-Control-Max-Age&#39;, 5);

    // 发送 PUT 请求会做一个试探性的请求 OPTIONS
    // 其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理
    if (req.method === &#39;OPTIONS&#39;) {
      res.end();
    }
  }
  next();
});

app.put(&#39;/getDate&#39;, function (req, res) {
  // res.setHeader(&#39;name&#39;, &#39;nihao&#39;); // 设置自定义响应头信息
  res.end(&#39;I love you&#39;);
});

app.get(&#39;/getDate&#39;, function (req, res) {
  res.end(&#39;I love you&#39;);
});

app.use(express.static(__dirname));
app.listen(4000);
</code></pre><h3 id="使用-postMessage-实现跨域"><a href="#使用-postMessage-实现跨域" class="headerlink" title="使用 postMessage 实现跨域"></a>使用 postMessage 实现跨域</h3><blockquote class="pullquote info"><p><strong>postMessage 是 <code>H5</code> 的新 <code>API</code>，跨文档消息传送（cross-document messaging），有时候简称为 <code>XMD</code>，指的是在来自不同域的页面间传递消息。</strong></p></blockquote><blockquote class="pullquote primary"><p><strong>调用方式：</strong><code>window.postMessage(message, targetOrigin)</code></p><ul><li><strong><code>message</code>：发送的数据</strong></li><li><strong><code>targetOrigin</code>：发送的窗口的域</strong></li></ul></blockquote><blockquote class="pullquote default"><p><strong>在对应的页面中用 <code>message</code> 事件接收，事件对象中有 <code>data</code>、<code>origin</code>、<code>source</code> 三个重要信息：</strong></p><ul><li><strong><code>data</code>：接收到的数据</strong></li><li><strong><code>origin</code>：接收到数据源的域（数据来自哪个域）</strong></li><li><strong><code>source</code>：接收到数据源的窗口对象（数据来自哪个窗口对象）</strong></li></ul></blockquote><p><strong>使用场景：不是使用 <code>Ajax</code> 的数据通信，更多是在两个页面之间的通信，在 <code>A</code> 页面中引入 <code>B</code> 页面，在 <code>A</code>、<code>B</code> 两个页面之间通信。</strong></p><p>与上面 <code>CORS</code> 类似，我们要创建跨域场景，搭建两个端口号不同的 <code>Node.js</code> 服务器，后面相同方式就不多赘述了。</p><pre><code class="lang-js">/* 服务端代码 */
// 服务器1
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(3000);

// 服务器2
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(4000);
</code></pre><p>通过访问 <a href="javascript:;">http://localhost:3000/a.html</a>，在 <code>a.html</code> 中使用 <code>iframe</code> 标签引入 <a href="javascript:;">http://localhost:4000/b.html</a>，在两个窗口间传递数据。</p><pre><code class="lang-html">&lt;!-- 文件：a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 A&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;iframe src=&quot;http://localhost:4000/b.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;
  &lt;/iframe&gt;
  &lt;script&gt;
    function load() {
      let frame = document.getElementById(&#39;frame&#39;);
      frame.contentWindow.postMessage(&#39;I love you&#39;, &#39;http://localhost:4000&#39;);
      window.onmessage = function (e) {
        console.log(e.data);
      }
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-html">&lt;!-- 文件：b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 B&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    window.onmessage = function (e) {
      // 打印来自页面 A 的消息
      console.log(e.data);
      // 给页面 A 发送回执
      e.source.postMessage(&#39;I love you, too&#39;, e.origin);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用-window-name-实现跨域"><a href="#使用-window-name-实现跨域" class="headerlink" title="使用 window.name 实现跨域"></a>使用 window.name 实现跨域</h3><p>同样是页面之间的通信，需要借助 <code>iframe</code> 标签，<code>A</code> 页面和 <code>B</code> 页面是同域的 <a href="javascript:;">http://localhost:3000</a>，<code>C</code> 页面在独立的域 <a href="javascript:;">http://localhost:4000</a>。</p><pre><code class="lang-js">/* 服务端代码 */
// 服务器1
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(3000);

// 服务器2
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(4000);
</code></pre><p>实现思路：在 <code>A</code> 页面中将 <code>iframe</code> 的 <code>src</code> 指向 <code>C</code> 页面，在 <code>C</code> 页面中将属性值存入 <code>window.name</code> 中，再把 <code>iframe</code> 的 <code>src</code> 换成同域的 <code>B</code> 页面，在当前的 <code>iframe</code> 的 <code>window</code> 对象中取出 <code>name</code> 的值，访问 <a href="javascript:;">http://localhost:3000/a.html</a>。</p><pre><code class="lang-html">&lt;!-- 文件：a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 A&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;iframe src=&quot;http://localhost:4000/c.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;
  &lt;/iframe&gt;
  &lt;script&gt;
    // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值
    let isFirst = true;
    function load() {
      let frame = document.getElementById(&#39;frame&#39;);
      if (isFirst) {
        frame.src = &#39;http://localhost:3000/b.html&#39;;
        isFirst = false;
      } else {
        console.log(frame.contentWindow.name);
      }
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-html">&lt;!-- 文件：c.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 C&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    window.name = &#39;I love you&#39;;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用-location-hash-实现跨域"><a href="#使用-location-hash-实现跨域" class="headerlink" title="使用 location.hash 实现跨域"></a>使用 location.hash 实现跨域</h3><p>与 <code>window.name</code> 跨域的情况相同，是不同域的页面间的参数传递，需要借助 <code>iframe</code> 标签，<code>A</code> 页面和 <code>B</code> 页面是同域的 <a href="javascript:;">http://localhost:3000</a>，<code>C</code> 页面是独立的域 <a href="javascript:;">http://localhost:4000</a>。</p><pre><code class="lang-js">/* 服务端代码 */
// 服务器1
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(3000);

// 服务器2
const express = require(express);
const app = express();
app.use(express.static(__dirname));
app.listen(4000);
</code></pre><p>实现思路：<code>A</code> 页面通过 <code>iframe</code> 引入 <code>C</code> 页面，并给 <code>C</code> 页面传一个 <code>hash</code> 值，<code>C</code> 页面收到 <code>hash</code> 值后创建 <code>iframe</code> 引入 <code>B</code> 页面，把 <code>hash</code> 值传给 <code>B</code> 页面，<code>B</code> 页面将自己的 <code>hash</code> 值放在 <code>A</code> 页面的 <code>hash</code> 值中，访问 <a href="javascript:;">http://localhost:3000/a.html</a>。</p><pre><code class="lang-html">&lt;!-- 文件：a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 A&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;iframe src=&quot;http://localhost:4000/c.html#Iloveyou&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;
  &lt;script&gt;
    // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值
    window.onhashchange = function () {
      console.log(location.hash);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-html">&lt;!-- 文件：c.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 C&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    // 打印 A 页面引入 C 页面设置的 hash 值
    console.log(location.hash);
    let iframe = document.createElement(&#39;iframe&#39;);
    iframe.src = &#39;http://localhost:3000/b.html#Iloveyoutoo&#39;;
    document.body.appendChild(iframe);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-html">&lt;!-- 文件：b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 B&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面
    window.parent.parent.location.hash = location.hash;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用-document-domain-实现跨域"><a href="#使用-document-domain-实现跨域" class="headerlink" title="使用 document.domain 实现跨域"></a>使用 document.domain 实现跨域</h3><p><strong>使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如</strong> <a href="javascript:;">www.baidu.com</a> <strong>与</strong> <a href="javascript:;">video.baidu.com</a> <strong>之间。</strong></p><pre><code class="lang-js">/* 服务端代码 */
const express = require(&#39;express&#39;);
const app = express();

app.use(express.static(__dirname));
app.listen(3000);
</code></pre><p>想要模拟使用 <code>document.domain</code> 跨域的场景需要做些小小的准备，到 <a href="javascript:;">C:\Windows\System32\drivers\etc</a> 该路径下找到 <code>hosts</code> 文件，在最下面创建一个一级域名和一个二级域名。</p><pre><code class="lang-vim">127.0.0.1   www.domainacross.com
127.0.0.1   sub.domainacross.com
</code></pre><p>命名是随意的，只要是符合一级域名与 二级域名的关系即可，然后访问 <a href="javascript:;">http://www.domainacross.com:3000/a.html</a>。</p><pre><code class="lang-html">&lt;!-- 文件：a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面 A&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;我是页面 A 的内容&lt;/p&gt;
  &lt;iframe
    src=&quot;http://sucess.domainacross.com:3000/b.html&quot;
    onload=&quot;load()&quot;
    id=&quot;frame&quot;
  &gt;&lt;/iframe&gt;
  &lt;script&gt;
    document.domain = &#39;domainacross.com&#39;;
    function load() {
      console.log(frame.contentWindow.message);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-html">&lt;!-- 文件：b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;页面 B&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;我是 B 页面的内容&lt;/p&gt;
  &lt;script&gt;
    document.domain = &#39;domainacross.com&#39;;
    var message = &#39;Hello A&#39;;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用-WebSocket-实现跨域"><a href="#使用-WebSocket-实现跨域" class="headerlink" title="使用 WebSocket 实现跨域"></a>使用 WebSocket 实现跨域</h3><blockquote class="pullquote info"><p><strong><code>WebSocket</code> 没有跨域限制，高级 <code>API</code>（不兼容），想要兼容低版本浏览器，可以使用 <code>socket.io</code> 的库，<code>WebSocket</code> 与 <code>HTTP</code> 内部都是基于 <code>TCP</code> 协议，区别在于 <code>HTTP</code> 是单向的（单双工），<code>WebSocket</code> 是双向的（全双工），协议是 <code>ws://</code> 和 <code>wss://</code> 对应 <code>http://</code> 和 <code>https://</code>，因为没有跨域限制，所以使用 <code>file://</code> 协议也可以进行通信。</strong></p></blockquote><p>由于我们在 <code>Node.js</code> 服务中使用了 <code>WebSocket</code>，所以需要安装对应的依赖：</p><pre><code class="lang-bash">$ npm install ws --save
</code></pre><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    // 创建 webSocket
    const socket = new WebSocket(&#39;ws://localhost:3000&#39;);
    // 连接上触发
    socket.onopen = function () {
      socket.send(&#39;I love you&#39;);
    }
    // 收到消息触发
    socket.onmessage = function (e) {
      // 打印收到的数据
      console.log(e.data); // I love you, too
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-js">/* 服务端代码 */
const express = require(&#39;express&#39;);
const app = express();

// 引入 webSocket
const WebSocket = require(&#39;ws&#39;);
// 创建连接，端口号与前端相对应
const wss = new WebSocket.Server({ port: 3000 });

// 监听连接
wss.on(&#39;connection&#39;, function (ws) {
  // 监听消息
  ws.on(&#39;message&#39;, function (data) {
    // 打印消息
    console.log(data); // I love you
    // 发送消息
    ws.send(&#39;I love you, too&#39;);
  });
});
</code></pre><h3 id="使用-nginx-实现跨域"><a href="#使用-nginx-实现跨域" class="headerlink" title="使用 nginx 实现跨域"></a>使用 nginx 实现跨域</h3><blockquote class="pullquote warning"><p><strong><code>nginx</code> 本身就是一个服务器，因此我们需要去 <code>nginx</code> 官网下载服务环境</strong> <a>http://nginx.org/en/download.html</a><strong>。</strong></p><ul><li><strong>下载后解压到一个文件夹中；</strong></li><li><strong>双击 <code>nginx.exe</code> 启动（此时可以通过</strong> <a href="javascript:;">http://localhost</a> <strong>访问 <code>nginx</code> 服务）；</strong></li><li><strong>在目录新建 <code>json</code> 文件夹；</strong></li><li><strong>进入 <code>json</code> 文件夹新建 <code>data.json</code> 文件并写入内容；</strong></li><li><strong>回到 <code>nginx</code> 根目录进入 <code>conf</code> 文件夹；</strong></li><li><strong>使用编辑器打开 <code>nginx.conf</code> 进行配置。</strong></li></ul></blockquote><p><strong>data.json 文件：</strong></p><pre><code class="lang-json">{
  &quot;name&quot;: &quot;nginx&quot;
}
</code></pre><p><strong>nginx.conf 文件：</strong></p><pre><code class="lang-nginx"># nginx 配置
server {
  # ...
  location ~.*\.json {
    root json;
    add_header &quot;Access-Control-Allow-Origin&quot; &quot;*&quot;;
  }
  # ...
}
</code></pre><blockquote class="pullquote danger"><p><strong>含义：</strong></p><ul><li><strong>~.*\.json：代表忽略大小写，后缀名为 json 的文件；</strong></li><li><strong>root json：代表 <code>json</code> 文件夹；</strong></li><li><strong>add_header：代表加入跨域的响应头及允许访问的域，<code>*</code> 为允许任何访问。</strong></li></ul></blockquote><p>在 <code>nginx</code> 根目录启动 <code>cmd</code> 命令行（<code>Windows</code> 系统必须使用 <code>cmd</code> 命令行）执行下面代码重启 <code>nginx</code>。</p><pre><code class="lang-bash">$ nginx -s reload
</code></pre><p>不跨域访问：<a href="javascript:;">http://localhost/data.json</a>，跨域访问时需要创建跨域条件代码如下：</p><pre><code class="lang-js">/* 服务端代码 */
const express = require(&#39;express&#39;);
const app = express();

app.use(express.static(__dirname));
app.listen(3000);
</code></pre><p>跨域访问：<a href="javascript:;">http://localhost:3000/index.html</a></p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;nginx跨域&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    const xhr = new XMLHttpRequest();
    xhr.open(&#39;GET&#39;, &#39;http://localhost/data.json&#39;, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) {
          console.log(xhr.response);
        }
      }
    }
    xhr.send();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用-http-proxy-middleware-实现跨域"><a href="#使用-http-proxy-middleware-实现跨域" class="headerlink" title="使用 http-proxy-middleware 实现跨域"></a>使用 http-proxy-middleware 实现跨域</h3><p><code>Node.js</code> 中间件 <code>http-proxy-middleware</code> 实现跨域代理，原理大致与 <code>nginx</code> 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 <code>cookieDomainRewrite</code> 参数修改响应头中 <code>cookie</code> 中的域名，实现当前域的 <code>cookie</code> 写入，方便接口登录认证。</p><h4 id="非-vue-框架的跨域（2-次跨域）"><a href="#非-vue-框架的跨域（2-次跨域）" class="headerlink" title="非 vue 框架的跨域（2 次跨域）"></a>非 vue 框架的跨域（2 次跨域）</h4><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;proxy 跨域&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    const xhr = new XMLHttpRequest();

    // 前端开关：浏览器是否读写 cookie
    xhr.withCredentials = true;

    // 访问 http-proxy-middleware 代理服务器
    xhr.open(&#39;get&#39;, &#39;http://www.proxy1.com:3000/login?user=admin&#39;, true);
    xhr.send();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>中间代理服务中使用了 <code>http-proxy-middleware</code> 中间件，因此需要提前下载：</p><pre><code class="lang-bash">$ npm install http-proxy-middleware --save-dev
</code></pre><pre><code class="lang-js">/* 中间代理服务器 */
const express = require(&#39;express&#39;);
const proxy = require(&#39;http-proxy-middleware&#39;);
const app = express();

app.use(
  &#39;/&#39;,
  proxy({
    // 代理跨域目标接口
    target: &#39;http://www.proxy2.com:8080&#39;,
    changeOrigin: true,

    // 修改响应头信息，实现跨域并允许带 cookie
    onProxyRes: function (proxyRes, req, res) {
      res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.proxy1.com&#39;);
      res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);
    },

    // 修改响应信息中的 cookie 域名
    cookieDomainRewrite: &#39;www.proxy1.com&#39; // 可以为 false，表示不修改
  });
);

app.listen(3000);
</code></pre><pre><code class="lang-js">/* 服务器 */
const http = require(&#39;http&#39;);
const qs = require(&#39;querystring&#39;);

const server = http.createServer();

server.on(&#39;request&#39;, function (req, res) {
  let params = qs.parse(req.url.substring(2));

  // 向前台写 cookie
  res.writeHead(200, {
    // HttpOnly：脚本无法读取
    &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly&#39;
  });

  res.write(JSON.stringify(params));
  res.end();
});

server.listen(&#39;8080&#39;);
</code></pre><h4 id="vue-框架的跨域（1-次跨域）"><a href="#vue-框架的跨域（1-次跨域）" class="headerlink" title="vue 框架的跨域（1 次跨域）"></a>vue 框架的跨域（1 次跨域）</h4><p>利用 <code>node + webpack + webpack-dev-server</code> 代理接口跨域。在开发环境下，由于 <code>Vue</code> 渲染服务和接口代理服务都是 <code>webpack-dev-server</code>，所以页面与代理接口之间不再跨域，无须设置 <code>Headers</code> 跨域信息了。</p><pre><code class="lang-js">/* 导出服务器配置 */
module.exports = {
  entry: {},
  module: {},
  // ...
  devServer: {
    historyApiFallback: true,
    proxy: [{
      context: &#39;/login&#39;,
      target: &#39;http://www.proxy2.com:8080&#39;,  // 代理跨域目标接口
      changeOrigin: true,
      secure: false,  // 当代理某些 https 服务报错时用
      cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为 false，表示不修改
    }],
    noInfo: true
  }
}
</code></pre><blockquote class="pullquote success"><p><strong>本篇文章在于帮助我们理解跨域，以及不同跨域方式的基本原理，在公司的项目比较多，多个域使用同一个服务器或者数据，以及在开发环境时，跨域的情况基本无法避免，一般会有各种各样形式的跨域解决方案，但其根本原理基本都在上面的跨域方式当中方式，我们可以根据开发场景不同，选择最合适的跨域解决方案。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTTP</tag>
        <tag>跨域</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟 Vue 手写一个 MVVM</title>
    <url>/20180328140039/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Vue/20180328140039/mvvm.png" title="MVVM"><p><br></p><h2 id="MVVM-的前世今生"><a href="#MVVM-的前世今生" class="headerlink" title="MVVM 的前世今生"></a>MVVM 的前世今生</h2><blockquote class="pullquote info"><p><strong><code>MVVM</code> 设计模式，是由 <code>MVC</code>（最早来源于后端）、<code>MVP</code> 等设计模式进化而来，<code>M</code> - 数据模型（<code>Model</code>），<code>VM</code> - 视图模型（<code>ViewModel</code>），<code>V</code> - 视图层（<code>View</code>）。</strong></p></blockquote><p>在 <code>MVC</code> 模式中，除了 <code>Model</code> 和 <code>View</code> 层以外，其他所有的逻辑都在 <code>Controller</code> 中，<code>Controller</code> 负责显示页面、响应用户操作、网络请求及与 Model 的交互，随着业务的增加和产品的迭代，Controller 中的处理逻辑越来越多、越来越复杂，难以维护。为了更好的管理代码，为了更方便的扩展业务，必须要为 <code>Controller</code> “瘦身”，需要更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离，<code>MVVM</code> 为此而生。</p><p>很多 <code>MVVM</code> 的实现都是通过数据绑定来将 <code>View</code> 的逻辑从其他层分离，可以用下图来简略的表示。</p><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Vue/20180328140039/mvvm-content.png" alt="MVVM 模型图"></div><div class="image-caption">MVVM 模型图</div></figure><p><br></p><p>使用 <code>MVVM</code> 设计模式的前端框架很多，其中渐进式框架 <code>Vue</code> 是典型的代表，并在开发使用中深得广大前端开发者的青睐，我们这篇就根据 <code>Vue</code> 对于 <code>MVVM</code> 的实现方式来简单模拟一版 <code>MVVM</code> 库。</p><h2 id="MVVM-的流程分析"><a href="#MVVM-的流程分析" class="headerlink" title="MVVM 的流程分析"></a>MVVM 的流程分析</h2><p>在 <code>Vue</code> 的 <code>MVVM</code> 设计中，我们主要针对 <code>Compile</code>（模板编译）、<code>Observer</code>（数据劫持）、<code>Watcher</code>（数据监听）和 <code>Dep</code>（发布订阅）几个部分来实现，核心逻辑流程可参照下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Vue/20180328140039/mvvm-flow.jpg" alt="MVVM 流程图"></div><div class="image-caption">MVVM 流程图</div></figure><p><br></p><p>类似这种 “造轮子” 的代码毋庸置疑一定是通过面向对象编程来实现的，并严格遵循开放封闭原则，由于 <code>ES5</code> 的面向对象编程比较繁琐，所以，在接下来的代码中统一使用 <code>ES6</code> 的 <code>class</code> 来实现。</p><h2 id="MVVM-类的实现"><a href="#MVVM-类的实现" class="headerlink" title="MVVM 类的实现"></a>MVVM 类的实现</h2><p>在 <code>Vue</code> 中，对外只暴露了一个名为 <code>Vue</code> 的构造函数，在使用的时候 <code>new</code> 一个 <code>Vue</code> 实例，然后传入了一个 <code>options</code> 参数，类型为一个对象，包括当前 <code>Vue</code> 实例的作用域 <code>el</code>、模板绑定的数据 <code>data</code> 等等。</p><p>我们模拟这种 <code>MVVM</code> 模式的时候也构建一个类，名字就叫 <code>MVVM</code>，在使用时同 <code>Vue</code> 框架类似，需要通过 <code>new</code> 指令创建 <code>MVVM</code> 的实例并传入 <code>options</code>。</p><pre><code class="lang-js">/* 文件：MVVM.js */
class MVVM {
  constructor(options) {
    // 先把 el 和 data 挂在 MVVM 实例上
    this.$el = options.el;
    this.$data = options.data;

    // 如果有要编译的模板就开始编译
    if (this.$el) {
      // 数据劫持，就是把对象所有的属性添加 get 和 set
      new Observer(this.$data);

      // 将数据代理到实例上
      this.proxyData(this.$data);

      // 用数据和元素进行编译
      new Compile(this.el, this);
    }
  }
  proxyData(data) { // 代理数据的方法
    Object.keys(data).forEach(key =&gt; {
      Object.defineProperty(this, key, {
        get() {
          return data[key];
        }
        set(newVal) {
          data[key] = newVal;
        }
      });
    });
  }
}
</code></pre><p>通过上面代码，我们可以看出，在我们 <code>new</code> 一个 <code>MVVM</code> 的时候，在参数 <code>options</code> 中传入了一个 <code>Dom</code> 的根元素节点和数据 <code>data</code> 并挂在了当前的 <code>MVVM</code> 实例上。</p><p>当存在根节点的时候，通过 <code>Observer</code> 类对 <code>data</code> 数据进行了劫持，并通过 <code>MVVM</code> 实例的方法 <code>proxyData</code> 把 <code>data</code> 中的数据挂在当前 <code>MVVM</code> 实例上，同样对数据进行了劫持，是因为我们在获取和修改数据的时候可以直接通过 <code>this</code> 或 <code>this.$data</code>，在 Vue 中实现数据劫持的核心方法是 <code>Object.defineProperty</code>，我们也使用这个方式通过添加 <code>getter</code> 和 <code>setter</code> 来实现数据劫持。</p><p>最后使用 <code>Compile</code> 类对模板和绑定的数据进行了解析和编译，并渲染在根节点上，之所以数据劫持和模板解析都使用类的方式实现，是因为代码方便维护和扩展，其实不难看出，<code>MVVM</code> 类其实作为了 <code>Compile</code> 类和 <code>Observer</code> 类的一个桥梁。</p><h2 id="模板编译-Compile-类的实现"><a href="#模板编译-Compile-类的实现" class="headerlink" title="模板编译 Compile 类的实现"></a>模板编译 Compile 类的实现</h2><p><code>Compile</code> 类在创建实例的时候需要传入两个参数，第一个参数是当前 <code>MVVM</code> 实例作用的根节点，第二个参数就是 <code>MVVM</code> 实例，之所以传入 <code>MVVM</code> 的实例是为了更方便的获取 <code>MVVM</code> 实例上的属性。</p><p>在 <code>Compile</code> 类中，我们会尽量的把一些公共的逻辑抽取出来进行最大限度的复用，避免冗余代码，提高维护性和扩展性，我们把 <code>Compile</code> 类抽取出的实例方法主要分为两大类，辅助方法和核心方法，在代码中用注释标明。</p><h3 id="解析根节点内的-Dom-结构"><a href="#解析根节点内的-Dom-结构" class="headerlink" title="解析根节点内的 Dom 结构"></a>解析根节点内的 Dom 结构</h3><pre><code class="lang-js">/* 文件：Compile.js */
class Compile {
  constructor(el, vm) {
    this.el = this.isElementNode(el) ? el : document.querySelector(el);
    this.vm = vm;

    // 如过传入的根元素存在，才开始编译
    if (this.el) {
      // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）
      let fragment = this.node2fragment(this.el);
    }
  }

  /* 辅助方法 */
  // 判断是否是元素节点
  isElementNode(node) {
    return node.nodeType === 1;
  }

  /* 核心方法 */
  // 将根节点转移至文档碎片
  node2fragment(el) {
    // 创建文档碎片
    let fragment = document.createDocumentFragment();
    // 第一个子节点
    let firstChild;

    // 循环取出根节点中的节点并放入文档碎片中
    while (firstChild = el.firstChild) {
      fragment.appendChild(firstChild);
    }
    return fragment;
  }
}
</code></pre><p>上面编译模板的过程中，前提条件是必须存在根元素节点，传入的根元素节点允许是一个真实的 <code>Dom</code> 元素，也可以是一个选择器，所以我们创建了辅助方法 <code>isElementNode</code> 来帮我们判断传入的元素是否是 <code>Dom</code>，如果是就直接使用，是选择器就获取这个 <code>Dom</code>，最终将这个根节点存入 <code>this.el</code> 属性中。</p><p>解析模板的过程中为了性能，我们应取出根节点内的子节点存放在文档碎片中（内存），需要注意的是将一个 <code>Dom</code> 节点内的子节点存入文档碎片的过程中，会在原来的 <code>Dom</code> 容器中删除这个节点，所以在遍历根节点的子节点时，永远是将第一个节点取出存入文档碎片，直到节点不存在为止。</p><h3 id="编译文档碎片中的结构"><a href="#编译文档碎片中的结构" class="headerlink" title="编译文档碎片中的结构"></a>编译文档碎片中的结构</h3><p>在 Vue 中的模板编译的主要就是两部分，也是浏览器无法解析的部分，元素节点中的指令和文本节点中的 Mustache 语法（双大括号）。</p><pre><code class="lang-js">/* 文件：Compile.js —— 完善 */
class Compile {
  constructor(el, vm) {
    this.el = this.isElementNode(el) ? el : document.querySelector(el);
    this.vm = vm;

    // 如过传入的根元素存在，才开始编译
    if (this.el) {
      // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）
      let fragment = this.node2fragment(this.el);

      // ********** 以下为新增代码 **********
      // 2、将模板中的指令中的变量和 {{}} 中的变量替换成真实的数据
      this.compile(fragment);

      // 3、把编译好的 fragment 再塞回页面中
      this.el.appendChild(fragment);
      // ********** 以上为新增代码 **********
    }
  }

  /* 辅助方法 */
  // 判断是否是元素节点
  isElementNode(node) {
    return node.nodeType === 1;
  }

  // ********** 以下为新增代码 **********
  // 判断属性是否为指令
  isDirective(name) {
    return name.includes(&#39;v-&#39;);
  }
  // ********** 以上为新增代码 **********

  /* 核心方法 */
  // 将根节点转移至文档碎片
  node2fragment(el) {
    // 创建文档碎片
    let fragment = document.createDocumentFragment();
    // 第一个子节点
    let firstChild;

    // 循环取出根节点中的节点并放入文档碎片中
    while (firstChild = el.firstChild) {
      fragment.appendChild(firstChild);
    }
    return fragment;
  }

  // ********** 以下为新增代码 **********
  // 解析文档碎片
  compile(fragment) {
    // 当前父节点节点的子节点，包含文本节点，类数组对象
    let childNodes = fragment.childNodes;

    // 转换成数组并循环判断每一个节点的类型
    Array.from(childNodes).forEach(node =&gt; {
      if (this.isElementNode(node)) { // 是元素节点
        // 递归编译子节点
        this.compile(node);

        // 编译元素节点的方法
        this.compileElement(node);
      } else { // 是文本节点
        // 编译文本节点的方法
        this.compileText(node);
      }
    });
  }
  // 编译元素
  compileElement(node) {
    // 取出当前节点的属性，类数组
    let attrs = node.attributes;
    Array.form(attrs).forEach(attr =&gt; {
      // 获取属性名，判断属性是否为指令，即含 v-
      let attrName = attr.name;

      if (this.isDirective(attrName)) {
        // 如果是指令，取到该属性值得变量在 data 中对应得值，替换到节点中
        let exp = attr.value;

        // 取出方法名
        let [, type] = attrName.split(&#39;-&#39;);

        // 调用指令对应得方法
        CompileUtil[type](node, this.vm, exp);
      }
    });
  }
  // 编译文本
  compileText(node) {
    // 获取文本节点的内容
    let exp = node.contentText;

    // 创建匹配 {{}} 的正则表达式
    let reg = /\{\{([^}+])\}\}/g;

    // 如果存在 {{}} 则使用 text 指令的方法
    if (reg.test(exp)) {
      CompileUtil[&#39;text&#39;](node, this.vm, exp);
    }
  }
  // ********** 以上为新增代码 **********
}
</code></pre><p><strong>上面代码新增内容得主要逻辑就是做了两件事：</strong></p><ul><li>调用 <code>compile</code> 方法对 <code>fragment</code> 文档碎片进行编译，即替换内部指令和 Mustache 语法中变量对应的值；</li><li>将编译好的 <code>fragment</code> 文档碎片塞回根节点。</li></ul><p>在第一个步骤当中逻辑是比较繁琐的，首先在 <code>compile</code> 方法中获取所有的子节点，循环进行编译，如果是元素节点需要递归 <code>compile</code>，传入当前元素节点。在这个过程当中抽取出了两个方法，<code>compileElement</code> 和 <code>compileText</code> 用来对元素节点的属性和文本节点进行处理。</p><p><code>compileElement</code> 中的核心逻辑就是处理指令，取出元素节点所有的属性判断是否是指令，是指令则调用指令对应的方法。<code>compileText</code> 中的核心逻辑就是取出文本的内容通过正则表达式匹配出被 Mustache 语法的 “&#123;&#123; &#125;&#125;” 包裹的内容，并调用处理文本的 <code>text</code> 方法。</p><p>文本节点的内容有可能存在 “&#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125;”，正则匹配默认是贪婪的，为了防止第一个 “&#123;” 和最后一个 “&#125;” 进行匹配，所以在正则表达式中应使用非贪婪匹配。</p><p>在调用指令的方法时都是调用的 <code>CompileUtil</code> 下对应的方法，我们之所以单独把这些指令对应的方法抽离出来存储在 <code>CompileUtil</code> 对象下的目的是为了解耦，因为后面其他的类还要使用。</p><h3 id="CompileUtil-对象中指令方法的实现"><a href="#CompileUtil-对象中指令方法的实现" class="headerlink" title="CompileUtil 对象中指令方法的实现"></a>CompileUtil 对象中指令方法的实现</h3><p><code>CompileUtil</code> 中存储着所有的指令方法及指令对应的更新方法，由于 <code>Vue</code> 的指令很多，我们这里只实现比较典型的 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 对应的方法，考虑到后续更新的情况，我们统一把设置值到 <code>Dom</code> 中的逻辑抽取出对应上面两种情况的方法，存放到 <code>CompileUtil</code> 的 <code>updater</code> 对象中。</p><pre><code class="lang-js">/* 文件：CompileUtil.js */
const CompileUtil = {};

// 更新节点数据的方法
CompileUti.updater = {
  // 文本更新
  textUpdater(node, value) {
    node.textContent = value;
  },
  // 输入框更新
  modelUpdater(node, value) {
    node.value = value;
  }
};
</code></pre><p>这部分的整个思路就是在 <code>Compile</code> 编译模板后处理 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 时，其实都是用 <code>data</code> 中的数据替换掉 <code>fragment</code> 文档碎片中对应的节点中的变量。因此会经常性的获取 <code>data</code> 中的值，在更新节点时又会重新设置 <code>data</code> 中的值，所以我们抽离出了三个方法 <code>getVal</code>、<code>getTextVal</code> 和 <code>setVal</code> 挂在了 <code>CompileUtil</code> 对象下。</p><pre><code class="lang-js">/* 文件：CompileUtil.js —— 取值方法 */
// 获取 data 值的方法
CompileUtil.getVal = function (vm, exp) {
  // 将匹配的值用 . 分割开，如 vm.data.a.b
  exp = exp.split(&#39;.&#39;);

  // 归并取值
  return exp.reduce((prev, next) =&gt; {
    return prev[next];
  }, vm.$data);
};

// 获取文本 {{}} 中变量在 data 对应的值
CompileUtil.getTextVal = function (vm, exp) {
  // 使用正则匹配出 {{ }} 间的变量名，再调用 getVal 获取值
  return exp.replace(/\{\{([^}]+)\}\}/g, (...args) =&gt; {
    return this.getVal(vm, args[1]);
  });
};

// 设置 data 值的方法
CompileUtil.setVal = function (vm, exp, newVal) {
  exp = exp.split(&#39;.&#39;);
  return exp.reduce((prev, next, currentIndex) =&gt; {
    // 如果当前归并的为数组的最后一项，则将新值设置到该属性
    if (currentIndex === exp.length - 1) {
      return prev[next] = newVal
    }

    // 继续归并
    return prev[next];
  }, vm.$data);
}
</code></pre><p>获取和设置 <code>data</code> 的值两个方法 <code>getVal</code> 和 <code>setVal</code> 思路相似，由于获取的变量层级不定，可能是 <code>data.a</code>，也可能是 <code>data.obj.a.b</code>，所以都是使用归并的思路，借用 <code>reduce</code> 方法实现的，区别在于 <code>setVal</code> 方法在归并过程中需要判断是不是归并到最后一级，如果是则设置新值，而 <code>getTextVal</code> 就是在 <code>getVal</code> 外包了一层处理 “&#123;&#123; &#125;&#125;” 的逻辑。</p><p>在这些准备工作就绪以后就可以实现我们的主逻辑，即对 <code>Compile</code> 类中解析的文本节点和元素节点指令中的变量用 <code>data</code> 值进行替换，还记得前面说针对 <code>v-model</code> 和 “&#123;&#123; &#125;&#125;” 进行处理，因此设计了 <code>model</code> 和 <code>text</code> 两个核心方法。</p><p><code>CompileUtil.model</code> 方法的实现：</p><pre><code class="lang-js">/* 文件：CompileUtil.js —— model 方法 */
// 处理 v-model 指令的方法
CompileUtil.model = function (node, vm, exp) {
  // 获取赋值的方法
  const updateFn = this.updater[&#39;modelUpdater&#39;];

  // 获取 data 中对应的变量的值
  let value = this.getVal(vm, exp);

  // 添加观察者，作用与 text 方法相同
  new Watcher(vm, exp, newValue =&gt; {
    updateFn &amp;&amp; updateFn(node, newValue);
  });

  // v-model 双向数据绑定，对 input 添加事件监听
  node.addEventListener(&#39;input&#39;, e =&gt; {
    // 获取输入的新值
    let newValue = e.target.value;

    // 更新到节点
    this.setVal(vm, exp, newValue);
  });

  // 第一次设置值
  updateFn &amp;&amp; updateFn(vm, value);
};
</code></pre><p><code>CompileUtil.text</code> 方法的实现：</p><pre><code class="lang-js">/* 文件：CompileUtil.js —— text 方法 */
// 处理文本节点 {{}} 的方法
CompileUtil.text = function (node, vm, exp) {
  // 获取赋值的方法
  const updateFn = this.updater[&#39;textUpdater&#39;];

  // 获取 data 中对应的变量的值
  let value = this.getTextVal(vm, exp);

  // 通过正则替换，将取到数据中的值替换掉 {{ }}
  exp.replace(/\{\{([^}]+)\}\}/g, (...args) =&gt; {
    // 解析时遇到了模板中需要替换为数据值的变量时，应该添加一个观察者
    // 当变量重新赋值时，调用更新值节点到 Dom 的方法
    new Watcher(vm, arg[1], newValue =&gt; {
      // 如果数据发生变化，重新获取新值
      updateFn &amp;&amp; updateFn(node, newValue);
    });
  });

  // 第一次设置值
  updateFn &amp;&amp; updateFn(vm, value);
};
</code></pre><p>上面两个方法逻辑相似，都获取了各自的 <code>updater</code> 中的方法，对值进行设置，并且在设置的同时为了后续 <code>data</code> 中的数据修改，视图的更新，创建了 <code>Watcher</code> 的实例，并在内部用新值重新更新节点，不同的是 <code>Vue</code> 的 <code>v-model</code> 指令在表单中实现了双向数据绑定，只要表单元素的 <code>value</code> 值发生变化，就需要将新值更新到 <code>data</code> 中，并响应到页面上。</p><p>所以我们的实现方式是给这个绑定了 <code>v-model</code> 的表单元素监听了 <code>input</code> 事件，并在事件中实时的将新的 <code>value</code> 值更新到 <code>data</code> 中，至于 <code>data</code> 中的改变后响应到页面中需要另外三个类 <code>Watcher</code>、<code>Observer</code> 和 <code>Dep</code> 共同实现，我们下面就来实现 <code>Watcher</code> 类。</p><h2 id="观察者-Watcher-类的实现"><a href="#观察者-Watcher-类的实现" class="headerlink" title="观察者 Watcher 类的实现"></a>观察者 Watcher 类的实现</h2><p>在 <code>CompileUtil</code> 对象的方法中创建 <code>Watcher</code> 实例的时候传入了三个参数，即 <code>MVVM</code> 的实例、模板绑定数据的变量名 <code>exp</code> 和一个 <code>callback</code>，这个 <code>callback</code> 内部逻辑是为了更新数据到 <code>Dom</code>，所以我们的 <code>Watcher</code> 类内部要做的事情就清晰了，获取更改前的值存储起来，并创建一个 <code>update</code> 实例方法，在值被更改时去执行实例的 <code>callback</code> 以达到视图的更新。</p><pre><code class="lang-js">/* 文件：Watcher.js */
class Watcher {
  constructor(vm, exp, callback) {
    this.vm = vm;
    this.exp = exp;
    this.callback = callback;

    // 更改前的值
    this.value = this.get();
  }
  get() {
    // 将当前的 watcher 添加到 Dep 类的静态属性上
    Dep.target = this;

    // 获取值触发数据劫持
    let value = CompileUtil.getVal(this.vm, this.exp);

    // 清空 Dep 上的 Watcher，防止重复添加
    Dep.target = null;
    return value;
  }
  update() {
    // 获取新值
    let newValue = CompileUtil.getVal(this.vm, this.exp);
    // 获取旧值
    let oldValue = this.value;

    // 如果新值和旧值不相等，就执行 callback 对 dom 进行更新
    if (newValue !== oldValue) {
      this.callback(newValue);
    }
  }
}
</code></pre><p><strong>看到上面代码一定有两个疑问：</strong></p><ul><li>使用 <code>get</code> 方法获取旧值得时候为什么要将当前的实例挂在 <code>Dep</code> 上，在获取值后为什么又清空了；</li><li><code>update</code> 方法内部执行了 <code>callback</code> 函数，但是 <code>update</code> 在什么时候执行。</li></ul><p>这就是后面两个类 <code>Dep</code> 和 <code>observer</code> 要做的事情，我们首先来介绍 <code>Dep</code>，再介绍 <code>Observer</code> 最后把他们之间的关系整个串联起来。</p><h2 id="发布订阅-Dep-类的实现"><a href="#发布订阅-Dep-类的实现" class="headerlink" title="发布订阅 Dep 类的实现"></a>发布订阅 Dep 类的实现</h2><p>其实发布订阅说白了就是把要执行的函数统一存储在一个数组中管理，当达到某个执行条件时，循环这个数组并执行每一个成员。</p><pre><code class="lang-js">/* 文件：Dep.js */
class Dep {
  constructor() {
    this.subs = [];
  }
  // 添加订阅
  addSub(watcher) {
    this.subs.push(watcher);
  }
  // 通知
  notify() {
    this.subs.forEach(watcher =&gt; watcher.update());
  }
}
</code></pre><p>在 <code>Dep</code> 类中只有一个属性，就是一个名为 <code>subs</code> 的数组，用来管理每一个 <code>watcher</code>，即 <code>Watcher</code> 类的实例，而 <code>addSub</code> 就是用来将 <code>watcher</code> 添加到 <code>subs</code> 数组中的，我们看到 <code>notify</code> 方法就解决了上面的一个疑问，<code>Watcher</code> 类的 <code>update</code> 方法是怎么执行的，就是这样循环执行的。</p><p><strong>接下来我们整合一下盲点：</strong></p><ul><li><code>Dep</code> 实例在哪里创建声明，又是在哪里将 <code>watcher</code> 添加进 <code>subs</code> 数组的；</li><li><code>Dep</code> 的 <code>notify</code> 方法应该在哪里调用；</li><li><code>Watcher</code> 内容中，使用 <code>get</code> 方法获取旧值得时候为什么要将当前的实例挂在 <code>Dep</code> 上，在获取值后为什么又清空了。</li></ul><p>这些问题在最后一个类 <code>Observer</code> 实现的时候都将清晰，下面我们重点来看最后一部分核心逻辑。</p><h2 id="数据劫持-Observer-类的实现"><a href="#数据劫持-Observer-类的实现" class="headerlink" title="数据劫持 Observer 类的实现"></a>数据劫持 Observer 类的实现</h2><p>还记得实现 <code>MVVM</code> 类的时候就创建了这个类的实例，当时传入的参数是 <code>MVVM</code> 实例的 <code>data</code> 属性，在 <code>MVVM</code> 中把数据通过 <code>Object.defineProperty</code> 挂到了实例上，并添加了 <code>getter</code> 和 <code>setter</code>，其实 <code>Observer</code> 类主要目的就是给 <code>data</code> 内的所有层级的数据都进行这样的操作。</p><pre><code class="lang-js">/* 文件：Observer.js */
class Observer {
  constructor (data) {
    this.observe(data);
  }
  // 添加数据监听
  observe(data) {
    // 验证 data
    if (!data || typeof data !== &#39;object&#39;) return;

    // 要对这个 data 数据将原有的属性改成 set 和 get 的形式
    // 要将数据一一劫持，先获取到 data 的 key 和 value
    Object.keys(data).forEach(key =&gt; {
      // 劫持（实现数据响应式）
      this.defineReactive(data, key, data[key]);
      this.observe(data[key]); // 深度劫持
    });
  }
  // 数据响应式
  defineReactive (object, key, value) {
    let _this = this;
    // 每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作
    const dep = new Dep();

    // 获取某个值被监听到
    Object.defineProperty(object, key, {
      enumerable: true,
      configurable: true,
      get() { // 当取值时调用的方法
        Dep.target &amp;&amp; dep.addSub(Dep.target);
        return value;
      },
      set(newValue) { // 当给 data 属性中设置的值适合，更改获取的属性的值
        if (newValue !== value) {
          _this.observe(newValue); // 重新赋值如果是对象进行深度劫持
          value = newValue;
          dep.notify(); // 通知所有人数据更新了
        }
      }
    });
  }
}
</code></pre><p>在的代码中 <code>observe</code> 的目的是遍历对象，在内部对数据进行劫持，即添加 <code>getter</code> 和 <code>setter</code>，我们把劫持的逻辑单独抽取成 <code>defineReactive</code> 方法，需要注意的是 <code>observe</code> 方法在执行最初就对当前的数据进行了数据类型验证，然后再循环对象每一个属性进行劫持，目的是给同为 <code>Object</code> 类型的子属性递归调用 <code>observe</code> 进行深度劫持。</p><p>在 <code>defineReactive</code> 方法中，创建了 <code>Dep</code> 的实例，并对 <code>data</code> 的数据使用 <code>get</code> 和 <code>set</code> 进行劫持，还记得在模板编译的过程中，遇到模板中绑定的变量，就会解析，并创建 <code>watcher</code>，会在 <code>Watcher</code> 类的内部获取旧值，即当前的值，这样就触发了 <code>get</code>，在 <code>get</code> 中就可以将这个 <code>watcher</code> 添加到 <code>Dep</code> 的 <code>subs</code> 数组中进行统一管理，因为在代码中获取 <code>data</code> 中的值操作比较多，会经常触发 <code>get</code>，我们又要保证 <code>watcher</code> 不会被重复添加，所以在 <code>Watcher</code> 类中，获取旧值并保存后，立即将 <code>Dep.target</code> 赋值为 <code>null</code>，并且在触发 <code>get</code> 时对 <code>Dep.target</code> 进行了短路操作，存在才调用 <code>Dep</code> 的 <code>addSub</code> 进行添加。</p><p>而 <code>data</code> 中的值被更改时，会触发 <code>set</code>，在 <code>set</code> 中做了性能优化，即判断重新赋的值与旧值是否相等，如果相等就不重新渲染页面，不等的情况有两种，如果原来这个被改变的值是基本数据类型没什么影响，如果是引用类型，我们需要对这个引用类型内部的数据进行劫持，因此递归调用了 <code>observe</code>，最后调用 <code>Dep</code> 的 <code>notify</code> 方法进行通知，执行 <code>notify</code> 就会执行 <code>subs</code> 中所有被管理的 <code>watcher</code> 的 <code>update</code>，就会执行创建 <code>watcher</code> 时的传入的 <code>callback</code>，就会更新页面。</p><p>在 <code>MVVM</code> 类将 <code>data</code> 的属性挂在 <code>MVVM</code> 实例上并劫持与通过 <code>Observer</code> 类对 <code>data</code> 的劫持还有一层联系，因为整个发布订阅的逻辑都是在 <code>data</code> 的 <code>get</code> 和 <code>set</code> 上，只要触发了 <code>MVVM</code> 中的 <code>get</code> 和 <code>set</code> 内部会自动返回或设置 <code>data</code> 对应的值，就会触发 <code>data</code> 的 <code>get</code> 和 <code>set</code>，就会执行发布订阅的逻辑。</p><p>通过上面长篇大论的叙述后，这个 MVVM 模式用到的几个类的关系应该完全叙述清晰了，虽然比较抽象，但是细心琢磨还是会明白之间的关系和逻辑，下面我们就来对我们自己实现的这个 MVVM 进行验证。</p><h2 id="验证-MVVM"><a href="#验证-MVVM" class="headerlink" title="验证 MVVM"></a>验证 MVVM</h2><p>我们按照 <code>Vue</code> 的方式根据自己的 <code>MVVM</code> 实现的内容简单的写了一个模板如下：</p><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;MVVM&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 双向数据绑定 靠的是表单 --&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
    &lt;div&gt;{{message}}&lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;{{message}}&lt;/li&gt;
    &lt;/ul&gt;
    {{message}}
  &lt;/div&gt;

  &lt;!-- 引入依赖的 js 文件 --&gt;
  &lt;script src=&quot;./js/Watcher.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./js/Observer.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./js/Compile.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./js/CompileUtil.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./js/Dep.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./js/MVVM.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const vm = new MVVM({
      el: &#39;#app&#39;,
      data: {
        message: &#39;hello world!&#39;
      }
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>打开 </strong>Chrom<strong> 浏览器的控制台，在上面通过下面操作来验证：</strong></p><ul><li>输入 <code>vm.message = &#39;hello&#39;</code> 看页面是否更新；</li><li>输入 <code>vm.$data.message = &#39;hello&#39;</code> 看页面是否更新；</li><li>改变文本输入框内的值，看页面的其他元素是否更新。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>通过上面的测试，相信应该理解了 MVVM 模式对于前端开发重大的意义，实现了双向数据绑定，实时保证 View 层与 Model 层的数据同步，并可以让我们在开发时基于数据编程，而最少的操作 <code>Dom</code>，这样大大提高了页面渲染的性能，也可以使我们把更多的精力用于业务逻辑的开发上。</strong></p></blockquote>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>源码分析</tag>
        <tag>Vue</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 event-loop 事件轮询</title>
    <url>/20180325170208/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Async/20180325170208/libuv.png" title="event-loop"><p><br></p><h2 id="浏览器中的事件轮询"><a href="#浏览器中的事件轮询" class="headerlink" title="浏览器中的事件轮询"></a>浏览器中的事件轮询</h2><blockquote class="pullquote default"><p><strong><code>JavaScript</code> 是一门单线程语言，之所以说是单线程，是因为在浏览器中，如果是多线程，并且两个线程同时操作了同一个 <code>Dom</code> 元素，那最后的结果会出现问题。所以，<code>JavaScript</code> 是单线程的，但是如果完全由上至下的一行一行执行代码，假如一个代码块执行了很长的时间，后面必须要等待当前执行完毕，这样的效率是非常低的，所以有了异步的概念，确切的说，<code>JavaScript</code> 的主线程是单线程的，但是也有其他的线程去帮我们实现异步操作，比如定时器线程、事件线程、<code>Ajax</code> 线程。</strong></p></blockquote><p>在浏览器中执行 <code>JavaScript</code> 有两个区域，一个是我们平时所说的同步代码执行，是在栈中执行，原则是先进后出，而在执行异步代码的时候分为两个队列，<code>macro-task</code>（宏任务）和 <code>micro-task</code>（微任务），遵循先进先出的原则。</p><a id="more"></a><pre><code class="lang-js">/* 作用域链 */
function one() {
  console.log(1);
  function two() {
    console.log(2);
    function three() {
      console.log(3);
    }
    three();
  }
  two();
}
one();

// 1
// 2
// 3
</code></pre><p>上面的代码都是同步的代码，在执行的时候先将全局作用域放入栈中，执行全局作用域中的代码，解析了函数 <code>one</code>，当执行函数调用 <code>one()</code> 的时候将 <code>one</code> 的作用域放入栈中，执行 <code>one</code> 中的代码，打印了 <code>1</code>，解析了 <code>two</code>，执行 <code>two()</code>，将 <code>two</code> 放入栈中，执行 <code>two</code>，打印了 <code>2</code>，解析了 <code>three</code>，执行了 <code>three()</code>，将 <code>three</code> 放入栈中，执行 <code>three</code>，打印了 <code>3</code>。</p><p>在函数执行完释放的过程中，因为全局作用域中有 <code>one</code> 正在执行，<code>one</code> 中有 <code>two</code> 正在执行，<code>two</code> 中有 <code>three</code> 正在执行，所以释放内存时必须由内层向外层释放，<code>three</code> 执行后释放，此时 <code>three</code> 不再占用 <code>two</code> 的执行环境，将 <code>two</code> 释放，<code>two</code> 不再占用 <code>one</code> 的执行环境，将 <code>one</code> 释放，<code>one</code> 不再占用全局作用域的执行环境，最后释放全局作用域，这就是在栈中执行同步代码时的先进后出原则，更像是一个杯子，先放进去的在最下面，需要最后取出。</p><p>而异步队列更像时一个管道，有两个口，从入口进，从出口出，所以是先进先出，在宏任务队列中代表的有 <code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>MessageChannel</code>，微任务的代表为 Promise 的 <code>then</code> 方法、<code>MutationObserve</code>（已废弃）。</p><p><strong>案例 1</strong></p><pre><code class="lang-js">const messageChannel = new MessageChannel();
const prot2 = messageChannel.port2;

messageChannel.port1.postMessage(&#39;I love you&#39;);
console.log(1);

prot2.onmessage = function (e) {
  console.log(e.data);
};
console.log(2);

// 1
// 2
// I love you
</code></pre><p>从上面案例中可以看出，<code>MessageChannel</code> 是宏任务，晚于同步代码执行。</p><p><strong>案例 2</strong></p><pre><code class="lang-js">setTimeout(() =&gt; console.log(1), 2000);
setTimeout(() =&gt; console.log(2), 1000);
console.log(3);

// 3
// 2
// 1
</code></pre><p>上面代码可以看出其实 <code>setTimeout</code> 并不是在同步代码执行的时候就放入了异步队列，而是等待时间到达时才会放入异步队列，所以才会有了上面的结果。</p><p><strong>案例 3</strong></p><pre><code class="lang-js">setImmediate(function () {
  console.log(&#39;setImmediate&#39;);
});

setTimeout(function () {
  console.log(&#39;setTimeout&#39;);
}, 0);

console.log(1);

// 1
// setTimeout
// setImmediate
</code></pre><p>同为宏任务，<code>setImmediate</code> 在 <code>setTimeout</code> 延迟时间为 <code>0</code> 时是晚于 <code>setTimeout</code> 被放入异步队列的，这里需要注意的是 <code>setImmediate</code> 在浏览器端，到目前为止只有 IE 实现了。</p><p>上面的案例都是关于宏任务，下面我们举一个有微任务的案例来看一看微任务和宏任务的执行机制，在浏览器端微任务的代表其实就是 Promise 的 <code>then</code> 方法。</p><p><strong>案例 4</strong></p><pre><code class="lang-js">setTimeout(() =&gt; {
  console.log(&#39;setTimeout1&#39;);
  Promise.resolve().then(data =&gt; {
    console.log(&#39;Promise1&#39;);
  });
}, 0);

Promise.resolve().then(data =&gt; {
  console.log(&#39;Promise2&#39;);
  setTimeout(() =&gt; {
    console.log(&#39;setTimeout2&#39;);
  }, 0);
});

// Promise2
// setTimeout1
// Promise1
// setTimeout2
</code></pre><blockquote class="pullquote info"><p><strong>从上面的执行结果其实可以看出，同步代码在栈中执行完毕后会先去执行微任务队列，将微任务队列执行完毕后，会去执行宏任务队列，宏任务队列执行一个宏任务以后，会去看看有没有产生新的微任务，如果有则清空微任务队列后再执行下一个宏任务，依次轮询，直到清空整个异步队列。</strong></p></blockquote><h2 id="Node-中的事件轮询"><a href="#Node-中的事件轮询" class="headerlink" title="Node 中的事件轮询"></a>Node 中的事件轮询</h2><blockquote class="pullquote primary"><p><strong>在 Node 中的事件轮询机制与浏览器相似又不同，相似的是，同样先在栈中执行同步代码，同样是先进后出，不同的是 Node 有自己的多个处理不同问题的阶段和对应的队列，也有自己内部实现的微任务 <code>process.nextTick</code>，Node 的整个事件轮询机制是 Libuv 库实现的。</strong></p></blockquote><p><strong>Node 中事件轮询的流程如下图：</strong></p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Async/20180325170208/event-loop.jpg" alt="Node 事件环流程图"></div><div class="image-caption">Node 事件环流程图</div></figure><p><br></p><blockquote class="pullquote info"><p><strong>从图中可以看出，在 Node 中有多个队列，分别执行不同的操作，而每次在队列切换的时候都去执行一次微任务队列，反复的轮询。</strong></p></blockquote><p><strong>案例 1</strong></p><pre><code class="lang-js">setTimeout(function () {
  console.log(&#39;setTimeout&#39;);
}, 0);

setImmediate(function () {
  console.log(&#39;setInmediate&#39;);
});
</code></pre><p>默认情况下 <code>setTimeout</code> 和 <code>setImmediate</code> 是不知道哪一个先执行的，顺序不固定，Node 执行的时候有准备的时间，<code>setTimeout</code> 延迟时间设置为 <code>0</code> 其实是大概 <code>4ms</code>，假设 Node 准备时间在 <code>4ms</code> 之内，开始执行轮询，定时器没到时间，所以轮询到下一队列，此时要等再次循环到 <code>timer</code> 队列后执行定时器，所以会先执行 <code>check</code> 队列的 <code>setImmediate</code>。</p><p>如果 Node 执行的准备时间大于了 <code>4ms</code>，因为执行同步代码后，定时器的回调已经被放入 <code>timer</code> 队列，所以会先执行 <code>timer</code> 队列。</p><p><strong>案例 2</strong></p><pre><code class="lang-js">setTimeout(() =&gt; {
  console.log(&#39;setTimeout1&#39;);
  Promise.resolve().then(() =&gt; {
    console.log(&#39;Promise1&#39;);
  });
}, 0);

setTimeout(() =&gt; {
  console.log(&#39;setTimeout2&#39;);
}, 0);
console.log(1);

// 1
// setTimeout1
// setTimeout2
// Promise1
</code></pre><p>Node 事件轮询中，轮询到每一个队列时，都会将当前队列任务清空后，在切换下一队列之前清空一次微任务队列，这是与浏览器端不一样的。</p><p>浏览器端会在宏任务队列当中执行一个任务后插入执行微任务队列，清空微任务队列后，再回到宏任务队列执行下一个宏任务。</p><p>上面案例在 Node 事件轮询中，会将 <code>timer</code> 队列清空后，在轮询下一个队列之前执行微任务队列。</p><p><strong>案例 3</strong></p><pre><code class="lang-js">setTimeout(() =&gt; {
  console.log(&#39;setTimeout1&#39;);
}, 0);

setTimeout(() =&gt; {
  console.log(&#39;setTimeout2&#39;);
}, 0);

Promise.resolve().then(() =&gt; {
  console.log(&#39;Promise1&#39;);
});
console.log(1);

// 1
// Promise1
// setTimeout1
// setTimeout2
</code></pre><p>上面代码的执行过程是，先执行栈，栈执行时打印 <code>1</code>，<code>Promise.resolve()</code> 产生微任务，栈执行完毕，从栈切换到 <code>timer</code> 队列之前，执行微任务队列，再去执行 <code>timer</code> 队列。</p><p><strong>案例 4</strong></p><pre><code class="lang-js">setImmediate(() =&gt; {
  console.log(&#39;setImmediate1&#39;);
  setTimeout(() =&gt; {
    console.log(&#39;setTimeout1&#39;);
  }, 0);
});

setTimeout(() =&gt; {
  console.log(&#39;setTimeout2&#39;);
  setImmediate(() =&gt; {
    console.log(&#39;setImmediate2&#39;);
  });
}, 0);

//结果1
// setImmediate1
// setTimeout2
// setTimeout1
// setImmediate2

// 结果2
// setTimeout2
// setImmediate1
// setImmediate2
// setTimeout1
</code></pre><p><code>setImmediate</code> 和 <code>setTimeout</code> 执行顺序不固定，假设 <code>check</code> 队列先执行，会执行 <code>setImmediate</code> 打印 <code>setImmediate1</code>，将遇到的定时器放入 <code>timer</code> 队列，轮询到 <code>timer</code> 队列，因为在栈中执行同步代码已经在 <code>timer</code> 队列放入了一个定时器，所以按先后顺序执行两个 <code>setTimeout</code>，执行第一个定时器打印 <code>setTimeout2</code>，将遇到的 <code>setImmediate</code> 放入 <code>check</code> 队列，执行第二个定时器打印 <code>setTimeout1</code>，再次轮询到 <code>check</code> 队列执行新加入的 <code>setImmediate</code>，打印 <code>setImmediate2</code>，产生结果 <code>1</code>。</p><p>假设 <code>timer</code> 队列先执行，会执行 <code>setTimeout</code> 打印 <code>setTimeout2</code>，将遇到的 <code>setImmediate</code> 放入 <code>check</code> 队列，轮询到 <code>check</code> 队列，因为在栈中执行同步代码已经在 <code>check</code> 队列放入了一个 <code>setImmediate</code>，所以按先后顺序执行两个 <code>setImmediate</code>，执行第一个 <code>setImmediate</code> 打印 <code>setImmediate1</code>，将遇到的 <code>setTimeout</code> 放入 <code>timer</code> 队列，执行第二个 <code>setImmediate</code> 打印 <code>setImmediate2</code>，再次轮询到 <code>timer</code> 队列执行新加入的 <code>setTimeout</code>，打印 <code>setTimeout1</code>，产生结果 <code>2</code>。</p><p><strong>案例 5</strong></p><pre><code class="lang-js">setImmediate(() =&gt; {
  console.log(&#39;setImmediate1&#39;);
  setTimeout(() =&gt; {
    console.log(&#39;setTimeout1&#39;);
  }, 0);
});

setTimeout(() =&gt; {
  process.nextTick(() =&gt; console.log(&#39;nextTick&#39;));
  console.log(&#39;setTimeout2&#39;);
  setImmediate(() =&gt; {
    console.log(&#39;setImmediate2&#39;);
  });
}, 0);

//结果1
// setImmediate1
// setTimeout2
// setTimeout1
// nextTick
// setImmediate2

// 结果2
// setTimeout2
// nextTick
// setImmediate1
// setImmediate2
// setTimeout1
</code></pre><p>这与上面一个案例类似，不同的是在 <code>setTimeout</code> 执行的时候产生了一个微任务 <code>nextTick</code>，我们只要知道，在 Node 事件轮询中，在切换队列时要先去执行微任务队列，无论是 <code>check</code> 队列先执行，还是 <code>timer</code> 队列先执行，都会很容易分析出上面的两个结果。</p><p><strong>案例 6</strong></p><pre><code class="lang-js">const fs = require(&#39;fs&#39;);

fs.readFile(&#39;./.gitignore&#39;, &#39;utf8&#39;, function () {
  setTimeout(() =&gt; {
    console.log(&#39;timeout&#39;);
  }, 0);
  setImmediate(function () {
    console.log(&#39;setImmediate&#39;);
  });
});

// setImmediate
// timeout
</code></pre><p>上面案例的 <code>setTimeout</code> 和 <code>setImmediate</code> 的执行顺序是固定的，前面都是不固定的，这是为什么？</p><p>因为前面的不固定是在栈中执行同步代码时就遇到了 <code>setTimeout</code> 和 <code>setImmediate</code>，因为无法判断 Node 的准备时间，不确定准备结束定时器是否到时并加入 <code>timer</code> 队列。</p><p>而上面代码明显可以看出 Node 准备结束后会直接执行 <code>poll</code> 队列进行文件的读取，在回调中将 <code>setTimeout</code> 和 <code>setImmediate</code> 分别加入 <code>timer</code> 队列和 <code>check</code> 队列，Node 队列的轮询是有顺序的，在 <code>poll</code> 队列后应该先切换到 <code>check</code> 队列，然后再重新轮询到 <code>timer</code> 队列，所以得到上面的结果。</p><p><strong>案例 7</strong></p><pre><code class="lang-js">Promise.resolve().then(() =&gt; console.log(&#39;Promise&#39;));
process.nextTick(() =&gt; console.log(&#39;nextTick&#39;));

// nextTick
// Promise
</code></pre><p>在 Node 中有两个微任务，<code>Promise</code> 的 <code>then</code> 方法和 <code>process.nextTick</code>，从上面案例的结果我们可以看出，在微任务队列中 <code>process.nextTick</code> 是优先执行的。</p><blockquote class="pullquote success"><p><strong>上面内容就是浏览器与 Node 在事件轮询的规则，相信在读完以后应该已经彻底弄清了浏览器的事件轮询机制和 Node 的事件轮询机制，并深刻的体会到了他们之间的相同和不同。</strong></p></blockquote>]]></content>
      <categories>
        <category>异步</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 命令总结，从零到熟悉</title>
    <url>/20171214024101/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20171214024101/git-image.png" title="Git"><p><br></p><h2 id="什么是-Git？"><a href="#什么是-Git？" class="headerlink" title="什么是 Git？"></a>什么是 Git？</h2><blockquote class="pullquote warning"><p><strong><code>Git</code> 是一个免费的开源分布式版本控制系统，它的设计目的是为了速度和效率的处理从小型到大型的项目；<code>Git</code> 可以帮我们管理我们的代码，记录历史，只要代码提交到 <code>Git</code> 上就永久不会丢失，可以随时 “穿越”（回到之前的某一个版本）；可以多端共享，团队协作中，多个人操作了同一个文件时，可以实现自动合并（模块化，组件化）、标记冲突，拥有强大的分支管理系统。</strong></p></blockquote><a id="more"></a><h2 id="Git-与-SVN-的区别"><a href="#Git-与-SVN-的区别" class="headerlink" title="Git 与 SVN 的区别"></a>Git 与 SVN 的区别</h2><p><code>SVN</code>：集中式，需要一台中央服务器，所有代码的拉取和提交都是在中央服务器，一旦中央服务器或者网络出现故障，则不能拉取和提交代码，需要不断去备份中央服务器，防止代码丢失。</p><p><code>Git</code>：分布式，有一个中央服务器的同时，每个开发者本地都有自己的本地仓库，拥有完整的版本库，不用担心代码丢失，Git 存储的是代码变化的快照，更新代码的速度要比 SVN 更快。</p><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><p><strong>Windows</strong></p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li></ul><p><strong>Mac</strong></p><ul><li>如果安装过 <code>Xcode</code> 自带 <code>Git</code>，<a>https://developer.apple.com/xcode/</a></li><li>可以安装 Homebrew，是 <code>wmac</code> 的包管理器，<a>https://brew.sh/</a>，下面是两款界面美化插件：<ul><li><code>Oh My ZSH</code>：<a>http://ohmyz.sh/</a></li><li><code>iTerm2</code>：<a>https://www.iterm2.com/</a></li></ul></li></ul><h2 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h2><h3 id="查看当前工作目录"><a href="#查看当前工作目录" class="headerlink" title="查看当前工作目录"></a>查看当前工作目录</h3><pre><code class="lang-bash">$ pwd
</code></pre><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><pre><code class="lang-bash">$ mkdir 文件夹名
</code></pre><h3 id="改变路径"><a href="#改变路径" class="headerlink" title="改变路径"></a>改变路径</h3><pre><code class="lang-bash"># 进入盘符
$ cd d:
</code></pre><pre><code class="lang-bash"># 进入文件夹
$ cd 文件夹名
</code></pre><pre><code class="lang-bash"># 回上一级目录
$ cd ..
</code></pre><pre><code class="lang-bash"># 进入某一个路径
$ cd 路径
</code></pre><blockquote class="pullquote primary"><p><strong>想要进入某一个不知道路径的文件夹中，可以直接拖拽该文件到命令窗口，会自动识别路径。</strong></p></blockquote><h3 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h3><pre><code class="lang-bash">$ ls
</code></pre><pre><code class="lang-bash">$ ls -a
</code></pre><pre><code class="lang-bash">$ ls -al
</code></pre><blockquote class="pullquote default"><p><strong>下面命令加了 <code>-a</code> 参数可以查看隐藏文件，加了 <code>-al</code> 参数可以查看所有文件及权限位。</strong></p></blockquote><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><pre><code class="lang-bash">$ touch 文件名
</code></pre><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><pre><code class="lang-bash">$ mv 文件/文件夹 路径
</code></pre><blockquote class="pullquote warning"><p><strong>移动文件时可以通过第二个参数对文件进行重命名操作。</strong></p></blockquote><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><pre><code class="lang-bash">$ cp 文件/文件夹 路径
</code></pre><blockquote class="pullquote success"><p><strong>将文件或者文件夹移动或拷贝到所输入的路径下。</strong></p></blockquote><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><pre><code class="lang-bash">$ cat 文件名
</code></pre><h3 id="删除文件-文件夹"><a href="#删除文件-文件夹" class="headerlink" title="删除文件 / 文件夹"></a>删除文件 / 文件夹</h3><pre><code class="lang-bash">$ rm -rf 文件夹名
</code></pre><pre><code class="lang-bash">$ rm 文件名
</code></pre><blockquote class="pullquote danger"><p><strong><code>-rf</code> 为递归删除，后面加上 <code>*</code> 为参数会递归删除整个文件夹的内容，<code>rm -rf *</code>（慎用）。</strong></p></blockquote><h3 id="清空命令窗口"><a href="#清空命令窗口" class="headerlink" title="清空命令窗口"></a>清空命令窗口</h3><pre><code class="lang-bash">$ clear
</code></pre><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><pre><code class="lang-bash"># 直接在命令行中查看
$ history
</code></pre><pre><code class="lang-bash"># 将当前 Git 的命令历史写入文件中
$ history &gt; 文件名
</code></pre><h3 id="使用-vi-编辑器编辑文件"><a href="#使用-vi-编辑器编辑文件" class="headerlink" title="使用 vi 编辑器编辑文件"></a>使用 vi 编辑器编辑文件</h3><pre><code class="lang-bash">$ vi 文件名
</code></pre><pre><code class="lang-bash"># 进入编辑模式（键盘）
i
</code></pre><pre><code class="lang-bash"># 进入命令模式（键盘）
Esc
</code></pre><pre><code class="lang-bash"># 保存并退出（键盘）
:wq
</code></pre><pre><code class="lang-bash"># 强制退出（键盘）
:q!
</code></pre><h3 id="使用命令编辑文件"><a href="#使用命令编辑文件" class="headerlink" title="使用命令编辑文件"></a>使用命令编辑文件</h3><pre><code class="lang-bash"># 向文件输入内容
$ echo 内容 &gt; 文件名
</code></pre><pre><code class="lang-bash"># 向文件追加内容
$ echo 内容 &gt;&gt; 文件名
</code></pre><blockquote class="pullquote info"><p><strong>当使用 <code>echo</code> 编辑了一个不存在的文件时，会创建一个新文件并将内容编辑到文件中，而 <code>touch</code> 创建的是空文件。</strong></p></blockquote><h2 id="Git-的本地操作"><a href="#Git-的本地操作" class="headerlink" title="Git 的本地操作"></a>Git 的本地操作</h2><blockquote class="pullquote success"><ul><li><strong>Git 在管理文件时，所有文件都具有三种状态，已修改、已暂存、已提交。</strong></li><li><strong>Git 在本地仓库中由三部分组成，工作区、暂存区、版本库。</strong></li><li><strong>Git 管理的文件夹下都有一个名为 <code>.git</code> 的隐藏文件夹。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>对应关系如下：</strong></p><ul><li><strong>已修改 → 工作区</strong></li><li><strong>已暂存 → 暂存区（<code>.git</code> 文件夹下的 <code>index</code> 文件中）</strong></li><li><strong>已提交 → 版本库</strong></li></ul></blockquote><h3 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h3><blockquote class="pullquote warning"><p><strong>不配置用户无法提交代码。</strong></p></blockquote><pre><code class="lang-git"># 查看配置信息
$ git config --list
</code></pre><pre><code class="lang-git"># 配置用户名
$ git config --global user.name &#39;你的名字&#39;
</code></pre><pre><code class="lang-git"># 配置邮箱
$ git config --global user.email &#39;你的邮箱&#39;
</code></pre><pre><code class="lang-git"># 查看某一项配置
$ git config --global user.name
$ git config --global user.email
</code></pre><blockquote class="pullquote primary"><p><strong>配置用户信息参数：</strong></p><ul><li><strong><code>--local</code>：只对某一个仓库生效；</strong></li><li><strong><code>--global</code>：对计算机当前用户所有仓库生效；</strong></li><li><strong><code>--system</code>：对计算机整个操作系统生效。</strong></li></ul></blockquote><h3 id="初始化-Git-仓库"><a href="#初始化-Git-仓库" class="headerlink" title="初始化 Git 仓库"></a>初始化 Git 仓库</h3><blockquote class="pullquote warning"><p><strong>在要初始化的文件夹下执行下面命令，告诉 Git 哪个文件夹被 Git 所管理，一个项目初始化一次，不能嵌套。</strong></p></blockquote><pre><code class="lang-git"># 把已有项目纳入 Git 管理
$ cd 项目代码所在文件夹
$ git init
</code></pre><pre><code class="lang-git"># 新建项目直接用 Git 管理
$ cd 希望创建项目的文件夹
$ git init your_project #会在当前路径下创建和项目名称同名的文件夹
$ cd your_project
</code></pre><h3 id="查看-Git-状态"><a href="#查看-Git-状态" class="headerlink" title="查看 Git 状态"></a>查看 Git 状态</h3><pre><code class="lang-git">$ git status
</code></pre><p>文件为红色，代表有修改，文件名为绿色，代表已经加入暂存区。</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><pre><code class="lang-git"># 将单个文件变化提交到暂存区，参数支持多个
$ git add 文件名/文件夹
</code></pre><pre><code class="lang-git"># 将已经被 Git 管理的文件变化全部提交
$ git add -u
</code></pre><pre><code class="lang-git"># 将修改、添加文件的变化全部提交
$ git add .
</code></pre><pre><code class="lang-git"># 将修改、添加、删除文件的变化全部提交
$ git add -A
</code></pre><h3 id="删除暂存区"><a href="#删除暂存区" class="headerlink" title="删除暂存区"></a>删除暂存区</h3><pre><code class="lang-git"># 删除暂存区，工作区不保留，参数支持多个
$ git rm 文件名/文件夹
</code></pre><pre><code class="lang-git"># 删除暂存区，工作区保留
$ git rm --cached 文件名
</code></pre><pre><code class="lang-git"># 删除全部暂存区
$ git rm --cached . -r
</code></pre><blockquote class="pullquote warning"><p><strong>当参数为 <code>.</code> 的时候删除全部暂存区，所以需要加上代表递归删除的参数 <code>-r</code>。</strong></p></blockquote><h3 id="重命名暂存区文件"><a href="#重命名暂存区文件" class="headerlink" title="重命名暂存区文件"></a>重命名暂存区文件</h3><pre><code class="lang-git"># 方式一（不常用）
$ mv oldname newname
$ git rm oldname
$ git add newname
</code></pre><pre><code class="lang-git"># 方式二
$ git mv oldname newname
</code></pre><blockquote class="pullquote info"><p><strong>当对一个已被 <code>Git</code> 管理的文件使用 <code>mv</code> 重命名时，执行 <code>git status</code> 命令时，会提示删除该文件（旧名字），新增该文件（新名字），使用 <code>git rm</code>、<code>git add</code> 命令进行删除和添加，执行 <code>git status</code> 命令时会提示该文件从 <code>renamed: oldname -&gt; newname</code>，而 <code>git mv</code> 命令等于将上面三个步骤合并成一个。</strong></p></blockquote><blockquote class="pullquote warning"><p><strong>注意：<code>OS</code> 系统中大小写不敏感，重命名后的文件名只是大小写改变，<code>git mv</code> 命令执行会失效。</strong></p></blockquote><h3 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h3><pre><code class="lang-git"># 从暂存区提交到版本库
$ git commit -m &#39;版本信息&#39;
</code></pre><pre><code class="lang-git"># 从工作区直接提交到版本库（需要之前添加过暂存区）
$ git commit -am &#39;版本信息&#39;
</code></pre><h3 id="查看提交日志（版本库）"><a href="#查看提交日志（版本库）" class="headerlink" title="查看提交日志（版本库）"></a>查看提交日志（版本库）</h3><pre><code class="lang-git"># 最详细的信息
$ git log
</code></pre><pre><code class="lang-git"># 查看某一个分支的提交历史
$ git log 分支名
</code></pre><pre><code class="lang-git"># 单行查看，只有版本号和提交信息
$ git log --online
</code></pre><pre><code class="lang-git"># 查看最近 4 个提交，数字根据需要配置
$ git log -n4
</code></pre><pre><code class="lang-git"># 查看所有分支的提交历史
$ git log --all
</code></pre><pre><code class="lang-git"># 查看所有分支图形化的提交历史
$ git log --all --graph
</code></pre><pre><code class="lang-git"># 查看全部版本记录，包含被删除的提交记录
$ git reflog
</code></pre><pre><code class="lang-git"># 以列表的方式查看单个文件的提交
$ git blame 文件名
</code></pre><blockquote class="pullquote success"><ul><li><strong><code>--oneline</code>、<code>-n*</code>（<code>n</code> 可省略）、<code>--all</code> 和 <code>--graph</code> 等参数可以组合使用；</strong></li><li><strong><code>log</code> 和 <code>reflog</code> 的区别在于 <code>reflog</code> 可以查看被删除的提交记录，当想回退被删除的提交时使用；</strong></li><li><strong>查看图形化分支时，红色线代表主分支，绿色线代表新创建的分支，分支上的 <code>*</code> 代表提交到版本库的节点。</strong></li></ul></blockquote><h3 id="查看-Git-命令-Web-文档"><a href="#查看-Git-命令-Web-文档" class="headerlink" title="查看 Git 命令 Web 文档"></a>查看 Git 命令 Web 文档</h3><pre><code class="lang-git">$ git help --web 命令
</code></pre><h3 id="暂存更改"><a href="#暂存更改" class="headerlink" title="暂存更改"></a>暂存更改</h3><blockquote class="pullquote primary"><p><strong>分支工作区有更改不能直接切换其他分支，可以提交更改或者暂存更改，若暂存更改（使用暂存区覆盖掉工作区），等待重新切回分支时，还原暂存。</strong><br><strong>此处所说的暂存不是之前的将代码提交到暂存区，因为当前分支工作区的代码会变成要切换分支工作区的代码，而导致当前分支工作区的更改丢失，此处的暂存类似于将修改寄存，重新切回该分支时再还原。</strong></p></blockquote><pre><code class="lang-git"># 暂存更改
$ git stash
</code></pre><pre><code class="lang-git"># 查看暂存列表
$ git stash --list
</code></pre><pre><code class="lang-git"># 还原暂存的内容
$ git stash apply|pop stash@{n}
</code></pre><blockquote class="pullquote info"><p><strong><code>apply</code> 与 <code>pop</code> 都是用于还原暂存的内容到工作区，<code>stash@{n}</code> 代表还原指定的暂存，<code>n</code> 代表暂存的序号，若省略 <code>stash@{n}</code> 则代表默认取出最新的暂存，<code>apply</code> 与 <code>pop</code> 的区别是，<code>apply</code> 还原的暂存，在暂存栈中依然存在，可多次还原，<code>pop</code> 还原的暂存在覆盖到工作区同时，暂存栈中删除该暂存。</strong></p></blockquote><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><pre><code class="lang-git"># 查看本地分支及分支最后一次提交信息
$ git branch
</code></pre><pre><code class="lang-git"># 查看本地分支
$ git branch -v
</code></pre><pre><code class="lang-git"># 查看所有分支
$ git branch -a
</code></pre><pre><code class="lang-git"># 查看所有分支及最后一次提交信息
$ git branch -av
</code></pre><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><pre><code class="lang-git"># 从当前所在分支的 commit 创建分支
$ git branch 新分支名
</code></pre><pre><code class="lang-git"># 基于已有分支的 commit 创建分支
$ git branch 新分支名 分支名
</code></pre><blockquote class="pullquote warning"><p><strong>注意：</strong></p><ul><li><em><strong>新创建的分支和主分支 <code>master</code> 还是同一个区域，新建的文件只有提交到新分支的版本库才真正脱离关系；</strong></em></li><li><em><strong><code>Git</code> 刚刚初始化管理的的文件夹必须有一次提交到版本库（<code>root-commit</code>：根提交）以后才会有主分支 <code>master</code>，否则即使创建了新分支也无法切换回 <code>master</code>。</strong></em></li></ul></blockquote><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><pre><code class="lang-git"># 切换分支
$ git checkout 分支名
</code></pre><pre><code class="lang-git"># 创建并切换分支
$ git checkout -b 分支名
</code></pre><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><pre><code class="lang-git"># 删除已经合并的分支
$ git branch -d 分支名
</code></pre><pre><code class="lang-git"># 删除未合并的分支
$ git branch -D 分支名
</code></pre><blockquote class="pullquote default"><p><strong>需切换出要删除的分支，才能进行删除操作，使用 <code>-d</code> 在删除前 <code>Git</code> 会判断在该分支上开发的功能是否被 <code>merge</code> 到其它分支，如果没有，不能删除，如果 <code>merge</code> 到其它分支，但之后又在其上做了开发，使用 <code>-d</code> 还是不能删除，<code>-D</code> 会强制删除。</strong></p></blockquote><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><blockquote class="pullquote success"><p><strong>将指定分支合并到当前所在的分支，所以，在分支开发完毕后，合并分支需要先切换回目标分支。</strong></p></blockquote><pre><code class="lang-git">$ git merge 指定的分支名
</code></pre><h3 id="比较变更"><a href="#比较变更" class="headerlink" title="比较变更"></a>比较变更</h3><pre><code class="lang-git"># 两个不同分支的比较，文件名参数省略比较所有文件
$ git diff 分支1 分支2 文件名
</code></pre><pre><code class="lang-git"># 两个不同的 commit 比较，文件名参数省略比较所有文件
$ git diff 61db01a 968adc7 文件名
</code></pre><blockquote class="pullquote danger"><p><strong><code>commit</code> 也可以用 <code>HEAD</code> 指代当前 <code>HEAD</code> 所在的提交，参数详情如下：</strong></p><ul><li><strong><code>HEAD^</code>：父节点；</strong></li><li><strong><code>HEAD^n</code>：第 <code>n</code> 个父节点；</strong></li><li><strong><code>HEAD^^</code>：父节点的父节点；</strong></li><li><strong><code>HEAD～</code>：父节点；</strong></li><li><strong><code>HEAD～2</code>：父节点的父节点。</strong></li></ul><p><strong><code>HEAD^^</code> 等同于 <code>HEAD～2</code>，一个节点可以有多个子节点（在某个 <code>commit</code> 下创建多个分支），也可以有多个父节点（多个分支的 <code>commit</code> 合并）。</strong></p></blockquote><pre><code class="lang-git"># 工作区和暂存区比较
$ git diff
</code></pre><pre><code class="lang-git"># 工作区和版本库比较
$ git diff 分支名
</code></pre><pre><code class="lang-git"># 暂存区和版本库比较
$ git diff --cached|--staged
</code></pre><h3 id="撤销和回退操作"><a href="#撤销和回退操作" class="headerlink" title="撤销和回退操作"></a>撤销和回退操作</h3><pre><code class="lang-git">$ git checkout 文件名
</code></pre><pre><code class="lang-git">$ git checkout .
</code></pre><pre><code class="lang-git"># 撤销某一个版本的文件到工作区
$ git checkout 版本号 文件名
</code></pre><blockquote class="pullquote warning"><p><strong>撤销操作是将暂存区覆盖到工作区，会放弃掉当前工作区修改的内容，. 参数是将整个暂存区覆盖当前工作区，一旦撤销就回不到之前的工作区了。</strong><br><strong>当不小心将当前工作区错误的代码提交到暂存区，可以使用下面命令将暂存区回滚到上一个暂存区，只可回滚一次。</strong></p></blockquote><pre><code class="lang-git"># 文件名参数，省略后为撤销全部文件更改的暂存
$ git reset HEAD 文件名
</code></pre><pre><code class="lang-git"># 按版本号回退版本
$ git reset --hard 版本号
</code></pre><pre><code class="lang-git"># 回退到上一个版本
$ git reset --hard HEAD^
</code></pre><blockquote class="pullquote info"><p><strong><code>reset</code> 指令的参数有三种，区别如下：</strong></p><ul><li><strong><code>--mixed</code>：默认参数，可省略，暂存区、版本库修改为指定的 <code>commit</code> 状态；</strong></li><li><strong><code>--soft</code>：只将版本库修改为指定的 <code>commit</code> 状态；</strong></li><li><strong><code>--hard</code>：工作区、暂存区、版本库都修改为指定的 <code>commit</code> 状态。</strong></li></ul></blockquote><blockquote class="pullquote danger"><p><em><strong>注意：当想要改变工作区内容时使用 <code>checkout</code>，当想要改变暂存区内容时使用 <code>reset</code>。</strong></em></p></blockquote><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><blockquote class="pullquote success"><p><strong>当创建分支后，分支和 <code>master</code> 主分支分别提交代码到版本库，此时切换回 <code>master</code> 主分支，合并分支会出现冲突，需手动处理后，重新提交到暂存区并提交到版本库。</strong></p></blockquote><p><strong>代码冲突：</strong></p><pre><code class="lang-vim">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改)
master 分支代码
=======
开发分支的代码
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 开发的分支 (传入的更改)
</code></pre><h2 id="Git-操作远程仓库"><a href="#Git-操作远程仓库" class="headerlink" title="Git 操作远程仓库"></a>Git 操作远程仓库</h2><blockquote class="pullquote default"><p><strong>远程仓库可以是 <code>Github</code>、<code>Gitee</code>（码云）、<code>Coding</code> 或者中央服务器等等。</strong></p></blockquote><p><strong>以下是常用免费仓库的地址，可以在首页注册账号：</strong></p><ul><li><strong>Github：</strong> <a>https://github.com</a></li><li><strong>Gitee：</strong> <a>https://gitee.com</a></li><li><strong>Coding：</strong> <a>https://coding.net</a></li></ul><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><h4 id="克隆仓库带工作区"><a href="#克隆仓库带工作区" class="headerlink" title="克隆仓库带工作区"></a>克隆仓库带工作区</h4><pre><code class="lang-git">$ git clone 项目地址 项目别名
</code></pre><blockquote class="pullquote success"><p><strong>上面命令项目别名是可选的，相当于给项目根文件夹重命名。</strong></p></blockquote><h4 id="克隆裸仓库"><a href="#克隆裸仓库" class="headerlink" title="克隆裸仓库"></a>克隆裸仓库</h4><pre><code class="lang-git"># 使用哑协议
$ pwd
# /Users/pandashen/Study/git_learning
$ git clone --bare /Users/pandashen/Study/git_learning/.git ya.git

# Cloning into bare repository &#39;ya.git&#39;...
# done.
</code></pre><pre><code class="lang-git"># 使用智能协议
$ git clone --bare fill:///Users/pandashen/Study/git_learning/.git zhineng.git

# Cloning into bare repository &#39;zhineng.git&#39;...
# remote: Enumerating objects: 23, done.
# remote: Counting objects: 100% (23/23), done.
# remote: Compressing objects: 100% (18/18), done.
# remote: Total 23 (delta 2), reused 0 (delta 0)
# Receiving objects: 100% (23/23), done.
# Resolving deltas: 100% (2/2), done.
</code></pre><blockquote class="pullquote primary"><p><strong>裸仓库是一个文件夹，内部存储的与带有工作区仓库的 <code>.git</code> 相同，使用哑协议和智能协议的区别是哑协议没有进度信息，而且智能协议由于对传输的信息进行了打包、压缩，所以传输速度更快。</strong></p></blockquote><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><pre><code class="lang-git"># 创建关联
$ git remote add origin 远程仓库地址
</code></pre><pre><code class="lang-git"># 查看关联的远程仓库
$ git remote -v
</code></pre><pre><code class="lang-git"># 删除远程仓库的关联
$ git remote rm 地址别名
</code></pre><blockquote class="pullquote default"><p><strong>地址别名指的是上面的 <code>origin</code>，也可以是其他名称，必须对应要删除关联的地址别名。</strong></p></blockquote><h3 id="处理需要提交时过滤的文件-文件夹"><a href="#处理需要提交时过滤的文件-文件夹" class="headerlink" title="处理需要提交时过滤的文件/文件夹"></a>处理需要提交时过滤的文件/文件夹</h3><p>使用 WebStrom 编辑器编辑代码时，会自动在根目录生成 <code>.idea</code> 文件夹，使用 Mac 开发时根目录下的 <code>.DS_Store</code> 文件夹，以及在项目开发时会安装依赖存放在 <code>node_modules</code> 文件夹中，此类文件夹都是在把代码上传到远程仓库或中央服务器时不应该上传的，因此应该在上传之前过滤掉。</p><p><strong>在根目录创建 <code>.gitignore</code> 文件用于记录上传时被忽略的文件夹，内容（可根据需要自行配置）如下：</strong></p><pre><code class="lang-makefile"># 文件：.gitignore
.idea
.DS_Store
node_modules
</code></pre><blockquote class="pullquote warning"><p><strong><code>Git</code> 上传时会自动忽略空文件夹，假设想要上传一个名为 <code>public</code> 的空文件夹，需要在文件夹内新建一个名为 <code>.gitkeep</code> 的文件（名字随意，最好有语义化），目的是使要提交的空文件夹不再为空。</strong></p></blockquote><h3 id="推送代码到远程仓库"><a href="#推送代码到远程仓库" class="headerlink" title="推送代码到远程仓库"></a>推送代码到远程仓库</h3><pre><code class="lang-git"># 将本地所有分支推送到远端
$ git push 地址别名 --all
</code></pre><pre><code class="lang-git"># 将本地分支推送到远端
$ git push 地址别名 分支名
</code></pre><pre><code class="lang-git">$ git push -u 地址别名 分支名
</code></pre><blockquote class="pullquote info"><p><strong>如果加上了 <code>-u</code> 参数，以后再次提交时可省略地址别名和分支名称，直接执行下面命令进行提交。</strong></p></blockquote><pre><code class="lang-git">$ git push
</code></pre><pre><code class="lang-git">$ git push -f
</code></pre><blockquote class="pullquote danger"><p><em><strong>注意：<code>-f</code> 参数是在 <code>Git</code> 默认不允许的情况下也能将代码推送到远程服务器，是一个非常危险的命令，团队中一般禁止使用。</strong></em></p></blockquote><h3 id="拉取远程仓库的代码"><a href="#拉取远程仓库的代码" class="headerlink" title="拉取远程仓库的代码"></a>拉取远程仓库的代码</h3><blockquote class="pullquote default"><p><strong>在提交代码时，如果直接提交到远程仓库，会将当前代码覆盖到远程仓库，如果别人之前也向远程仓库提交了代码，会在远程仓库中造成冲突，所以一般在提交代码之前先拉取远程仓库的代码与本地代码进行合并，并产生一个新的历史记录，若出现冲突，手动处理冲突后再统一提交到远程仓库。</strong></p></blockquote><pre><code class="lang-git"># 拉取但不合并代码（与 merge 配合，不常用）
$ git fetch 地址别名 分支名
</code></pre><pre><code class="lang-git"># 拉取并合并代码（常用）
$ git pull origin master
</code></pre><pre><code class="lang-git"># 拉去代码执行变基操作
$ git pull --rebase
</code></pre><h3 id="创建并拉取远程仓库的分支"><a href="#创建并拉取远程仓库的分支" class="headerlink" title="创建并拉取远程仓库的分支"></a>创建并拉取远程仓库的分支</h3><pre><code class="lang-git"># 创建、切换并拉取远程分支
$ git checkout -b 分支名 地址别名/分支名
</code></pre><blockquote class="pullquote success"><p><strong>上面命令的意思是在本地创建并切换分支，同时将远端分支代码拉取到这个刚创建的分支。</strong></p></blockquote><h3 id="创建-gh-pages-分支来发布静态页"><a href="#创建-gh-pages-分支来发布静态页" class="headerlink" title="创建 gh-pages 分支来发布静态页"></a>创建 gh-pages 分支来发布静态页</h3><p><strong>涉及到远程仓库网站上的操作均以 Github 为例，其他仓库大同小异：</strong></p><ul><li><strong>在项目中创建一个静态页分支，我们使用 <code>gh-pages</code> 作为分支名；</strong></li><li><strong>将 <code>gh-pages</code> 分支提交到线上仓库；</strong></li><li><strong>找到提供仓库网站的 <code>Settings</code> 设置，切换到 <code>github-pages</code> 分支；</strong></li><li><strong>点击该栏顶端的地址可以访问我们的静态页。</strong></li></ul><pre><code class="lang-git"># 创建静态页命令
$ git checkout -b gh-pages
$ touch index.html
$ git add .
$ git commit -m &#39;提交信息&#39;
$ git push origin gh-pages
</code></pre><h3 id="向别人的项目提问"><a href="#向别人的项目提问" class="headerlink" title="向别人的项目提问"></a>向别人的项目提问</h3><ul><li><strong>在远程仓库网站进入别人的项目页面；</strong></li><li><strong>点击 <code>Issue</code> 选项；</strong></li><li><strong>输入问题标题和问题描述并点击提交；</strong></li><li><strong>项目所有者可以回复或关闭问题。</strong></li></ul><h3 id="更改别人的项目代码"><a href="#更改别人的项目代码" class="headerlink" title="更改别人的项目代码"></a>更改别人的项目代码</h3><ul><li><strong>在别人项目的主页上有一个叉子的图标，操作名为 <code>Fork</code>；</strong></li><li><strong><code>Fork</code> 是在当前项目下克隆了一份，如果代码更新，不会随之更新；</strong></li><li><strong>使用 <code>clone</code> 命令克隆自己的地址将项目拉到本地，进行操作；</strong></li><li><strong>默认就是 Git 仓库而且有 <code>origin</code> 地址，修改后可以将代码提交到自己的仓库上；</strong></li><li><strong>只有 <code>Fork</code> 关系才能修改别人代码后点击 <code>New pull request</code> 发送提交请求；</strong></li><li><strong>点击 <code>Create pull request</code> 按钮，填写提交标题，和提交详情，确认提交；</strong></li><li><strong>项目所有者可以在自己的项目页面中 <code>Pull request</code> 菜单中查看提交并处理；</strong></li><li><strong>点击 <code>Close pull request</code> 关闭，点击 <code>Merge pull request</code> 同意提交并合并。</strong></li></ul><blockquote class="pullquote info"><p><strong>如果是一个团队的其他人需要操作同一个项目，上面的过程显得很繁琐，项目所有者可以在 <code>Settings</code> 的 <code>Collaborators</code> 选项中通过添加别人的账号或用户名向项目中添加贡献者，被添加的人拥有最大权限。</strong></p></blockquote><h2 id="GUI-界面化"><a href="#GUI-界面化" class="headerlink" title="GUI 界面化"></a>GUI 界面化</h2><blockquote class="pullquote primary"><p><strong>在当前的前端开发编辑器中，如 <code>VSCode</code> 和 <code>WebStorm</code> 等都集成了 <code>Git</code>，也有专门用于管理代码的软件 <code>Sourcetree</code> 等，可以直接点击按钮操作，不必使用命令行，这种操作 <code>Git</code> 的界面称作 <code>GUI</code> 界面，个人建议还是尽量少的使用 <code>GUI</code> 界面，命令行是根本，还是多敲命令，孰能生巧。</strong></p></blockquote>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>代码管理/版本控制</tag>
        <tag>命令行</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的继承方式及优缺点</title>
    <url>/20170710162724/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170710162724/extends.png" title="JS 继承"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong><code>JavaScript</code> 原本不是纯粹的 <code>OOP</code> 语言，因为在 <code>ES5</code> 规范中没有类的概念，在 <code>ES6</code> 中才正式加入了 <code>class</code> 的编程方式，在 <code>ES6</code> 之前，也都是使用面向对象的编程方式，当然是 <code>JavaScript</code> 独有的面向对象编程，而且这种编程方式是建立在 <code>JavaScript</code> 独特的原型链的基础之上的，我们本篇就将对原型链以及面向对象编程最常用到的继承进行刨析。</strong></p></blockquote><a id="more"></a><h2 id="继承简介"><a href="#继承简介" class="headerlink" title="继承简介"></a>继承简介</h2><blockquote class="pullquote default"><p><strong>在 <code>JavaScript</code> 的中的面向对象编程，继承是给构造函数之间建立关系非常重要的方式，根据 <code>JavaScript</code> 原型链的特点，其实继承就是更改原本默认的原型链，形成新的原型链的过程。</strong></p></blockquote><h2 id="复制的方式进行继承"><a href="#复制的方式进行继承" class="headerlink" title="复制的方式进行继承"></a>复制的方式进行继承</h2><p>复制的方式进行继承指定是对象与对象间的浅复制和深复制，这种方式到底算不算继承的一种备受争议，我们也把它放在我们的内容中，当作一个 “不正经” 的继承。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p>创建一个浅复制的函数，第一个参数为复制的源对象，第二个参数为目标对象。</p><pre><code class="lang-js">// 浅复制方法
function extend(p, c = {}) {
  for (let k in p) {
    c[k] = p[k];
  }
  return c;
}

// 源对象
const parent = {
  a: 1,
  b: function () {
    console.log(1);
  }
};

// 目标对象
const child = {
  c: 2
};

// 执行
extend(parent, child);
console.log(child); // { c: 2, a: 1, b: ƒ }
</code></pre><p>上面的 <code>extend</code> 方法在 ES6 标准中可以直接使用 <code>Object.assign</code> 方法所替代。</p><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>可以组合使用 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 来实现，但是有局限性，不能处理函数和正则类型，所以我们自己实现一个方法，参数与浅复制相同。</p><pre><code class="lang-js">// 深复制方法
function extendDeeply(p, c = {}) {
  for (let k in p) {
    if (typeof p[k] === &#39;object&#39; &amp;&amp; typeof p[k] !== null) {
      c[k] = p[k] instanceof Array ? [] : {};
      extendDeeply(p[k], c[k]);
    } else {
      c[k] = p[k];
    }
  }
  return c;
}

// 源对象
const parent = {
  a: {
    b: 1
  },
  b: [1, 2, 3],
  c: 1,
  d: function () {
    console.log(1);
  }
};

// 执行
const child = extendDeeply(parent);

console.log(child); // { a: {b: 1}, b: [1, 2, 3], c: 1, d: ƒ }
console.log(child.a === parent.a); // false
console.log(child.b === parent.b); // false
console.log(child.d === parent.d); // true
</code></pre><p>在上面可以看出复制后的新对象 <code>child</code> 的 <code>a</code> 属性和 <code>b</code> 的引用是独立的，与 <code>parent</code> 的 <code>a</code> 和 <code>b</code> 毫无关系，实现了深复制，但是 <code>extendDeeply</code> 函数并没有对函数类型做处理，因为函数内部执行相同的逻辑指向不同引用是浪费内存的。</p><h2 id="原型替换"><a href="#原型替换" class="headerlink" title="原型替换"></a>原型替换</h2><p>原型替换是继承当中最简单也是最直接的方式，即直接让父类和子类共用同一个原型对象，一般有两种实现方式。</p><pre><code class="lang-js">/* 原型替换 */
// 父类
function Parent() {}

// 子类
function Child() {}

// 简单粗暴的写法
Child.prototype = Parent.prototype;

// 另一种种实现方式
Object.setPrototypeOf(Child.prototype, Parent.prototype);
</code></pre><p>上面这种方式 <code>Child</code> 的原型被替换掉，<code>Child</code> 的实例可以直接调用 <code>Parent</code> 原型上的方法，实现了对父类原型方法的继承。</p><p>上面第二种方式使用了 <code>Object.setPrototypeOf</code> 方法，该方法是将传入第一个参数对象的原型设置为第二个参数传入的对象，所以我们第一个参数传入的是 <code>Child</code> 的原型，将 <code>Child</code> 原型的原型设置成了 <code>Parent</code> 的原型，使父、子类原型链产生关联，<code>Child</code> 的实例继承了 <code>Parent</code> 原型上的方法，在 Node.js 中的内置模块 <code>util</code> 中用来实现继承的方法 <code>inherits</code>，底层就是使用这种方式实现的。</p><blockquote class="pullquote primary"><p><strong>缺点：父类的实例也同样可以调用子类的原型方法，我们希望继承是单向的，否则无法区分父、子类关系，这种方式一般是不可取的。</strong></p></blockquote><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承的思路是子类的原型的原型是父类的原型，形成了一条原型链，建立子类与父类原型的关系。</p><pre><code class="lang-js">/* 原型链继承 */
// 父类
function Parent(name) {
  this.name = name;
  this.hobby = [&#39;basketball&#39;, &#39;football&#39;];
}

// 子类
function Child() {}

// 继承
Child.prototype = new Parent();
</code></pre><p>上面用 <code>Parent</code> 的实例替换了 <code>Child</code> 自己的原型，由于父类的实例原型直接指向 <code>Parent.prototype</code>，所以也使父、子类原型链产生关联，子类实例继承了父类原型的方法。</p><blockquote class="pullquote info"><p><strong>缺点：</strong></p><ul><li><strong>只能继承父类原型上的方法，却无法继承父类上的属性；</strong></li><li><strong>由于原型对象被替换，原本原型的 <code>constructor</code> 属性丢失；</strong></li><li><strong>如果父类的构造函数中有属性，则创建的父类的实例也会有这个属性，用这个实例的作为子类的原型，这个属性就变成了所有子类实例所共有的，这个属性可能是多余的，并不是我们想要的，也可能我们希望它不是共有的，而是每个实例自己的。</strong></li></ul></blockquote><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>构造函数继承又被国内的开发者叫做 “经典继承”。</p><pre><code class="lang-js">/* 构造函数继承 */
// 父类
function Parent(name) {
  this.name = name;
}

// 子类
function Child() {
  Parent.apply(this, arguments);
}

let c = new Child(&#39;Panda&#39;);
console.log(c); // { name: &#39;Panda&#39; }
</code></pre><p>构造函数继承的原理就是在创建 <code>Child</code> 实例的时候执行了 <code>Child</code> 构造函数，并借用 <code>call</code> 或 <code>apply</code> 在内部执行了父类 <code>Parent</code>，并把父类的属性创建给了 <code>this</code>，即子类的实例，解决了原型链继承不能继承父类属性的缺点。</p><blockquote class="pullquote danger"><p><strong>缺点：子类的实例只能继承父类的属性，却不能继承父类的原型的方法。</strong></p></blockquote><h2 id="构造函数原型链组合继承"><a href="#构造函数原型链组合继承" class="headerlink" title="构造函数原型链组合继承"></a>构造函数原型链组合继承</h2><p>为了使子类既能继承父类原型的方法，又能继承父类的属性到自己的实例上，就有了这种组合使用的方式。</p><pre><code class="lang-js">/* 构造函数原型链组合继承 */
// 父类
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function () {
  console.log(this.name);
};

// 子类
function Child() {
  Parent.apply(this, arguments);
}

// 继承
Child.prototype = new Parent();

const c = new Child(&#39;Panda&#39;);
console.log(c); // { name: &#39;Panda&#39; }
c.sayName(); // Panda
</code></pre><p>这种继承看似完美，但是之前 <code>constructor</code> 丢失和子类原型上多余共有属性的问题还是没有解决，在这基础上又产生了新的问题。</p><blockquote class="pullquote success"><p><strong>缺点：父类被执行了两次，在使用 <code>call</code> 或 <code>apply</code> 继承属性时执行一次，在创建实例替换子类原型时又被执行了一次。</strong></p></blockquote><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承主要用来解决用父类的实例替换子类的原型时共有属性的问题，以及父类构造函数执行两次的问题，也就是说通过原型式继承能保证子类的原型是 “干净的”，而保证只在继承父类的属性时执行一次父类。</p><pre><code class="lang-js">/* 原型式继承 */
// 父类
function Parent(name) {
  this.name = name;
}

// 子类
function Child() {
  Parent.apply(this, arguments);
}

// 继承函数
function create(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}

// 继承
Child.prototype = create(Parent.prototype);

const c = new Child(&#39;Panda&#39;);
console.log(c); // { name: &#39;Panda&#39; }
</code></pre><p>原型式继承其实是借助了一个中间的构造函数，将中间构造函数 <code>F</code> 的 <code>prototype</code> 替换成了父类的原型，并创建了一个 <code>F</code> 的实例返回，这个实例是不具备任何属性的（干净的），用这个实例替换子类的原型，因为这个实例的原型指向 <code>F</code> 的原型，<code>F</code> 的原型同时又是父类的原型对象，所以子类实例继承了父类原型的方法，父类只在创建子类实例的时候执行了一次，省去了创建父类实例的过程。</p><p>原型式继承在 <code>ES5</code> 标准中被封装成了一个专门的方法 <code>Object.create</code>，该方法的第一个参数与上面 <code>create</code> 函数的参数相同，即要作为原型的对象，第二个参数则可以传递一个对象，会把对象上的属性添加到这个原型上，一般第二个参数用来弥补 <code>constructor</code> 的丢失问题，这个方法不兼容 IE 低版本浏览器。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承就是用来解决子统一为原型式继承中返回的对象统一添加方法的问题，只是在原型式继承的基础上做了小小的修改。</p><pre><code class="lang-js">/* 寄生式继承 */
// 父类
function Parent(name) {
  this.name = name;
}

// 子类
function Child() {
  Parent.apply(this, arguments);
}

// 继承函数
function create(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}

// 将子类方法私有化函数
function creatFunction(obj) {
  // 调用继承函数
  let clone = create(obj);
  // 子类原型方法（多个）
  clone.sayName = function () {};
  clone.sayHello = function () {};

  return clone;
}

// 继承
Child.prototype = creatFunction(Parent.prototype);
</code></pre><blockquote class="pullquote default"><p><strong>缺点：因为寄生式继承最后返回的是一个对象，如果用一个变量直接来接收它，那相当于添加的所有方法都变成这个对象自身的了，如果创建了多个这样的对象，无法实现相同方法的复用。</strong></p></blockquote><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><pre><code class="lang-js">/* 寄生组合式继承 */
// 父类
function P(name, age) {
  this.name = name;
  this.age = age;
}

P.prototype.headCount = 1;
P.prototype.eat = function () {
  console.log(&#39;eating...&#39;);
};

// 子类
function C(name, age) {
  P.apply(this, arguments);
}

// 寄生组合式继承方法
function myCreate(Child, Parent) {
  function F() {}
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  // 让 Child 子类的静态属性 super 和 base 指向父类的原型
  Child.super = Child.base = Parent.prototype;
}

// 调用方法实现继承
myCreate(C, P);

// 向子类原型添加属性方法，因为子类构造函数的原型被替换，所以属性方法仍然在替换之后
C.prototype.language = &#39;javascript&#39;;
C.prototype.work = function () {
  console.log(&#39;writing code use &#39; + this.language);
};
C.work = function () {
  this.super.eat();
};

// 验证继承是否成功
const f = new C(&#39;nihao&#39;, 16);
f.work();
C.work();

// writing code use javascript
// eating...
</code></pre><p>寄生组合式继承基本规避了其他继承的大部分缺点，应该比较强大了，也是平时使用最多的一种继承，其中 <code>Child.super</code> 方法的作用是为了在调用子类静态属性的时候可以调用父类的原型方法。</p><blockquote class="pullquote warning"><p><strong>缺点：子类没有继承父类的静态方法。</strong></p></blockquote><h2 id="class…extends…-继承"><a href="#class…extends…-继承" class="headerlink" title="class…extends… 继承"></a>class…extends… 继承</h2><p>在 ES6 规范中有了类的概念，使继承变得容易，在规避上面缺点的完成继承的同时，又在继承时继承了父类的静态属性。</p><pre><code class="lang-js">/* class...extends... 继承 */
// 父类
class P {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayName() {
    console.log(this.name);
  }
  static sayHi() {
    console.log(&#39;Hello&#39;);
  }
}

// 子类继承父类
class C extends P {
  constructor(name, age) {
    supper(name, age); // 继承父类的属性
  }
  sayHello() {
    P.sayHi();
  }
  static sayHello() {
    super.sayHi();
  }
}

let c = new C(&#39;jack&#39;, 18);

c.sayName(); // jack
c.sayHello(); // Hello
C.sayHi(); // Hello
C.sayHello(); // Hello
</code></pre><blockquote class="pullquote success"><p><strong>在子类的 <code>constructor</code> 中调用 <code>supper</code> 可以实现对父类属性的继承，父类的原型方法和静态方法直接会被子类继承，在子类的原型方法中使用父类的原型方法只需使用 <code>this</code> 或 <code>supper</code> 调用即可，此时 <code>this</code> 指向子类的实例，如果在子类的静态方法中使用 <code>this</code> 或 <code>supper</code> 调用父类的静态方法，此时 <code>this</code> 指向子类本身。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 JavaScript 原型链</title>
    <url>/20170709131856/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170709131856/proto.png" title="JS 原型链"><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote class="pullquote default"><p><strong>在 JavaScript 中有种说法叫 “万物皆对象”，就是说无论是构造函数创建的实例，构造函数本身、原型对象、数组、函数本质上都是对象，都拥有 <code>__proto__</code> 属性，即隐式原型，所有函数都拥有 <code>prototype</code> 属性，即显式原型（仅限函数），原型对象（<code>prototype</code> 属性指向的对象），在定义函数时就被创建。</strong></p></blockquote><a id="more"></a><h2 id="原型链指向概述"><a href="#原型链指向概述" class="headerlink" title="原型链指向概述"></a>原型链指向概述</h2><p>在 JavaScript 中整个原型链及查找机制用下图可以完整的表示出来。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170709131856/prototype.png" alt="JS 原型链"></div><div class="image-caption">JS 原型链</div></figure><p><br></p><p><strong>原型链指向：</strong></p><p>通过字面量和 <code>new Object()</code> 所创建的对象，他们是构造函数是 <code>function Object()</code> 的实例，<code>Object</code> 构造函数的 <code>prototype</code> 指向原型对象 <code>Object.prototype</code>，<code>Object.prototype</code> 的 <code>constructor</code> 指向构造函数 <code>Object</code>，而实例的 <code>__proto__</code> 也指向 <code>Object.prototype</code>，<code>Object.prototype</code> 的 <code>__proto__</code> 指向 <code>null</code>，所以 <code>Object.prototype</code> 也叫做顶级原型对象。</p><p>上图中 <code>new Foo()</code> 创建的对象是构造函数 <code>function Foo()</code> 的实例，<code>Foo</code> 的 <code>prototype</code> 指向原型对象 <code>Foo.prototype</code>，<code>Foo.prototype</code> 的 <code>constructor</code> 指向构造函数 <code>Foo</code>，而实例的 <code>__proto__</code> 也指向 <code>Foo.prototype</code>，并且 <code>Foo.prototype</code> 虽然是原型对象，但也是对象，所以是构造函数 <code>Object</code> 的实例，<code>__proto__</code> 指向顶级原型对象 <code>Object.prototype</code>。</p><p>数组的构造函数是 <code>function Array()</code> 原型链的指向与其他除 <code>Object</code> 以外的构造函数相同，<code>Array.prototype</code> 的 <code>__proto__</code> 也指向顶级原型对象 <code>Object.prototype</code>，每一个数组都是 <code>Array</code> 的实例，<code>__proto__</code> 都指向 <code>Array.prototype</code>。</p><p><code>Object</code>、<code>Array</code>、<code>Foo</code> 等构造函数的本质也是对象，他们的构造函数是 <code>function Function()</code>，<code>Function</code> 的 <code>prototype</code> 指向 <code>Function.prototype</code>，<code>Function.prototype</code> 的 <code>constructor</code> 指向 <code>Function</code>，所有的构造函数的 <code>__proto__</code> 都指向 <code>Function.prototype</code>，包括 <code>Function</code> 本身，也就是说构造函数 <code>Function</code> 是由自己构造的，<code>Function.prototype</code> 的 <code>__proto__</code> 同样指向顶级原型对象 <code>Object.prototype</code>。</p><h2 id="prototype-原型对象"><a href="#prototype-原型对象" class="headerlink" title="prototype 原型对象"></a>prototype 原型对象</h2><p><code>prototype</code> 是函数的一个属性，属性的值指向了一个对象，所以，只有函数才有 <code>prototype</code> 原型对象。</p><pre><code class="lang-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

typeof Person.prototype; // object
Person.prototype.constructor; // Person {}
Person.prototype.job = &#39;qianduan&#39;;

var p1 = new Person(&#39;panda&#39;, 18);
var p2 = new Person(&#39;shen&#39;, 20);

p1.constructor.prototype; // 实例对象查找构造函数原型对象的方法
</code></pre><p>一般会把对象共有的属性和方法都放在构造函数的原型对象上。</p><h2 id="实例、构造函数、原型对象的关系"><a href="#实例、构造函数、原型对象的关系" class="headerlink" title="实例、构造函数、原型对象的关系"></a>实例、构造函数、原型对象的关系</h2><p>构造函数的原型 <code>prototype</code> 属性指向一个原型对象，实例也可以通过 <code>__proto__</code> 指向原型对象，但本质上实例和构造函数之间是没有关系的。</p><pre><code class="lang-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

var p = new Person(&#39;nihao&#39;, 16);
p.constructor = { name: &#39;haha&#39; };
p.name; // nihao
</code></pre><p>上面的代码中改变了构造函数的值为一个对象，对象中的属性 <code>name</code> 并没有影响实例的 <code>name</code> 属性值。</p><h2 id="实例属性-proto"><a href="#实例属性-proto" class="headerlink" title="实例属性 __proto__"></a>实例属性 __proto__</h2><p>上面访问实例 <code>p</code> 的原型，实际使用 <code>p.constructor.prototype</code> 去找原型对象，当构造函数的值改变后是找不到原型对象的，所以实例并不是通过 <code>constructor.prototype</code> 去查找原型对象的，而是通过每一个实例都有的 <code>__proto__</code> 属性，这个属性指向创建实例的构造函数原本的原型对象，这个属性不是标准，在 IE 下不存在。</p><pre><code class="lang-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.job = &#39;qianduan&#39;;
var p = new Person(&#39;nihao&#39;, 16);

p.__proto__.job; // qianduan
</code></pre><p>当构造函数的 <code>prototype</code> 属性值被改变之后，在之前创建的实例的 <code>__proto__</code> 属性值的仍然引用原型对象，所以对构造函数改变前创建的实例是没有影响的，会影响后面创建的实例。</p><h2 id="原型链查找机制"><a href="#原型链查找机制" class="headerlink" title="原型链查找机制"></a>原型链查找机制</h2><p>实例对象在调用了一个属性或方法时，如果对象本身没有这个属性或方法，会去自己的原型对象查找，也就是 <code>__proto__</code> 中查找，如果原型对象中没有，去原型对象的原型对象查找，一般（原型链没有被修改）情况下就是去 <code>__proto__</code> 的 <code>__proto__</code> 中查找，即顶级原型对象 <code>Object.prototype</code>，如果实例对象本身有这个属性，则直接输出，不再向上查找，如果对象本身和原型对象具有同名属性，则会屏蔽掉原型对象的属性。</p><pre><code class="lang-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.job = &#39;qianduan&#39;;
var p = new Person(&#39;nihao&#39;, 16);

p.job; // qianduan
p.job = &#39;houtai&#39;;
p.job; // houtai
p.__proto__.job; // qianduan
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>原型链的指向及原型链的查找机制是 JavaScript 中非常重要的基础知识，理解原型链是更深入了解继承和面向对象编程的必经之路。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基础知识总结</title>
    <url>/20170704154632/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170704154632/regex.jpg" title="正则表达式"><p><br></p><h2 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h2><pre><code class="lang-js">/* 字面量 */
const reg = /test/g;
</code></pre><pre><code class="lang-js">/* 构造函数 */
const reg = new RegExp(&#39;test&#39;, &#39;g&#39;);
</code></pre><p>创建正则表达式有两种方式，使用字面量创建和通过构造函数创建，构造函数创建是使用字符串创建，可以动态生成正则表达式，构造函数中的第二个参数是修饰符。</p><h2 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h2><blockquote class="pullquote danger"><p><strong>正则表达式中包含一些修饰符用来决定匹配的模式，如忽略大小写、全局匹配等。</strong></p><ul><li><strong><code>i</code>：忽略大小写，如 <code>/test/i</code>，可以匹配 <code>test</code>、<code>TEST</code>、<code>Test</code>、<code>tEsT</code> 等；</strong></li><li><strong><code>g</code>：全局匹配，在查找到第一个匹配项时不会停止，会继续向后查找到所有的匹配项；</strong></li><li><strong><code>m</code>：允许多行匹配，对获取 <code>textarea</code> 和 <code>html</code> 标签中的内容很有用；</strong></li><li><strong><code>y</code>：开始贪婪匹配，开启贪婪匹配时会试图从最后一个匹配的位置开始；</strong></li><li><strong><code>u</code>：允许使用 <code>Unicode</code> 点转义符，如 <code>\u...</code>。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>修饰符可以多个同时作用于同一个正则，如 <code>/test/ig</code> 或 <code>new RegExp(&#39;test&#39;, &#39;ig&#39;)</code>。</strong></p></blockquote><h2 id="术语和操作符"><a href="#术语和操作符" class="headerlink" title="术语和操作符"></a>术语和操作符</h2><h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>除了非特殊字符和操作符之外，字符必须准确出现在表达式中，称为精确匹配，如 <code>/test/</code>，代表 <code>t</code> 连接 <code>e</code>，<code>e</code> 连接 <code>s</code>，<code>s</code> 连接 <code>t</code>。</p><h3 id="匹配字符集"><a href="#匹配字符集" class="headerlink" title="匹配字符集"></a>匹配字符集</h3><blockquote class="pullquote default"><ul><li><strong><code>[abc]</code> 代表匹配 <code>a</code>、<code>b</code>、<code>c</code> 中任意一个字符；</strong></li><li><strong><code>[^abc]</code> 代表匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 的任意一个字符；</strong></li><li><strong><code>[a-z]</code> 代表匹配小写字母 <code>a</code> 到 <code>z</code> 的任意一个字符，<code>[A-Z]</code>、<code>[0-9]</code> 同理；</strong></li></ul></blockquote><h3 id="起止符号"><a href="#起止符号" class="headerlink" title="起止符号"></a>起止符号</h3><blockquote class="pullquote success"><ul><li><strong><code>^</code> 直接链接匹配的字符时，代表匹配以该串字符开头；</strong></li><li><strong><code>$</code> 直接链接匹配的字符时，代表匹配以该串字符结尾。</strong></li></ul></blockquote><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>如果想匹配在正则表达式中带有语义的字符需要对字符进行转义，如匹配 <code>[</code>、<code>]</code>、<code>.</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>^</code> 等，需使用 <code>\</code> 或 <code>\\</code> 进行转义，如 <code>\[</code> 或 <code>\\[</code>。</p><blockquote class="pullquote warning"><p><strong>在字面量中创建的正则使用 <code>\</code> 进行转义，使用构造函数创建的正则，由于传入的字符串，所以需要使用 <code>\\</code> 进行转义。</strong></p></blockquote><h3 id="匹配重复出现"><a href="#匹配重复出现" class="headerlink" title="匹配重复出现"></a>匹配重复出现</h3><blockquote class="pullquote primary"><ul><li><strong><code>?</code>：表示匹配连续 <code>0</code> 个或 <code>1</code> 个；</strong></li><li><strong><code>+</code>：表示匹配连续 <code>1</code> 个或多个；</strong></li><li><strong><code>*</code>：表示匹配连续 <code>0</code> 个、<code>1</code> 个或多个；</strong></li><li><strong><code>{n}</code>: 表示匹配连续 <code>n</code> 个；</strong></li><li><strong><code>{m, n}</code> 表示匹配连续 <code>m</code> 到 <code>n</code> 个；</strong></li><li><strong><code>{m,}</code> 表示匹配连续 <code>m</code> 个以上。</strong></li></ul></blockquote><h3 id="贪婪和非贪婪匹配"><a href="#贪婪和非贪婪匹配" class="headerlink" title="贪婪和非贪婪匹配"></a>贪婪和非贪婪匹配</h3><p>正则匹配默认是贪婪模式，可以匹配所有可能的字符，会直接匹配到最后，使用 <code>?</code> 可以转换为非贪婪匹配。</p><p>例如 <code>/a+/</code> 对于字符串 <code>aaaaa</code>, 会匹配 <code>aaaaa</code>，<code>/a+?/</code> 则只会匹配到 <code>a</code>。</p><h3 id="预定义字符集"><a href="#预定义字符集" class="headerlink" title="预定义字符集"></a>预定义字符集</h3><p>希望匹配的内容有些无法用字符表示，如回车、空格，或者想快速匹配一些预定义的字符，下面是预定义字符集的表。</p><table><thead><tr><th style="width:20%">预定义元字符</th><th>匹配的字符集</th></tr></thead><tbody><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\b</td><td>空格</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\cA:\cZ</td><td>控制字符</td></tr><tr><td>\u0000:\uFFFF</td><td>十六进制 Unicode 码</td></tr><tr><td>\x00:\xFF</td><td>十六进制 ASCII 码</td></tr><tr><td>\.</td><td>匹配除换行字符（\r、\n、\u2028 和 \u2029）以外的任意字符</td></tr><tr><td>\d</td><td>匹配任意十进制数字，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配除了十进制数字以外的任意字符，等价于 [^0-9]</td></tr><tr><td>\w</td><td>匹配任何字母、数字和下划线，等价于 [A-Za-z0-9_]</td></tr><tr><td>\W</td><td>匹配除了字母、数字和下划线之外的字符，等价于 [^A-Za-z0-9_]</td></tr><tr><td>\s</td><td>匹配任意空白字符（包括空格、制表符、换页符等）</td></tr><tr><td>\S</td><td>匹配除空白字符外的任意字符</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\B</td><td>匹配非单词边界（单词内部）</td></tr></tbody></table><h3 id="或操作符"><a href="#或操作符" class="headerlink" title="或操作符"></a>或操作符</h3><p>或操作符使用 <code>|</code> 表示，如 <code>/a|b/</code> 可以匹配字符 <code>a</code> 或者 <code>b</code>。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>想要匹配某一个单词或者满足某一匹配规则的一段字符，可以使用分组实现，使用 <code>()</code> 进行分组。</p><p>如 <code>/(ab)+/</code> 可以匹配一个或多个 <code>ab</code> 字符，<code>/(ab)+|(cd)+/</code> 可以匹配一个或多个 <code>ab</code> 或 <code>cd</code> 字符。</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用指可以快速引用某一个分组所匹配出的结果作为当前的匹配规则，通常用 <code>\1</code> 或 <code>\2</code> 等表示，数字位置对应当前正则中第几个分组。</p><p>如 <code>/&lt;(\w+)&gt;(.+)&lt;\/\1&gt;/</code> 可以用来匹配类似 <code>&lt;div&gt;hello&lt;/div&gt;</code> 等 <code>html</code> 标签。</p><h2 id="捕获匹配的片段"><a href="#捕获匹配的片段" class="headerlink" title="捕获匹配的片段"></a>捕获匹配的片段</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><code>match</code> 方法是字符串方法，参数为正则表达式，未匹配返回 <code>null</code>，匹配结果返回数组，数组元素如下：</p><blockquote class="pullquote info"><ul><li><strong>索引 <code>0</code>：为匹配到的源字符串；</strong></li><li><strong>索引 <code>1</code> ~ <code>length - 3</code>：匹配到的分组对应的值；</strong></li><li><strong>索引 <code>length - 2</code>：匹配到分组起始单词所在源字符串中的索引位置；</strong></li><li><strong>索引 <code>length - 1</code>：源字符串。</strong></li></ul></blockquote><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>exec</code> 是正则表达式对象的实例方法，参数为字符串，匹配结果与 <code>match</code> 相似。</p><blockquote class="pullquote primary"><p><strong><code>match</code> 与 <code>exec</code> 的主要区别在于对正则表达式 <code>g</code> 修饰符的处理，全局模式下 <code>match</code> 可以匹配到全部内容，而 <code>exec</code> 分为多次调用才可以匹配出全部内容。</strong></p></blockquote><h3 id="被动子表达式"><a href="#被动子表达式" class="headerlink" title="被动子表达式"></a>被动子表达式</h3><p>在复杂并且存在分组嵌套的正则表达式中，我们希望有些分组不被捕获，可以通过在分组起始括号后加 <code>?:</code> 实现。</p><pre><code class="lang-js">const pattern = /((hello-)+)world/;
</code></pre><pre><code class="lang-js">/* 修改为 */
const pattern = /((?:hello-)+)world/;
</code></pre><h3 id="正则替换-replace"><a href="#正则替换-replace" class="headerlink" title="正则替换 replace"></a>正则替换 replace</h3><p>如果想对一个字符串中匹配出的某些匹配项进行替换可以使用 <code>replace</code>，第一个参数为正则表达式，第二个参数可以传入要替换的内容，会完全按照正则匹配的规则进行替换，如果第二个参数传入的是函数，则会在匹配时调用这个函数，并将函数的返回值作为该次匹配的替换值。</p><p>函数的参数与 <code>match</code> 方法类似，第一个参数为正则匹配的值，第二到倒数第三个参数为分组的匹配项等等，不同的是 <code>match</code> 成功匹配的结果为数组，而 <code>replace</code> 为传入参数的参数列表。</p><pre><code class="lang-js">/* 将短横线连接的单词转换成驼峰式 */
const word = &#39;border-bottom-width&#39;;

word.replace(/-(\w)/g, (match, group) =&gt; {
  return group.toUpperCase();
});

console.log(word); // borderBottomWidth
</code></pre><pre><code class="lang-js">/* 解析查询字符串 */
const parse = (query) =&gt; {
  const result = {};

  query.replace(/([^&amp;=]+)=([^&amp;]*)/g, (full, key, value) =&gt; {
    result[key] = value;
  });

  return result;
}

console.log(parse(&#39;a=1&amp;b=2&amp;c=3&#39;)); // {a: &quot;1&quot;, b: &quot;2&quot;, c: &quot;3&quot;}
</code></pre><h2 id="使用正则表达式解决常见问题"><a href="#使用正则表达式解决常见问题" class="headerlink" title="使用正则表达式解决常见问题"></a>使用正则表达式解决常见问题</h2><h3 id="匹配带换行的内容"><a href="#匹配带换行的内容" class="headerlink" title="匹配带换行的内容"></a>匹配带换行的内容</h3><p>我们经常希望匹配某一段字符串中包括换行的某段内容，比如要匹配爬虫爬到的 <code>html</code> 页面中某个标签中的全部内容。</p><blockquote class="pullquote warning"><p><strong>在正则的预定义字符集中的 <code>.</code> 可以匹配所有字符，但是不包括换行，可以用于匹配一行中满足条件的字符，如果匹配多行可以使用 <code>[\S\s]*</code> 或 <code>(:?.|\s)*</code> 来实现。</strong></p></blockquote><pre><code class="lang-js">/* 匹配 id 为 container 内的所有标签 */
const html = `
&lt;div id=&quot;container&quot;&gt;
  &lt;span&gt;Hello&lt;/span&gt;
  &lt;b&gt;world!&lt;/b&gt;
&lt;/div&gt;
`;

const reg = /&lt;div id=&quot;container&quot;&gt;([\S\s]*?)&lt;\/div&gt;/;
const content = html.match(reg)[1];

console.log(content);
// &lt;span&gt;Hello&lt;/span&gt;
// &lt;b&gt;world!&lt;/b&gt;
</code></pre><h3 id="匹配-Unicode-字符"><a href="#匹配-Unicode-字符" class="headerlink" title="匹配 Unicode 字符"></a>匹配 Unicode 字符</h3><p>有时匹配的字符不知要包含常见字符，还要包含特殊的符号等等，可以通过匹配 <code>Unicode</code> 编码来实现，因为 <code>Unicode</code> 编码所包含的范围更全。</p><pre><code class="lang-js">/* 匹配 CSS 属性选择器 */
const text = &quot;data-v-6fb581d0&quot;;

const reg = /[\w\u0080-\uFFFF_-]+/;

console.log(text.match(reg)[0]) // data-v-6fb581d0
</code></pre><h3 id="匹配转义字符"><a href="#匹配转义字符" class="headerlink" title="匹配转义字符"></a>匹配转义字符</h3><p>在有些时候需要匹配的字符串中可以匹配出反斜杠连接的单词，比如一个库的开发者实现 <code>CSS</code> 选择器引擎时，需要支持转译字符，这样用户可以在写 <code>CSS</code> 属性是使用 <code>.</code> 等转译字符。</p><pre><code class="lang-js">const tests = [
  &#39;formUpdate&#39;,
  &#39;form\\.update&#39;,
  &#39;form\\:update&#39;,
  &#39;\\f\\o\\r\\m\\u\\p\\d\\a\\t\\e&#39;
];

const pattern = /^((\w+)|(\\.))+$/;

for (let i = 0; i &lt; tests.length; i++) {
  console.log(tests[i].match(pattern)[0]);
}

// formUpdate
// \form\.update
// form\:update
// \f\o\r\m\u\p\d\a\t\e
</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>封装一个 cookie 功能</title>
    <url>/20170702182645/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/HTTP/20170702182645/cookie.png" title="cookie"><p><br></p><h2 id="cookie-概述"><a href="#cookie-概述" class="headerlink" title="cookie 概述"></a>cookie 概述</h2><blockquote class="pullquote info"><p><strong>由于浏览器无状态的特性，<code>cookie</code> 技术应运而生，<code>cookie</code> 是一个会话级的存储，用于某些网站为了辨别用户身份、进行 <code>session</code> 跟踪而储存在用户本地终端上的数据（通常经过加密），通过访问某些服务器而特定携带的存储信息，不支持跨域，在浏览器清空缓存或超过有效期后失效。</strong></p></blockquote><a id="more"></a><h2 id="JavaScript-中的-cookie"><a href="#JavaScript-中的-cookie" class="headerlink" title="JavaScript 中的 cookie"></a>JavaScript 中的 cookie</h2><p>在 JavaScript 中操作 <code>cookie</code> 通过 <code>document.cookie</code> 来实现：</p><pre><code class="lang-js">// 操作 cookie
document.cookie = &#39;key1=value1; key2=value2; path=/; domain=pandashen.com&#39;;
</code></pre><p>在传递 <code>cookie</code> 过程中，使用上面这样的方式对于参数的传递和拼接都是不太方便的，下面我们来封装一个自己的 <code>cookie</code> 功能。</p><h2 id="封装一个-cookie-模块"><a href="#封装一个-cookie-模块" class="headerlink" title="封装一个 cookie 模块"></a>封装一个 cookie 模块</h2><h3 id="整体思路设计"><a href="#整体思路设计" class="headerlink" title="整体思路设计"></a>整体思路设计</h3><pre><code class="lang-js">(function () {
  var kvTool = {
    maxage: &#39;max-age&#39;,
    path: &#39;path&#39;,
    domain: &#39;domain&#39;,
    secure: &#39;secure&#39;
  };

  function setCookie() {}

  function getCookie() {}

  var cookieUtil = function () {};

  window.cookieUtil = cookieUtil;
})();
</code></pre><p>我们封装了一个自执行函数，在内部将 <code>cookie</code> 基本参数的键名存入 <code>kvTool</code> 对象当中设计的 <code>options</code> 参数的键名一一对应，并单独声明一个设置 <code>cookie</code> 的方法 <code>setCookie</code> 和获取 <code>cookie</code> 的方法 <code>getCookie</code>，最后用函数表达式的形式声明一个 <code>cookieUtil</code> 暴露给全局作用域。</p><h3 id="setCookie-方法的实现"><a href="#setCookie-方法的实现" class="headerlink" title="setCookie 方法的实现"></a>setCookie 方法的实现</h3><pre><code class="lang-js">(function () {
  var kvTool = {
    maxage: &#39;max-age&#39;,
    path: &#39;path&#39;,
    domain: &#39;domain&#39;,
    secure: &#39;secure&#39;
  };

  function setCookie(k, v, options) {
    if (!options) {
      document.cookie = k + &#39;=&#39; + v;
    } else {
      var tmp = [];
      for (var key in options) {
        // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; }
        tmp.push(kvTool[key] + &#39;=&#39; + options[key]);
      }
      document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;);
    }
  }

  function getCookie() {}

  var cookieUtil = function () {};

  window.cookieUtil = cookieUtil;
})();
</code></pre><blockquote class="pullquote warning"><p><strong><code>setCookie</code> 方法的有三个参数：</strong></p><ul><li><strong><code>k</code>：<code>cookie</code> 发送信息的键</strong></li><li><strong><code>v</code>：<code>cookie</code> 发送信息的值</strong></li><li><strong><code>options</code>：<code>cookie</code> 的基本参数</strong></li></ul></blockquote><p>当没有传入基本参数 <code>options</code> 的时候直接将 <code>cookie</code> 发送信息的键值拼接赋值给 <code>document.cookie</code>。</p><p>传入基本参数 <code>options</code> 的时候取出 <code>kvTool</code> 真正的键名，并和 <code>cookie</code> 发送的信息的键值拼接成 <code>k=v; k=v</code> 形式的字符串赋值给 <code>document.cookie</code>。</p><h3 id="getCookie-方法的实现"><a href="#getCookie-方法的实现" class="headerlink" title="getCookie 方法的实现"></a>getCookie 方法的实现</h3><pre><code class="lang-js">(function () {
  var kvTool = {
    maxage: &#39;max-age&#39;,
    path: &#39;path&#39;,
    domain: &#39;domain&#39;,
    secure: &#39;secure&#39;
  };

  function setCookie(k, v, options) {
    if (!options) {
      document.cookie = k + &#39;=&#39; + v;
    } else {
      var tmp = [];
      for (var key in options) {
        // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; }
        tmp.push(kvTool[key] + &#39;=&#39; + options[key]);
      }
      document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;);
    }
  }

  function getCookie(k) {
    var strCookie = document.cookie;
    // 形如: &#39;k=v; k=v; k=v; k=v&#39;
    var kvs = strCookie.split(&#39;;&#39;).map(v =&gt; v.trim());
    var objCookie = {};

    kvs.forEach(v =&gt; {
      var kv = v.split(&#39;=&#39;);
      objCookie[kv[0]] = kv[1];
    });

    return objCookie[k];
  }

  var cookieUtil = function () {};

  window.cookieUtil = cookieUtil;
})();
</code></pre><p><code>getCookie</code> 方法只有一个参数，即我们要获取的 <code>cookie</code> 的某一个属性的键，函数会将对应的值返回。</p><p>其实对外暴露的方法只有 <code>cookieUtil</code>，所以 <code>setCookie</code> 和 <code>getCookie</code> 都是在 <code>cookieUtil</code> 内部调用的。</p><h3 id="cookieUtil-方法的实现"><a href="#cookieUtil-方法的实现" class="headerlink" title="cookieUtil 方法的实现"></a>cookieUtil 方法的实现</h3><pre><code class="lang-js">(function () {
  var kvTool = {
    maxage: &#39;max-age&#39;,
    path: &#39;path&#39;,
    domain: &#39;domain&#39;,
    secure: &#39;secure&#39;
  };

    function setCookie(k, v, options) {
      if (!options) {
        document.cookie = k + &#39;=&#39; + v;
      } else {
        var tmp = [];
        for (var key in options) {
          // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; }
          tmp.push(kvTool[key] + &#39;=&#39; + options[key]);
        }
        document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;);
      }
    }

    function getCookie(k) {
      var strCookie = document.cookie;
      // 形如: &#39;k=v; k=v; k=v; k=v&#39;
      var kvs = strCookie.split(&#39;;&#39;).map(v =&gt; v.trim());
      var objCookie = {};

      kvs.forEach(v =&gt; {
        var kv = v.split(&#39;=&#39;);
        objCookie[kv[0]] = kv[1];
      });

      return objCookie[k];
    }

    var cookieUtil = function (key, value, options) {
      if (!value) {
        // 没有传参, 得到数据
        return getCookie(key);
      } else {
        setCookie(key, value, options);
      }
    };

    window.cookieUtil = cookieUtil;
})();
</code></pre><p><code>cookieUtil</code> 的逻辑为当 <code>key</code> 和 <code>value</code> 两个参数都传入时，调用 <code>setCookie</code> 来设置 <code>cookie</code>，只传入 <code>key</code> 时，调用 <code>getCookie</code> 获取 <code>cookie</code> 对应参数的值。</p><blockquote class="pullquote success"><p><strong>上面就是我们封装的 <code>cookie</code> 功能模块来帮主我们设置和获取 <code>cookie</code>，之所以封装这个功能最终的目的就是让我们更方便的通过 <code>JavaScript</code> 来操作 <code>cookie</code>。</strong></p></blockquote>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTTP</tag>
        <tag>cookie/session</tag>
      </tags>
  </entry>
  <entry>
    <title>简单封装一个靠谱的检测数据类型模块</title>
    <url>/20170630162209/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170630162209/javascript-types.png" title="check javascript types"><p><br></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote class="pullquote warning"><p><strong>本篇主要对 JavaScript 数据类型检测做一些介绍，并封装一个相对靠谱的数据类型检测模块。</strong></p></blockquote><h2 id="常见检测数据类型的三种方式"><a href="#常见检测数据类型的三种方式" class="headerlink" title="常见检测数据类型的三种方式"></a>常见检测数据类型的三种方式</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 可以满足大部分基本数据类型的检测，如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code> 和 <code>symbol</code>，对于 <code>null</code> 使用 <code>typeof</code> 则会直接返回 <code>object</code>，对于引用类型的检测，只有 <code>function</code> 是可以正确返回的，其他都返回 <code>object</code>，可以看出 <code>typeof</code> 只适用于部分场景，并不是那么的靠谱。</p><a id="more"></a><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 本质是用来检测一个对象是不是一个构造函数的实例，因为基本数据类型是基本包装类，已经不是对象了，所以 <code>instanceof</code> 是用不适合检测基本数据类型，<code>instanceof</code> 也有一个缺点，用 <code>instanceof</code> 检测一个对象原型链上的其他原型对象对应的构造函数时，也返回 <code>true</code>，所以说 <code>instanceof</code> 也不能保证绝对的准确。</p><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h3><p><code>Object.prototype.toString.call</code> 在我们传入数据的时候，可以 <code>[object Object]</code> 的形式精准的返回给我们当前的数据类型，如 <code>[object Array]</code> 等等，我们本次要封装的类型检测工具就是基于这个方法。</p><h2 id="封装检测类型模块"><a href="#封装检测类型模块" class="headerlink" title="封装检测类型模块"></a>封装检测类型模块</h2><p>最终在全局会产生一个 <code>checkTypes</code> 的对象，上面对应着检测不同类型的方法，每个方法的参数都为被检测数据，返回值都为布尔值。</p><pre><code class="lang-js">/* 检测类型模块 */
(function () {
  // 存储检测数据类型方法的对象
  var checkTypesFun = {};

  // 涉及到的数据类型
  var types = [
    &#39;String&#39;,
    &#39;Number&#39;,
    &#39;Boolean&#39;,
    &#39;Undefined&#39;,
    &#39;Null&#39;,
    &#39;Symbol&#39;,
    &#39;Function&#39;,
    &#39;Array&#39;,
    &#39;Object&#39;,
    &#39;RegExp&#39;
  ];

  // 通过闭包返回检测单个类型的函数
  function isType(type) {
    return function (content) {
      var result = Object.prototype.toString.call(content);
      return type === result.replace(/\[object\s|\]/g, &#39;&#39;);
    };
  }

  types.forEach(function (type) {
    // 构建检测不同类型的方法，返回布尔值
    checkTypesFun[&#39;is&#39; + type] = isType(type);
  });

  // 将检测类型模块暴露在全局
  window.checkTypes = checkTypesFun;
})();
</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>上面代码是自执行函数，执行后会将 <code>checkTypes</code> 对象暴露在全局，可以直接使用。</p><pre><code class="lang-js">/* 使用模块 */
checkTypes.isString(&#39;123&#39;); // true
checkTypes.isNumber(&#39;123&#39;); // false
checkTypes.isArray([1, 2, 3]); // true
checkTypes.isRegExp(/^[0-9]$/); // true
checkTypes.isObject({}); // true
</code></pre><blockquote class="pullquote info"><p><strong>可以使用 <code>console.log(checkTypes)</code> 查看所有的方法。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型检测</tag>
      </tags>
  </entry>
  <entry>
    <title>前端优化 —— 函数的节流和防抖</title>
    <url>/20170612130942/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170612130942/throttle-vs-debounce.png" title="函数节流和防抖"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>在前端开发当中我们经常会绑定一些事件触发的某些程序执行，有时这些事件会连续触发，如浏览器窗口的 <code>scroll</code>、<code>resize</code>，输入框的 <code>keyup</code>、<code>input</code>，以及 <code>click</code> 事件在连续点击时连续发送请求等等，这些情况有些会严重影响前端性能，有些会增加服务器压力，使用户体验大打折扣，而函数节流和防抖就是为了解决这样的问题。</strong></p></blockquote><a id="more"></a><h2 id="函数节流-throtter"><a href="#函数节流-throtter" class="headerlink" title="函数节流 throtter"></a>函数节流 throtter</h2><blockquote class="pullquote info"><p><strong>函数节流：当持续发生事件时，保证在一个固定的时间间隔只执行一次真正的事件处理程序，通俗的说就像 “节流” 的名字一样，打开水龙头时要秉承勤俭节约的原则，把阀门关小，最好是达到在固定间隔内水一滴一滴的往下流。</strong></p></blockquote><h3 id="节流函数的时序图"><a href="#节流函数的时序图" class="headerlink" title="节流函数的时序图"></a>节流函数的时序图</h3><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170612130942/fun-throtter.png" alt="函数节流时序图"></div><div class="image-caption">函数节流时序图</div></figure><p><br></p><p>从图中可以看出，连续触发事件时，真正执行事件处理程序的间隔是固定的，多次触发，也只会在某一个时间间隔内触发一次，由于事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的节流函数。</p><h3 id="节流函数的封装"><a href="#节流函数的封装" class="headerlink" title="节流函数的封装"></a>节流函数的封装</h3><pre><code class="lang-js">/* 文件：throtter.js */
// 节流函数
const throtter = (func, delay = 60) =&gt; {
  // 锁的标识
  let lock = false;

  // 返回一个事件处理函数
  return (...args) =&gt; {
    // 如果 lock 为 true 则跳出
    if (lock) return;

    // 执行函数并更改锁的状态
    func(...args);
    lock = true;

    // 添加定时器，在到达时间间隔时重置锁的状态
    setTimeout(() =&gt; lock = false, delay);
  }
}
</code></pre><p><code>throtter</code> 函数有两个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为定义的间隔时间，在函数执行时定义了 <code>lock</code> 的初始值，通过闭包返回一个函数作为事件处理函数，在返回的函数内部判断 <code>lock</code> 状态并确定执行真正的函数 <code>func</code> 还是跳出，每次执行 <code>func</code> 后会更改 <code>lock</code> 状态，通过定时器在规定的时间间隔内重置 <code>lock</code>，这就是函数节流的原理。</p><h3 id="验证节流函数"><a href="#验证节流函数" class="headerlink" title="验证节流函数"></a>验证节流函数</h3><pre><code class="lang-js">/* 文件：throtter-test.js */
// 使用节流函数
document.addEventListener(&#39;scroll&#39;, throtter(console.log));
</code></pre><p>上面我们给 <code>document</code> 对象添加了滚动事件，并不断的打印事件对象，事件处理函数的默认参数为事件对象，从执行效果应该可以看出，平均每 <code>60ms</code> 才会触发一次事件，达到了优化性能的目的，如果想让真正执行的函数 <code>func</code> 传入更多的参数，只需如下处理。</p><pre><code class="lang-js">/* 文件：throtter-test.js */
// a b 为函数要传入的参数
const a = 1, b = 2;

// 返回事件处理函数
const func = throtter(console.log);

// 添加事件监听
document.addEventListener(&#39;scroll&#39;, e =&gt; func(e, a, b));
</code></pre><blockquote class="pullquote warning"><p><strong>节流函数一般用于 <code>scroll</code>、<code>resize</code> 事件的情况较多，因为这些事件的触发是连续性的，需要在一个时间间隔内只触发一次。</strong></p></blockquote><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 debounce"></a>函数防抖 debounce</h2><blockquote class="pullquote primary"><p><strong>函数防抖：当持续发生事件时，事件只在上一次触发后的一段时间内没再触发事件，才会真正的执行事件处理逻辑，如果每两次触发的间隔小于这个时间，则不执行事件逻辑。</strong></p></blockquote><h3 id="防抖函数的时序图"><a href="#防抖函数的时序图" class="headerlink" title="防抖函数的时序图"></a>防抖函数的时序图</h3><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170612130942/fun-debounce.png" alt="函数防抖时序图"></div><div class="image-caption">函数防抖时序图</div></figure><p><br></p><p>从图中可以看出，连续触发事件时并没有执行事件处理函数，只有在某一阶段连续触发后的最后一次才执行，也就是上一次触发的时间间隔要大于设定值才执行，同样的，事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的防抖函数。</p><h3 id="防抖函数的封装"><a href="#防抖函数的封装" class="headerlink" title="防抖函数的封装"></a>防抖函数的封装</h3><pre><code class="lang-js">/* 文件：debounce.js */
// 防抖函数
const dobounce = (func, delay = 300, timer = null) =&gt; {
  return (...args) =&gt; {
    // 清除定时器
    clearInterval(timer);

    // 在定时器到时后执行事件处理函数
    timer = setTimeout(() =&gt; func(...args), delay);
  }
}
</code></pre><p><code>dobounce</code> 函数有三个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为执行事件的延迟时间，第三个参数为定时器 <code>ID</code> 的初始值，执行 <code>dobounce</code> 通过闭包返回了事件处理函数，在处理函数内部先清除定时器，然后定义定时器并将 <code>ID</code> 赋值给 <code>timer</code>，如果事件连续触发，则会不断的清除定时器，直到有一次触发间隔超过了设定延时时间 <code>delay</code>，才会真正执行 <code>func</code>。</p><h3 id="验证防抖函数"><a href="#验证防抖函数" class="headerlink" title="验证防抖函数"></a>验证防抖函数</h3><pre><code class="lang-html">&lt;!-- 文件：index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;函数防抖&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="lang-js">/* 文件：debounce-test.js */
// 使用防抖函数
const ipt = document.querySelector(&#39;#ipt&#39;);

// 添加事件监听
ipt.addEventListener(&#39;keyup&#39;, debounce(console.log));
</code></pre><p>上面的功能跟 <code>throtter</code> 类似，真正执行事件处理函数时打印事件对象，通过验证，连续输入触发 <code>keyup</code> 事件，上一次触发和下一次触发间隔时间必须大于 <code>300ms</code> 才会执行打印事件对象的逻辑，如果想传入多个参数套路相同。</p><pre><code class="lang-js">/* 文件：debounce-test.js */
// 获取 dom 元素
const ipt = document.querySelector(&#39;#ipt&#39;);

// a b 为函数要传入的参数
const a = 1, b = 2;

// 返回事件处理函数
const func = debounce(console.log);

// 添加事件监听
ipt.addEventListener(&#39;keyup&#39;, e =&gt; func(e, a, b));
</code></pre><blockquote class="pullquote default"><p><strong>防抖函数一般用于输入框事件，常用场景就是搜索或查询，如果不使用防抖会连续发送请求，增加服务器的压力，使用防抖后，会在用户输入要查询的关键词后才发送请求，这也更符合用户的习惯，例如百度搜索，就是这样实现的。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“节流” 和 “防抖” 是前端在项目中经常使用的优化手段，代码虽然不多，但是确是前端面试 “出镜率” 非常高的知识点，从而能看出它们的重要性，所以建议前端同学们一定要知道，并能手写，这是 “一箭双雕” 的事，可以用来通过面试，也可以因为工作中遇到直接就写而提高工作效率。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础 —— call、apply 和 bind 的原理</title>
    <url>/20170524162030/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170524162030/call-apply-bind.jpg" title="call、apply 和 bind 的原理"><p><br></p><h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p><code>call</code> 和 <code>apply</code> 是 <code>Function</code> 构造函数原型对象上的方法，所有的函数都可以调用 <code>call</code> 和 <code>apply</code>，作用是可以改变调用 <code>call</code> 和 <code>apply</code> 函数内部的 <code>this</code> 指向，并执行函数。</p><h3 id="call-的使用方法"><a href="#call-的使用方法" class="headerlink" title="call 的使用方法"></a>call 的使用方法</h3><pre><code class="lang-js">/* 不指定 this */
function fn() {
  console.log(this, arguments);
}

fn.call();

// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]
</code></pre><p>不指定替换的 <code>this</code>，则调用 <code>call</code> 的函数在运行时决定 <code>this</code> 指向，当前案例中在浏览器中运行，则指向 <code>window</code> 对象。</p><pre><code class="lang-js">/* 一次调用 call */
function fn() {
  console.log(this, arguments);
}

fn.call(&#39;hello&#39;, &#39;1&#39;, &#39;2&#39;);

// String { &quot;hello&quot; }
// Arguments(2) [&quot;1&quot;, &quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ]
</code></pre><p>在上面案例中，<code>call</code> 将 <code>fn</code> 内部的 <code>this</code> 更改为 <code>hello</code> 的基本包装类（对象），而 <code>1</code> 和 <code>2</code> 作为 <code>fn</code> 的参数，以 <code>arguments</code> 的形式被打印出来。</p><pre><code class="lang-js">/* 多次调用 call */
function fn1() {
  console.log(this, arguments);
}

function fn2() {
  console.log(this, arguments);
}

fn1.call.call(fn2, &#39;1&#39;, &#39;2&#39;);

// String { &quot;1&quot; }
// Arguments [&quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ]
</code></pre><p>由于 <code>call</code> 是函数原型的方法，当然也可以被 <code>call</code> 自己调用，在上面的案例中，第一个 <code>call</code> 内部的 <code>this</code> 为调用者 <code>fn1</code>，通过第二个 <code>call</code> 将第一个 <code>call</code> 内部的 <code>this</code> 由 <code>fn1</code> 更改为 <code>fn2</code>，<code>1</code> 和 <code>2</code> 作为参数传递给第一个 <code>call</code>，而 <code>1</code> 又作为第一个 <code>call</code> 内部 <code>this</code> 指向的 <code>fn2</code> 内部的 <code>this</code>，<code>2</code> 作为 <code>fn2</code> 的参数，最后执行 <code>fn2</code>，固有上面执行结果。</p><h3 id="call-的实现原理"><a href="#call-的实现原理" class="headerlink" title="call 的实现原理"></a>call 的实现原理</h3><p>根据 <code>call</code> 方法的特点，来模拟实现一个自己封装的 <code>call</code> 方法，代码如下。</p><pre><code class="lang-js">/* call 的实现原理 */
// context 参数为要替换的 this
Function.prototype.call = function (context) {
  // 将传入的 this 转换成对象，若没传则使用 window 作为 this
  context = context ? Object(context) : window;

  // 将调用 call 的函数作为属性赋值给传入的 this
  context.fn = this;

  var args = [];

  // 将传递给调用 call 函数的参数转化成字符串取值的形式
  for (var i = 1; i &lt; arguments.length; i++) {
    // args [&#39;arguments[1]&#39;, &#39;arguments[2]&#39;]
    args.push(&#39;arguments[&#39; + i + &#39;]&#39;);
  }

  // 利用 eval 执行 context.fn，并利用数组转换字符串的 toString 去掉 [ ]
  var result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;);

  // 删除 context 上多余的 fn 属性
  delete context.fn;

  return result;
}
</code></pre><blockquote class="pullquote info"><p><strong>上面的实现方式重点解决两个问题：</strong></p><ul><li><strong>如何让调用 <code>call</code> 函数内部的 <code>this</code> 指向传入的 <code>this</code>，我们通过将传入 <code>this</code> 上加一个属性 <code>fn</code>，值为调用 <code>call</code> 的函数，在执行函数时并不直接调用 <code>this</code>，而是执行 <code>context.fn</code>，这样内部的 <code>this</code> 指向了调用者 <code>context</code>，即指向了传入要替换的 <code>this</code>；</strong></li><li><strong>如何将 <code>call</code> 调用时除第一个参数以外的参数列表作为调用 <code>call</code> 函数的参数依次传入，我们这里借用了 <code>eval</code> 提供执行环境，将要执行的代码拼接成字符串，这样就可以容易的将 <code>argument</code> 第二项后面的所有项通过循环的方式拼接。</strong></li></ul></blockquote><blockquote class="pullquote danger"><p><strong>给 <code>context</code> 添加的多余属性 <code>fn</code>，要在函数 <code>context.fn</code> 执行后删除。</strong></p></blockquote><h3 id="apply-的使用方法"><a href="#apply-的使用方法" class="headerlink" title="apply 的使用方法"></a>apply 的使用方法</h3><p><code>apply</code> 与 <code>call</code> 的作用相同，基本用法如下。</p><pre><code class="lang-js">/* apply 用法 */
function fn() {
  console.log(this, arguments);
}

fn.apply(&#39;hello&#39;, [&#39;1&#39;, &#39;2&#39;]);

// String { &quot;hello&quot; }
// Arguments(2) [&quot;1&quot;, &quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ]
</code></pre><h3 id="apply-的实现原理"><a href="#apply-的实现原理" class="headerlink" title="apply 的实现原理"></a>apply 的实现原理</h3><p>通过用法可以看出 <code>apply</code> 与 <code>call</code> 唯一不同的就是传参方式，<code>call</code> 传递给调用它的函数传参靠调用时使用参数列表的方式依次传入，而 <code>apply</code> 是通过数组的方式传入，只需要将 <code>call</code> 的代码稍加改造就可以实现 <code>apply</code>。</p><pre><code class="lang-js">/* apply 的实现原理 */
// context 参数为要替换的 this，args 为调用 apply 函数执行的参数
Function.prototype.apply = function (context, args) {
  context = context ? Object(context) : window;
  context.fn = this;
  var result;

  // 判断是否传入参数列表，如果没传则直接执行
  if (!args) {
    result = context.fn();
  } else {
    result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;);
  }

  delete context.fn;

  return result;
}
</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="bind-的使用方法"><a href="#bind-的使用方法" class="headerlink" title="bind 的使用方法"></a>bind 的使用方法</h3><p><code>bind</code> 函数是 <code>Function</code> 原型对象上的方法，<code>bind</code> 的作用是可以将调用它的函数内部的 <code>this</code> 绑定成所指定的 <code>this</code>，第一个参数为指定的 <code>this</code>，与 <code>call</code> 和 <code>apply</code> 不同的是，调用 <code>bind</code> 的函数并不会执行，而是返回一个新的函数，新的函数调用时传入的参数会和 <code>bind</code> 调用时传入的除第一个以外的参数进行合并，并作为调用 <code>bind</code> 的函数执行的参数，下面是 <code>bind</code> 的基本用法。</p><pre><code class="lang-js">/* 返回的函数当做普通函数调用 */
var obj = {
  name: &#39;Shen&#39;
};

function sayName() {
  console.log(this.name);
}

var bindFn = sayName.bind(obj);
bindFn();
// Shen
</code></pre><pre><code class="lang-js">/* 调用 bind 和执行返回函数分开传参 */
var obj = {
  name: &#39;Shen&#39;
};

function animal(name, age) {
  console.log(this.name + &#39; have a &#39; + name + &#39; is &#39; + age + &#39; years old.&#39;);
}

var bindFn = animal.bind(null, &#39;cat&#39;);
bindFn(2);
// Shen have a cat is 2 years old.
</code></pre><pre><code class="lang-js">/* 返回的函数当做构造函数执行 */
var obj = {
  name: &#39;Shen&#39;
};

function Animal(name, age) {
  this.name = name;
  this.age = age;
}

// 动物类别为哺乳类
Animal.prototype.category = &#39;mammalia&#39;;

var BindFn = Animal.bind(obj, &#39;cat&#39;);
var cat = new BindFn(2);

console.log(cat); // Animal {name: &quot;cat&quot;, age: 2}
console.log(cat.category); // mammalia
</code></pre><h3 id="bind-的原理"><a href="#bind-的原理" class="headerlink" title="bind 的原理"></a>bind 的原理</h3><p>从上面的例子已经可以看出 <code>bind</code> 不但能绑定 <code>this</code>，收集参数，返回的函数既可以直接调用，又可以作为构造函数实例化对象，而实例化的对象的方式，<code>bind</code> 绑定的 <code>this</code> 不生效，<code>this</code> 指向被创建的实例，实例依然可以找到原来函数原型上的属性和方法，根据 <code>bind</code> 的特性，模拟实现的代码如下。</p><pre><code class="lang-js">/* bind 的实现原理 */
// context 参数为要绑定的 this
Function.prototype.bind = function (context) {
  // this 为调用 bind 的函数
  var self = this;

  // 收集除了 context 以外所有的参数
  var bindArgs = Array.prototype.slice.call(arguments, 1);

  // 返回的新函数 fBound
  function fBound() {
    // 收集 fBound 的参数
    var args = Array.prototype.slice.call(arguments);

    // 执行调用 bind 的函数
    // 若是普通函数调用，this 为 context，若是作为构造函数则 this 为实例
    self.apply(this instanceof fBound ? this : context, bindArgs.concat(args));
  }

  // 用来继承的中间函数
  function fNOP() {}

  // 作为构造函数调用 fBound 时，为了实例可以找到调用 bind 函数的原型对象，进行继承
  if (this.prototype) {
    // Function.prototype 为函数，可以调用 bind，当时没有原型对象，所以要判断
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
  }

  return fBound;
}
</code></pre><blockquote class="pullquote warning"><p><strong>在上面代码中，如果调用 <code>bind</code> 返回函数作为构造函数使用，则需要通过继承找回原函数的属性和方法，但是有一个特例，就是 <code>Function.prototype</code>，类型为函数，却没有 <code>prototype</code> 属性，所以需要判断。</strong></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p><strong>上面就是 <code>call</code>、<code>apply</code> 和 <code>bind</code> 的基本用法、实现原理以及区别，希望读者可以通过这篇文章加深对 <code>call</code>、<code>apply</code> 和 <code>bind</code> 的印象，运用自如。</strong></p></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础 —— new 的实现原理</title>
    <url>/20170522115959/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20170522115959/new.jpg" title="的实现原理"><p><br></p><h2 id="构造函数和实例化"><a href="#构造函数和实例化" class="headerlink" title="构造函数和实例化"></a>构造函数和实例化</h2><p>在 <code>JavaScript</code> 可以通过构造函数批量创建对象，这个创建的过程通过 <code>new</code> 关键字实现，也被称作实例化，对象被创建时会有默认的属性和原型方法。</p><pre><code class="lang-js">function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHi = function () {
  var output = &quot;My name is &quot; + this.name + &quot;, I&#39;m &quot; + this.age + &quot; years old.&quot;
  console.log(output);
}

var panda = new Person(&#39;panda&#39;, 25);

panda.sayHi(); // My name is panda, I&#39;m 25 years old.
</code></pre><h2 id="new-的过程都做了什么"><a href="#new-的过程都做了什么" class="headerlink" title="new 的过程都做了什么"></a>new 的过程都做了什么</h2><blockquote class="pullquote success"><p><strong>在 <code>new</code> 的过程中主要做了 <code>4</code> 件事：</strong></p><ul><li><strong>创建一个空对象；</strong></li><li><strong>将这个空对象的原型指向构造函数的原型；</strong></li><li><strong>执行构造函数，并将默认属性挂载到这个空对象上；</strong></li><li><strong>判断构造函数的返回值，如果是对象则返回这个对象，否则返回新创建的对象。</strong></li></ul></blockquote><h2 id="模拟-new-关键字"><a href="#模拟-new-关键字" class="headerlink" title="模拟 new 关键字"></a>模拟 new 关键字</h2><p>清楚了构造函数实例化的过程，我们就来手动实现一个 <code>New</code> 函数，来替代关键字 <code>new</code>。</p><pre><code class="lang-js">// New 函数的第一个参数为构造函数，剩余的参数为实例化传入的参数
function New() {
  var Constructor = Array.prototype.shift.call(arguments);
  var obj = {};
  obj.__proto__ = Constructor.prototype;
  var result = Constructor.apply(obj, arguments);
  return result instanceof Object ? result : obj;
}
</code></pre><pre><code class="lang-js">// 使用 New 创建实例
var panda = New(Person, &#39;panda&#39;, 25);

console.log(panda); // Person {name: &quot;panda&quot;, age: 25}
panda.sayHi(); // My name is panda, I&#39;m 25 years old.
</code></pre><p>上面的方法已经实现了 <code>new</code> 关键字的功能，但是美中不足的是，不能将构造函数和实例化的参数区分清晰，下面稍微优化一下。</p><pre><code class="lang-js">/* 优化后 */
function New(Constructor) {
  return function () {
    var obj = {};
    obj.__proto__ = Constructor.prototype;
    var result = Constructor.apply(obj, arguments);
    return result instanceof Object ? result : obj;
  }
}
</code></pre><pre><code class="lang-js">/* 使用 New 创建实例 */
var panda = New(Person)(&#39;panda&#39;, 25);

console.log(panda); // Person {name: &quot;panda&quot;, age: 25}
panda.sayHi(); // My name is panda, I&#39;m 25 years old.
</code></pre><p>与第一种相比只是 <code>New</code> 函数的使用方式有所变化，<code>New</code> 执行后返回一个函数，调用这个返回的函数，才会进行实例化，传入的参数为实例化对象的参数，这样是 <code>New</code> 的功能变的单一，也将构造函数与实例化的参数分开。</p>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 中 Markdown 特殊字符的处理方法</title>
    <url>/20170519135903/</url>
    <content><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/BlogBuild/20170519135903/hexo-markdown.png" title="markdown questions in hexo"><p><br></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote class="pullquote default"><p><strong>在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 <code>-</code>、<code>.</code>、空格、制表符等等，在正常情况下可以使用 <code>\</code> 进行转译，但是有一些字符无法转译，使用后在执行 <code>hexo server</code> 命令的时候会报错。</strong></p></blockquote><p><strong>报错信息：</strong></p><pre><code class="lang-bash">Unhandled rejection Template render error: (unknown path) [Line 7, Column 23]
  Error: Unable to call `worldcount`, which is undefined or falsey......
</code></pre><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>报错的原因是，Hexo 编译时发生错误，可能是文章中存在特殊字符，如：&#123; &#91; &#40; &#41; &#93; &#125; 等等。如下面这段代码：</p><p><strong>在页面中：</strong></p><pre><code class="lang-ejs">&lt;%= worldcount(post.content) %&gt;
</code></pre><p><strong>在 Markdown 中：</strong></p><pre><code class="lang-md">&amp;#123;&amp;#123; worldcount&amp;#40;post.content&amp;#41; &amp;#125;&amp;#125;
</code></pre><p>在 Markdown 中使用 <code>\</code> 无法转译的字符需要使用字符的命名实体或十进制编码，如上面代码中。</p><blockquote class="pullquote warning"><p><em><strong>注意：需要转义的字符只是文本中的特殊字符，代码块中的特殊字符无需转译或使用转译字符。</strong></em></p></blockquote><h2 id="常见特殊字符"><a href="#常见特殊字符" class="headerlink" title="常见特殊字符"></a>常见特殊字符</h2><p><strong>常用特殊字符转译字符对照表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">空格</td><td style="text-align:center">&#38;&#110;&#98;&#115;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">全角空格</td><td style="text-align:center">&#38;&#101;&#109;&#115;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#50;&#56;&#56;&#59;</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">&#38;&#97;&#112;&#111;&#115;&#59;</td><td style="text-align:center">&#38;&#35;&#51;&#57;&#59;</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">&#38;&#113;&#117;&#111;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">(</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#52;&#48;&#59;</td></tr><tr><td style="text-align:center">)</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#52;&#49;&#59;</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">&#38;&#108;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">&#38;&#103;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#54;&#50;&#59;</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#57;&#49;&#59;</td></tr><tr><td style="text-align:center">]</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#59;</td></tr><tr><td style="text-align:center">{</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#51;&#59;</td></tr><tr><td style="text-align:center">}</td><td style="text-align:center">—</td><td style="text-align:center">&#38;&#35;&#49;&#50;&#53;&#59;</td></tr><tr><td style="text-align:center">´</td><td style="text-align:center">&#38;&#97;&#99;&#117;&#116;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#56;&#48;&#59;</td></tr><tr><td style="text-align:center">°</td><td style="text-align:center">&#38;&#100;&#101;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#54;&#59;</td></tr><tr><td style="text-align:center">®</td><td style="text-align:center">&#38;&#114;&#101;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#52;&#59;</td></tr><tr><td style="text-align:center">©</td><td style="text-align:center">&#38;&#99;&#111;&#112;&#121;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#54;&#57;&#59;</td></tr></tbody></table></div><p><strong>常用数学转译字符对照表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">≤</td><td style="text-align:center">&#38;&#108;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#52;&#59;</td></tr><tr><td style="text-align:center">≥</td><td style="text-align:center">&#38;&#103;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#53;&#59;</td></tr><tr><td style="text-align:center">≈</td><td style="text-align:center">&#38;&#97;&#115;&#121;&#109;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#55;&#51;&#59;</td></tr><tr><td style="text-align:center">≠</td><td style="text-align:center">&#38;&#110;&#101;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#56;&#48;&#48;&#59;</td></tr><tr><td style="text-align:center">∩</td><td style="text-align:center">&#38;&#99;&#97;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#53;&#59;</td></tr><tr><td style="text-align:center">∪</td><td style="text-align:center">&#38;&#99;&#117;&#112;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#54;&#59;</td></tr><tr><td style="text-align:center">∠</td><td style="text-align:center">&#38;&#97;&#110;&#103;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#54;&#59;</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">&#38;&#105;&#110;&#102;&#105;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">±</td><td style="text-align:center">&#38;&#112;&#108;&#117;&#115;&#109;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#49;&#55;&#55;&#59;</td></tr><tr><td style="text-align:center">√</td><td style="text-align:center">&#38;&#114;&#97;&#100;&#105;&#99;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#51;&#48;&#59;</td></tr><tr><td style="text-align:center">∑</td><td style="text-align:center">&#38;&#115;&#117;&#109;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#50;&#50;&#59;</td></tr><tr><td style="text-align:center">∫</td><td style="text-align:center">&#38;&#105;&#110;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#52;&#55;&#59;</td></tr><tr><td style="text-align:center">Δ</td><td style="text-align:center">&#38;&#68;&#101;&#108;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#49;&#54;&#59;</td></tr></tbody></table></div><p><strong>常用希腊字母转译字符对照表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">命名实体</th><th style="text-align:center">十进制编码</th></tr></thead><tbody><tr><td style="text-align:center">Φ</td><td style="text-align:center">&#38;&#80;&#104;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#52;&#59;</td></tr><tr><td style="text-align:center">Ω</td><td style="text-align:center">&#38;&#79;&#109;&#101;&#103;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#51;&#55;&#59;</td></tr><tr><td style="text-align:center">α</td><td style="text-align:center">&#38;&#97;&#108;&#112;&#104;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#53;&#59;</td></tr><tr><td style="text-align:center">β</td><td style="text-align:center">&#38;&#98;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#54;&#59;</td></tr><tr><td style="text-align:center">γ</td><td style="text-align:center">&#38;&#103;&#97;&#109;&#109;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#55;&#59;</td></tr><tr><td style="text-align:center">δ</td><td style="text-align:center">&#38;&#100;&#101;&#108;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#56;&#59;</td></tr><tr><td style="text-align:center">ε</td><td style="text-align:center">&#38;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#52;&#57;&#59;</td></tr><tr><td style="text-align:center">ζ</td><td style="text-align:center">&#38;&#122;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#48;&#59;</td></tr><tr><td style="text-align:center">η</td><td style="text-align:center">&#38;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#49;&#59;</td></tr><tr><td style="text-align:center">θ</td><td style="text-align:center">&#38;&#116;&#104;&#101;&#116;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#50;&#59;</td></tr><tr><td style="text-align:center">λ</td><td style="text-align:center">&#38;&#108;&#97;&#109;&#98;&#100;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#53;&#59;</td></tr><tr><td style="text-align:center">μ</td><td style="text-align:center">&#38;&#109;&#117;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#54;&#59;</td></tr><tr><td style="text-align:center">ξ</td><td style="text-align:center">&#38;&#120;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#53;&#56;&#59;</td></tr><tr><td style="text-align:center">π</td><td style="text-align:center">&#38;&#112;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#48;&#59;</td></tr><tr><td style="text-align:center">ρ</td><td style="text-align:center">&#38;&#114;&#104;&#111;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#49;&#59;</td></tr><tr><td style="text-align:center">σ</td><td style="text-align:center">&#38;&#115;&#105;&#103;&#109;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#51;&#59;</td></tr><tr><td style="text-align:center">φ</td><td style="text-align:center">&#38;&#112;&#104;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#54;&#59;</td></tr><tr><td style="text-align:center">ψ</td><td style="text-align:center">&#38;&#112;&#115;&#105;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#56;&#59;</td></tr><tr><td style="text-align:center">ω</td><td style="text-align:center">&#38;&#111;&#109;&#101;&#103;&#97;&#59;</td><td style="text-align:center">&#38;&#35;&#57;&#54;&#57;&#59;</td></tr><tr><td style="text-align:center">∂</td><td style="text-align:center">&#38;&#112;&#97;&#114;&#116;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#48;&#54;&#59;</td></tr><tr><td style="text-align:center">∅</td><td style="text-align:center">&#38;&#101;&#109;&#112;&#116;&#121;&#59;</td><td style="text-align:center">&#38;&#35;&#56;&#55;&#48;&#57;&#59;</td></tr></tbody></table></div>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
