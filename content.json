[{"title":"React 基础篇 —— React Hooks","date":"2019-05-07T07:54:11.000Z","path":"20190507155411/","text":"React Hooks 简介React Hooks 是 16.8 版本中正式加入的特性，配合函数组件使用，在没有 Hooks 之前，函数组件使用场景非常有限，只适合编写纯展示性的 UI 组件，其余复杂的场景不得不使用类组件，而 Hooks 的主要作用是在函数组件中使用原本所不具备的 React 特性。React Hooks 产生的动机在业务开发中，数据主要存在两种形式，业务数据和 UI 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（Redux、Mobx 等），会增加开发者的学习成本和项目的维护成本。使用 React 的开发者都知道，React 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染，为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件（HOC）、属性渲染（Render props）、渲染回调（Prop callback）等更高级的 React 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 DOM 的层级。上面这些实际问题促成了 React Hooks 的诞生，而在有 Hooks 后官方也越来越推荐使用函数组件。推荐使用函数组件主要原因总结如下：为了状态相关逻辑的提取和复用；解决复杂组件代码变得难以理解的问题；解决类组件带给开发者一些容易混淆的点，比如 this 指向问题；由于 JS 解释器在解释 class 关键字时的性能问题，使用函数组件代替。React 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 Hooks。React Hooks 分类React 官方主要给 Hooks 分为两大类：基础 Hooks API：useState、useEffect、useContext；其他 Hooks API：useReducer、useCallback、useImperativeHandle、useMemo、useRef、useLayoutEffect、useDebugValue。React Hooks 使用规则为了保证 Hooks 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（强制遵守），在此提前声明。只在函数组件内部最顶层调用 Hook，不要在循环、条件判断或者嵌套函数中调用；只能在函数组件中调用 Hook（自定义 Hook 中可以调用 Hook），不要在其他 JavaScript 函数中调用。React Hooks APIuseStateuseState 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 state 一样的作用。/* 类组件实现的计数器 */ import React, { Components } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Components { constructor() { super(); this.state = { count: 0 }; } handleClick = () =&gt; { this.setState({ count: this.state.count + 1 }) } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={this.handleClick}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, root); 上面是一个类组件实现的计数器，当前计数器的值在类组件的 state 中进行管理。/* Hooks 实现的计数器 */ import React, { useState } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Counter() { const [ count, setCount ] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;Counter /&gt;, root); 使用 React Hooks 的 useState 实现的计数器和类组件实现的功能完全相同，从 useState 实现的代码可以看出 useState 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。/* 实现每次加 2 的计数器 */ import React, { useState } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Counter() { const [ count, setCount ] = useState(0); const countAction = (preCount, n) =&gt; preCount + n; return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(countAction(count, 2))}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;Counter /&gt;, root); 上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 useState 进行重构。/* 类组件实现的模态切换功能 */ import React, { Component, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import { Button, Modal } from &#39;antd&#39;; import &#39;antd/dist/antd.css&#39;; // Toggle 组件专门提供切换状态和切换方法 class Toggle extends Component { constructor(props) { super(props); // 初始化 on 的值 this.state.on = this.props.initial; } state = { on: false } toggle = () =&gt; { this.setState({ on: !this.state.on }); } render() { return this.props.children(this.state.on, this.toggle); } } function App() { return ( &lt;Toggle initial={false}&gt; { (on, toggle) =&gt; ( &lt;Fragment&gt; &lt;Button type=&quot;primary&quot; onClick={toggle}&gt; Open Model &lt;/Button&gt; &lt;Modal visible={on} onCancel={toggle} /&gt; &lt;/Fragment&gt; ) } &lt;/Toggle&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面代码中的类组件 Toggle 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 children 并传入一个函数，目的是函数可以在类组件内部通过 children 属性调用，并将 Toggle 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 useState 进行重构。/* useState 重构切换模态的功能 */ import React, { useState, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import { Button, Modal } from &#39;antd&#39;; import &#39;antd/dist/antd.css&#39;; function App() { const [ on, setOn ] = useState(false); return ( &lt;Fragment&gt; &lt;Button type=&quot;primary&quot; onClick={() =&gt; setOn(true)}&gt; Open Model &lt;/Button&gt; &lt;Modal visible={on} onCancel={() =&gt; setOn(false)}/&gt; &lt;/Fragment&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 因为 React Hooks 的 useState 让函数组件具备了管理组件状态的能力，所以不需要单独实现 Toggle 组件，代码变得更精简、清晰，更函数式编程，更新的粒度更细。useState 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。/* 当 useState 更新的状态依赖于上一次的值 */ import React, { useState } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Counter() { const [ count, setCount ] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;Counter /&gt;, root); useEffect正如 useEffect 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。import React, { useState, useEffect } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function App() { const [ count, setCount ] = useState(0); // 每次渲染后执行 useEffect(() =&gt; { document.title = `You clicked ${count} times`; }); // 初次渲染后执行 useEffect(() =&gt; { console.log(&#39;Execute once&#39;); }, []); // 当 count 更改时才执行 useEffect(() =&gt; { console.log(&#39;count changed&#39;); }, [ count ]); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click! &lt;/button&gt; &lt;button onClick={() =&gt; setCount(count)}&gt; Click no change! &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面案例是通过 useState 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 useEffect 实现，useEffect 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。可以使用 useEffect 替代类组件的生命周期 componentDidMount、componentDidUpdate 和 componentWillUnmount。useEffect 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 useState 监听），此时 useEffect 内部会做一次比较，数组中变量的值没发生变化时，传入对应 useEffect 的回调不会执行，当传入 useEffect 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的生命周期 componentDidMount。import React, { useState, useEffect, Component, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 使用 Hooks 的函数组件 function HooksCom() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { document.title = `You clicked ${count} times (hooks)`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } // 类组件 class ClassCom extends Component { constructor(props) { super(props); this.state = { count: 1 }; } componentDidMount() { document.title = `You clicked ${this.state.count} times (class)`; } componentDidUpdate() { document.title = `You clicked ${this.state.count} times (class)`; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click! &lt;/button&gt; &lt;/div&gt; ) } } function App() { return ( &lt;Fragment&gt; &lt;HooksCom /&gt; &lt;ClassCom /&gt; &lt;/Fragment&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 通过上面案例，对于使用了 componentDidMount 生命周期的类组件和使用了 useEffect 的函数组件对于页面标题更改的对比，useEffect 的执行会晚于 componentDidMount。import React, { useState, useEffect, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const ChatAPI = { handle: null, isOnline: false, login() { this.isOnline = true; this.handle &amp;&amp; this.handle({ isOnline: true }); }, logout() { this.isOnline = false; this.handle &amp;&amp; this.handle({ isOnline: false }); }, subscribeToFriendStatus(id, handle) { console.log(`订阅好友：${id}`); this.handle = handle; }, unsubscribeToFriendStatus(id, handle) { console.log(`清理好友：${id}`); this.handle = null; } }; // 用于渲染好友在线状态的函数组件 function FriendStatus(props) { // 控制好友在线的变量和方法 const [ isOnline, setIsOnline ] = useState(null); // 设置好友状态的函数 const handleStatusChange = (status) =&gt; setIsOnline(status.isOnline); useEffect(() =&gt; { // 订阅好友状态 ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { // 清除好友状态 ChatAPI.unsubscribeToFriendStatus(props.friend.id); } }, [ props.friend.id ]); if (isOnline === null) { return &#39;Loading...&#39; } return ( &lt;div&gt; &lt;span&gt;计数器：{props.friend.count}&lt;/span&gt; &lt;br/&gt; &lt;span&gt; 登录状态： { isOnline ? &#39;Online&#39; : &#39;Offline&#39; } &lt;/span&gt; &lt;/div&gt; ) } function App() { const [ show, setShow ] = useState(true); const [ count, setCount ] = useState(0); const [ userId, setUserId ] = useState(1); return ( &lt;div&gt; &lt;span&gt;用户ID：{userId}&lt;/span&gt; &lt;br/&gt; { show &amp;&amp; &lt;FriendStatus friend={{ id: userId, name: 'Hello' }}/&gt; } &lt;button onClick={() =&gt; setShow(!show)}&gt;显示/关闭&lt;/button&gt; &lt;button onClick={() =&gt; setUserId(userId + 1)}&gt;增加用户ID&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;增加计数器&lt;/button&gt; &lt;button onClick={ChatAPI.login.bind(ChatAPI)}&gt;登录&lt;/button&gt; &lt;button onClick={ChatAPI.logout.bind(ChatAPI)}&gt;退出&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面是一个覆盖比较全的 useEffect 案例，用来实现组件 FriendStatus 内对用户的订阅和取消订阅，其中 App 组件中的 show 状态用来控制 FriendStatus 组件是否渲染，显示/关闭 按钮用来控制 show 的值，FriendStatus 默认登录状态显示 Loading...，登录 和 退出 按钮用来空登录状态的显示（Online 或 Offline），增加用户ID 和 增加计数器 按钮分别用来更改当前用户 ID 和计数器的值，计数器的 count 属性和 setUserId 通过 Props 的方式传递给 FriendStatus，我们将使用到的方法统一都放在 ChatAPI 对象上。默认渲染 FriendStatus 在控制台发现 useEffect 执行了，并订阅了当前传入的用户，而点击 显示/关闭 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 useEffect 回调内部返回的函数，点击增加计数器按钮，FriendStatus 组件发生了重新渲染，而 useEffect 内部并没有再次对用户进行订阅，原因是指定了 useEffect 的第二个参数，并将用户的 ID 作为元素存入数组内，也就是用户 ID 不发生变化的时候就不会重新执行这个 useEffect 去订阅用户，当点击 增加用户ID 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 FriendStatus 组件重新渲染时，如果需要执行 useEffect，则会优先执行回调内返回的取消订阅的函数。如果在 useEffect 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 useEffect 时优先执行。/* 频繁更新未被监听的变量不变 */ import React, { useState, useEffect } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Counter() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { const id = setInterval(() =&gt; setCount(count + 1), 1000); return () =&gt; clearInterval(id); }, []); return &lt;h1&gt;{count}&lt;/h1&gt;; } ReactDOM.render(&lt;Counter /&gt;, root); 上面的案例是一个状态频繁变化的组件，但是我们给 useEffect 传入的第二个参数为空数组，这就会产生一个 Bug，由于 useEffect 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是初始的状态值，还记得上面一节 useState 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 Bug。/* 解决频繁更新未被监听变量不变的问题 */ import React, { useState, useEffect } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Counter() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { const id = setInterval(() =&gt; setCount(prev =&gt; prev + 1), 1000); return () =&gt; clearInterval(id); }, []); return &lt;h1&gt;{count}&lt;/h1&gt;; } ReactDOM.render(&lt;Counter /&gt;, root); 所以说在有些时候，对于 useEffect 第二个参数传入 [ ] 的行为不是绝对安全的，并且不建议这样使用。useReduceruseReducer 是 useState 的替代方案，用来处理复杂的 state 更新，看到这个名字大家可能会想到 Redux 中的 reducer，其实 useReducer 就是 React Hooks 中用来替代 Redux 解决问题的，让我们从此不需要 Redux。import React, { useReducer, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 初始 state const initalCountState = { count: 0 }; // reducer 函数 function reducer(state, action) { switch (action.type) { case &#39;reset&#39;: return { count: action.payload }; case &#39;increment&#39;: return { count: state.count + 1 }; case &#39;decrement&#39;: return { count: state.count - 1 }; default: return state; } } // 默认初始 state 函数 function init(initalCountState) { return { count: initalCountState.count + 1 }; } function Counter({ initalCount }) { const [ state, dispatch ] = useReducer(reducer, initalCountState, init); return ( &lt;Fragment&gt; count: { state.count } &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39;, payload: initalCount })}&gt; Reset &lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt; &lt;/Fragment&gt; ) } function App() { return &lt;Counter initalCount={0} /&gt; } ReactDOM.render(&lt;App /&gt;, root); useReducer 有三个参数：第一个参数为 reducer 函数（根据 action 的类型匹配新的 state 值）；第二个参数为监听状态对象 state 的初始值；第三个参数是一个函数，参数为初始的 state，作用是输出一个新的 state 替换初始的 state，只在最初执行一次。useReducer 的返回值为数组：数组第一项是监听的 state 对象；数组第二项是用来触发 state 更新的函数，参数为 action。/* useReducer 不传第三个参数 */ import React, { useReducer, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function reducer(state, action) { switch (action.type) { case &#39;reset&#39;: return { count: action.payload }; case &#39;increment&#39;: return { count: state.count + 1 }; case &#39;decrement&#39;: return { count: state.count - 1 }; default: return state; } } function Counter({ initalCount }) { const [ state, dispatch ] = useReducer(reducer, initalCount); return ( &lt;Fragment&gt; count: { state.count } &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39;, payload: initalCount.count })}&gt; Reset &lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt; &lt;/Fragment&gt; ) } function App() { return &lt;Counter initalCount={{ count: 0 }} /&gt; } ReactDOM.render(&lt;App /&gt;, root); 这个案例跟之前的稍有差别，去掉了 useReducer 的第三个参数，并将 Counter 组件的入参 initalCount 作为了初始 state。使用 React 进行过项目开发应该都是用过 Redux 和 Mobx 之类的状态管理工具，但其实他们并不是专门针对 React 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 React 搭配使用时更舒适，而 React hooks 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 Facebook 挖来了 Redux 的作者开发了 React hooks 中状态管理相关的 API。useContext想了解 useContext 首先要了解 context API，即 React.createContext 方法，执行后返回一个对象，其中包含两个属性分别为 Provider 和 Consumer，都为组件，Provider 用于包裹提供状态的容器组件，Consumer 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 React 官方文档。import React, { useState, useContext } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const myContext = React.createContext(); // 子组件 function Com() { const { count, setCount } = useContext(myContext); return ( &lt;div&gt; 子组件：{count} &lt;br /&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt; &lt;/div&gt; ) } // 父组件 function App() { const [ count, setCount ] = useState(0); return ( &lt;myContext.Provider value={{ count, setCount }}&gt; 父组件：{count} &lt;br /&gt; &lt;Com /&gt; &lt;/myContext.Provider&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面是 useContext 的一个简单用法，我们创建了 context，在父组件 App 中创建了 count 和更改 count 的函数 setCount，并将它们通过 context 的 Provider 组件提供给子组件 Com，子组件中调用 useContext 并传入这个创建的 context 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 count 都发生了变化。上面说 React hooks 中提供了自己的状态管理解决方案，也就是说可以替代 Redux 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 useContext 和 useReducer 来实现一个简单的状态管理逻辑。/* reducer.js */ import React, { useReducer } from &#39;react&#39;; // 初始状态（默认值） const initalState = { count: 0 }; // 导出共用的上下文 export const myContext = React.createContext(); // 导出 reducer 函数 export function reducer(state, action) { switch (action.type) { case &#39;reset&#39;: return initalState; case &#39;increment&#39;: return { count: state.count + 1 }; case &#39;decrement&#39;: return { count: state.count - 1 }; default: return state; } } // 导出提供状态的函数组件 export const ContextProvider = props =&gt; { const [ state, dispatch ] = useReducer(reducer, initalState); return ( &lt;myContext.Provider value={{ state, dispatch }}&gt; {props.children} &lt;/myContext.Provider&gt; ) } 上面的 reducer.js 文件用来提供整个状态管理的核心逻辑，创建了初始的 state，创建了共用的上下文对象，创建了 reducer 函数（通过 action 来匹配并返回新的 state），创建了用来提供 state 和 dispatch 的公共组件 ContextProvider，该组件内部通过创建上下文的 Provider 组件给该组件中间包裹的所有子组件 children 通过 value 提供 state 和 dispatch（通过 useReducer 创建）。/* App.js */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import { ContextProvider } from &#39;./reducer&#39;; import Counter from &#39;./Counter&#39;; function App() { return ( &lt;div&gt; &lt;ContextProvider&gt; &lt;Counter /&gt; &lt;/ContextProvider&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); App 组件，是提供状态的容器（一般使用根组件），根据 reducer.js 的用法，只需要引入 ContextProvider 组件包裹需要使用状态的子组件，与 react-redux 的 Provider 组件提供 store 的模式相似，这样被 ContextProvider 组件包裹的子组件就可以使用 reducer.js 中所 useReducer 所提供的 state 和 dispatch，Counter 子组件代码如下。import React, { useContext } from &#39;react&#39;; import { myContext } from &#39;./reducer&#39;; function Counter() { const { state, dispatch } = useContext(myContext); return ( &lt;div&gt; Counter count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39; })}&gt;Reset&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt; &lt;/div&gt; ) } export default Counter; 在使用 reducer.js 中实现的状态管理逻辑的组件中，只需要引入 reducer.js 提供的 context，并使用 useContext 就可以解构出 state 和 dispatch，并通过 action 实现三种不同的对状态的 state 的操作。useCallbackuseCallback 是 React 针对函数组件的优化考虑所设计的 Hook API，在函数被渲染时，React 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 React Hooks 以后，函数组件中需要的函数可以通过 useCallback 创建。import React, { useCallback, Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 用来存储 useCallback 返回的函数 let fn = null; // 使用 useCallback 的函数组件 function TestUseCallback({ nums, name }) { const memoizedCallback = useCallback(() =&gt; { console.log(nums, &#39;Hello world!&#39;); }, [ nums ]); console.log(&#39;callback 是否相同：&#39;, Object.is(fn, memoizedCallback)); console.log(&#39;nums &gt; &#39;, nums, &#39;name &gt; &#39;, name); fn = memoizedCallback; return ( &lt;div&gt; &lt;button onClick={memoizedCallback}&gt;TestUseCallback&lt;/button&gt; &lt;/div&gt; ) } // 用来触发重新 render 的类组件 class App extends Component { state = { nums: [1, 2, 3], count: 0, name: &#39;hello&#39; }; componentDidMount() { setInterval(() =&gt; { this.setState((state) =&gt; ({ count: state.count + 1 })); }, 3000); } handleChangeNum = () =&gt; this.setState({ nums: [4, 5, 6], name: &#39;world&#39; }); render() { const { nums, name } = this.state; return ( &lt;div className=&quot;App&quot;&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;button onClick={this.handleChangeNum}&gt;修改传入的 nums 值&lt;/button&gt; &lt;TestUseCallback nums={nums} name={name} /&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, root); 在上面的案例中渲染的组件 App 是一个类组件，该组件在挂载后会创建一个定时器，每 3s 更新 state 的 count 值，来完成重渲染，内部的 TestUseCallback 组件也会跟着重渲染，在内部检测 useCallback 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 useCallback 是否会新创建返回的值。执行 useCallback 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，React 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 GC 的压力。/* 组件中不同方式事件处理函数的区别 */ class Com1 extends Component { handleClick() { console.log(&#39;click happened&#39;); } render() { return &lt;button onClick={() =&gt; this.handleClick()}&gt;Click me&lt;/button&gt; } } class Com2 extends Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(&#39;click happened&#39;); } render() { return &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt; } } function Com3() { const handleClick = () =&gt; { console.log(&#39;click happened&#39;); } return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; } function Com4() { const memoizedHandleClick = useCallback(() =&gt; { console.log(&#39;click happened&#39;); }, []); return &lt;button onClick={memoizedHandleClick}&gt;Click me&lt;/button&gt; } Com1：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；Com2：类组件，在 constructor 中使用 bind 绑定 this，每次重新渲染都使用同一个函数；Com3：函数组件，直接创建函数，每次重新渲染都产生新的函数；Com4：函数组件，使用 useCallback 创建函数，每次重新渲染都使用同一个函数；import React, { useState, useCallback } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const Child = React.memo(({ a, memo }) =&gt; { return ( &lt;div&gt; {console.log(&#39;Child 渲染&#39;)} &lt;span&gt;a: {a}&lt;/span&gt; &lt;button onClick={memo}&gt;Click in child&lt;/button&gt; &lt;/div&gt; ) }); const App = props =&gt; { const [ a, setA ] = useState(0); const [ b, setB ] = useState(0); // 直接创建的函数 // const handleClick = () =&gt; console.log(&#39;click&#39;); // 使用 useCallback 创建的函数 const handleClick = useCallback(() =&gt; console.log(&#39;click&#39;), []); return ( &lt;div&gt; {console.log(&#39;App 渲染&#39;)} &lt;Child a={a} memo={handleClick} /&gt; &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt; &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt; &lt;button onClick={handleClick}&gt;Click&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面案例中使用了 React.memo 的函数组件优化方法来进一步验证了 useCallback 的作用，方法 React.memo 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 props 不发生变化时，则不会重新渲染。父组件 App 中使用 useCallback 创建的函数和使用 useState 创建的状态 a 作为参数传递给子组件 Child，并通过点击事件改变 a 和 b 的状态，初次渲染时控制台打印 App 渲染 和 Child 渲染，当点击 改变 a 时，父、子组件同时渲染，是因为子组件 props 中的 a 发生变化，当点击 改变 b 时，父组件重新渲染，但是子组件并没有，说明 useCallback 并没有产生新的函数传递给子组件，当使用 App 组件注释中直接创建的函数时，则点击 改变 b，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。import React, { useState, useCallback } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 存储两个组件的函数 let fun1 = null; let fun2 = null; // 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时） const ExpensiveCom = React.memo(({ onClick }) =&gt; { const date = new Date(); return ( &lt;h1 onClick={onClick}&gt; {console.log(&#39;昂贵组件渲染了！&#39;)} {date.getSeconds()} 我是一个昂贵的组件！渲染耗时！ &lt;/h1&gt; ) }); function Com1({ p1 }) { const fn = () =&gt; console.log(&#39;fn&#39;, p1); console.log(&#39;Com1&#39;, Object.is(fun1, fn)); fun1 = fn; return ( &lt;ExpensiveCom onClick={fn} /&gt; ) } function Com2({ p2 }) { const fn = useCallback(() =&gt; console.log(&#39;fn&#39;, p2), [ p2 ]); console.log(&#39;Com2&#39;, Object.is(fun2, fn)); fun2 = fn; return ( &lt;ExpensiveCom onClick={fn} /&gt; ) } function App() { const [ p1, setP1 ] = useState(0); const [ p2, setP2 ] = useState(0); return ( &lt;div&gt; &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt; &lt;Com1 p1={p1} /&gt; &lt;button onClick={() =&gt; setP1({ p1: p1 + 1 })}&gt;p1 + 1&lt;/button&gt; &lt;br/&gt; &lt;h2&gt;不用重复生成 fn&lt;/h2&gt; &lt;Com2 p2={p2} /&gt; &lt;button onClick={() =&gt; setP2({ p2: p2 + 1 })}&gt;p2 + 1&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面例子中假设 ExpensiveCom 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 Com1 和 Com2 中对比，ExpensiveCom 参数是在父组件 Com1 和 Com2 中创建的函数，前者直接创建，后者使用 useCallback 创建，在 App 组件中渲染 Com1 和 Com2，分别传入状态 p1 和 p2，并在 Com1 和 Com2 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。当在页面点击 p1 + 1 或 p2 + 1 时，都会导致 App 的状态变化，也就是 App 的重渲染，而作为 App 的子组件, Com1 和 Com2，也会跟着重新渲染，点击 p1 + 1，从控制台打印结果看，只有 Com1 内部的 “昂贵” 组件重新渲染，而 Com2 中并没有，是因为 useCallback 中依赖的 p2 没有改变，没有生成新的函数，当点击 p2 + 1 时，Com2 内部的 “昂贵” 组件重新渲染，同时 Com1 内部的 “昂贵” 组件也重新渲染，由此可以看出 Com2 的性能是要优于 Com1 的。在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 useCallback 对函数组件进行优化是非常有必要的。useMemouseMemo 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是第一个参数传入函数执行后的返回结果，在函数组件渲染时，其中的 useMemo 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。import React, { useState, useMemo } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 存储 useMemo 的返回结果 let ch = null; // 用于观察是否重渲染的组件 const Com = ({ val }) =&gt; { console.log(&#39;Com 重新渲染了&#39;); return &lt;h2&gt;{val}&lt;/h2&gt; } // 父组件 function Parent({ a, b }) { const child1 = useMemo(() =&gt; ( &lt;div&gt; {console.log(&#39;child1 重新计算&#39;)} &lt;Com val={b} /&gt; &lt;/div&gt; ), [ a ]); console.log(&#39;child1 是否和之前相等&#39;, child1 === ch); ch = child1; const child2 = ( &lt;div&gt; {console.log(&#39;child2 重新计算&#39;)} &lt;Com val={b} /&gt; &lt;/div&gt; ) return ( &lt;div&gt; {child1} {child2} &lt;/div&gt; ) } // 提供状态的容器组件 const App = props =&gt; { const [ a, setA ] = useState(0); const [ b, setB ] = useState(0); return ( &lt;div&gt; &lt;Parent a={a} b={b} /&gt; &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt; &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面例子中 App 组件提供状态 a 和 b 作为参数提供给 Parent 组件，App 中可以通过 改变 a 和 改变 b 按钮更新状态 a 和 b，当 a 和 b 发生变化时导致 Parent 组件重新渲染，内部的 child1 和 child2 分别是通过 useMemo 和直接创建的组件，其中分别渲染 Com 组件，默认情况下 child1 和 child2 都会渲染，点击 改变 a，child1 和 child2 重新渲染，因为 child1 的依赖 a 发生变化，点击 改变 b，发现只有 child2 重新渲染，而再此点击 改变 a，\b由于都重新渲染导致 child1 和 child2 渲染的值同步了。useMemo 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 useMemo 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 useEffect 的范畴，而不是 useMemo。useRef在 React 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 onChange 事件和 state 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 ref 属性获取 Dom 的引用，进而对表单进行操作，在 React 16.3 以后推荐使用 React.createRef 方法创建。类组件中使用 ref 通常是将引用关联到类组件的实例属性上，方便操作，而 useRef 就是为了在函数组件中实现这个功能而存在的。import React, { useState, useRef, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function TextInputWithFocusButton() { const inputEl = useRef(); const onButtonClick = () =&gt; { inputEl.current.focus(); } return ( &lt;Fragment&gt; &lt;input ref={inputEl} type=&quot;text&quot; /&gt; &lt;button onClick={onButtonClick}&gt;获取焦点&lt;/button&gt; &lt;/Fragment&gt; ) } const App = props =&gt; { const [ count, setCount ] = useState(0); return ( &lt;div&gt; {count} &lt;TextInputWithFocusButton /&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 在函数组件中同样可以 React.createRef 来实现，但是函数组件的每一次重新渲染都会导致 ref 对象的重新创建，浪费内存和性能，useRef 的参数为创建 ref 对象 current 属性的初始值，ref 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。useImperativeHandle在介绍 useImperativeHandle 之前一定要清楚 React 关于 ref 转发（也叫透传）的知识点，是使用 React.forwardRef 方法实现的，该方法返回一个组件，参数为函数（Prop callback，并不是函数组件），函数的第一个参数为父组件传递的 props，第二给参数为父组件传递的 ref，其目的就是希望可以在封装组件时，外层组件可以通过 ref 直接控制内层组件或元素的行为。/* 一个关于 ref 转发的例子 */ import React, { useCallback, useRef } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 实现 ref 的转发 const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;div&gt; &lt;input ref={ref} type=&quot;text&quot; /&gt; &lt;button&gt;{props.children}&lt;/button&gt; &lt;/div&gt; )); // 父组件中使用子组件的 ref function App() { const ref = useRef(); const handleClick = useCallback(() =&gt; ref.current.focus(), [ ref ]); return ( &lt;div&gt; &lt;FancyButton ref={ref}&gt;Click Me&lt;/FancyButton&gt; &lt;button onClick={handleClick}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面例子中创建了一个 FancyButton 组件，内部渲染了一个 button 元素，我们希望在父元素 App 中渲染 FancyButton，并通过传递给 FancyButton 的 ref 直接操作内部的 button。/* 一个官方的 useImperativeHandle 例子 */ import React, { useRef, useImperativeHandle } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const FancyInput = React.forwardRef((props, ref) =&gt; { const inputRef = useRef(); useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus(); } })); return &lt;input ref={inputRef} type=&quot;text&quot; /&gt; }); const App = (props) =&gt; { const fancyInputRef = useRef(); return ( &lt;div&gt; &lt;FancyInput ref={fancyInputRef} /&gt; &lt;button onClick={() =&gt; fancyInputRef.current.focus()}&gt; 父组件调用子组件的 focus &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面这个例子中与直接转发 ref 不同，直接转发 ref 是将 React.forwardRef 中函数上的 ref 参数直接应用在了返回元素的 ref 属性上，其实父、子组件引用的是同一个 ref 的 current 对象，官方不建议使用这样的 ref 透传，而使用 useImperativeHandle 后，可以让父、子组件分别有自己的 ref，通过 React.forwardRef 将父组件的 ref 透传过来，通过 useImperativeHandle 方法来自定义开放给父组件的 current。useImperativeHandle 的第一个参数是定义 current 对象的 ref，第二个参数是一个函数，返回值是一个对象，即这个 ref 的 current 对象，这样可以像上面的案例一样，通过自定义父组件的 ref 来使用子组件 ref 的某些方法，进而将子组件的 ref 保护起来，符合开放封闭原则。useImperativeHandle 和 React.forwardRef 是需要配合使用的，这也是为什么在开头要介绍 ref 的转发。import React, { useState, useRef, useImperativeHandle, useCallback } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const FancyInput = React.forwardRef((props, ref) =&gt; { const [ fresh, setFresh ] = useState(false) const attRef = useRef(0); useImperativeHandle(ref, () =&gt; ({ attRef, fresh }), [ fresh ]); const handleClick = useCallback(() =&gt; { attRef.current++; }, []); return ( &lt;div&gt; {attRef.current} &lt;button onClick={handleClick}&gt;Fancy&lt;/button&gt; &lt;button onClick={() =&gt; setFresh(!fresh)}&gt;刷新&lt;/button&gt; &lt;/div&gt; ) }); const App = props =&gt; { const fancyInputRef = useRef(); return ( &lt;div&gt; &lt;FancyInput ref={fancyInputRef} /&gt; &lt;button onClick={() =&gt; console.log(fancyInputRef.current)}&gt; 父组件访问子组件的实例属性 &lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面的案例相对于官方的例子意图更明显一些，通过 useImperativeHandle 将子组件的实例属性输出到父组件，而子组件内部通过 ref 更改 current 对象后，组件不会重新渲染，需要改变 useState 设置的状态才能更改。useImperativeHandle 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，useImperativeHandle 才会重新将子组件的实例属性输出到父组件 ref 的 current 属性上，如果为空数组，则不会重新输出。useLayoutEffectuseLayoutEffect 的使用方法和 useEffect 相同，唯一的区别就是执行时机不一样。/* 对比 useLayoutEffect 与 useEffect 的执行时机 */ import React, { useState, useEffect, useLayoutEffect } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; function Com() { useEffect(() =&gt; { console.log(&#39;useEffect 执行...&#39;); return () =&gt; { console.log(&#39;useEffect 销毁...&#39;); } }); useLayoutEffect(() =&gt; { console.log(&#39;useLayoutEffect 执行...&#39;); return () =&gt; { console.log(&#39;useLayoutEffect 销毁...&#39;); } }); return ( &lt;div&gt; {console.log(&#39;Com 渲染&#39;)} &lt;h2&gt;Com1&lt;/h2&gt; &lt;/div&gt; ) } const App = props =&gt; { const [ count, setCount ] = useState(0) return ( &lt;div&gt; &lt;Com /&gt; {count} &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面的例子中在 Com 组件中同时使用了 useLayoutEffect 和 useEffect，在页面初次渲染时可以看到控制台打印顺序为 Com 渲染 → useLayoutEffect 执行... → useEffect 执行...。当点击 App 组件按钮更新状态导致 Com 重新渲染，打印顺序为 Com 渲染 → useLayoutEffect 销毁... → useLayoutEffect 执行... → useEffect 销毁... → useEffect 执行...。在刚接触 React Hooks 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 useLayoutEffect、useEffect 与类组件生命周期配合使用的例子。/* 对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机 */ import React, { useEffect, useLayoutEffect, Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 使用 useLayoutEffect 和 useEffect 的函数组件 function Com() { useEffect(() =&gt; { console.log(&#39;useEffect 执行...&#39;); return () =&gt; { console.log(&#39;useEffect 销毁...&#39;); } }); useLayoutEffect(() =&gt; { console.log(&#39;useLayoutEffect 执行...&#39;); return () =&gt; { console.log(&#39;useLayoutEffect 销毁...&#39;); } }); return ( &lt;div&gt; {console.log(&#39;Com 渲染&#39;)} &lt;h2&gt;Com1&lt;/h2&gt; &lt;/div&gt; ) } // 使用生命周期的类组件 class App extends Component { state = { count: 0 } setCount = () =&gt; { this.setState({ count: this.state.count + 1 }); } componentDidMount() { console.log(&#39;App componentDidMount&#39;); } componentDidUpdate() { console.log(&#39;App componentDidUpdate&#39;); } render() { return ( &lt;div&gt; {this.state.count} &lt;Com /&gt; {console.log(&#39;App 渲染&#39;)} &lt;button onClick={this.setCount}&gt;count + 1&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, root); 上面例子中 useLayoutEffect 和 useEffect 依然在 Com 组件中使用，App 组件为类组件，Com 作为 App 的子组件，在首次渲染时控制台的打印顺序为 App 渲染 → Com 渲染 → useLayoutEffect 执行... → App componentDidMount → useEffect 执行...。而点击按钮更改状态触发重渲染时，打印顺序为 App 渲染 → Com 渲染 → useLayoutEffect 销毁... → useLayoutEffect 执行... → App componentDidUpdate → useEffect 销毁... → useEffect 执行...。useLayoutEffect 的执行时机要早于 useEffect，useLayoutEffect 的执行在类组件生命周期前，useEffect 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 useEffect，以避免阻塞视觉更新，如果是将代码从类组件重构为 React Hooks，并且使用 useEffect 出现问题，再考虑使用 useLayoutEffect，服务端渲染时使用 useLayoutEffect 会触发警告。useDebugValueuseDebugValue 用于在 React 开发者工具（如果已安装，在浏览器控制台 React 选项查看）中显示 自定义 Hook 的标签。import React, { useState, useDebugValue } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 自定义 Hook function useMyCount(num) { const [ count, setCount ] = useState(0); // 调试自定义 Hook，显示在 devtools 上 useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;); const myCount = () =&gt; { setCount(count + 2); } return [ count, myCount ]; } function App() { const [ count, setCount ] = useMyCount(10); return ( &lt;div&gt; {count} &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面例子中创建了 useMyCount 自定义 Hook，在内部使用 useDebugValue 对 count 的状态进行了调试，在开发工具中显示如下图。useDebugValue 调试效果图useDebugValue 还支持第二个参数，类型为函数，函数的默认参数为 debug 的状态，作用是对 debug 的值进行格式化，官方叫做 “延迟格式化”。/* 延迟格式化 */ import React, { useState, useDebugValue } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 自定义 Hook function useMyCount(num) { const [ count, setCount ] = useState(0); // 延迟格式化 useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;, (status) =&gt; { return status === &#39;溢出&#39; ? 1 : 0; }); const myCount = () =&gt; { setCount(count + 2); } return [ count, myCount ]; } function App() { const [ count, setCount ] = useMyCount(10); return ( &lt;div&gt; {count} &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面的例子只是做了小小的改动，增加了一个格式化函数作为 useDebugValue 的第二个参数，当状态为 不足 时显示 0，为 溢出 时显示 1。提示：我们不推荐你向每个自定义 Hook 使用 useDebugValue，只有自定义 Hook 被复用时才最有意义。自定义 Hook在开篇介绍 React Hooks 产生的动机时，提到了在类组件中使用 “高阶组件”（HOC）和 “渲染回调”（Prop callback）的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 React 16.8 以后可以通过自定义 Hook 来解决这些问题。/* 一个没有解决问题的例子 */ import React, { useState, useEffect, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 计数器 1 function Counter1() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { console.log(&#39;开启一个新的定时器&#39;) const timer = setInterval(() =&gt; { setCount(count + 1); }, 1000); return () =&gt; { console.log(&#39;销毁老的定时器&#39;) clearInterval(timer); } }); return &lt;p&gt;{count}&lt;/p&gt; } // 计数器 2 function Counter2() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { console.log(&#39;开启一个新的定时器&#39;) const timer = setInterval(() =&gt; { setCount(count + 1); }, 1000); return () =&gt; { console.log(&#39;销毁老的定时器&#39;) clearInterval(timer); } }); return &lt;p&gt;{count}&lt;/p&gt; } function App() { return ( &lt;Fragment&gt; &lt;Counter1 /&gt; &lt;Counter2 /&gt; &lt;/Fragment&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 React Hooks 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 Hook 改写的例子。/* 使用自定义 Hook 对状态逻辑进行抽离 */ import React, { useState, useEffect, Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 自定义 Hook function useNumber() { const [ count, setCount ] = useState(0); useEffect(() =&gt; { console.log(&#39;开启一个新的定时器&#39;) const timer = setInterval(() =&gt; { setCount(count + 1); }, 1000); return () =&gt; { console.log(&#39;销毁老的定时器&#39;) clearInterval(timer); } }); return count; } // 计数器 1 function Counter1() { let number = useNumber(); return &lt;p&gt;{number}&lt;/p&gt; } // 计数器 2 function Counter2() { let number = useNumber(); return &lt;p&gt;{number}&lt;/p&gt; } function App() { return ( &lt;Fragment&gt; &lt;Counter1 /&gt; &lt;Counter2 /&gt; &lt;/Fragment&gt; ) } ReactDOM.render(&lt;App /&gt;, root); 使用自定义 Hook 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。注意：官方建议在创建自定义 Hook 时，也采用 use 开头的命名方式，以保持命名的默认约定，便于识别，非强制，所以项目中可以使用 ESlint 进行检查和约束。总结React Hooks 出现后让我们对使用 React 编程如释重负，好的技术就是应该尽量减小学习坡度和上手难度，越用越简单，编写大家都读得懂又直观的代码才是优秀的代码，上面就是在学习完 React Hooks 后的一些总结，最后附上相关案例的 Guthub 地址。","tags":[{"name":"Hooks","slug":"Hooks","permalink":"https://www.overtaking.top/tags/Hooks/"},{"name":"React","slug":"React","permalink":"https://www.overtaking.top/tags/React/"}]},{"title":"JavaScript 获取对象属性名的方法和区别","date":"2019-04-17T03:25:36.000Z","path":"20190417112536/","text":"前言在 JavaScript 中想获取某一个对象的属性名，有多种方法可供选择：for inObject.keysObject.getOwnPropertyNamesObject.getOwnPropertySymbolsReflect.ownKeys在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。创建对象案例下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。/* 父类，继承自 Object.prototype */ const parent = Object.create(Object.prototype, { a: { value: 1, writable: true, enumerable: true, configurable: true }, b: { value: 2, writable: true, enumerable: false, configurable: true }, [Symbol(&#39;symbolParent&#39;)]: { value: 3, writable: true, enumerable: true, configurable: true } }); /* 子类，继承自 parent */ const child = Object.create(parent, { c: { value: 4, writable: true, enumerable: true, configurable: true }, d: { value: 5, writable: true, enumerable: false, configurable: true }, [Symbol(&#39;symbolChild&#39;)]: { value: 6, writable: true, enumerable: true, configurable: true } }); 在上面我们创建了一个对象 parent，上面创建了两个普通属性 a（可枚举）、b（不可枚举）和一个键为 Symbol 类型的属性 symbolParent，创建了一个对象 child 继承自 parent，上面创建了两个普通属性 c（可枚举）、d（不可枚举）和一个键为 Symbol 类型的属性 symbolChild。for…infor (let k in child) { console.log(k); } // c // a 从结果来看，for...in 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。总结：for...in 可以遍历自身和继承的、可枚举的、非 Symbol 类型的属性。Object.keysObject.keys(child); // [&quot;c&quot;] 从结果来看，Object.keys 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 for...in 与 hasOwnProperty 方法的组合。for (let k in child) { if (child.hasOwnProperty(k)) { console.log(k); } } // c 总结：Object.keys 只能遍历自身的、可枚举的、非 Symbol 类型的属性。Object.getOwnPropertyNamesObject.getOwnPropertyNames(child); // [&quot;c&quot;, &quot;d&quot;] 从结果看，Object.getOwnPropertyNames 方法返回了一个数组，存储获取对象属性的键名。总结：Object.getOwnPropertyNames 只能遍历自身的（包含不可枚举）、非 Symbol 类型的属性。Object.getOwnPropertySymbolsObject.getOwnPropertySymbols(child); // [Symbol(symbolChild)] 从结果看，Object.getOwnPropertySymbols 方法返回了一个数组，存储的都是 Symbol 类型的键，说明是专门用来处理 Symbol 类型的。总结：Object.getOwnPropertySymbols 只能遍历自身 Symbol 类型的属性。Reflect.ownKeysReflect.ownKeys(child); // [&quot;c&quot;, &quot;d&quot;, Symbol(symbolChild)] Reflect.ownKeys 的返回值为数组，存储遍历到的属性名。总结：Reflect.ownKeys 可以遍历自身的所有属性（包含不可枚举和 Symbol 类型）。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://www.overtaking.top/tags/ES6/"}]},{"title":"TypeScript 基础知识总结","date":"2019-04-16T08:06:37.000Z","path":"20190416160637/","text":"TypeScript 简介TypeScript 是由微软开发的开源编程语言（后面简称 TS），是 JavaScript 的超集（后面简称 JS），由于 JS 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 Bug 和风险，而 TS 更适合大型企业应用，是因为 TS 需要编译成 JS 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。TypeScript 与 JavaScript 关系图TS 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 TS 编写，也有很多大牛在推广 TS，目前使用 TS 开发的典型项目有 VSCode、Angular6、Vue3 和 React16 等。如何使用 TS安装在使用 TS 之前应该先进行全局安装，安装 TS 的命令：$ npm install typescript -g 全局安装后会提供 tsc 命令，tsc -v 可以查看当前安装 TS 版本。编译我们可以通过命令单独对文件进行编译，也可以编译整个项目的 TS 文件。编译单个文件：$ tsc &lt;filename&gt; 块级作用域变量名检测，两个文件（无论 JS 还是 TS）不允许有相同的变量名。编译整个项目的 TS 文件需要在项目中设置 tsconfig.json 的配置文件，快速生成配置文件命令如下：tsc --init 生成 TS 配置文件以后，编译命令 tsc 不需要再指定文件名，会默认读取 tsconfig.json 文件的配置进行编译，关于 tsconfig.json 属性详解请看（TO DO）。当 TS 文件发生变化时，可以通过 --watch 参数进行实时监听，并当 TS 文件变化时实时编译，也可以把命令配置在 package.json 中通过 npm 执行。/* package.json 文件 */ { &quot;scripts&quot;: { &quot;build&quot;: &quot;tsc&quot;, &quot;start&quot;: &quot;tsc --watch&quot; } } TS 的数据类型在 TS 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 TS 比较好的编辑器，如 VSCode，可以在代码编写时根据智能提示及时发现错误。基本数据类型基本数据类型定义TS 中包含了 JS，所以 TS 也有 6 种基本数据类型，string、number、boolean、undefined、null、symbol。let name: string = &#39;panda&#39;; let age: number = 18; let merried: boolean = false; let un: undefined = undefined; let nu: null = null; let sym: symbol = Symbol(); 上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。undefined 和 null 是其他基本类型的子类型：类型定义为 undefined 的变量只能赋值 undefined；类型定义为 null 的变量只能赋值 null；类型定义为除 undefined 和 null 以外的其他类型，可以赋值为 undefined 和 null。/* 默认会报错 */ let name: string = undefined; let age: number = null; 其他类型的赋值也必须严格与其定义相对应（默认行为，也被叫做严格类型检查模式），可以通过配置 tsconfig.json 文件 compilerOptions 的 strictNullChecks 属性值为 false 跳过严格检查。/* tsconfig.json 文件 */ { &quot;compilerOptions&quot;: { &quot;strictNullChecks&quot;: false } } 数据类型 any希望定义的数据类型可以赋值任何类型的值，可以将数据类型定义为 any，这样相当于没有使用类型校验，等同于直接使用 JS（戏称 AnyScript）。let value: any = 18; value = &#39;hello world&#39;; value = true; value = null; value = undefined; value = Symbol(); 上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 any。类型推论在 TS 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。let num = 10; num = &#39;hello&#39;; // 报错，不能将类型“&quot;hello&quot;”分配给类型“number” let str = &#39;world&#39;; str = 1; // 报错，不能将类型“1”分配给类型“string” let value; // let value: any 类型推论规则：从报错的结果可以看出，TS 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；当声明变量没有直接赋值时，TS 会将变量的值类型定义为 any。基本包装类TS 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。/* 基本数据类型调用方法的包装 */ let num = 10; num.toFixed(2); // new Number(num).toFixed(2); 联合类型有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。/* 联合类型 */ let value: string | number = &#39;hello&#39;; value = 10; value = true; // 报错 被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 | 隔开，当被赋值不符合联合类型时会报错。上面联合类型的写法如果多处相同会让代码冗余，在 TS 中提供了 type 关键字来声明类型，用法如下。// 冗余的写法 let x: string | number | boolean = &#39;hello&#39;; let y: string | number | boolean = 10; let z: string | number | boolean = true; // 更改后... type MyType = string | number | boolean; let x: MyType = &#39;hello&#39;; let y: MyType = 10; let z: MyType = true; 类型断言被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。let value: string | number | boolean; value = &#39;hello&#39;; value = 10; value = true; console.log((value as string).length); // 报错 断言的语法是将变量使用 as 关键字指定要断言的类型，上面代码中因为变量 value 值最后已经是布尔，而强行将 value 指定为 string 类型去获取 length 属性报错，因为布尔值无法调用 length 属性。值的联合值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。let point: 1 | 6 | 10; point = 10; point = &#39;hello&#39;; // 报错 let level: &#39;A&#39; | &#39;B&#39; | &#39;C&#39;; level = &#39;B&#39;; level = &#39;b&#39;; // 报错 数组在 TS 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。/* 普通数组类型定义 */ let names: string[] = [&#39;Jim&#39;, &#39;Peter&#39;]; let ages: number[] = [18, 20]; /* 泛型定义（泛型会在后面详细说明） */ let names: Array&lt;string&gt; = [&#39;Jim&#39;, &#39;Peter&#39;]; let ages: Array&lt;number&gt; = [18, 20]; 上面两种方式定义的数组内元素类型必须统一，如果数组内要支持多种数据类型则可以使用联合类型或元组类型。let data: Array&lt;string | number&gt; = [&#39;James&#39;, 25]; 元组如果让数组内部元素类型不同该怎么办，在 TS 中有一种特殊的数组类型定义叫做 “元组类型”（tuple）。/* 元组类型定义 */ let people: [string, number] = [&#39;Jim&#39;, 18]; 元组的越界问题：let tuple: [string, number] = [&#39;hello&#39;, 100]; tuple.push(false); console.log(tuple); // [&#39;hello&#39;, 100, false] tuple[2] // 报错 元组类型可以越界添加元素，如使用数组的 push 方法，但是访问越界元素会报错，强烈不建议让元组越界。元组类型和数组类型的特点如下表：元组数组元素可以是不同类型元素必须为相同类型有预定的长度没有预定的长度用于表示一个结构用于表示一个列表对象TS 可以通过 object 来声明对象类型。let obj: object = {x: 1, y: 2}; obj.x = 3; // 报错 用 object 类型并不能定义对象上具体属性的类型，所以对 x 属性重新赋值会报错，也可以在创建对象时直接定义属性的类型如下：let obj: {x: number, y: number} = {x: 1, y: 2}; obj.x = 3 对象类型内部成员的类型很少使用上面的方式，通常使用接口（后面介绍）进行定义。枚举枚举类型是 JS 中所不包含的数据类型，通过 enum 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。数字枚举enum Gender { BOY, GIRL } /* 编译后 */ var Gender; (function (Gender) { Gender[Gender[&quot;BOY&quot;] = 0] = &quot;BOY&quot;; Gender[Gender[&quot;GIRL&quot;] = 1] = &quot;GIRL&quot;; })(Gender || (Gender = {})); 从编译结果来看，枚举类型编译成 JS 后帮助我们创建了一个类似于映射表的同名对象（实现原理，反向映射），所以可以在 TS 中通过对象属性的方式获取枚举的值。/* 获取枚举值 */ console.log(Gender.BOY); // 0 console.log(Gender[1]); // &quot;GIRL&quot; 如果给第一个枚举值设置数值类型的初始值，则后面的枚举值会依次递增。字符串枚举enum Week { MONDAY = &#39;1&#39;, TUESDAY = &#39;2&#39; } /* 编译后 */ var Week; (function (Week) { Week[&quot;MONDAY&quot;] = &quot;1&quot;; Week[&quot;TUESDAY&quot;] = &quot;2&quot;; })(Week || (Week = {})); 字符串枚举是在枚举过程中给枚举项明确赋值，值类型为字符串类型。异构枚举异构枚举是将数字枚举和字符串枚举混合使用（容易引起混淆，不建议使用）。enum Answer { N, Y = &#39;Yes&#39; } 常量枚举常量枚举的语法是在创建枚举的 enum 关键字前使用 const 声明。const enum Colors { RED, YELLOW, BLUE } let colors: Array&lt;number&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE]; /* 编译后 */ var colors = [0 /* RED */, 1 /* YELLOW */, 2 /* BLUE */]; 常数枚举与其他类型枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。枚举成员枚举成员主要分为两类：const member：以编译阶段计算结果，以常量的形式出现在运行时环境；没有初始值的枚举值；对已有枚举成员的引用；常量的表达式。computed member：编译阶段不会计算，会被保留在程序的执行阶段。动态计算的表达式；后面的枚举值必须赋值初始值。enum Char { // const member a, // 无初始值 b = Char.a, // 对已有成员的引用 c = 1 + 2, // 常量表达式 // computed member d = Math.random(), e = &#39;123&#39;.length, } Char.a = 1 // 报错 枚举成员的值为只读类型，在定义后不能重新赋值。函数参数类型定义function sum(a: number, b: number) { return a + b; } sum(1, 2); // 3 在函数中经常会定义可选参数，即非必传，但是 TS 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。/* 可选参数 */ function people(name: string, age?: number) { console.log(name); } people(&#39;jim&#39;); 使用 ?: 替代 :，即代表该参数为可选参数，在 TS 中也支持使用默认参数和剩余参数，使用方式如下。/* 默认参数 */ function fn(sum: number = 0) { console.log(sum); } fn(); // 0 /* 剩余参数 */ function sum(prefix: string, ...args: number[]) { return prefix + args.reduce((sum, val) =&gt; sum + val, 0); } sum(&#39;$&#39;, 1, 2, 3); // 6 在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。返回值类型定义function sum(a: number, b: number): number { return a + b; } 特殊的返回值类型：never：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完成；void：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 TS 认为返回值为 void 类型。/* never 为返回值类型的函数 */ function fn1(): nerver { throw new Error(&#39;报错了&#39;); console.log(1); } function fn2(): nerver { while (true) {} console.log(1); } 上面两个函数返回值设置为 never，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。/* void 为返回值类型的函数 */ function fn1(): void { console.log(1); } function fn2(): void { return null; } 上面的 fn2 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 void 的函数可以返回 null 和 undefined。函数表达式之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？let fullName: (x: string, y: string) =&gt; string; fullName = function (firstName:string, lastName:string): string { return firstName + lastName; } 括号中 x 和 y 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 type 关键字进行声明。type Fn = (x: string, y: string) =&gt; string; let fullName: Fn = function (firstName: string, lastName: string): string { return firstName + lastName; } 赋值函数的参数类型必须与变量声明的函数参数类型严格一致，赋值函数的返回值类型必须与变量声明的函数返回值类型严格一致。函数重载函数重载是强类型语言中的特性，在 Java 中代表多个同名函数参数不相同，而在 TS 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。// 联合类型 type MyType = string | number | boolean // 重载限定函数 double function double(val: string): string; function double(val: number): number; function double(val: boolean): boolean; // 函数 function double(val: MyType) { if (typeof val === &#39;string&#39;) return val + val; if (typeof val === &#39;number&#39;) return 2 * val; if (typeof val === &#39;boolean&#39;) return !val; } double(&#39;hello&#39;); // hellohello double(5); // 10 double(true); // false 重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。类类的定义TS 类的定义与 JS 相同，使用 class 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。class Person { name: string getName(): void { console.log(this.name) } } let p = new Person(); p.name = &#39;neil&#39;; p.getName(); // neil 存取器在 TS 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。class Person { myName: string, constructor(myName: string) { this.myName = myName; } get name(): string { return this.myName; } set name(newVal: string) { this.myName = newVal; } } let p = new Person(&#39;neil&#39;); console.log(p.name); // neil p.name = &#39;jim&#39;; console.log(p.name); // jim 参数属性上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。/* 简化前 */ class Person { name: string; constructor(name: string) { this.name = name; } } /* 简化后 */ class Person { constructor(public myName: string) {} } let p = new Person(&#39;neil&#39;); console.log(p.myName); // neil public 修饰符写在 constructor 的参数前，代表创建一个与参数同名的公有属性。只读属性在 TS 中可以在类中定义只读属性，只需要通过 readonly 修饰符修饰即可，只在编译阶段进行检查。class Person { constructor(public readonly myName: string) { this.myName = myName; } } let p = new Person(&#39;neil&#39;); console.log(p.myName); // neil p.myName = &#39;jim&#39;; // 报错 不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。类的继承类与类之间通过 extends 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。// 父类 class Parent { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } getName(): string { return this.name; } setName(name: string): void { this.name = name; } } // 子类继承父类 class Child extends Parent { hobby: string; constructor(name: string, age: number, hobby: number) { super(name, age); this.hobby = hobby; } getHobby(): number { return this.hobby; } } let c = new Child(&#39;neil&#39;, 20, &#39;swim&#39;); console.log(c.getHobby()); // swim console.log(c.getName()); // neil console.log(c.getAge()); // 20 访问控制修饰符在 TS 的类中有三种访问控制修饰符：public：公有的属性，所有地方都能访问；protected：受保护的属性，不能被实例化只能被继承，只能在自己和自己的子类中被访问；private：私有属性，既不能被实例化也不能被继承，只有自己内部可以访问。// 父类 class Parent { public name: string; protected age: number; private money: number; constructor(name: string, age: number, money: number) { this.name = name; this.age = age; this.money = money; } getName() { console.log(&#39;父类：&#39; + this.name); } getAge() { console.log(&#39;父类：&#39; + this.age); } getMoney() { console.log(&#39;父类：&#39; + this.money); } } // 子类 class Child extends Parent { constructor(name, age, money) { super(name, age, money); } getName() { console.log(&#39;子类：&#39; + this.name); } getAge() { console.log(&#39;子类：&#39; + this.age); } getMoney() { console.log(&#39;子类：&#39; + this.money); // 报错 } } 在上面代码中 name 属性可以通过父类的实例访问、子类的实例访问，父类的 getName 方法访问，子类的 getName 方法访问，age 属性可以只能通过父类和子类的 getAge 方法访问，money 属性只能通过父类 getMoney 方法访问，其他不被允许的访问方式都会报错。静态属性和方法在 TS 中给类定义私有属性和方法的修饰符为 static，与 JS 的类相同。class Father { static myName: string = &#39;hello&#39;; static getMyName(): string { return Father.myName; } } console.log(Father.myName); // hello console.log(Father.getMyName()); // hello 抽象类抽象类是一种抽象的概念，使用 abstract 关键字定义，无法被实例化（无法使用 new），只能被继承。抽象类的内部包含抽象方法和抽象属性，同样使用 abstract 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，且必须实现。abstract class Animal { abstract name: string; abstract speak(); } class Cat extends Animal { name: string; speak() { console.log(&#39;喵喵喵&#39;); } } class Dog extends Animal { name: string; speak() { console.log(&#39;汪汪汪&#39;); } } 继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承过程，子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。接口接口是 TS 中的核心之一，主要有两个作用：用于描述或约束一种对象结构，描述属性的名称和值的类型；用来表示行为的抽象，让类去实现接口。接口的定义和使用TS 中使用 interface 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。/* 定义接口，使用接口创建对象 */ interface UserInterface { name: string; age: number; } let user: UserInterface = { name: &#39;hello&#39;, age: 20 }; 上面 UserInterface 接口创建的对象 user，属性和值的类型必须与定义的接口严格对应。/* 让类去实现定义的接口 */ interface Flyable { fly(): void; } class Bird implements Flyable { fly() { console.log(&#39;bird fly&#39;); } } 让类实现一个接口使用 implements 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。/* 一个类实现多个接口 */ // 接口 interface Speakable { name: string; speak(): void; } interface Eatable { food: string; eat(): void; } // 类 class Person implements Speakable, Eatable { name: &#39;hello&#39;; food: &#39;cake&#39;; speak() { console.log(&#39;say hello&#39;); } eat() { console.log(&#39;eat cake&#39;); } } 继承与实现接口的区别：一个类可以实现多个接口，一个接口可以被多个类实现；而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。接口的只读属性接口中可以定义只读属性，这样通过接口创建对象的值在修改时会报错，可以在定义接口属性是加上 readonly 修饰符实现。/* 接口的只读属性 */ interface Person { id: number; readonly name: string; } let p: Person = { id: 1; name: &#39;hello&#39;; }; console.log(p.id); // 1 p.name = 2; // 报错 接口的可选属性在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。/* 接口的可选属性 */ interface Person { id: number; name: string; age?: number; } let p1: Person = { id: 1, name: &#39;hello&#39;, age: 20 }; let p2: Person = { id: 2, name: &#39;world&#39; }; 定义接口的可选属性与函数定义可选参数类似，都是使用 ?: 替代原本的 : 即代表可选。接口的未知属性当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。interface Person { id: number; name: string; [proName: string]: any; } let p: Person = { id: 1, name: &#39;hello&#39;, age: 20, city: &#39;Beijing&#39; }; proName 名字是任意的，可以随意取，string 代表属性的类型，any 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 [name: type]: type 的结构即可。根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。可索引接口限制数组和对象：/* 限制数组 */ interface UserInterface { [index: number]: string; } let userArr: UserInterface = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; userArr = [&#39;a&#39;, &#39;b&#39;, 1]; // 报错 上面的数组 userArr 内的的索引为数字类型，满足可索引接口的要求，但是使用 UserInterface 约束后，所有项必须是字符串，如果改成其他类型则会报错。/* 限制对象 */ interface UserInterface { [index: string]: string; } let userObj: UserInterface = { jim: &#39;1&#39;, bob: &#39;2&#39; }; 上面的对象 userObj 使用 UserInterface 约束后，键和值必须都为字符串，否则报错。接口的继承接口的继承同类的继承相同，使用 extends 关键字实现，下面是一段接口继承的代码。// 父接口 interface Speakable { speak(): void; } // 子接口 interface SpeakChinese extends Speakable { speakChinese(): void; } // 类实现接口 class ChinesePerson implements SpeakChinese { speak() { console.log(&#39;speak&#39;); } speakChinese() { console.log(&#39;你好&#39;); } } 当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。函数型接口函数型接口专门对函数或方法传入的参数和返回值进行约束。interface Discount { (price: number): number; } function discount(price: number): number { return price * 0.8; } const dFun: Discount = discount; 上面代码中 Discount 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 discount 定义的参数和返回值类型必须与 Discount 接口内部定义的类型保持一致。构造函数型接口在 TS 中存在对构造函数或类的实例化的类型约束，即在执行 new 操作的时候进行约束检查。// 被约束实例化动作的类 class Animal { constructor(public name: string) {} } // 约束实例化的接口 interface WithNameClazz { new (name: string): Animal; } // 工厂函数 function createAnimal(Clazz: WithNameClazz, name: string) { return new Clazz(name); } let animal = createAnimal(Animal, &#39;hellop&#39;); 上面代码的 interface 中，new 代表约束的动作为实例化操作，name 为参数，string 为参数的类型，而 Animal 代表返回值需要是一个 Animal 类的实例。泛型“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。泛型函数在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。/* 为使用泛型定义的函数 */ function createArray(len: number, val: any): any[] { const result: any[] = []; for (let i = 0; i &lt; len; i++) { result[i] = val; } return result; } console.log(createArray(3, &#39;x&#39;)); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;] 在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 val 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。function createArray&lt;T&gt;(len: number, val: T): T[] { const result: T[] = []; for (let i = 0; i &lt; len; i++) { result[i] = val; } return result; } console.log(createArray&lt;string&gt;(3, 1)); // 报错 上面的 T 是泛型的占位符，代表 Type 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。泛型类class MyArray&lt;T&gt; { list: T[] = []; add(val: T) { this.list.push(val); } getFirst(): T { return this.list[0]; } } let myArray = new MyArray&lt;number&gt;(); myArray.add(1); myArray.add(2); console.log(myArray.getFirst()); 泛型类与泛型函数相似，都是通过占位符 T 占位，在真正实例化的时候传入类型。泛型接口上面接口一节中，接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。interface SUM&lt;T&gt; { (a: T, b: T): T } const sum: SUM&lt;number&gt; = function (a: number, b: number): number { return a + b; } 泛型占位符（上面为 T）只在约束的函数、类和接口内部可以使用，可类比函数的形参。默认泛型类型默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。class MyArray&lt;T = number&gt; { list: T[] = []; add(val: T) { this.list.push(val); } } let myArray = new MyArray(); myArray.add(1); myArray.add(&#39;a&#39;); // 报错 定义多个泛型上面的泛型中都只使用了一个占位符 T，其实泛型是允许有多个的。function swap&lt;A, B&gt;(tuple: [A, B]): [B, A] { return [tuple[1], tuple[0]]; } console.log(swap&lt;string, number&gt;([&#39;a&#39;, 1])); // [1, &#39;a&#39;] 上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。泛型的约束在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。function logger&lt;T&gt;(val: T): void { console.log(val.length); // 报错 } 泛型的继承如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。// 接口 interface LengthWise { length: number; } // 函数 function logger&lt;T extends LengthWise&gt;(val: T): void { console.log(val.length); } logger&lt;number&gt;(&#39;hello&#39;); // 报错 logger&lt;string&gt;(&#39;hello&#39;); // 5 泛型的流程控制在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。interface Fish { nameFish: string; } interface Water { nameWater: string; } interface Bird { nameBird: string; } interface Sky { nameSky: string; } type Condition&lt;T&gt; = T extends Fish ? Water : Sky; let con: Condition&lt;Fish&gt; = { nameWater: &#39;hello&#39; } 上面定义了四个接口 Fish、Bird、Water 和 Sky，定义一个 Condition 类型和泛型，如果泛型为 Fish 则继承 Water，否则继承 Sky，在变量 con 使用类型 Condition 时，传入 Fish 接口。泛型的别名泛型可以使用 type 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。let arr: Array&lt;string&gt; = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; 其实上面的 Array 就是定义泛型的别名，&lt;string&gt; 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。// 定义泛型别名 type Cart&lt;T&gt; = { list: T[] } | T[]; // 使用泛型别名 let cart1: Cart&lt;string&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; let cart2: Cart&lt;string&gt; = { list: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] }; 在 JS 中有很多类数组对象，如 arguments、获取的 DOM 元素集合等等，每一种类数组对象 TS 都定义了对应的泛型别名，下面看两个案例。/* arguments 对象的泛型 */ function sum(...args: number[]) { let params: IArguments = arguments; let result = 0; for (let i = 0; i &lt; params.length; i++) { result += params[i]; } return result; } /* DOM 节点类数组对象的泛型 */ let root = document.getElementById(&#39;root&#39;); let children: HTMLCollection = root.children; let childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes; 上面用来定义 arguments 类数组对象的泛型别名为 IArguments，获取 DOM 节点的元素节点集合的泛型别名为 HTMLCollection，而全部子节点的泛型别名为 NodeListOf&lt;ChildNode&gt;，如果使用 VSCode 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。接口和泛型别名的区别：接口会创建一个新的名称，而别名不会（只是用 type 关键字创建了一个变量）；别名不能被继承和实现；定义一个类型的时候使用接口，要使用联合类型或者元组类型时，泛型别名会更合适。结构类型系统如果传入的变量和声明的类型不匹配，TS 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。基本数据类型的兼容性基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 toString 方法的约束，则右侧值凡是可以通过 toString 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。let num1: string | number; let str1: string; num1 = str1; let num2: { toString(): string; }; let str2: number; num2 = str2; type People = { name: string; age: number; } let p: People = { name: &#39;hello&#39;, age: 20, gender: &#39;male&#39; // 报错 }; 枚举的兼容性默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。enum Colors { RED, YELLOW, BLUE } // 兼容数字类型 let colorRed: number = Colors.RED; // 兼容枚举类型 let colorYello: Colors; colorYello = Colors.Red; colorYello = 1; // 所有枚举值没有初始值 enum E { a, b } // 所有枚举值初始值都为数值 enum F { a = 1, b = 2 } // 所有枚举值类型都为字符串 enum G { a = &#39;apple&#39;, b = &#39;banana&#39; } 赋值可以超出枚举值范围：let e: E = 3; // 不报错 不同枚举约束的变量不可以进行比较：let e: E = 1; let f: F = 2; console.log(e === f); // 报错 相同枚举不同枚举值约束的变量不可以进行比较：let e1: E.a = 1; let e2: E.b = 2; let e3: E.a = 1; console.log(e1 === e2) // 报错 console.log(e1 === e3) // true 字符串枚举和字符串枚举值约束赋值：// 字符串枚举约束赋值必须是类型中的枚举值 let g1: G = G.a // 字符串的枚举值约束赋值必须是这个枚举值 let g2: G.b = G.b 函数的兼容性比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。参数的兼容性/* 参数的类型比较 */ type SumFunc = (a: number, b: number) =&gt; number; let sum: SumFunc; // 不报错的赋值 sum = function(a: number, b: number): number { return a + b; } sum = function(a: number): number { return a; } sum = function(): number { return 0; } // 报错的赋值 sum = function(a: number, b: number, c: number): number { return a + b + c; } 函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。参数的双向协变参数的 “双向协变” 是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。type LogFunc = (val: number | string) =&gt; void; let log: LogFunc; // 变量定义类型兼容赋值定义类型 log = function (val: string) { console.log(val); } // 变量赋值类型兼容变量定义的类型 log = function (val: number | string | boolean) { console.log(val); } 返回值的兼容性/* 返回值的类型比较 */ type GetPerson = () =&gt; { name: string, age: number }; let getPerson: GetPerson; // 不报错的赋值 getPerson = function () { return { name: &#39;hello&#39;, age: 20 }; } getPerson = function () { return { name: &#39;hello&#39;, age: 20, gender: 1 }; } // 报错的赋值 getPerson = function () { return { name: &#39;hello&#39; }; } // 可能调用 age 属性的方法 getPerson().age.toFixed(2); 返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。类的兼容性class Parent { name: string; } class Child extends Parent { age: number; } let p1: Parent = new Parent(); let c1: Child = new Child(); let p2: Parent = new Child(); let c2: Child = new Parent(); // 报错 父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 p2 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 c2 报错是因为父类的实例并没有提供子类泛型要求的属性。接口的兼容性比较属性的兼容性在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。interface Person { name: string; age: number; gender: number; } let p: Person = { name: &#39;hello&#39;, age: 20, gender: 0 }; 鸭式变形法“鸭式变形法” 是很多动态语言的类型风格，指的是一只鸟如果看起来像鸭子，游起来像鸭子，叫起来像鸭子，这只鸟就可以被当做一直鸭子，回到 TS 中，传入接口的对象只要符合接口的必要条件，即传入的属性不必接口约束的少，就认为可以通过校验，不会报错。上面的案例可以稍微做改造如下：interface Animal { name: string; age: number; } interface Person { name: string; age: number; gender: number; } let p: Person = { name: &#39;hello&#39;, age: 20, gender: 0 }; function getName(a: Animal): string { return a.name; } getName(p); // hello; 上面的代码中定义了两个接口 Animal 和 Person，Person 定义的属性更多，当一个符合 Person 的对象传给参数用 Animal 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。、在实际的开发应用中，有一个常见的场景，就是前端代码要对后端返回的数据进行定义和约束，往往后端返回的数据及类型对于前端并不是全部必要的，则可以利用该特性使用接口对必要的字段进行兼容。interface List { id: number; name: string; } interface Result { data: List[]; } function render(result: Result) { result.data.forEach(({ id, name }) =&gt; { console.log(id, name) }); } render({ data: [ {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错 {id: 2, name: &#39;B&#39;} ] }); 有一种特殊情况，就是直接传入对象字面量，则 TS 会对额外的字段进行检查，绕过检查的方式一共有三种：将对象字面量直接赋值给变量；使用类型断言；在定义接口时使用可索引签名；// 第一种方式：对象字面量赋值给变量 let result = { data: [ {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, {id: 2, name: &#39;B&#39;}, ] }; render(result); // 第二种方式：使用类型断言 render({ data: [ {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错 {id: 2, name: &#39;B&#39;}, ] } as Result); // 或 // React 中容易产生歧义 render(&lt;Result&gt;{ data: [ {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错 {id: 2, name: &#39;B&#39;}, ] }); // 第三种方式：定义接口使用可索引签名 interface List { id: number; name: string; [x: string]: any; } 可索引接口的兼容性用数值类型去索引一个接口，相当于给数组创建接口，可索引返回值的具体类型约束数组成员类型。interface StringArray { [index: number]: string; } const chars: StringArray = [&#39;A&#39;, &#39;B&#39;] 使用字符串类型作为可索引类型，则不能添加其他类型的属性：interface Names { [x: string]: string; y: number; // 报错 } 可是使用字符串和数值类型同时作为可索引类型，数字类型返回值必须是字符串类型返回值的子类型：interface Names { [x: string]: string; [y: number]: string; } 泛型的兼容性泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。/* 空接口 */ interface Empty&lt;T&gt; {} let x: Empty&lt;string&gt;; let y: Empty&lt;number&gt;; x = y; /* 属性使用了泛型的接口 */ interface NotEmpty&lt;T&gt; { data: T; } let x: NotEmpty&lt;string&gt;; let y: NotEmpty&lt;number&gt;; x = y; // 报错，因为 number 类型的属性不能赋值给 string 类型的定义 // 等价于 interface NotEmptyString{ data: string } interface NotEmptyNumber{ data: number } let xString: NotEmptyString; let yNumber: NotEmptyNumber; xString = yNumber; // 报错 类型保护类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。typeof 和 instanceof 类型保护/* typeof 类型保护 */ function double(val: string | number | boolean) { if (typeof val === &#39;string&#39;) { return val.repeat(2); } if (typeof val === &#39;number&#39;) { return val * 2; } if (typeof val === &#39;boolean&#39;) { return !val; } } 上面方法因为使用 typeof 做了类型判断，所以分别在 if 判断的作用域内 val 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。/* instanceof 类型保护 */ class Bird { nameBird: string; } class Dog { nameDog: string; } function getName(animal: Bird | Dog) { if (animal instanceof Bird) { return animal.nameBird; } if (animal instanceof Dog) { return animal.nameDog; } } 与 typeof 类似，使用 instanceof 判断了函数 getName 是否是 Bird 和 Dog 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。null 类型保护之前我们提到过在 tsconfig.json 文件 compilerOptions 的 strictNullChecks 属性设置为 true 时，则会对 null 进行严格检查，此时下面代码将会报错。function getFirstLetter(str: string | null) { return str.charAt(0); // 报错 } 此时的报错就是由于对 null 的类型保护引起的，有如下解决方法。/* 方法一 */ function getFirstLetter(str: string | null) { str = str || &#39;&#39;; return str.charAt(0); } /* 方法二 */ function getFirstLetter(str: string | null) { if (str == null) { return &#39;&#39;; } return str.charAt(0); } 上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 str 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。function getFirstLetter(str: string | null) { function log() { console.log(str.tirm()); // 报错 } str = str || &#39;&#39;; log(); return str.charAt(0); } 上面代码中，str 调用 tirm 方法的代码封装在了函数 log 内部，当 log 调用时 str 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 log 的时候就已经在函数内部报错了。function getFirstLetter(str: string | null) { function log() { console.log(str!.tirm()); // 强制调用 } str = str || &#39;&#39;; log(); return str.charAt(0); } 上面代码在 log 函数中，str 调用 tirm 方法时加了一个 !，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 getFirstLetter 的参数类型检查。链判断运算符上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 JS 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 ?. 来调用。/* 链判断运算符的几种用法 */ a?.b; // 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于 a == null ? undefined : a.b; a?.[b]; // 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于 a == null ? undefined : a[b]; a?.b() // 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()，如果 a.b 不是一个函数抛出类型错误，等同于 a == null ? undefined : a.b(); a?.() // 如果 a 不是函数则返回 undefined，否则执行 a()，等同于 a == null ? undefined : a(); 可辨识的联合类型可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。interface WarningButton { class: &#39;warning&#39;; name1: &#39;modified&#39;; } interface DangerButton { class: &#39;danger&#39;; name2: &#39;delete&#39;; } // 定义联合类型 type Button = WarningButton | DangerButton; function getButton(button: Button) { if (button.class === &#39;warning&#39;) { return button.name1; } if (button.class === &#39;danger&#39;) { return button.name2; } } in 操作符在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 in 操作符和不同属性判断进行类型保护。interface Bird { talon: number; } interface Dog { leg: number; } function getNumber(animal: Bird | Dog) { if (&#39;talon&#39; in animal) { console.log(animal.talon); } if (&#39;leg&#39; in animal) { console.log(animal.leg); } } 自定义类型保护TS 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。interface Bird { talon: number; } interface Dog { leg: number; } // 自定义类型保护函数 function isBird(animal: Bird | Dog): animal is Bird { // return (animal as Bird).talon &gt; 0; return (&lt;Bird&gt;animal).talon &gt; 0; } function getNumber(animal: Bird | Dog) { if (isBird(animal)) { console.log(animal.talon); } else { console.log(animal.leg); } } 上面的自定义保护函数 isBird 中参数类型与 getNumber 参数一致，返回值的 animal is Bird 是一个类型谓词，语法为 param is type，代表返回是否满足 Bird 接口，由于 animal 并不知道自己符合哪一个接口，所以使用类型断言指定成了 Bird，isBird 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 isBird 就可以在 getNumber 中使用并实现类型保护。类型变换交叉类型交叉类型表示为将多个类型合并为一个类型。interface Bird { name: string; fly(): void; } interface Person { name: string; eat(): void; } // 取的是接口的并集 type BirdMan = Bird &amp; Person; // 实现接口必须包含两个接口所有的属性和方法 let birdMan: BirdMan = { name: &#39;niao&#39;, fly() { console.log(&#39;fly&#39;); }, eat() { console.log(&#39;eat&#39;); } }; typeof 获取类型在 TS 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 typeof 关键字快速获取一个变量的类型。/* 先定义类型，后定义变量 */ interface People { name: string; age: number; } let p: People = { name: &#39;hello&#39;, age: 20; }; /* 先定义变量，后定义接口 */ let p: People = { name: &#39;hello&#39;, age: 20; }; type People = typeof p; function getName(p: People) { return p.name; } 上面获取的类型定义 People 是根据 p 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。索引访问操作符TS 中的索引访问操作符指可以通过 [] 获取一个类型的子类型。// 定义嵌套类型接口 interface Person { name: string; age: number; // 对象，包含 name 属性 job: { name: string; }; // 成员为对象组成的数组，对象中含有 name 和 level 属性 hobbies: { name: string; level: number }[]; } // 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型 let FEJob: Person[&quot;job&quot;] = { name: &quot;FE&quot; }; // 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型 let hobbyLevel: Person[&#39;hobbies&#39;][0][&#39;level&#39;] = 10; keyofTS 中定义的关键字 keyof 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 string 不准确，因为很可能传入一个对象本身没有的属性字符串，keyof 就是用来解决类似这样问题的。interface Person { name: string; age: number; gender: &#39;male&#39; | &#39;female&#39;; } // 使用 keyof 定义类型 type PersonKey = keyof Person; function getValueByKey(p: Person, key: PersonKey) { return p[key]; } let: person: Person = { name: &#39;hello&#39;, age: 20, gender: &#39;male&#39; }; getValueByKey(person, &#39;name&#39;); // hello getValueByKey(person, &#39;say&#39;); // 报错 映射类型在某一个类型定义中使用 in 操作符和 keyof 操作符批量映射修改一个新的类型定义。interface Person { name: string; age: number; gender: &#39;male&#39; | &#39;female&#39;; } // 映射 Person 接口定义的类型，把每一个属性都变成可选的 type PartPerson = { [key in keyof Person]?: Person[key]; } let p1: PartPerson = { name: &#39;hello&#39; }; 上面的代码中 keyof Person 取到了 Person 接口的每一个属性的类型，key 通过运算符 in（批量映射）代表获取的每一个属性名，?: 代表可选，Person[key] 代表对应的值。内置工具类型在 TS 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。PartialPartial 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。// 定义接口 interface Person { name: string; age: number; } // 使用 Partial let p: Partial&lt;Person&gt; = { name: &#39;hello&#39; }; // Partial 的原理 type Partial&lt;T&gt; = { [key in keyof T]?: T[key] } RequiredRequired 可以将传入类型定义的属性变为必选，使用 -?: 替换原有的 : 也可以实现。// 定义接口 interface Person { name: string; age: number; } // 使用 Required let p: Required&lt;Person&gt; = { name: &#39;hello&#39; }; // 报错 // Required 的原理 type MyRequired&lt;T&gt; = { [key in keyof T]-?: T[key] } ReadonlyReadonly 可以将传入类型定义的属性每一项都加上 readonly 修饰符来实现属性的只读。// 定义接口 interface Person { name: string; age: number; } // 使用 Readonly let p: Readonly&lt;Person&gt; = { name: &#39;hello&#39;, age: 10 }; p.name = &#39;world&#39;; // 报错 // Readonly 的原理 type MyReadonly&lt;T&gt; = { readonly [key in keyof T]: T[key]; } PickPick 可以摘取传入类型定义的属性中的某一项返回。// 定义接口 interface Person { name: string; age: number; } // 使用 Pick let p: Pick&lt;Person, &#39;name&#39;&gt; = { name: &#39;hello&#39; }; // Pick 的原理 type MyPick&lt;T, K extends keyof T&gt; = { [key in K]: T[key]; } 内置条件类型还记得在泛型一节中提到了泛型的流程控制，在 TS 中内置了一些常用的条件类型。Exclude// 定义 Exclude&lt;T, U&gt; // 从 T 可分配给的类型中排除 U // 使用 type E = Exclude&lt;string | number, string&gt; let x: E = 10; let y: E = &#39;hello&#39;; // 报错 Extract// 定义 Extract&lt;T, U&gt; // 从 T 可分配的类型中提取 U // 使用 type E = Extract&lt;string | number, string&gt; let x: E = 10; // 报错 let y: E = &#39;hello&#39;; NonNullable// 定义 NonNullable&lt;T&gt; // 从 T 中排除 null 和 undefined // 使用 type E = NonNullable&lt;string | null | undefined&gt; let x: E = null; // 报错 let y: E = &#39;hello&#39;; ReturnType// 定义 ReturnType&lt;T&gt; // 获取函数类型的返回类型 // 使用 function getUserInfo() { return { name: &quot;hello&quot;, age: 10 }; } type UserInfo = ReturnType&lt;typeof getUserInfo&gt;; let user: UserInfo = { name: &#39;haha&#39;, age: 18 }; InstanceType// 定义 InstanceType&lt;T&gt; // 获取构造函数类型的实例类型 // 使用 class Person { constructor(public name) {} getName() { console.log(this.name); } } type P = InstanceType&lt;typeof Person&gt;; let p: P = { name: &#39;hello&#39;, getName() { console.log(&#39;myName&#39;); } }; 未完待续…","tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://www.overtaking.top/tags/TypeScript/"}]},{"title":"Node.js 实现一个提交自动检测的 Git Hook","date":"2019-04-08T18:46:40.000Z","path":"20190409024640/","text":"什么是 Git HookGit Hook 是能在 Git 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 .git/hooks 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 .sample，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。实现 Hook 功能介绍本次将使用 Node.js 实现一个 Git Hook，功能为在提交代码之前检测功能如下：检测是否为 Git 项目；检测邮箱是否符合规格；检测代码是否含有冲突；自动执行 Eslint，并检测问题。需求的由来在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 hook，下面列举的场景可能都会对团队项目持续集成的历史 “树” 造成污染，或在协同开发时对团队成员造成麻烦。邮箱错误：当团队 Gitlab 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，很可能邮箱配置错误进行了提交，而推代码到远端时发现邮箱错了，要对本地的 commit 记录修正，再重新推到远端。容易造成邮箱设置错误的常见原因：新入职员工刚刚领了新的笔记本或老员工电脑重做系统；维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 remote 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 rebase 强行修正错误的邮箱，变基后的 commit 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到 rebase 之前的公共 commit 节点。代码冲突：开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。容易造成冲突未及时处理的原因：项目过大，文件较多；编辑器不智能；前端项目使用了路由懒加载，不切换到冲突代码所在的路由对组件进行渲染，项目不会报错。Eslint 检查：有些团队的项目对代码规范要求高，并为了减小线上 Bug 率，会在项目中集成 Eslint 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。为了规避上面的情况，所以才有了这次关于 Git Hook 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。目录结构及文件简介 git-hooks |- default-events.js |- default-rules.js |- git-checker.js |- pre-commit.js default-events.js：用来编写默认的检测事件；default-rules.js：用来管理默认检测事件用到的规则（正则）；git-checker.js：用来构建 Hook 的核心逻辑；pre-commit.js：用来编写执行检测的调用逻辑。项目依赖在编写这个 hook 之前需要用到第三方模块 husky，这个模块的作用是根据项目中 package.json 的配置来向 .git/hooks 中的脚本写入我们的逻辑，项目中需要安装。$ npm install husky 代码设计思路分析设计这个 hook 时提供了 Git 目录检测、邮箱验证、冲突检测、和执行 Eslint 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。项目中的 husky 配置如下：/* 使用 hook 项目的 package.json */ { &quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot; } } } 可以看出，husky 帮我们执行了 git-hooks/pre-commit.js 文件。我们希望使用者的用法如下：/* ~git-hooks/pre-commit.js */ const GitChecker = require(&#39;./git-checker&#39;); const commitChecker = new GitChecker(&#39;pre-commit&#39;, { // default event names defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;, &#39;conflict&#39;, &#39;eslint&#39;], rules: { // your costom rules }, checkEvents: { // your custom check events } }); commitChecker.checkStart(); 上面的用法通过创建实例来创建 checker，即 “检测者”，调用 checkStart 方法帮助我们检测，创建实例的参数为 options，类型为对象。上面的用法既可以让用户通过配置 options 的 defaultEventNames 属性来选择性的使用默认的检测函数，又可以通过 checkEvents 属性来让使用者编写检测函数。rules 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 default-rules.js 文件来管理默认检测函数中使用的正则。/* ~git-hooks/default-rules.js */ module.exports = { emailCheck: /\\S+((@youemail\\.com)|(@enterprise\\.com))(\\n|\\r\\n)*$/, conflictCheck: &#39;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\\\s&#39; }; GitChecker 类的实现我们需要一个工厂创造 “检测者”，取名为 GitChecker，在 GitChecker 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 checkStart 方法时依次执行，代码如下：/* ~git-hooks/git-checker.js */ // 引入依赖 const EventEmitter = require(&#39;events&#39;); const exec = require(&#39;child_process&#39;).execSync; const chalk = require(&#39;chalk&#39;); const defaultRules = require(&#39;./default-rules&#39;); const defaultEvents = require(&#39;./default-events&#39;); const { log } = console; // 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emit class GitChecker extends EventEmitter { constructor(type, options) { super(); // 防止使用者 options 内部属性传错，进行初始化 const { rules = {}, defaultEventNames = [], checkEvents = {} } = options; // 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理 this.rules = Object.assign(defaultRules, rules); // 合并用户选择使用的默认检测函数和自定义检测函数 this.checkEvents = Object.assign(this.getDefaultEvents(defaultEventNames), checkEvents); this.type = type; // git 操作类型 this.isCommit = true; // 当前是否可以被提交 this.gitConfigEnvs = [&#39;local&#39;, &#39;global&#39;, &#39;system&#39;]; // 取邮箱时的环境 // 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向 this.forbiddenCommit = this.forbiddenCommit.bind(this); this.init(); // 初始化 } init() { // 将检测函数常用方法挂载到实例上 this.log = log; this.exec = exec; this.chalk = chalk; // 注册当前类型 git 操作对应的检测函数 this.register(this.type); } getDefaultEvents(eventsNames) { return eventsNames.reduce((memo, eventName) =&gt; { memo[eventName + &#39;CheckTask&#39;] = defaultEvents[eventName + &#39;CheckTask&#39;]; return memo; }, {}); } register(type) { Object.keys(this.checkEvents).forEach((event) =&gt; { // 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法 this.on(type, () =&gt; this.checkEvents[event](this)); }); } forbiddenCommit() { this.isCommit = false; } async checkStart() { log(chalk.green(&#39;开始代码检测&#39;)); // 发布执行检测函数 await this.emit(this.type); // 结束后结束当前 git 操作进程 this.checkEnd(); } checkEnd() { // 如果当前状态为不可提交，则退出进程号不为 0（git 规定） if (!this.isCommit) process.exit(1); log(chalk.green(&#39;检测通过&#39;)); process.exit(0); } } module.exports = GitChecker; 在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。默认检测函数的实现由于检测工厂 GitChecker 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 default-events.js 文件中统一管理。检测目录是否被 Git 管理/* ~git-hooks/default-events.js */ exports.isGitCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; { // 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目 try { exec(&#39;git status&#39;); } catch (e) { log(chalk.red(&#39;错误：当前不是一个git项目目录&#39;)); forbiddenCommit(); // 更改提交状态太为不能提交 } }; 检测是否为一个 Git 所管理的项目只需执行 git status 来检测一下文件变化，如果抛出异常则说明不被 Git 所管理。检测邮箱是否合规上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。/* ~git-hooks/default-events.js */ exports.emailCheckTask = (checker) =&gt; { const checkEmailEnvs = (i) =&gt; { // 取出正则和获取 git 邮箱的环境参数集合 const gitConfigEnvs = checker.gitConfigEnvs; const rules = checker.rules; // 获取邮箱的 git 命令 const command = &#39;git config --&#39; + gitConfigEnvs[i] + &#39; user.email&#39;; // 如果获取邮箱成功，则校验邮箱是否合规 try { const userEmail = checker.exec(command).toString(); const isValidate = rules.emailCheck.test(userEmail); if (!isValidate) { checker.log(checker.chalk.red(&#39;错误：请使用正确的邮箱提交代码&#39;)); checker.log(checker.chalk.yellow(&#39;你当前的邮箱是：&#39; + userEmail)); checker.forbiddenCommit(); } else { checker.log(checker.chalk.green(&#39;邮箱校验通过&#39;)); } } catch (e) { if (i === gitConfigEnvs.length) { checker.log(checker.chalk.red(&#39;错误：请设置git的提交邮箱&#39;)); checker.forbiddenCommit(); } else { checkEmailEnvs(i + 1); } } }; checkEmailEnvs(0); }; 在 Git 中有三个参数设置邮箱，分别 --local、--global、--system，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。检测冲突/* ~git-hooks/default-events.js */ exports.conflictCheckTask = (checker) =&gt; { // 对文件进行正则匹配的 git 命令 const command = &#39;git grep -n -P -E &quot;&#39; + rules.conflictCheck + &#39;&quot;&#39;; // 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码 try { const conflicts = checker.exec(command, { encoding: &#39;utf-8&#39; }); if (conflicts) { checker.log(checker.chalk.red(&#39;错误：发现冲突，请解决后再提交&#39;)); checker.log(checker.chalk.red(&#39;错误代码：&#39;)); checker.log(checker.chalk.red(conflicts.trim())); checker.forbiddenCommit(); } } catch (e) { checker.log(checker.chalk.green(&#39;未发现冲突&#39;)); } }; 在上面的 Git 命令中，-n 为显示匹配文件的行号，因为 shell 的正则支持不全，-P 和 -E 是为了支持正则扩展，保证正则生效。执行 Eslint/* ~git-hooks/default-events.js */ exports.eslintCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; { try { exec(&#39;lint-staged&#39;); log(chalk.green(&#39;Eslint 校验通过&#39;)); } catch (e) { log(chalk.red(&#39;错误：Eslint 校验不通过&#39;)); forbiddenCommit(); } }; Eslint 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 Eslint 的项目，如果项目已经集成了 Eslint 可以不适用检测冲突函数。关于扩展当需求变更，需要在 push 之前执行某些脚本应该怎么办，可以在 git-hooks 文件夹增加一个 pre-push.js 文件，文件内容如下。/* ~git-hooks/pre-push.js */ const GitChecker = require(&#39;./git-checker&#39;); const pushChecker = new GitChecker(&#39;pre-push&#39;, { defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;], // default event names rules: { // your costom rules }, checkEvents: { myHook: ({ log, chalk, forbiddenCommit }) =&gt; { log(chalk.red(&#39;check prev push&#39;)); forbiddenCommit(); } } }); commitChecker.checkStart(); 由于我们的 hook 依赖于 husky，所以项目 package.json 中的 husky 也有所修改如下：/* 使用 hook 项目的 package.json */ { &quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot;, &quot;pre-push&quot;: &quot;node git-hooks/pre-push&quot; } } } 最后以上就是本次 Git Hook 的使用场景和实现，也希望通过本文，能让大家对 Git Hook 的相关知识有一定了解，另附赠 Github 地址 git-hooks。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Hooks","slug":"Hooks","permalink":"https://www.overtaking.top/tags/Hooks/"},{"name":"Git","slug":"Git","permalink":"https://www.overtaking.top/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.overtaking.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"命令行","slug":"命令行","permalink":"https://www.overtaking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"Git 系列之 Github 团队协作","date":"2019-03-26T18:51:16.000Z","path":"20190327025116/","text":"Github 的由来尽管当时 Git 对于代码的管理以及团队协作方面已经非常出色，但是 Git 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 Git 特性的代码平台的诉求成为必然，基于 Git 的这个局限，Github 就这样诞生了。如何在 Github 高效的搜索项目如今 Github 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 Github 上托管的仓库数量巨大，这对在 Github 上寻找需要的开源项目造成了困扰，其实在 Github 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。在登录 Github 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 Advanced search（高级搜索）就会跳转到高级搜索页面。From these owners：按照作者名搜索，格式 user:username；In these repositories：按照仓库名称搜索，格式 repo:username/reponame；Created on the dates：按照创建日期搜索，格式 created:&lt;YYYY-MM-DD；Written in this language：按照语言进行搜索，格式 language:JavaScript；With this many stars：按照星星数查找，格式 stars:&gt;1000；上面列举只是常用的部分搜索方式和格式，具体可以查看 https://github.com/search/advanced，也可以不通过高级搜索的页面直接将规则写在 Github 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 partcontent in readme。Organizations（组织）在 Github 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。创建组织步骤（如 Github 功能更新请搜索最新教程或自行探索）如下：个人信息 setting；进入界面点击左侧 Organizations；点击右上角 new organization；填好组织信息后点击下方 Create organization。添加后的组织会出现在用户 setting 页面的 Organizations 选项中，点击进入某个组织，可以添加 Github 中能搜索到的成员进行协同开发、在组织下新建仓库、创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。怎样选择适合团队的工作流一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。主干开发主干开发是围绕着一条主开发分支进行开发，团队所有成员的 commit 都及时的集成在这条主分支，让团队其他成员第一时间知道。主分支开发工作流适用团队：适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。Git FlowGit Flow 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图：Git Flow 工作流master：专门用来存储正式发布的历史；develop：作为功能的集成分支，可以多团队、跨迭代同时在 develop 分支集成；feature：专门用来开发某一个新功能，仅仅只和 develop 交互；release：发布（提测）分支，当快要到达发既定发布时间，从 develop 分支分出用来 bugfix、上线、与 master 进行合并，同时与 develop 进行合并；hotfix：上线后从 master 分出用来修复线上 Bug。适用团队：对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。Github FlowGithub Flow 工作流就是基于 master 的某一个 commit 拉一条特性分支进行开发，在开发完毕后再重新集成到 master 的工作流。Github 工作流适用团队：不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。Gitlab FlowGithub Flow 是在 Github Flow 的基础上做了一些优化，新增了平行的 production 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。Gitlab 工作流适用团队：适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；适用同一个时间节点项目发布出去会有多个版本同时存在的情况（公共库）。Create pull request在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 master 主分支，需要提交 pull request，在 Github 项目页面点击上面的 Pull requests 按钮，上面有两个选项：base：目标分支；compare：合并的特性分支。在选好 base（目标分支） 和 compare（合并的特性分支） 后，点击下方 Create pull request，填写提交的描述信息后再次点击 Create pull request，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。pull request 有三种模式：Create a merge commit：直接将某一个特性分支通过 merge 的方式合并到 master；Squash and merge：会将特性分支的所有变更集组合成一个 commit 合并到 master 当前指向的节点之后，特性分支的树将独立；Rebase and merge：会将特性分支变更集直接合并到 master 当前指向的节点之后，特性分支的树将独立。选择 pull request 模式后，需要对这个 pull request 进行再次确认，填写确认信息并点击 Confirm merge 确认合并，在完成合并后 Github 会给我们提供删除特性分支的快捷按钮 Delete branch，一般会等到项目稳定后才会删除特性分支。IssuesIssues 用于追踪需求和任务，在开源项目中使用者发现 Bug 或有新的需求都是通过 Issues 提出，在 Issues 的 Labels 中有开发者设置的代表当前处理状态的标签，通过 Issue 上的状态标签可以知道 Issue 的处理进度。创建 Issue创建 Issue 的步骤：点击项目的 Issues 进入 Issues 页面；点击 New Issue;填写 Issues 的标题及内容；点击 Submit new issue 创建 Issue。创建 Issue 模版Issues 的类型不是单一的，项目的所有者是可以给项目的 Issues 添加分类模版的，操作如下：进入项目的 Setting 页面；点击 Issues 选项的 Set up templates 按钮进入设置页面；通过下拉框选择 Issues 模版的类型，分类如下：Bug report：用来提出项目中的 Bug；Feature request：用来提出新的需求和功能；Custom issue template：自定义的模版类型，由项目所有者创建时决定具体用途。点击 Preview and edit 对添加的 Issue 模版进行编辑，编辑后点击 Close preview 保存编辑的内容；添加 Issues 模版后点击 Propose changes；添加本次修改的记录，同时可以选择用 master 分支还是新创建分支来管理这些 Issues；点击 Commit changes 则会生成模版，再次执行创建 Issues 的步骤时可以看到设置的模版；点击模版对应的 Get started 快速生成对应的模版。在编辑模版后，模版会生成对应 markdown 文件被保存在项目中的 .github/ISSUE_TEMPLATE 路径下。Issues 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 Issue 中的内容进行评论交流，甚至可以直接 @ 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 Issue 中提出的问题。Projects在开源项目开发时可以为当前项目的某个正在进行的迭代创建 Project，创建的 Project 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 Issue 和 pull request（需要在创建 Issue 和 pull request 时选中关联这个 Project）。创建 Project 步骤如下：进入项目的 Projects 页面；点击 Create a project；填写项目的名称和描述并点击下方 Create project。在看板中分别对应四个区域如下：To do：将要完成的任务；In progress：正在进行中的任务；Needs review：需要复盘的任务；Reviewer approved：已经审核通过的任务。任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。分支保护在 Github 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。设置分支保护步骤：进入项目的 Setting 页面；选中左侧的 Branches 选项；点击 Add rule 来添加保护规则；Branch name pattern 内制定要保护的分支名字；Rule settings 中可以设置分支保护规则。可选规则（可根据项目需求和要保护分支的安全级别多选）如下：Require pull request reviews before merging：选中该项后所有的提交合并都必须通过 pull request 进行，下面有三个子选项如下：Required approving reviews：同意 pull request 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；Dismiss stale pull request approvals when new commits are pushed：勾选后在有新的 pull request 时会撤销旧的 pull request；Require review from Code Owners：勾选该项后，pull request 必须通过项目所有者的通过才能进行合并。Require status checks to pass before merging：在合并前必须通过状态检查才能合并，状态检查如下：Require branches to be up to date before merging：要求分支在合并之前是最新的。Require signed commits：勾选该项后要求在提交时验证签名；Include administrators：加入管理员执行所有限制的配置。WikiWiki 是 Github 提供的说明文档功能，点击项目上的 Wiki 选项进入文档页面，在项目从来没有编辑过文档页面时，会默认出现 Create the first page 按钮，点击则会跳转编辑 Wiki 的页面，可以输入 Wiki 标题、内容和提交信息，内容支持 Markdown 语法编写。当已经创建过一个 Wiki page 后再次进入项目的 Wiki 页面，会在右上角显示 Edit 和 New page 按钮，分别用于修改和新增 Wiki page，在左侧有所有 Wiki page 的列表，最下面是 Wiki 的仓库地址，也可以通过编辑器在本地创建 Wiki page，编写后通过 Git 推送到 Wiki 仓库。在 Wiki 页面还有两个扩展功能，分别为 Add a custom footer 和 Add a custom sidebar，用于创建自定义底部和侧边栏（如编写目录等）。总结Github 管理项目实现协同开发是非常便捷的，在 Github 中每一个的操作的参与者和被参与者都会收到 Github 邮件进行通知，进入邮件链接也可以直接对项目变化进行 code review，在企业级项目中目前 Gitlab 的私有仓库更流行，基本功能与 Github 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件。","tags":[{"name":"Git","slug":"Git","permalink":"https://www.overtaking.top/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.overtaking.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Github","slug":"Github","permalink":"https://www.overtaking.top/tags/Github/"}]},{"title":"Git 系列之实战技及巧注意事项总结","date":"2019-03-15T03:50:08.000Z","path":"20190315115008/","text":"前言Git 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 Git 的基础上来详细总结一下这些注意事项。分离头指针在日常开发时，我们经常都是在某一个分支下进行的，commit 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 Git 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 commit 非常的感兴趣，并希望在这个 commit 下去做一些事情，可以执行下面命令实现。$ git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2 当切换分支后对某些文件做一些修改，并重新 commit。$ git add . $ git commit -m &#39;分离头指针测试&#39; $ git log 执行上面命令后我们发现新的 commit 信息后面不在对应某一个分支，而是 HEAD，这种情况下就代表着我们的 Git 目前已经处于分离头指针的状态了。分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 commit 在重新切换分支时，会被 Git 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。分离头指针优缺点：优点：尝试性的 commit 可以在分离头指针的状态下进行；缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 commit 丢失。在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。$ git branch 分支名 分离头指针状态的提交（哈希值） 修改本地 commit修改最近一次提交$ git commit --amend --amend 可以将暂存区新存入的内容同时提交到最近的一次 commit 中，而不会生成新的 commit，同时也可以修改 commit 时的提交信息。修改任意一次提交$ git rebase -i a4d56bb 该操作为 git rebase 命令的交互模式，即输入 -i 命令，后面所输入的 commit 哈希值并不是要修改的 commit，而是要修改的 commit 的父级 commit 哈希值，在执行命令后会弹出修改的交互界面如下。第一个交互界面：pick 52f3935 add css file - pick 91bd053 change css + reword 91bd053 change css # Rebase a4d56bb..91bd053 onto a4d56bb (2 commands) # # Commands: # p, pick &lt;commit&gt; = use commit # r, reword &lt;commit&gt; = use commit, but edit the commit message # e, edit &lt;commit&gt; = use commit, but stop for amending # s, squash &lt;commit&gt; = use commit, but meld into previous commit # ... 从上面的信息来看第一条代表当前要修改的 commit，第二条代表该分支最新的 commit，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 pick 修改成 reword 并保存，保存后会弹出下一个修改提交信息的界面如下。第二个交互界面：- css content + add css content # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Date: Tue Mar 19 14:48:22 2019 +0800 # # interactive rebase in progress; onto a4d56bb # Last command done (1 command done): # reword 9e4f711 add css content # Next command to do (1 remaining command): # pick c220cf2 change css # You are currently editing a commit while rebasing branch &#39;test&#39; on &#39;a4d56bb&#39;. # # Changes to be committed: # new file: index.css 该界面上为 commit 的 message，修改后保存，就完成了对该 commit 的修改，值得注意的是，使用 git log 查看历史可以发现，修改 commit 时指定的父级 commit 后所有的 commit 哈希值都会发生变化。修改 commit 后的提示信息：[detached HEAD de48b04] add css content Date: Tue Mar 19 14:48:22 2019 +0800 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 index.css Successfully rebased and updated refs/heads/test. 可以看出，其实使用 git rebase 命令修改 commit 的原理也是分离头指针，只是在分离头指针修改 commit 后又重新将当前分支的指针指回了最新的 commit。将多个连续的 commit 合并成一个将多个 commit 合并成一个的原理与修改任意一个 commit 的原理相同，都是通过 git rebase 命令的交互模式实现的（-i），参数为合并几个 commit 的父级 commit 哈希值。查看历史：$ git log --oneline # edd2400 (HEAD -&gt; test) add content to readme # 50a015c add background css # 15237d2 change css # 4a8fd80 add css content # 5149bad new READ.md # 7f73a76 new html 现在我们尝试将 50a015c、15237d2 和 4a8fd80 这三个 commit 合并成一个，与修改 commit 唯一不同的是被修改的 commit 参数不再是 reword，而是 squash，多个要合并的 commit 之中有一个目标 commit，这个 commit 的参数必须是 pick。第一个交互界面：pick 4a8fd80 add css content - pick 15237d2 change css - pick 50a015c add background css + squash 15237d2 change css + squash 50a015c add background css pick edd2400 add content to readme # Rebase 5149bad..edd2400 onto 5149bad (4 commands) # # Commands: # p, pick &lt;commit&gt; = use commit # r, reword &lt;commit&gt; = use commit, but edit the commit message # e, edit &lt;commit&gt; = use commit, but stop for amending # s, squash &lt;commit&gt; = use commit, but meld into previous commit # ... 对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 commit 与修改单个 commit 不同的是，第二个界面会展示所有被合并 commit 的信息，我们可以为合并后的 commit 添加一个新的 message。第二个交互界面：# This is a combination of 3 commits. + + css changes + # This is the 1st commit message: add css content # This is the commit message #2: change css # This is the commit message #3: add background css # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Date: Tue Mar 19 14:48:22 2019 +0800 # # interactive rebase in progress; onto 5149bad # Last commands done (3 commands done): # squash 15237d2 change css # squash 50a015c add background css # Next command to do (1 remaining command): # pick edd2400 add content to readme # You are currently rebasing branch &#39;test&#39; on &#39;5149bad&#39;. # # Changes to be committed: # new file: index.css 查看合并提交后的历史：$ git log --oneline # 2c84584 (HEAD -&gt; test) add content to readme # ac001bc css changes # 5149bad new READ.md # 7f73a76 new html 将多个间隔的 commit 合并成一个上面的 commit 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 commit 中要合并的树是间隔的，使用 git rebase 命令同样可以做到。查看历史：$ git log --oneline # 23d6939 (HEAD -&gt; test) append content into readme # 178ea29 link css in html # 2c84584 add content to readme # ac001bc css changes # 5149bad new READ.md # 7f73a76 new html 在之前使用 git rebase 命令时都是将操作 commit 的父级 commit 作为参数，如果我们要操作的 commit 已经没有父级 commit，接下来在合并多个间隔的 commit 时来测试一下这样的情况，接下来将 7f73a76 和 178ea29 两个关于 html 文件的操作合并成一个。执行命令：$ git rebase -i 7f73a76 由于我们要操作的 commit 已经没有了父级，所以我们就在执行命令时传入这个 commit，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 commit，所以需要手动补上，而间隔的 commit 要移动到和合并的目标 commit 连续的位置。第一个交互界面：+ pick 7f73a76 + squash 178ea29 link css in html pick 4a8fd80 add css content pick 5149bad new READ.md pick ac001bc css changes pick 2c84584 add content to readme - pick 178ea29 link css in html pick 23d6939 append content into readme # Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands) # # Commands: # p, pick &lt;commit&gt; = use commit # r, reword &lt;commit&gt; = use commit, but edit the commit message # e, edit &lt;commit&gt; = use commit, but stop for amending # s, squash &lt;commit&gt; = use commit, but meld into previous commit # ... 在保存后出现如下报错信息，是因为 commit 的父节点是我们新增上去导致的。提示信息：The previous cherry-pick is now empty, possibly due to conflict resolution. If you wish to commit it anyway, use: git commit --allow-empty Otherwise, please use &#39;git reset&#39; interactive rebase in progress; onto 7f73a76 Last command done (1 command done): pick 7f73a76 Next commands to do (5 remaining commands): squash 178ea29 link css in html pick 5149bad new READ.md You are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;. nothing to commit, working tree clean Could not apply 7f73a76... 执行 git status 提示信息：Last command done (1 command done): pick 7f73a76 Next commands to do (5 remaining commands): squash 178ea29 link css in html pick 5149bad new READ.md (use &quot;git rebase --edit-todo&quot; to view and edit) You are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;. (all conflicts fixed: run &quot;git rebase --continue&quot;) nothing to commit, working tree clean 想继续合并：$ git rebase --continue 想还原回合并之前：$ git rebase --abort 如果在继续合并后没有出现第二个交互界面（与合并连续 commit 类似，用来新增合并后 commit 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。查看合并后的历史：$ git log --oneline # 4d4f771 (HEAD -&gt; test) append content into readme # a83f526 add content to readme # 463fd85 css changes # 7e44e19 new READ.md # 753ebcd about html changes 注意：当前对 commit 的变更和合并操作只是对 commit 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 commit 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。删除后提交的 commit在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 commit，但是发现有更好的方案，想要删除这些 commit，这时可以通过将 HEAD 指针重新指向这些 commit 之前的提交，命令如下。$ git reset --hard 版本号 这样的操作会导致工作区、暂存区的代码都会到这个 commit 的状态，当然也有 “后悔药”，可以使用 git reflog 找到所有的 commit 版本号 包含已删除），再通过同样的方式将 HEAD 的指针指回去。$ git reflog $ git reset --hard 已删除的版本号 忽略上传的文件在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 .idea 等，或者这个文件夹非常的大，如 node_modules，我们可以通过 .gitignore 文件来配置忽略上传的文件。在 .gitignore 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 .gitignore，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。先将要忽略的文件添加到 .gitignore，然后执行下面命令对之前添加的文件进行删除操作。$ git rm --cached 文件名/文件夹 在开发当中处理紧急发布（CR）任务在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 Bug 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。当前代码跟要修复代码在同一条分支：将当前代码暂存；修复代码后合并到 dev 发布测试环境验证，通过后发布；恢复暂存代码继续开发；$ git stash $ git stash pop 当前代码跟要修复的代码不在同一条分支：提交当前分支代码；切换到 master 分支创建一条新分支；修复问题并提测；验证通过后合并到 master 或 dev 分支发布；回到开发新功能 feature 分支将修复代码（hotfix）集成进来并继续开发。$ git add . $ git commit -m &#39;message&#39; $ git checkout master $ git checkout -b 修复问题分支 $ git checkout 测试分支 $ git merge 修复问题分支 $ git checkout 开发分支 $ git rebase 测试分支 当然上面的思路仅供参考，因为不同的团队规范有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 git reset 命令实现。non-fast-forwards 和 fast-forwards在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。推送代码时的错误信息：error: failed to push some refs to &#39;git@github.yourRepository.git&#39; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. fast-forwards 是指将本地分支推送到远端，tree 上两个分支拥有共同的 “祖先”，可以自动合并成一个 tree，而 non-fast-forwards 正好相反，两个分支的 tree 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 tree 整理成 fast-forwards 的状态。实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 fast-forwards 状态后再进行推送，拉取远端分支可以使用 fetch 或 pull，区别在于 fetch 拉取回来的代码仍然是 non-fast-forwards 状态，需要手动 merge 进行合并或 rebase（因为有些团队比较喜欢线性的提交记录以便追溯）操作，而 pull 将 fetch 和 merge 这两个步骤合二为一。注意：使用 fetch 拉取代码在进行 merge 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 README.md 等文件造成的，则需要在 merge 时加上 --allow-unrelated-histories 参数去允许历史上完全独立的两棵树进行合并，达到 fast-forwards 的状态。合并不相关的树：$ git merge 本地分支 --allow-unrelated-histories 远端分支 执行命令后会弹出交互界面可以修改本次合并的 message。Git 多人单分支集成协作多人协同开发时本地仓库与远端的同步在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。同步新分支信息：$ git fetch 地址别名 查看新分支：$ git branch -av 拉取新分支到本地：$ git checkout -b 新分支名 地址别名/新分支名 还有一种场景也需要通过上面的方式来同步仓库信息，就是在 Github 中帮助别人的项目贡献代码或修复 Issue 时，首先需要 Fork 别人的仓库，但是 Fork 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 Fork 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 push request 的方式让原作者进行代码审核并合并到原始仓库。不同人修改不同文件的处理方式在实际开发中，两个人在一条分支开发，当 A 同学修改了 a 文件，B 同学修改了 b 文件时，此时 B 同学先进行了提交，A 同学并不知道的情况下，在 A 同学推送代码到远端时会变成 non-fast-forwards 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 commit 回退到与远端完全一致的 commit 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。撤销本地新的提交：$ git reset 与远端相同的提交 不同的人修改相同文件不同区域的处理方式我们将上面 A、B 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 B 先提交到远端，A 不知情的情况下推送代码到远端，一样会变成 non-fast-forwards，同样可以通过上面的方式处理，Git 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 fast-forwards 状态。不同的人修改相同文件相同区域的处理方式依然沿用上面 A、B 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，B 先提交到远端，A 在提交到远端时有因为状态为 non-fast-forwards 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。合并后报错：... Auto-merging yourfile CONFLICT (content): Merge conflict in yourfile Automatic merge failed; fix conflicts and then commit the result. 由于两个人操作了同一个区域导致 Git 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。在解决冲突时可能存在的情况：两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；两个人开发功能重复了，需要进行沟通协商决定保留哪一个。在手动处理冲突对文件进行合并时，可以通过 git status 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。撤销合并：$ git merge --abort 不同的人同时变更文件名的处理方式在不同人同时修改同一个文件名时，Git 时无法处理的，当然会变成 non-fast-forwards 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。$ git rm oldfilename $ git add newfilename $ git commit -m &#39;merge message&#39; $ git push 在一个人修改文件名，其他人修改内容的情况下，Git 的文件内容都是通过 blob 对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 Git 可以非常智能的检测并同步。禁止在已共享的集成分支使用强推“强推” 是指使用 git push -f 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 non-fast-forwards 状态，我们可以理解为这是 Git 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 non-fast-forwards 状态强行将代码推送到远端。在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 non-fast-forwards 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 HEAD 指向的 commit 之后所有的提交历史都将丢失。禁止在已共享的集成分支上做变基操作还记得前面 修改本地 commit 一节中强调 rebase 操作只适用于修改本地还未同步到远端的 commit，这是因为如果对已经同步到远端的进行了变基操作会导致 commit 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 commit 之上在做新的开发，会导致无法将本地代码推送到远端。有些团队严令禁止对集成分支做变基操作，被称作 “rebase 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 commit 之后做变基操作。如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令：$ git pull --rebase 或者分为两步走，把远端变基后的分支 fetch 到本地，再把本地的当前分支基于 fetch 下来的远端分支做 rebase 操作，命令如下：$ git fetch $ git rebase 地址别名/分支名 总结本文内容是自己在对 Git 的学习和工作中总结的笔记，另外想了解 rebase 和 merge 更详细的信息推荐阅读 git rebase vs git merge 详解。","tags":[{"name":"Git","slug":"Git","permalink":"https://www.overtaking.top/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.overtaking.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"命令行","slug":"命令行","permalink":"https://www.overtaking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"Git 系列之 .git 内部刨析","date":"2019-03-10T15:38:56.000Z","path":"20190310233856/","text":"HEAD 文件HEAD 文件内容：ref: refs/heads/master ref 代表引用，refs/heads/master 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支操作时，HEAD 文件中的 ref 值会随着切换的分支变化。config 文件config 文件基本内容：[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [user] name = yourname email = youremail [core] 代表当前 Git 管理中的主要配置，[user] 代表用户配置，随着 Git 管理的不断复杂，所有的配置项都将被存放在 config 文件中。refs 文件夹分支 headsheads 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 commit 对象。查看 heads 文件夹：$ ls -al .git/refs/heads # drwxr-xr-x 3 systemname staff 96 2 24 17:31 . # drwxr-xr-x 5 systemname staff 160 2 12 17:35 .. # -rw-r--r-- 1 systemname staff 41 2 24 17:31 master 查看分支文件：$ cat .git/refs/tags/master # ef5aaed0707989ebc069efcd842424f6315ab4e2 $ git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2 # commit 其实使用 git checkout 命令切换分支时，就是在更改 HEAD 文件的引用内容，即上面提到的 ref: refs/heads/branchname，进而找到 heads 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。标签 tags在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 v0.0.1 开发到 v1.0.0，可以专门为这个版本的 commit 打上一个标签，而 refs/tags 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 tag 对象，tag 对象中存储着当前标签对应历史版本的 commit 对象。查看 tags 文件夹：$ ls -al .git/refs/tags # drwxr-xr-x 6 systemname staff 192 2 24 17:31 . # drwxr-xr-x 5 systemname staff 160 2 12 17:35 .. # -rw-r--r-- 1 systemname staff 41 2 15 18:33 1.0.0 查看标签文件：$ cat .git/refs/tags/1.0.0 # ef5aaed0707989ebc069efcd842424f6315ab4e2 $ git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2 # object bcadbfea5e937e9b5eaed113dd8149c86124d72a # type commit # tag 1.0.0 # tagger yourusername &lt;youruseremail&gt; 1550212832 +0800 $ git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a # commit 可以使用 git cat-file 命令查看文件对象类型。objects 文件夹查看 objects 内部$ ls -al .git/objects # drwxr-xr-x 72 systemname staff 2304 2 24 17:31 . # drwxr-xr-x 13 systemname staff 416 3 14 15:43 .. # drwxr-xr-x 4 systemname staff 128 2 24 17:29 00 # ... # drwxr-xr-x 3 systemname staff 96 2 24 17:29 f9 # drwxr-xr-x 2 systemname staff 64 2 12 16:59 info # drwxr-xr-x 2 systemname staff 64 2 12 16:59 pack 在 objects 文件夹中，除了 info 和 pack 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 Git 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 git cat-file 可以查看该完整哈希值的对象类型，肯能为 tree、blob、commit。Git 对象：tree：树对象，存储内容为 blob 对象的哈希值和对应的文件名称；blob：存储文件内容，只要文件内容相同，则始终生成唯一一个 blob 对象；commit：存储提交的相关信息。tree、commit、blob 对象的关系在 Git 中最重要的就是这三个对象以及它们之间的关系，这对于理解 Git 的原理非常有帮助，下面有一张关系图。tree、commit、blob 关系图commit 对象中，tree 代表提交时所在的树，一个 commit 对象只会对应一棵树，tree 对象存储的只是当前 commit 时，所有文件目录的一个 “快照”，tree 对象中的 tree 对象代表该文件夹中还有文件夹，tree 中的 blob 对象代表文件，blob 对象中存储的是文件内容，Git 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。blob 对象是在将文件增加到暂存区后创建的，commit 和 tree 对象在进行提交操作后创建。hooks 文件夹hooks 文件夹，默认存储了一系列的 hook 文件，用于在执行某些特定的 Git 命令时，在某个生命周期执行，内部可以编写 shell 脚本，也可以通过 hasky 等 npm 包来介入。例如下面文件：# ... pre-commit.sample # 提交前执行 pre-push.sample # 推送前执行 pre-rebase.sample # 变基前执行 # ... 上面的文件默认扩展名为 sample，即默认不生效，要想在某个 Git 操作时可以执行对应的 hook 文件，只需要去掉对应 hook 文件的扩展名即可。","tags":[{"name":"Git","slug":"Git","permalink":"https://www.overtaking.top/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.overtaking.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"命令行","slug":"命令行","permalink":"https://www.overtaking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"Webpack4 —— 应用篇","date":"2018-11-15T02:56:56.000Z","path":"20181115105656/","text":"系列文章链接：Webpack4 —— 基础篇Webpack4 —— 优化篇多页面打包通用方案多页面应用简介多页面（MPA）和单页面（SPA）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 .html 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。多页面的优势是页面与页面之间是相互解耦的，对 SEO 更加友好，缺点是每次新增或删除页面都需要更改构建的配置。基础的多页面配置const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { entry: { admin: path.resolve(__dirname. &#39;src/pages/admin/index.js&#39;), search: path.resolve(__dirname. &#39;src/pages/search/index.js&#39;) }, output: { filename: &#39;[name][chunkhash:8].js&#39;, path: &#39;./dist&#39; }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, // 模板文件路径 filename: &#39;index.html&#39;, // 输出文件名称 // ... }), new HtmlWebpackPlugin({ template: &#39;./src/search.html&#39;, filename: &#39;search.html&#39;, // ... }), ] // ... } 上面是一个基础的多页面配置，如果开发过程成页面的增加非常快速，且多人同时开发，这样每增加一个页面都需要在 entry 中增加一个入口，在 plugins 中增加一个 HtmlWebpackPlugin 插件的实例，这样的维护方式并不优雅。我们更希望增加页面时不需要更改 Webpack 配置文件，而是可以动态的向 entry 和 plugins 中添加配置。动态的多页面配置按照上面的优化思路，我们需要在 Webpack 配置中读取本地某一个固定目录的文件，以知道有哪些页面需要配置，当然我们可以使用 fs 模块自己实现，在这里更推荐使用 glob 模块，glob 模块可以通过通配符的方式按照定义的规则去匹配文件目录。安装依赖：$ npm install glob html-webpack-plugin -D 动态生成页面配置：const path = require(&#39;path&#39;); const glob = require(&#39;glob&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const setMPA = () =&gt; { const entry = {}; const htmlPlugins = []; const pathMatch = path.resolve(__dirname, &#39;./src/pages/*/index.js&#39;) const entryFiles = glob.sync(pathMatch); entryFiles.map((pagePath) =&gt; { const pageName = pagePath.match(/.*\\/(.*)\\/index.js/)[1]; entry[pageName] = pagePath; htmlPlugins.push(new HtmlWebpackPlugin({ template: &#39;./src/pages/&#39; + pageName + &#39;/index.html&#39;, // 模板文件路径 filename: pageName + &#39;.html&#39;, // 输出文件名称 chunks: [pageName], // 使用的 chunk 名称 inject: true, // 将 js 资源放在 body 底部 minify: { collapseWhitespace: true, // 是否删除空白符与换行符 removeAttributeQuotes: true, // 是否移除引号 minifyCSS: true, // 压缩 CSS minifyJS: true, // 压缩 JS removeComments: true // 是否移除 HTML 中的注释 } })); }); return { entry, htmlPlugins }; } module.exports = setMPA(); 首先我们创建一个模块，模块中创建 setMPA 函数专门用来对页面进行动态化处理，函数返回 entry 和 HtmlWebpackPlugin 的实例，首先通过 glob 的 sync 同步读取本地目录 pages 下的文件，获取页面文件的绝对路径（数组），循环的过程中匹配页面名称，并根据页面名称动态的创建 entry 和 HtmlWebpackPlugin。动态化配置示例：const path = require(&#39;path&#39;); const {entry, htmlPlugins} = require(&#39;./setMPA&#39;); module.exports = { entry, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name][chunkhash:8].js&#39; }, plugins: [ ...htmlPlugins ] } 在 Webpack 配置中只需要引入 setMPA 模块，解构出 entry 和 HtmlWebpackPlugin 的集合，并写在对应的配置上，这样就化解了有人新增页面就要增加对应页面配置的尴尬。集成 ESlintESlint 介绍ESlint 的作用是对项目的 JS 代码进行规范检查和风格统一，可以减少代码中的隐患和潜在问题，团队越大开发人员越多体现越明显，团队也可以根据实际情况制定规范。ESlint 可以与 lint-staged 和 husky 等模块在代码提交阶段进行检测，可以与 Gitlab 和 Github 等代码管理平台中的 CI/CD 进行集成，也可以在发布平台云构建过程中进行规范检查。/* package.json */ { &quot;script&quot;: { &quot;precommit&quot;: &quot;lint-staged&quot; }, &quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;lint-staged&quot; } }, &quot;lint-staged&quot;: { &quot;linters&quot;: { &quot;*.{js,scss}&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ] } } } 也有些优秀的 ESlint 规范模块可以使用，如腾讯的 eslint-config-airbnb、eslint-config-airbnb-base 等。Webpack 中使用 ESlint也可以在 Webpack 构建中集成 ESlint 规范检查，需要借助 eslint-loader，如果代码不符合 ESlint 规范，构建会中断。安装依赖：$ npm install babel-loader eslint-loader -D Webpack 配置示例：module.exports = { module: { rules: [ // ... { test: /.js$/, exclude: /node_modules/, // 排除项 use: [ &#39;babel-loader&#39;, &#39;eslint-loader&#39; ] } // ... ] } } ESlint 配置示例：/* .eslint.js */ module.exports = { parser: &#39;babel-eslint&#39;, // 使用的 eslint 规范 extends: [&#39;airbnb&#39;], // 继承的 eslint 规犯 // 启用的环境 env: { browser: true, node: true } // 自定义规则 rules: { // 规则名称 indent: [ &#39;error&#39;, // 错误级别 2 // 配置项的值 ] } } 自定义 ESlint 规则或想要根据成熟的 ESlint 规则做定制化修改，可以在 .eslintrc 、.eslint.js 或 .eslint.yml 文件中进行配置。通过 Webpack 构建组件和基础库构建描述这里所说的打包组件和基础库其实就是 “造轮子” 时，对于自己封装的模块进行构建，在做这个事情的时候使用 rollup 其实更适合，因为 rollup 更纯粹，也更简单一些，Webpack 功能比较强大，除了对于平时开发的业务项目进行构建，对于打包组件和基础库也完全胜任。开发组件或基础库通常需要满足下面两个要求：输出的文件要构建成压缩版本和非压缩版本，非压缩版本用于开发阶段，压缩版本用于线上；要支持多种模块化方式，如 AMD、CommonJS、ES-Module 以及 script 标签引入。各种引入方式：/* AMD */ require([&#39;large-number&#39;], function (largeNumber) { largeNumber.add(&#39;999&#39;, &#39;1&#39;); }) /* CommonJS */ const largeNumber = require(&#39;large-number&#39;); largeNumber.add(&#39;999&#39;, &#39;1&#39;); /* ES-Module */ import * as largeNumber from &#39;large-number&#39;; largeNumber.add(&#39;999&#39;, &#39;1&#39;); &lt;!-- script --&gt; &lt;script src=&quot;//xxcnd/large-number.js&quot;&gt;&lt;/script&gt; &lt;script&gt; largeNumber.add(&#39;999&#39;, &#39;1&#39;); &lt;/script&gt; 构建一个基础库目录结构下面我们封装一个计算大数字加法的库，并把这个库作为第三方模块使用 Webpack 进行构建，项目目录结构如下： large-number |- dist | |- large-number.js | |- large-number.min.js |- src | |- index.js |- index.js |- package.json |- webpack.config.js dist 是我们希望输出的目录，large-number.js 为非压缩版，large-number.min.js 为非压缩版；src 是构建的目录，index.js 是大整数加法功能函数所在文件；index.js：入口文件；package.josn：依赖配置文件；webpack.config.js：Webpack 配置文件。功能函数/* ~src/index.js */ export default function add(a, b) { // 相加两数的当前位的指针 let i = a.length - 1; let j = b.length - 1; let carry = 0; // 是否进位 let ret = &#39;&#39;; // 最后输出结果 // 循环，个位个位相加，十位十位相加... while (i &gt;= 0 || j &gt;= 0) { let x = 0; // a 的当前位 let y = 0; // b 的当前位 let sum; // 当前位数的和 // 如果存在当前位数将 a 的数字转化为数字，并将指针指向上一位 if (i &gt;= 0) { x = a[i] - &#39;0&#39;; i--; } // 如果存在当前位数将 b 的数字转化为数字，并将指针指向上一位 if (j &gt;= 0) { y = b[j] - &#39;0&#39;; j--; } sum = x + y + carry; // 求总和 // 如果总和大于 10 进位，并修正当前位数 if (sum &gt;= 10) { carry = 1; sum -= 10; } else { carry = 0; } ret = sum + ret; // 将求和数子转换字符串 } // 循环结束，如果仍然存在进位，则将进位的值与之前结果拼接 if (carry) { ret = carry + ret; } return ret; // 返回最终结果 } package.json{ &quot;name&quot;: &quot;large-number&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;大整数加法&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;prepublish&quot;: &quot;npm run build&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;terser-webpack-plugin&quot;: &quot;^2.1.3&quot;, &quot;webpack&quot;: &quot;^4.41.2&quot;, &quot;webpack-cli&quot;: &quot;^3.3.9&quot; } } 其中 main 是模块指定执行的文件，指向根目录的主文件。主文件/* index.js */ if (process.env.NODE_ENV === &#39;production&#39;) { module.exports = require(&#39;./dist/large-number.min.js&#39;); } else { module.exports = require(&#39;./dist/large-number.js&#39;); } 主文件中根据当前的引用环境区分提供压缩版和非压缩文件版。构建配置下面是整个模块构建最重要的，就是 Webpack 的配置文件。/* webpack.config.js */ const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;); module.exports = { mode: &#39;none&#39;, entry: { &#39;large-number&#39;: &#39;./src/index.js&#39;, &#39;large-number.min&#39;: &#39;./src/index.js&#39; }, output: { filename: &#39;[name].js&#39;, library: &#39;largeNumber&#39;, libraryExport: &#39;default&#39;, libraryTarget: &#39;umd&#39; }, optimization: { minimize: true, minimizer: [ // 压缩的同时转换 ES6 语法，基于 uglifyPlugin 改造 new TerserWebpackPlugin({ include: /\\.min\\.js$/ }) ] } } 配置文件参数解析：entry：large-number：压缩版入口文件路径；large-number.min：非压缩版入口文件路径。output：filename：出口文件名；library：导出的文件所提供的全局变量名；libraryExport：默认值为 default，如不配置访问导出对象的default 属性才可以获取对应的方法；libraryTarget：打包的模块规则，如 CommonJS，ES-Module 等，详情见 Webpack 官网。TerserWebpackPlugin：基于 UglifyPlugin 插件实现的，相较于 UglifyPlugin，压缩的同时可以转换 ES6 语法。include：属性的值为正则，默认匹配了 large-number.min.js 文件。构建 SSR 应用为什么要有 SSR 应用通常的客户端渲染流程如下：开始加载（白屏）；HTML 加载成功（提供 loading）;请求 CSS、JS 等资源；解析 CSS、JS 等资源；页面渲染样式、执行 JS 逻辑；如发送数据、图片请求；页面达到可交互状态。从客户端的渲染流程看，我们可以发现从请求 HTML 到达到可交互状态中的请求是串行执行的，会导致白屏时间长，并且刚刚请求回的 .html 文件上的动态数据是空的，不利于搜索引擎的爬虫分析页面（不利于 SEO）。什么是服务端渲染SSR（Server Side Rendering） 又称为服务端渲染，将渲染后的 .html 整个返回给客户端，可以让客户端在加载 .html 后直接看到页面。服务端渲染流程：开始加载（白屏）；服务端同构，将 HTML、Data、CSS 等进行组合；返回给客户端解析并渲染；页面达到可交互状态。跟客户端渲染的流程对比，可以发现服务端渲染的优势：串行的请求在服务端，内网拉取资源更快；服务端渲染把客户端渲染的多个串行的请求优化成了一个请求（减少请求数）；返回页面就能直接渲染出内容，减少了白屏的时间；页面返回首屏所有数据，对 SEO 更友好。客户端渲染和服务端渲染的差别对比：客户端渲染服务端渲染请求多个请求（HTML，数据等）1 个请求加载过程HTML 与数据串行加载1 个请求返回 HTML 和数据渲染前端渲染服务端渲染（如 Node.js）可交互图片等静态资源加载完成，JS 逻辑执行完成可交互构建服务端和客户端假设负责服务端渲染的服务是由 Express 实现的，前端是使用 React 实现的，代码如下：$ npm install express -D /* ~server/index.js 服务端 */ const express = require(&#39;express&#39;); const fs = require(&#39;fs&#39;); const axios = require(&#39;axios&#39;); // React 内部提供的方法，用于将 JSX 转换成 HTML 字符 const { renderToString } = require(&#39;react-dom/server&#39;); // 引入需要转换的 JSX const SSR = require(&#39;./dist/index-server&#39;); // 引入构建后的模板 const html = fs.readFile(&#39;./dist/index.html&#39;, &#39;utf-8&#39;); // 增加 hask，防止属于浏览器的对象在服务端报错 if (window === undefined) { global.window = {}; } const server = (port) =&gt; { const app = express(); app.use(express.static(&#39;dist&#39;)); app.get(&#39;/&#39;, (req, res) =&gt; { const html = renderMarkup(renderToString(SSR)); res.status(200).send(html); }); app.listen(port, () =&gt; { console.log(`server start ${port}`); }); } const renderMarkup = async (str) =&gt; { const data = await axios.get(&#39;/xxx/xxx&#39;); return html.replace(&#39;&lt;!-- HTML_PLACEHOLDER --&gt;&#39;, str).replace( &#39;&lt;!-- INITAIL_DATA_PLACEHOLDER --&gt;&#39;， &#39;&lt;script&gt;window.__inital_data = &#39; + data + &#39;&lt;/script&gt;&#39; ); } server(process.env.PORT || 3000); &lt;!-- ~dist/index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Search&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 占位符，用于插入 HTML --&gt; &lt;div id=&quot;root&quot;&gt;&lt;!-- HTML_PLACEHOLDER --&gt;&lt;/div&gt; &lt;!-- 数据占位符，用于插入数据 --&gt; &lt;!-- INITAIL_DATA_PLACEHOLDER --&gt; &lt;/body&gt; &lt;/html&gt; /* ~dist/index-server.js 客户端 */ const React = require(&#39;react&#39;); class App extends React.Component { render() { return &lt;h1&gt;Hello world!&lt;/h1&gt; } } module.exports = &lt;App /&gt;; 注意：由于 React 组件的 JSX 要通过服务端进行转换、渲染，所以不能使用 ReactDom.render 进行渲染，需要使用 require 引入， module.exports 导出。构建配置const path = require(&#39;path&#39;); module.exports = { // ... output: { path: path.join(__dirname, &#39;dist&#39;), filename: &#39;[name]-server.js&#39; libararyTarget: &#39;umd&#39; }, module: { rules: [ { test: /\\.css$/, use: [ &#39;ignore-loader&#39; // 使用构建后 `dist` 目录的 CSS ] } ] } // ... } Webpack SSR 注意的问题需要兼容浏览器的全局变量，如 window、document 等；组件适配：将不兼容的组件根据打包环境适配，如服务端为 CommonJS 模块化规范；请求适配：将 fetch 或者 ajax 请求的写法改写成 isomorphic-fetch 或者 axios（对于服务端做过适配）；样式无法解析，服务端打包通过 ignore-loader 忽略掉 CSS 解析，或者将 style-loader 替换成 isomorphic-style-loader（使用 CSS-Module 的编码方式）。定制构建命令行的显示日志在每一次构建时，默认在命令行都会打印一堆的日志信息，但是对于一个关注业务的开发者来说，更希望在构建错误时才去关注日志，并且快速定位错误，在 Webpack 中提供了 stat 配置用来控制日志内容的显示。生产环境配置示例：module.exports = { // ... stat: &#39;errors-only&#39; // ... } 开发环境配置示例：module.exports = { // ... devServer: { // ... stat: &#39;errors-only&#39; // ... } // ... } 生产环境控制执行构建命令时的日志显示，如 npm run build，而开发环境控制代码热更新重新构建时的日志显示。stat 可选值如下：可选值描述errors-only只在发生错误时输出errors-warnings只在发生错误或有新的编译时输出minimal只在发生错误或有新的编译时输出none没有输出normal标准输出verbose全部输出detailed全部输出除了 chunkModules 和 chunkRootModules目前存在一个问题是成功、警告以及失败的日志信息不够明显，使用 FriendlyErrorsWebpackPlugin 插件，可以通过颜色区分更明显的标注日志信息。插件安装：$ npm install friendly-errors-webpack-plugin -D 插件配置示例：const FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;); module.exports = { // ... plugins: [ new FriendlyErrorsWebpackPlugin() ] // ... } 构建异常和中断处理在执行构建时，如果构建成功，接下来可能会执行发布操作，如果构建失败，可能会做错误上报的操作，这就需要我们的 Webpack 配置中能构处理构建异常和中断，其实在 Webpack4 中每次进程执行构建后都会抛出结束的状态码，0 为构建成功，其他只为构建失败。# 查看状态码 echo $? 但我们的目的并不是通过命令拿到错误码，而是在构建过程刚结束时，可以针对状态码去做不同的处理，其实根据 Webpack 的底层对象 Compiler 的特性去实现一个插件就可以实现构建异常和中断处理，在插件中通过 process.exit 抛出状态码。process.exit 方法：状态码为 0，构建成功，回调函数中 err 参数为 null；状态码为其他值，构建失败或中断，回调函数中 err 为错误对象，err.code 就是状态码。插件简易实现和配置：module.exports = { // ... plugins: [ // ... function () { const interceptor = (stats) =&gt; { if (stats.complation.errors &amp;&amp; process.argv.includes(&#39;--watch&#39;)) { // 处理错误，上报 process.exit(1); } } if (this.hooks) { this.hooks.done.tap(&#39;done&#39;, interceptor); // Webpack4 } else { this.plugin(&#39;done&#39;, interceptor); // Webpack3 } } // ... ] // ... } plugins 不一定是类 new 出的插件实例对象，也可以是函数，上面的函数就可以作为插件被执行，在 Webpack 构建结束后会自动执行 done 事件，可以在 done 事件的回调函数中获取状态码和错误信息，做进一步的处理。未完待续…","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"构建","slug":"构建","permalink":"https://www.overtaking.top/tags/%E6%9E%84%E5%BB%BA/"}]},{"title":"Webpack4 —— 优化篇","date":"2018-11-10T12:31:21.000Z","path":"20181110203121/","text":"系列文章链接：Webpack4 —— 基础篇Webpack4 —— 应用篇文件指纹“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。“文件指纹” 的种类：Hash：和整个项目的构建有关，只要项目中有文件发生变化，使用该配置的文件名的 “指纹” 就会发生变化；ChunkHash：和 Webpack 打包的 chunk 有关，不同的 entry（多页应用时）会生成不同的 “指纹”，页面对应的文件发生变化才会影响该页面的 “指纹”；ContentHash：根据具体文件的内容生成 “指纹”，在具体某一个页面下引用的多个文件中，如果使用 ChunkHash 会导致一个文件变化其他的文件 “指纹” 也发生变化，使用 ContentHash 可以保证文件内容不变不会 “指纹” 不会发生变化。合理使用 “文件指纹”：const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); module.exports = { entry: { app: &#39;./pages/app.js&#39;, appAdmin: &#39;./pages/appAdmin.js&#39; }, output: { // 不同页面出口文件使用 chunkhash filename: &#39;[name][chunkhash:8].js&#39;, path: __dirname + &#39;dist&#39; }, module: { rules: [ // ... { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, ], }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#39;url-loader&#39;, options: { limit: 10000, // MD5 根据文件内容生成，字体文件同理 name: &#39;[name].[hash:8].[ext]&#39; } } // ... ] } plugins: [ // 使用该插件将 CSS 文件单独提取 new MiniCssExtractPlugin({ // 该 contenthash 同图片的 hash filename: &#39;[name][contenthash:8].css&#39; }) ] // ... } “指纹” 配置不能和热更新插件 HotModuleReplacementPlugin 同时使用，因此也突出了 Webpack 配置根据环境（mode）区分的重要性。代码压缩在项目正式上线时，代码压缩是非常必要的，因为代码压缩后资源的字节会更少，文件大小会更小，这样在文件传输过程中也会节约带宽进而加快文件的访问速度。JS 压缩在 Webpack4 中内置了 uglifyjs-webpacl-plugin 插件，在 mode 配置为 production 时会默认实现 .js 文件的压缩，也可以手动安装该插件去配置关于压缩的其他参数，如并行压缩等（非必要）。CSS 压缩在 Webpack 旧版本中可以通过 css-loader 中配置参数来实现压缩，但是后来 css-loader 去掉了这个配置，所以在 Webpack4 中可以通过 OptimizeCssAssetsWebpackPlugin 插件来实现对 .css 文件的压缩。安装依赖：$ npm install cssnano optimize-css-assets-webpack-plugin -D 配置示例：/* 在 plugins 中配置 */ const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); // 用于匹配 CSS 文件的处理器（默认） const Cssnano = require(&#39;cssnano&#39;); module.exports = { // ... plugins: [ new OptimizeCssPlugin({ assetNameRegExp: /\\.css$/g, cssProcessor: Cssnano, cssProcessorOptions: { // 注释处理 discardComments: { removeAll: true // 移除所有注释 }, normalizeUnicode: false // 防止 unicode-range 时产生乱码 } }) ] } /* 在 optimization 中配置 */ const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); // 用于匹配 CSS 文件的处理器（默认） const Cssnano = require(&#39;cssnano&#39;); module.exports = { // ... optimization: { // ... minimizer: [ new OptimizeCssPlugin({ assetNameRegExp: /\\.css$/g, cssProcessor: Cssnano, cssProcessorOptions: { // 注释处理 discardComments: { removeAll: true // 移除所有注释 }, normalizeUnicode: false // 防止 unicode-range 时产生乱码 } }) ] // ... } } Html 压缩压缩 .html 文件主要还是依靠 HtmlWebpackPlugin 插件，通过生产环境构建时配置一些参数来实现。安装依赖：$ npm install html-webpack-plugin -D 配置示例：const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { // ... plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, // 模板文件路径 filename: &#39;index.html&#39;, // 输出文件名称 inject: true, // 将 js 资源放在 body 底部 minify: { collapseWhitespace: true, // 是否删除空白符与换行符 removeAttributeQuotes: true, // 是否移除引号 minifyCSS: true, // 压缩 CSS minifyJS: true, // 压缩 JS removeComments: true // 是否移除 HTML 中的注释 } }) ] // ... } 资源内联资源内联就是将资源的代码放在 .html 文件中一起请求回来，资源内联优化的意义大致可以分为两个层面，代码层面和网络层面。在代码层面可以内联一些 meta 标签，便于维护管理文件，可以内联一些页面框架的初始化脚本、上报埋点相关的脚本，也可以将首屏使用的 CSS 内联，防止网络不好的情况下页面闪动；从网络层面，对一些小图片和字体资源进行内联可以减少请求次数，增加页面的响应速度。Html 和 JS 的内联内联 Html 和 JS 文件需要依赖 raw-loader 加载器，raw-loader 的功能其实就是读取一个文件，然后把文件读取的内容以字符串形式返回并插入到对应的位置。安装依赖（0.5.1 版本比较稳定）：$ npm install raw-loader@0.5.1 -D 使用示例：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- html 内联可以直接放在对应位置 --&gt; ${ require(&#39;raw-loader!./meta.html&#39;) } &lt;!-- js 内联需要包裹在 script 标签中，防止存在 ES6 代码需要添加 babel-loader --&gt; &lt;script&gt;${ require(&#39;raw-loader!babel-loader!./xxx.js&#39;) }&lt;/script&gt; &lt;title&gt;注入 Html 和 JS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 由于 Webpack 使用编译模板的插件是 HtmlWebpackPlugin，默认模板使用的是 ejs，所以支持上面 ${} 的模板语法。CSS 内联CSS 内联需要两个步骤：如果直接使用 style-loader 会把所有打包后的 CSS 样式都动态的注入 .html 文件中，所以需要使用 MiniCssExtractPlugin 插件优先对 CSS 进行抽离；将抽离后首屏的 .css 文件注入到 .html 文件中，借助 HtmlInlineCssWebpackPlugin 插件来实现。安装依赖：$ npm install mini-css-extract-plugin html-webpack-plugin html-inline-css-webpack-plugin -D 配置示例：const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); const HtmlInlineCssWebpackPlugin = require(&#39;html-inline-css-webpack-plugin&#39;); module.exports = { // ... module: { rules: [ // ... { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39; ] } // ... ] }, plugins: [ new MiniCssExtractPlugin({ filename: &#39;[name][contenthash:8].css&#39; }), new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;index.html&#39; }), new HtmlInlineCssWebpackPlugin() // ... ] // ... } 需要注意的是 HtmlWebpackPlugin 插件应该在 HtmlInlineCssWebpackPlugin 之前，因为这两个插件的执行顺序有所依赖，必须先产生 index.html 文件后才能对 CSS 进行注入。图片、字体的内联一些小图标和字体如果体积非常小的情况下发出多个请求是没有必要的，所以最好是转换成 Base64 直接内联在 .html 和 .css 文件中，可以通过 url-loader 在构建中实现。安装依赖：$ npm install url-loader -D 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.(png|svg|gif|jpe?g)$/, use: [ { loader: &#39;url-loader&#39;, options: { limit: 10240 // 图片小于 10k 转为 Base64 } } ] }, { test: /\\.(woff2?|eot|ttf|otf)$/, use: [ { loader: &#39;url-loader&#39;, // 字体小于 10k 转为 Base64 options: { limit: 10240 } } ] } // ... ] } // ... } 这样的方式最大的问题是只能根据图片大小控制所有满足条件的图片和字体资源，而不能单独控制某一个资源，想要单独控制某一个资源可以使用自己编写 Webpack 插件或类似功能的第三方插件。抽取公共依赖在开发中的很多页面使用了相同的基础库，或者这些基础库之间引用了相同的依赖，或不同的组件中使用了相同的模块，以及 node_modules 中有些模块使用相同的依赖，这样直接打包会对公共部分重复打包，造成打包后的文件体积非常的大，这也是一个可以优化的点，可以将公共的部分按照优先级、权重、同步异步加载的方式进行抽取，进而对文件进行拆分，减小打包后文件的体积。基础库分离假如我们是做 React 开发，默认情况下是会对 react 和 react-dom 构建并打包到 bundle 中去，可以通过 CDN 的方式进行引入，在打包的时候每一次都忽略 react 和 react-dom 文件，以减小 bundle 的体积，我们可以通过 HtmlWebpackExternalsPlugin 插件来实现。安装依赖：$ npm install html-webpack-externals-plugin -D 配置示例：const HtmlWebpackExternalsPlugin = require(&#39;html-webpack-externals-plugin&#39;); module.exports = { // ... plugins: [ // ... new HtmlWebpackExternalsPlugin({ externals: [ { module: &#39;react&#39;, // 模块名称 entry: &#39;//xxcnd.com/boudle/react.min.js&#39;, // cdn 地址 global: &#39;React&#39; // 全局变量名 }, { module: &#39;react-dom&#39;, entry: &#39;//xxcnd.com/boudle/react-dom.min.js&#39;, global: &#39;ReactDom&#39; } ] }) // ... ] // ... } 代码分割在 Webpack4 中内置了代码分割的功能插件，非常强大，可以通过将公共依赖抽离成单独文件的方式减小 bundle 的体积，这也是官方建议使用的方式。配置示例：/* 默认参数 */ module.exports = { // ... optimization: { // ... splitChunks: { chunks: &#39;all&#39;, minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitalRequests: 3, automaticNameDelimiter: &#39;~&#39;, name: true } // ... } // ... } splitChunks 参数详解：chunks：async：异步引入的库进行分离（默认）；inital：同步引入的库进行分离；all：所有引入的库进行分离（推荐）。minSize：抽离公共包最小字节数；maxSize：抽离公共包最大字节数；minChunks：抽离公共包最小使用次数；maxAsyncRequests：浏览器同时请求同步资源的个数；maxInitalRequests：浏览器同时请求异步资源的个数；automaticNameDelimiter：抽离插件的文件名间隔符；name：值为 true 根据模块名称和缓存组（cacheGroups）的键自动选择名称。使用自定义缓存组 cacheGroups 配置示例：/* 自定义缓存组拆分同步异步模块 */ module.exports = { // ... optimization: { // ... splitChunks: { chunks: &#39;all&#39;, cacheGroups: { &#39;commons&#39;: { chunks: &#39;initial&#39;, name: &#39;commons&#39;, minChunks: 2, minSize: 0, reuseExistingChunk: true, priority: -5 }, &#39;async-commons&#39;: { chunks: &#39;async&#39;, name: &#39;async-commons&#39;, minChunks: 2, minSize: 0, reuseExistingChunk: true, priority: 5 }, &#39;vendors&#39;: { test: /[\\\\/]node_modules[\\\\/]/, name: &#39;vendors&#39;, chunks: &#39;initial&#39;, minChunks: 2, priority: 10, enforce: true, reuseExistingChunk: true }, &#39;async-vendors&#39;: { test: /[\\\\/]node_modules[\\\\/]/, minChunks: 2, chunks: &#39;async&#39;, name: &#39;async-vendors&#39;, priority: 15, enforce: true, reuseExistingChunk: true } } } // ... } // ... } cacheGroups 参数详解：commons：所有代码中的公共依赖（同步）；test：匹配依赖代码的文件夹，通常匹配 node_modules；reuseExistingChunk：允许重用现有模块，而不是在模块完全匹配时创建新模块；priority：权重，当被多个规则重用时会根据权重打包到对应策略的文件中；enforce：设置为 true 强制按照该规则拆分出一个文件，忽略文件大小；async-commons：所有代码中的公共依赖（异步）；vendors：依赖代码（node_modules）中的公共依赖（同步）；async-vendors：依赖代码（node_modules）中的公共依赖（异步）；注意：在使用 cacheGroups 属性进行代码分割后，产生的新 chunks 名称必须在页面 HtmlWebpackPlugin 实例的 chunks 属性中进行一一对应的配置。HtmlWebpackPlugin 配置：/* HtmlWebpackPlugin 使用前需安装 */ const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { // ... plugins: [ // ... new HtmlWebPackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;index.html&#39;, // 包含 splitChunks.cacheGroups 中 key 值和页面的出口文件名称 chunks: [ &#39;commons&#39;, &#39;async-commons&#39;, &#39;vendors&#39;, &#39;async-vendors&#39;, &#39;index&#39; ] // ... }) // ... ] // ... } tree-shaking 优化配置 tree-shaking这个优化的名字是非常形象的，像摇晃树一样，把多余的枯叶都晃掉，其实指的就是一个模块中有多个方法，在打包的 uglify 阶段擦除掉没有使用（被标记）的方法，通过不打包无用代码的方式来减小 bundle 的体积，进而减小资源的加载时间。这个优化的思想借鉴了 rollup，并在 Webpack2 中进行了实现，通过插件配置，目前 Webpack4 版本已经内置了 tree-shaking 优化，在 mode 被配置为 production（生产环境）时默认生效，如果需要在开发环境中使用配置如下。/* .babelrc */ { &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, ] } 想要使 tree-shaking 生效的注意点：引入模块必须使用 ES6 的模块化语法，因为 tree-shaking 的实现依赖于 ES6 模块化的静态特性；导出的函数不能存在 “副作用”，即导出的函数需要是纯函数，否则默认的 tree-shaking 也会失效。tree-shaking 原理简介说到 tree-shaking 的原理是应该先了解 DCE（dead code elimination）的概念，就是指 “死” 代码消除。DCE 有以下情况：代码不会被执行，不可到达；代码只会影响死变量，只写不读；代码执行的结果不会被用到。/* 代码不会被执行，不可到达 */ if (false) { console.log(&#39;dead code&#39;); } /* 代码只会影响死变量，只写不读 */ let hello = &#39;nihao&#39;; /* 代码执行的结果不会被用到 */ // tool.js export const fn1 = () =&gt; { return &#39;hello&#39;; } fn1(); export const fn2 = () =&gt; { return &#39;world&#39;; } // main.js import { fn2 } from &#39;./tool.js&#39;; fn2(); tree-shaking 就是通过检查具有上面特性的代码并做相应处理来达到擦除多余代码的目的，并且依赖 ES6 模块化的静态特性，原因是哪些代码是多余的哪些代码是有用的在编译阶段就需要确定下来，ES6 模块的静态特性正好符合编译阶段对代码的分析，CommonJS 的模块化规范就明显不适合，因为模块的引入是动态的，由运行时决定。依赖模块静态化特性的原因：只能在顶层使用 import 引用模块；引用的变量都是常量；引入的模块对象的不可更改（immutable）特性。深度 tree-shaking如果函数中存在副作用，默认的 tree-shaking 之所以失效了是因为只能够在编译阶段做词法分析，而不能做作用域（scope）分析，如下面代码。// tool.js import lodash from &#39;lodash-es&#39;; export const fn1 = () =&gt; { console.log(&#39;hello&#39;); } export const fn2 = (arg) =&gt; { console.log(lodash.isArray(arg)); } // main.js import { fn1 } from &#39;./tool.js&#39;; fn1(); 在上面案例中并没有使用 fn2，但是由于 fn2 函数中有副作用，即引用了 lodash，所以还是对 lodash 和 fn2 进行了打包，这种情况下如果想要继续实现 tree-shaking，需要借助 WebpackDeepScopePlugin 插件来实现。安装依赖：$ npm install webpack-deep-scope-plugin -D 配置示例：const WebpackDeepScopePlugin = require(&#39;webpack-deep-scope-plugin&#39;); module.exports = { // ... plugins: [ // ... new WebpackDeepScopePlugin() // ... ] // ... } Scope Hoisting 优化由于浏览器对模块化语法支持依然不好，为了保证代码可以在各个浏览器中可执行，所以使用 Webpack 进行构建。/* 构建前 */ // a.js export default &#39;xxx&#39;; // b.js import index from &#39;./a.js&#39;; console.log(index); /* 构建后 */ (function (module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot; // 模块 b 构建内容，省略... }) (function (module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot; // 模块 a 构建内容，省略... }) 被 Webpack 转换后的模块会包裹一层自执行函数，构建后的代码会存在大量的闭包，其中 import 会被转换成 __webpack_require__ 的调用，export 会被转换成 __webpack_exports__ 对象属性的的赋值。会导致的问题：大量函数闭包包裹的代码会导致体积增大，模块越多越明显；运行代码时创建的函数作用域变多，内存开销变大。Scope Hoisting 又被称为作用域提升，借鉴于 rollup，在 Webpack3 中被提出，将所有模块的代码按照引用顺序存放在一个函数作用域里，然后适当的重命名来防止变量命名冲突，用来减少函数声明代码，减小内存开销。在 Webpack4 中当 mode 为 production（生产环境）时会默认开启 Scope Hoisting，当想在开发环境或 Webpack3 中配置开启，需要依赖 Webpack 的内置插件 ModuleConcatenationPlugin 来实现。配置示例：const Webpack = require(&#39;webpack&#39;); module.exports = { // ... plugins: [ // ... new Webpack.optimize.ModuleConcatenationPlugin() // ... ] // ... } 开启 Scope Hoisting 后，在多个模块中都会引用的模块会单独提取出来形成闭包函数，否则会将多个引用的模块按照引用顺序放在同一个闭包函数中。资源懒加载Webpack 所特有的 require.ensure() 可以实现懒加载，符合 CommonJS 规范，目前已经被 ES6+ 的动态 import() 取代，属于代码分割的一部分，对于大型 Web 单页面应用来讲，将所有代码都放在一个 bundle 文件中是没有必要的，特别是某些代码块不是经常被用到，大大降低了首屏的加载速度，使用动态 import 优化可以使类似这样的代码在使用时才去加载，使得初始化的时候代码体积更小。在 Webpack 中要解析动态 import() 语法需要依赖 babel 中的 @babel/plugin-syntax-dynamic-import 插件。安装依赖：$ npm install @babel/preset-env @babel/plugin-syntax-dynamic-import -D 配置示例：/* .babelrc */ { &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ], &quot;plugins&quot;: [ &quot;@babel/plugin-syntax-dynamic-import&quot; ] } 只要使用了动态 import() 语法加载的模块，在 Webpack 构建时都会打包出单独的 chunk，构建的代码内当需要加载模块时是通过 JSONP 的方式去加载的。未完待续…","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"构建","slug":"构建","permalink":"https://www.overtaking.top/tags/%E6%9E%84%E5%BB%BA/"},{"name":"性能优化","slug":"性能优化","permalink":"https://www.overtaking.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"设计模式 JS 表现 —— 策略模式","date":"2018-10-05T17:48:12.000Z","path":"20181006014812/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式策略模式简介“策略模式” 是将定义的一组算法封装起来，使其可以相互替换，封装的算法具有一定的独立性，让算法独立于客户端而变化，可以大大减少 if...else 和 switch...case 等判断。策略模式 UML 图策略模式的实现下面是一个关于会员打折的逻辑，根据顾客身份不同输出不同的支付金额，是未使用 “策略模式” 的实现。/* 未使用策略模式 */ class Customer { constructor(type) { this.type = type; } pay(amount) { if (this.type === &#39;member&#39;) { return amount * 0.9; } else if (this.type === &#39;vip&#39;) { return amount * 0.8; } else { return amount; } } } const c1 = new Customer(&#39;normal&#39;); const c2 = new Customer(&#39;member&#39;); const c3 = new Customer(&#39;vip&#39;); console.log(c1.pay(100)); // 100 console.log(c2.pay(100)); // 90 console.log(c3.pay(100)); // 80 上面的代码与 状态模式 一节中的问题类似，违反开放封闭原则和单一职责原则，代码冗余且判断条件过多，“状态模式” 虽然可以解决状态不同时不同复杂逻辑的抽离和解耦，但是并不能解决过多条件判断的问题，下面就是用 “策略模式” 来对这个点进行优化。/* 使用策略模式优化 —— 策略类 */ class Customer { constructor(kind) { this.kind = kind; } pay(amount) { return this.kind.pay(amount); } } // 策略类 class Normal { pay(amount) { return amount; } } class Member { pay(amount) { return amount * 0.9; } } class VIP { pay(amount) { return amount * 0.8; } } const c1 = new Customer(new Normal()); const c2 = new Customer(new Member()); const c3 = new Customer(new VIP()); console.log(c1.pay(100)); // 100 console.log(c2.pay(100)); // 90 console.log(c3.pay(100)); // 80 上面是使用策略类对复杂判断逻辑的内容进行了抽象，并将原本 if...else 中的逻辑分别放在了不同的策略类中维护，如果每一个策略类中要维护的逻辑并不是很复杂，也可以使用第二种方案，即使用策略对象维护不同的逻辑。/* 使用策略模式优化 —— 策略对象 */ class Customer { constructor() { // 策略对象 this.kinds = { normal(amount) { return amount; }, member(amount) { return amount * 0.9; }, vip(amount) { return amount * 0.8; } }; } pay(kind, amount) { return this.kinds[kind](amount); } } const c1 = new Customer(); const c2 = new Customer(); const c3 = new Customer(); console.log(c1.pay(&#39;normal&#39;, 100)); // 100 console.log(c2.pay(&#39;member&#39;, 100)); // 90 console.log(c3.pay(&#39;vip&#39;, 100)); // 80 策略模式的应用jQuery 的 animate 动画在 jQuery 的源码实现中，animate 方法就用到了 “策略模式”，通过不同的状态定义了动画不同的行为，使用代码如下：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jQuery-animate&lt;/title&gt; &lt;style&gt; #content{ width: 100px; height: 100px; background-color: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;bigger&quot;&gt;变大&lt;/button&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#39;#bigger&#39;).on(&#39;click&#39;, function () { $(&#39;#content&#39;).animate({ width: &#39;200px&#39;, height: &#39;200px&#39; }, 1000, &#39;linear&#39;); // linear 参数为动画策略的一种类型 }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 表单校验在 装饰器模式 一节中也有表单校验的应用，代码如下：&lt;!-- 表单校验应用装饰器模式 --&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt; &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt; &lt;form&gt; &lt;script&gt; const submitBtn = document.getElementById(&#39;submit-btn&#39;); // 添加切面函数 Function.prototype.before = function (beforeFn) { const _this = this; return function () { let result = beforeFn.apply(this, arguments); result &amp;&amp; _this.apply(this, arguments); } } // 表单提交事件 function submit() { console.log(&#39;提交表单&#39;); } // 验证用户名 submit = submit.before(function () { const username = document.getElementById(&#39;username&#39;).value; if (!username) { return alert(&#39;请输入用户名&#39;); } return true; }); // 验证 submit = submit.before(function () { const password = document.getElementById(&#39;password&#39;).value; if (!password) { return alert(&#39;请输入密码&#39;); } return true; }); submitBtn.addEventListener(&#39;click&#39;, submit); &lt;/script&gt; “装饰器模式” 是将对每个表单校验逻辑，通过增加切面（AOP）的方式插入在了 submit 事件之前，如果有一个校验不通过则不会执行下一个切面的校验操作或提交表单，但是这样的表单校验有局限性，如果页面表单校验非常多需要对校验逻辑进行统一管理，并且大多数场景下是所有的表单都校验后对所有的表单进行错误提示，这是就需要 “策略模式” 的策略对象来管理所有的校验逻辑。&lt;!-- 表单校验应用策略模式 --&gt; &lt;form id=&quot;userform&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; 手机号：&lt;input type=&quot;text&quot; name=&quot;mobile&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script&gt; const form = document.getElementById(&#39;userform&#39;); const validator = (function () { const rules = { noEmpty(val, msg) { if (val === &#39;&#39;) return msg; }, minLength(val, min, msg){ if (val === &#39;&#39; || val.length &lt; min) return msg; }, isMobile(val, msg) { if (!/1\\d{10}/.test(val)) return msg; } }; // 存储 const checks = []; // 增加校验的项目 function add(element, rule) { checks.push(function () { // [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;] const name = rule.shift(); // [val, 6, &#39;密码长度不能少于 6 位&#39;] rule.unshift(element.value); return rules[name] &amp;&amp; rules[name].apply(element, rule); }); } // 给策略对象增加新的功能 function addRule(name, rule){ rules[name] = rule; } // 开始校验 function start() { for (let i = 0; i &lt; checks.length; i++) { const msg = checks[i](); if (msg) return msg; } } return { add, addRule, start }; })(); // 添加自定义规则 validator.addRule(&#39;maxLength&#39;, function (val, max, msg) { if (val === &#39;&#39; || val.length &gt; max) return msg; }); form.onsubmit = function () { validator.add(form.username, [&#39;noEmpty&#39;, &#39;用户名不能为空&#39;]); validator.add(form.password, [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;]); validator.add(form.password, [&#39;maxLength&#39;, 12, &#39;密码长度不能大于 12 位&#39;]); validator.add(form.mobile, [&#39;isMobile&#39;, &#39;必须输入合法的手机号&#39;]); const msg = validator.start(); alert(msg || &#39;校验通过&#39;); return !msg; } &lt;/script&gt; 通过对比两段代码可以显而易见的看出 “策略模式” 在对于表单校验的功能上比 “装饰器模式” 更加健壮，可以在保证可维护性的基础上支持更多复杂的功能。总结“策略模式” 和 “状态模式” 都有上下文、策略和状态类，上下文把这些请求委托给这些类来执行，“策略模式” 中，各个类是平等的，没有关系，客户端需要知道算法主动切换，“状态模式” 中，状态的切换和行为被封装好了，客户端不需要了解细节，所以 “策略模式” 真正意义的解决了状态过多时条件判断过多的问题，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.overtaking.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 状态模式","date":"2018-10-05T08:12:13.000Z","path":"20181005161213/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 策略模式状态模式简介有些情况下一个对象的行为取决于一个或者多个动态变化的属性，这样的属性叫做状态，这个对象叫做有状态的对象，这种情况下通常有很多的判断来处理状态不同时代码的执行逻辑，执行逻辑可能会非常复杂，让代码变得难以维护，“状态模式” 就是将这些逻辑委托给外面的对象或类来单独维护，来减少状态对象的逻辑，增强代码的维护性。状态模式 UML 图状态模式的实现下面是一个类，功能为根据电池不同状态打印当前不同的颜色，下面是正常的实现方式。class Battery { constructor() { this.amount = &#39;high&#39;; // 电量高 } show() { if (this.amount === &#39;high&#39;) { console.log(&#39;显示绿色&#39;); this.amount = &#39;middle&#39;; // 电量中等 } else if (this.amount === &#39;middle&#39;) { console.log(&#39;显示黄色&#39;); this.amount = &#39;low&#39;; // 电量低 } else if (this.amount === &#39;low&#39;) { console.log(&#39;显示红色&#39;); } } } const battery = new Battery(); battery.show(); // 显示绿色 battery.show(); // 显示黄色 battery.show(); // 显示红色 上面的代码虽然实现了我们想要的功能，但是代码中 show 方法违反了开放封闭原则和单一职责原则，状态切换逻辑不明显，判断条件太多，维护性和扩展性差，下面使用状态模式进行优化。class Battery { constructor() { this.amount = &#39;high&#39;; // 电量高 this.state = new SuccessState(); // 绿色状态 } show() { // 把显示逻辑委托给状态对象 this.state.show(); if (this.amount === &#39;high&#39;) { this.amount = &#39;middle&#39;; // 电量中等 this.state = new WarningState(); // 黄色状态 } else if (this.amount === &#39;middle&#39;) { this.amount = &#39;low&#39;; // 电量低 this.state = new ErrorState(); // 红色状态 } } } class SuccessState { show() { console.log(&#39;显示绿色&#39;); } } class WarningState { show() { console.log(&#39;显示黄色&#39;); } } class ErrorState { show() { console.log(&#39;显示红色&#39;); } } const battery = new Battery(); battery.show(); // 显示绿色 battery.show(); // 显示黄色 battery.show(); // 显示红色 经过 “状态模式” 的优化，我们将状态拆分成三个类，无论关于状态操作的多复杂的逻辑都在拆分出的类中实现，而不再需要在状态对象 Battery 中。状态模式的应用点赞点赞是我们在项目开发中经常见到的功能，点赞后也可以取消点赞，这就出现了按钮关于点赞状态的切换和按钮文案的切换，下面是使用 “状态模式” 来实现的点赞功能。&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script&gt; // 维护点赞渲染逻辑的对象 const likeState = { render(element) { element.innerHTML = &#39;赞&#39;; } }; // 维护取消点赞渲染逻辑的对象 const likedState = { render(element) { element.innerHTML = &#39;取消&#39; } } class Button { constructor(container) { this.liked = false; // 默认为未点赞状态 this.state = likeState; // 设置当前的状态为未点赞 this.element = document.createElement(&#39;button&#39;); container.appendChild(this.element); this.render(); // 初始化渲染 } setState(state) { this.state = state; // 修改渲染状态 button.liked = !button.liked; // 修改状态属性 this.render(); // 重新渲染 } render() { this.state.render(this.element); } } // 获取按钮对象并添加点击事件 const button = new Button(document.getElementById(&#39;root&#39;)); button.element.addEventListener(&#39;click&#39;, () =&gt; { button.setState(button.liked ? likeState : likedState); }); &lt;/script&gt; 上面代码使用 “状态模式” 统一封装了按钮的类 Button，传入的参数为渲染按钮的容器元素，按钮类的内部创建按钮并添加到容器元素中，统一管理了点赞状态，点赞渲染对象，如果想要切换状态只需要执行 button 对象提供的 setState 方法通过传入的不同状态对象进行状态切换和页面渲染。React 组件显示隐藏在 React 中，经常会出现通过事件切换组件的显示隐藏，最简单的方式是通过类组件状态来控制，但其实也可以使用 “状态模式” 在组件外编写对状态更改的逻辑，这样可以使组件的逻辑更清晰，代码更精简。import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 状态管理对象 const States = { show() { console.log(&#39;显示 Banner&#39;); this.setState({ isShow: true }); }, hide() { console.log(&#39;隐藏 Banner&#39;); this.setState({ isShow: false }); } }; class Banner extends React.Component { state = { isShow: true } toggle = () =&gt; { const currentState = this.state.isShow ? &#39;hide&#39; : &#39;show&#39;; States[currentState] &amp;&amp; States[currentState].apply(this); } render() { return ( &lt;div&gt; { isShow &amp;&amp; ( &lt;nav&gt;导航&lt;/nav&gt; ) } &lt;button&gt;toggle&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Banner /&gt;, document.getElementById(&#39;root&#39;)); 在上面代码中组件外部的 States 就是管理切换状态逻辑的对象，就是说 “状态模式” 也可以在框架中单独使用。有限状态机其实 “状态模式” 来源一个有限状态机的概念，有限状态机是指一个事物拥有多种状态，但是同一时间只会处于一种状态，可以通过动作来改变当前的状态，在 JavaScript 中拥有第三方模块 javascript-state-machine 专门帮我们来做这件事。javascript-state-machine 使用javascript-state-machine 提供一个类，创建实例时传入的参数为一个 options 对象，属性 init 用来定义初始状态值，属性 transitions 用来定义属性变化，methods 用来定义属性发生变化时所触发的钩子。// 有限状态机对象 const StateMachine = require(&#39;javascript-state-machine&#39;); const fsm = new StateMachine({ init: &#39;solid&#39;, // 初始状态（固态） transitions: [ { from: &#39;solid&#39;, to: &#39;liquid&#39;, name: &#39;melt&#39; }, { from: &#39;liquid&#39;, to: &#39;solid&#39;, name: &#39;freeze&#39; }, { from: &#39;liquid&#39;, to: &#39;gas&#39;, name: &#39;vaporize&#39; }, { from: &#39;gas&#39;, to: &#39;liquid&#39;, name: &#39;condense&#39; } ], methods: { onMelt() { console.log(&#39;melt&#39;); }, onFreeze() { console.log(&#39;freeze&#39;); }, onVaporize() { console.log(&#39;vaporize&#39;); }, onCondense() { console.log(&#39;condense&#39;); } } }); console.log(fsm.state); // solid console.log(fsm.can(&#39;gas&#39;)); // false console.log(fsm.cannot(&#39;gas&#39;)); // true console.log(fsm.transitions()); // [ &#39;melt&#39; ] console.log(fsm.allTransitions()); // [ &#39;init&#39;, &#39;melt&#39;, &#39;freeze&#39;, &#39;vaporize&#39;, &#39;condense&#39; ] console.log(fsm.allStates()); // [ &#39;none&#39;, &#39;solid&#39;, &#39;liquid&#39;, &#39;gas&#39; ] fsm.melt(); // melt console.log(fsm.state); // liquid console.log(fsm.transitions()); // [ &#39;freeze&#39;, &#39;vaporize&#39; ] fsm.state：当前状态；fsm.can：查看是否可直接转换到某个状态，参数为要转换的状态值；fsm.cannot：查看是否不能直接转换到某个状态，参数为要转换的状态值；fsm.transitions：返回可转换状态的方法列表；fsm.allTransitions：返回所有状态转换方法列表；fsm.allStates：返回定义的所有状态。javascript-state-machine 原理根据 javascript-state-machine 的用法我们模拟实现最基本的逻辑，构建一个有限状态机，代码如下：class StateMachine { constructor(options) { const { init = &#39;none&#39;, transitions = [], methods = {} } = options; this.state = init; transitions.forEach(transition =&gt; { const { from, to, name } = transition; this[name] = function () { if (this.state === from) { this.state = to; const method = &#39;on&#39; + name.slice(0, 1).toUpperCase() + name.slice(1); methods[method] &amp;&amp; methods[method](); } } }); } } 总结“状态模式” 实现的有限状态机可以更大限度的让状态变化与状态对象进行解耦，更减少了大量的判断逻辑，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.overtaking.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 发布/订阅和观察者模式","date":"2018-10-04T03:49:07.000Z","path":"20181004114907/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式发布/订阅模式发布/订阅模式实现在说 “观察者模式” 之前一定要说一下 “发布/订阅模式”，因为这两个模式非常相似又有些不同，最重要的是在设计模式中使用频繁。/* 发布/订阅的类 */ class Event { constructor() { this.events = {}; } on(type, fn) { (this.events[type] || (this.events[type] = [])).push(fn) } emit(type) { if (this.events[type]) { this.events[type].forEach(fn =&gt; fn()); } } } 上面的类有一个基本属性 events，值为对象，用来存储不同类型的事件集合，原型方法 on 是用来订阅事件，第一个参数 type 为订阅事件的类型，fn 是要被执行的事件，emit 方法用来执行某个类型所有的事件。/* 发布/订阅的使用 */ const event = new Event(); // 订阅事件 event.on(&#39;say&#39;, () =&gt; console.log(&#39;hello&#39;)); event.on(&#39;say&#39;, () =&gt; console.log(&#39;world&#39;)); // 发布事件 event.emit(&#39;say&#39;); // hello // world 发布/订阅模式的应用浏览器事件监听：&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt; &lt;script&gt; const btn = document.getElementById(&#39;btn&#39;); btn.addEventListener(&#39;click&#39;, () =&gt; console.log(1)); btn.addEventListener(&#39;click&#39;, () =&gt; console.log(2)); btn.addEventListener(&#39;click&#39;, () =&gt; console.log(3)); &lt;/script&gt; 当点击按钮触发事件时，三个回调函数会按照添加的顺序依次执行。Promise 的异步调用的回调管理：const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(&#39;res&#39;), 3000); }); promise.then(data =&gt; console.log(1, data)); promise.then(data =&gt; console.log(2, data)); 上面给同一个 Promise 实例的 then 方法中添加了两个回调函数，因为在创建 Promise 实例时内部使用了定时器，所以状态的变化延后了 3s，其实在 Promise 内部也是通过队列来对 then 的回调进行统一管理，在状态发生变化后立即循环执行。在 Node.js 中，有一个核心模块 events 提供的类 EventEmitter，几乎所有的事件都是基于这个模块实现的，如流的 data 和 end 事件、http 的 request 事件，而 EventEmitter 的内部原理就是 “发布/订阅模式”。观察者模式观察者模式的简单实现下面我们是 “观察者模式” 的案例，通过上面 “发布/订阅模式” 的实现来对比一下异同。/* 观察者模式 */ // 被观察者类 class Star { constructor(name) { this.name = name; this.state = &#39;&#39;; this.observers = []; } getState() { return this.state; } setState(state) { this.state = state; this.notify(); // 更新状态后通知 } attach(observer) { this.observers.push(observer); // 添加观察者 } notify() { // 订阅状态的观察者更新修改后的状态 this.observers.forEach(observer =&gt; observer.update()); } } // 观察者类 class Fan { constructor(name, star) { this.name = name; this.star = star; this.star.attach(this); } update() { console.log(&#39;我喜欢的明星喜欢&#39; + this.star.getState() + &#39;，我也喜欢。&#39;); } } 在 “观察者模式” 中有两个基本的类，观察者和被观察者，被观察者提供状态 state，观察者去使用这个状态，当被观察者更新状态时会主动发布到订阅了状态的观察中，实现同步更新。const star = new Star(&#39;Super Star&#39;); const fan = new Fan(&#39;张三&#39;, star); star.setState(&#39;绿色&#39;); // 我喜欢的明星喜欢绿色，我也喜欢。 观察者模式的应用Vue 框架的数据响应式原理及 watch 方法：&lt;div id=&quot;root&quot;&gt; &lt;p&gt;FullName: {{fullName}}&lt;/p&gt; &lt;p&gt; FirstName: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt; &lt;/p&gt; &lt;p&gt; LastName: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt; &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &#39;#root&#39;, data: { firstName: &#39;张&#39;, lastName: &#39;三&#39;, fullName: &#39;张三&#39; }, watch: { firstName(newName, oldName) { this.fullName = newName + this.lastName; } } }); &lt;/script&gt; 在 Vue 2.x 版本的数据响应式和 watch 监听的底层，就使用了 “观察者模式”，在模板解析过程中为变量添加观察者（watcher），在使用 Object.defineProperty 的 getter 和 setter 进行劫持数据，数据获取和更改会触发 get 和 set 方法，进而执行订阅和通知的逻辑，而通知的过程中调用了被统一管理的观察者的 update 方法，实现了视图层与数据层的同步。redux 的 createStore 方法：function createStore(reducer) { let state; let listeners = []; // 获取 store const getState = () =&gt; JSON.parse(JSON.stringify(state)); // 订阅方法 const subscribe = fn =&gt; { listeners.push(fn); // 取消订阅方法 return () =&gt; { listeners = listeners.filter(listener =&gt; listener !== fn); }; } // 派发动作 const dispatch = action =&gt; { state = reducer(state, action); listeners.forEach(listener =&gt; listener()); } dispatch({ type: &#39;@INIT&#39; }); return { getState, subscribe, dispatch }; } 在 redux 的实现思想中也包含了 “观察者模式”，例如在 redux 与 React 的配合使用，redux 提供了订阅的方法 subscribe 和派发动作更新 store 的方法 dispatch，React 组件会使用 store 中提供的状态数据，这个 store 就是被观察者，而观察者就是 React 的各个组件，当使用 dispatch 派发动作更新数据时，会执行所有的观察者中的监听函数，实现组件数据与 store 的同步。发布/订阅模式和观察者模式观察者模式是由 “发布/订阅模式” 演变过来的，都存在订阅、通知的事件机制，“发布/订阅模式” 是对订阅的事件进行统一管理，主动触发通知，依次执行订阅的事件，而 “观察者模式” 是通过一个单独类去订阅观察者，当状态发生变化时通知到各个 “观察者” 实现状态的更新同步。“发布/订阅模式” 与 “观察者模式” 的区别：“发布/订阅模式” 事件是统一由调度中心调度，订阅发布不存在依赖；“观察者模式” 事件是被观察者调度，订阅与发布是存在依赖的；总结“观察者模式” 的意义就在于可以使多个对象数据重合的部分进行复用，同时还可以对各个对象之间解耦，最重要的是数据更新可以及时通知所有数据的使用者进行数据同步，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.overtaking.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Webpack4 —— 基础篇","date":"2018-10-01T20:14:34.000Z","path":"20181002041434/","text":"系列文章链接：Webpack4 —— 应用篇Webpack4 —— 优化篇为什么需要构建工具？转换 ES6+ 语法；转换 JSX 语法 / Vue 指令；CSS 私有前缀补全 / 预处理器（less，sass）；压缩混淆 / 图片压缩；为什么选择 Webpack？早期的打包工具有 Grount，把打包构建分成一个一个的任务，队列式的处理每一个任务，如解析 html 任务、解析 CSS 任务、解析 JS 任务、图片压缩任务、代码压缩任务等等，每一个任务处理完成之后会将任务结果存放在本地磁盘的 .temp 目录，由于产生了 IO 操作，会导致打包速度比较慢。后来产生了 Glup，原理与 Grount 类似，管道式的处理打包任务，不同的是 Gulp 有文件流的概念，每一个任务构建后的结果不会存放磁盘，而是存在内存中，在下一个步骤中可以直接使用上一个步骤内存中的结果，提高了打包速度。目前最火爆的打包工具是 Webpack，在打包性能优于上面工具的基础上，更归功于丰富的生态社区、配置灵活的 loader 和 plugin，可以通过很灵活的配置完成团队项目个性化的打包需求，并且拥有强大的官方团队进行更新迭代，维护了众多稳定的 loader 和 plugin，更新速度非常快。安装 Webpack 及打包命令安装：$ npm install webpack webpack-cli -D 使用 Webpack 进行打包执行的其实是 ./node_modules/.bin 目录的 webpack 文件。# 打包命令 $ ./node_modules/.bin/webpack 为了方便项目中通常将打包命令配置在 package.json 的 scripts 中。/* 打包命令配置 */ { &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; } } 执行配置后的打包命令：$ npm run build Webpack 基础配置零配置在 Webpack4 中，在不编写配置文件也可以进行打包，这就是 4.x 版本号称的 “零配置”，其实内部默认对入口文件（entry）和出口文件（output）进行了配置。/* 零配置默认值 */ module.exports = { entry: &#39;./src/index.js&#39;, output: &#39;./dist/main.js&#39; } modemode 是 Webpack4 新提出的概念，用来指定当前构建环境是开发环境（production）、生产环境（development）或 none，默认为 production，设置 mode 可以使用 Webpack 的一些参数值和内置的函数，也可以在打包时针对不同的环境配置不同的打包和优化策略。mode 配置示例：module.exports = { // ... mode: &#39;development&#39; // ... } 设置为 development 开启的参数如下：设置 process.env.NODE_ENV 值为 development；开启 NamedChunksPlugin、NamedModulesPlugin，在代码热更新阶段标识更新的 chunk 和具体模块。设置为 production 开启的参数如下：设置 process.env.NODE_ENV 值为 production；开启 FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、NoEmitOnErrorsPlugin、ModuleConcatenationPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin、TerserPlugin，开启这些插件 Webpack 会对 JS 压缩，识别 package.json 文件中标识代码是否存在副作用的参数等。将 mode 设置为 none 不开启任何优化选项。entryentry 用于配置打包文件的入口，这个文件中会存在一些依赖关系，依赖的模块又存在依赖关系，最后形成一棵依赖树，Webpack 则将这些模块根据依赖关系，最后打包成多个静态资源，entry 主要有两种应用场景（单页应用和多页应用），配置如下。/* 单入口（SPA） */ module.exports = { entry: &#39;./src/index.js&#39; } /* 多入口（多页应用） */ module.exports = { entry: { app: &#39;./src/pages/app.js&#39;, adminApp: &#39;./src/pages/adminApp.js&#39; } } outputentry 配置是用于指定的是源代码，那 output 就是用于指定 Webpack 打包后的结果代码，即用来告诉 Webpack 如何将编译后的文件输出到磁盘。module.exports = { // ... output: { filename: &#39;bundle.js&#39;, path: __dirname + &#39;/dist&#39; } } output 属性值为对象，其中 filename 属性用于指定打包输出后的文件名，path 用于指定打包输出的目录，如果是多页应用，可以使用占位符保证打包后输出多个出口文件名字的唯一性。/* 多页应用 */ module.exports = { entry: { app: &#39;./src/pages/app.js&#39;, adminApp: &#39;./src/pages/adminApp.js&#39; }, output: { filename: &#39;[name].js&#39;, path: __dirname + &#39;/dist&#39; } } 上面的 [name] 打包后最后输出的出口文件与入口配置的文件名对应，即 app.js 和 adminApp.js。loadersWebpack 默认情况下只支持 js 和 json 两种文件类型，loader （加载器）是专门用来支持其他文件类型并把其他文件转换成有效的模块添加到依赖树中，每一个 loader 都默认导出一个函数，接受源文件作为参数，并返回转换的结果，loaders 选项是专门用来配置这些加载器的。常见 loader 表：名称描述babel-loader转化 ES6、ES7 等 JS 新特性css-loader支持 .css 文件的加载和解析less-loader将 less 文件转换成 cssts-loader将 TS 转换成 JSfile-loader对图片、字体等文件的打包raw-loader将文件以字符串的形式导入thread-loader多进程打包 JS 和 CSS配置示例：module.exports = { // ... module: { rules: [ { test: /\\.txt$/, // 指定匹配规则（文件后缀名） use: &#39;raw-loader&#39; // 指定使用的 loader 名称 } ] } } 解析 ES6+ 语法安装依赖：$ npm install babel-loader @babel/preset-env -D loader 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.js$/, use: &#39;babel-loader&#39; } // ... ] } // ... } 在工程中添加 .babelrc 文件来对解析的 ES6+ 语法进行配置。.babelrc 配置示例：/* 以 babel7 为例 */ { &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ], &quot;plugins&quot;: [ &quot;@babel/proposal-class-properties&quot; // ... ] } babel 配置主要包含两部分，presets 和 plugins，plugins 中配置的每一项都是为了解析某一个语法，而 presets 配置的是这些功能的集合。解析 React 的 JSX 语法由于 React 是在 .js 或 .jsx 的文件中使用 JSX 语法，所以解析 JSX 语法也是解析 JS 工作的一部分，同样需要 babel-loader，需要在 Webpack 配置文件的 loader 配置中增加识别 .jsx 文件以及在 .babelrc 配置文件的 presets 中专门增加解析 JSX 功能的集合。安装依赖：$ npm install babel-loader @babel/preset-env @babel/preset-react -D loader 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.(jsx?)$/, use: &#39;babel-loader&#39; } // ... ] } // ... } .babelrc 配置示例：{ &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;: [ &quot;@babel/proposal-class-properties&quot; // ... ] } 解析 CSS解析 CSS 主要靠 css-loader 和 style-loader：css-loader：用于加载 .css 文件，并转换成 CommonJS 对象；style-loader：将样式通过 &lt;style&gt;&lt;/style&gt; 标签插入到 html 文件的 head 中。安装依赖：$ npm install css-loader style-loader -D loader 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] } // ... ] } // ... } 值得注意的是，在处理同一个类型文件使用多个 loader 时，是链式调用的，loader 的执行顺序是从右向左的，所以在编写解析 CSS 加载器配置时应该 style-loader 在前，css-loader 在后，即先通过 css-loader 解析 .css 文件，将解析好的结果传递给 style-loader 处理并插入到页面的 head 中。解析 Less 和 SassLess 和 Sass 作为 CSS 的预编译语言，加入了很多编程的特性，功能更强，对样式的组织也更加的灵活，但是浏览器依然不识别，所以也需要 Webpack 进行编译转换。安装依赖（Less）：$ npm install css-loader style-loader less-loader less -D 安装依赖（Sass）：$ npm install css-loader style-loader sass-loader node-sass -D loader 配置示例：/* less 配置 */ module.exports = { // ... module: { rules: [ // ... { test: /\\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] } // ... ] } // ... } /* sass 配置 */ module.exports = { // ... module: { rules: [ // ... { test: /\\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] } // ... ] } // ... } 解析图片和字体资源Webpack 对其他类型的文件进行打包编译需要依赖 file-loader（专门用于处理文件）。安装依赖：$ npm install file-loader -D file-loader 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.(png|svg|gif|jpe?g)$/, // 解析图片 use: &#39;file-loader&#39; }, { test: /\\.(woff2?|eot|ttf|otf)$/, // 解析字体 use: &#39;file-loader&#39; } // ... ] } // ... } 也可以使用 url-loader 来实现对图片和字体资源的解析，url-loader 相比 file-loader 而言，支持更颗粒化的解析方式，可以配置解析后出口文件的具体目录，也可以根据资源大小设置将资源转换成 base64。安装依赖：$ npm install url-loader -D url-loader 配置示例：module.exports = { // ... module: { rules: [ // ... { test: /\\.(png|svg|gif|jpe?g)$/, // 解析图片 use: [ { loader: &#39;url-loader&#39;, options: { limit: 10240, // 资源小于该数值转为 base64 name: &#39;img/[name].[ext]&#39; // 打包后的输出路径 } } ] } // 字体资源同理... ] } // ... } PostCSS 对 CSS 的增强在开发 CSS 时，存在着很多让我们头疼的的问题，比如有些 CSS3 的属性由于各浏览器的实现标准不同要加上不同的私有前缀，也比如为了在移动端进行页面适配使用的 rem、vw 单位与 px 的转换问题等等，其中的一部分问题其实是可以在 Webpack 构建的过程中直接解决的。安装依赖：$ npm install postcss-loader autoprefixer postcss-px2rem -D 可以通过 Webpack 配置文件中直接配置，也可以 PostCSS 配置文件中进行配置。配置示例：/* 配置在 Webpack 配置文件 */ module.exports = { module: { rules: [ // ... { test: /\\.css/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, // 使用 postcss-loader options: { plugins: [ // 添加私有前缀 require(&#39;autoprefixer&#39;)({ // 兼容浏览器版本（最后两个版本、使用率大于 1%，ios 7 以上） browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;] }), // px 自动转换 rem require(&#39;postcss-px2rem&#39;)({ remUnit: 75, // 75 px 等于 1 rem remPrecision: 8 // 换算结果小数点后面保留几位小数 }) // ... ] } } ] } // ... ] } } /* 在 postcss.config.js 中配置 */ module.exports = { plugins: [ require(&#39;autoprefixer&#39;)({ browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;] }), require(&#39;postcss-px2rem&#39;)({ remUnit: 75, remPrecision: 8 }) // ... ] } 如果使用其他 PostCSS 的功能也是类似的，需要先下载对应的 PostCSS 插件，然后在配置文件中进行配置。pluginsplugins 通常用来对 Webpack 打包功能的增强，对打包过程和出口文件大小的优化、资源管理和环境变量的注入，可以作用域整个构建过程。常见 plugin 表：名称描述CommonsChunkPlugin将 chunks 相同的模块代码提取成公共 jsCleanWebpackPlugin清理构建目录ExtracTextWebpackPlugin将 CSS 从 bundle 文件里提取成一个独立的 .css 文件CopyWebpackPlugin将文件或者文件夹拷贝到构建的输出目录HtmlWebpackPlugin创建 html 文件并注入 bundle 文件UglifyjsWebpackPlugin压缩 .js 文件ZipWebpackPlugin将打包出的资源生成一个 .zip 包自动生成 index.html自动生成 index.html 文件主要通过 HtmlWebpackPlugin 插件实现。安装依赖：$ npm install html-webpack-plugin -D 配置示例：// 引入插件 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { // ... plugins: [ // 创建插件的实例 new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, // 模板文件路径 filename: &#39;index.html&#39; // 输出文件名称 }) // ... ] } 抽取 CSS 文件Webpack 在上面对 CSS 的解析中，使用了 css-loader 和 style-loader，通过构建后的结果发现 .css 文件被注入到了 .js 文件中，在生产环境通常会为了减小出口文件的体积对 .css 文件进行抽离，在 Webpack4 中使用 MiniCssExtractPlugin 插件来实现。安装依赖：$ npm install mini-css-extract-plugin -D 配置示例：const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); module.exports = { // ... module: { rules: [ // ... { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, // 用于将 CSS 抽离的加载器 &#39;css-loader&#39;, ] } // ... ] }, plugins: [ // ... new MiniCssExtractPlugin({ filename: &#39;[name].css&#39; // 抽离的文件名 }) // ... ] // ... } 解析 .css 文件无论哪种方式需要使用 css-loader，但 MiniCssExtractPlugin 提供的 loader 与 style-loader 的功能是互斥的，style-loader 用于将解析的 CSS 注入，而 MiniCssExtractPlugin.loader 意在单独抽离。自动清理构建目录如果输出的文件配置了 hash 且在每次构建时没有及时删除指定的输出目录（如 dist），会导致输出目录中的文件越来越多，不容易区分哪些是新构建出来的文件，所以应该让 Webpack 在每次构建之前清除输出的目录。当然清除的方式可以多种，比如手动删除，或者在 package.json 中配置的构建命令中增加前置命令如下。/* 不优雅的方式 */ { &quot;scripts&quot;: { &quot;build&quot;: &quot;rm -rf ./dist &amp;&amp; webpack&quot; } } 这种方式并不优雅，完全可以通过 Webpack 配置中增加 CleanWebpackPlugin 插件来解决这个问题，这样在每次构建之前就会自动清除输出目录。安装依赖：$ npm install clean-webpack-plugin -D 配置示例：const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); module.exports = { // ... output: { filename: &#39;[name][chunkhash:8].js&#39;, path: __dirname + &#39;dist&#39; } plugins: [ new CleanWebpackPlugin() ] // ... } watchWebpack 中，文件监听是指发现源文件发生变化时，自动重新构建出新的输出文件。Webpack 开启监听模式有两种方式：启动 Webpack 命令时带上 --watch 参数，可以在 package.json 中进行配置；在 Webpack 配置文件中进行设置。添加参数：/* 配置命令 */ { &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot; } } 执行命令：$ npm run watch Webpack 配置文件：/* webpack 配置文件 */ module.exports = { // ... watch: true, // 开启监听 watchOptions: { // 忽略监听的文件目录 ignored: /node_modules/, // 监听到发生变化会等待 300ms 去重新构建（防止多次保存），默认 300ms aggregateTimeout: 300， // 每秒检查 1000 次 poll: 1000 } // ... } watch 监听原理分析：Webpack 会轮询的判断文件的最后编辑时间是否发生变化，如果某个文件发生变化不会立即重新构建，而是会将变化缓存起来，等待 aggregateTimeout 配置的时间后重新构建，这样做是为了防止短时间的多次变化或产生了新的变化文件，在该时间到达时将变化的文件列表进行统一构建，以提高性能，这样的监听方式的缺陷是浏览器不会自动刷新，需要手动刷新查看文件修改后的效果。devServerwebpack-dev-server 是在本地启动服务来监听文件的变化，不是以输出文件的形式更新，而是即时将重新构建的结果放在内存中。安装依赖：$ npm install webpack-dev-server -D 配置示例：module.exports = { // ... mode: &#39;development&#39;, // 由于 webpack-dev-server 在开发环境中使用 devServer: { host: &#39;localhost&#39;, // 本地服务的域名 contentBase: &#39;./dist&#39;, // server 作用的目录 port: 8080, // 端口号 compress: true // 是否启动服务器压缩 } // ... } 配置服务启动命令：{ &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --open&quot; } } devtool在 Webpack 构建后的代码中，经过了压缩、混淆等，会出现一个新的问题，就是代码执行出错后不容定位错误是在源代码中哪一个位置产生的，而 devtool 的配置的作用就是让我们更容易定位错误的位置。devtool 的关键词：关键词作用evel使用 evel 函数包裹代码source-map产生 .map 文件cheap不含列信息inline将 .map 内容作为 DataURI 嵌入，不单独生成 .map 文件module包含 loader 的 source-mapdevtool 属性的值就是由上面的关键词组成的，不同的名字会使用不同的调试策略，而名字中的关键词则包含了上面特性，下面是 Webpcak 官网给出的不同构建策略对应的信息。devtool首次构建二次构建是否适合生产环境可以定位的代码none++++++yes最终输出的代码eval++++++noWebpack 生成的代码（一个个的模块）cheap-eval-source-map+++no经过 loader 转换后的代码（只能看到行）cheap-module-eval-source-mapo++no源代码（只能看到行）eval-source-map--+no源代码cheap-source-map+ono经过 loader 转换后的代码（只能看到行）cheap-module-source-mapo-no源代码（只能看到行）inline-cheap-source-map+ono经过 loader 转换后的代码（只能看到行）inline-cheap-module-source-mapo-no源代码（只能看到行）source-map----yes源代码inline-source-map----no源代码hidden-source-map----yes源代码nosources-source-map----yes无源代码+++ 非常快速，++ 快速，+ 比较快，o 中等，- 比较慢，-- 慢配置示例：module.exports = { // ... devtool: &#39;evel&#39; // ... } 使用不同的 devtool 会带来不同的效果，使用 evel 不安全，使用 inline 注入会增加打包文件的大小、线上环境生成 .map 文件会容易被人反编译进而暴露业务逻辑等等，所以在 devtool 使用时还是根据自己的需要和安全考虑来权衡。热更新配置热更新的方式webpack-dev-server 可以配合自带的插件实现热更新，即文件修改后，不刷新浏览器的情况下自动构建并在浏览器中响应渲染。/* 使用 webpack-dev-server */ const webpack = require(&#39;webpack&#39;); module.exports = { // ... mode: &#39;development&#39;, devServer: { host: &#39;localhost&#39;, contentBase: &#39;./dist&#39;, port: 8080, compress: true }, plugins: [ new webpack.HotModuleReplacementPlugin() ] // ... } 想要颗粒度更细致的控制 Webpack 的热更新，也可以使用另一种方式，即借助 Express 或 Koa 自己创建一个服务，并借助 webpack-dev-middleware 来实现热更新，这种方式更适合灵活的定制化场景。/* 使用 webpack-dev-middleware */ const express = require(&#39;express&#39;); const webpack = require(&#39;webpack&#39;); const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;); const config = require(&#39;./webpack.config.js&#39;); const app = express(); const compiler = webpack(config); app.use(webpackDevMiddleware(compiler, { publicPath: config.output.publicPath })); app.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 热更新原理简介热更新的实现分为服务端和浏览器两个部分：Webpack Dev ServerWebpack Compile：Webpack 的编译器，作用是将 JS 编译成 Bundle；HMR Server：将热更新的文件输出给 HMR Runtime；Bundle Server：提供文件在浏览器以服务器的方式访问。BrowserHMR Runtime：开发阶段打包过程中，会被注入到浏览器，使浏览器的 bundle.js 和服务器建立 websocket 链接，以更新文件的变化；bundle.js：构建输出的文件。Webpack 在将本地文件显示在浏览器其实有两个阶段：第一个阶段为启动阶段通过 Webpack Compile 将文件系统中的文件进行构建，然后将文件传递给 Bundle Server，Bundle Server 将 bundle.js 响应给浏览器；第二个阶段为热更新阶段，依然通过 Webpack Compile 对文件系统中修改的文件进行构建，将构建后的结果传递给 HMR Server，HMR Server 通过 Websocket 协议将文件变化的结果通知浏览器端的 HMR Runtime，执行代码并刷新页面。未完待续…","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"构建","slug":"构建","permalink":"https://www.overtaking.top/tags/%E6%9E%84%E5%BB%BA/"}]},{"title":"设计模式 JS 表现 —— 外观模式","date":"2018-10-01T08:51:25.000Z","path":"20181001165125/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式外观模式简介“外观模式” 就是把一些复杂的流程封装成一个接口，提供给外部更简单的使用。在外观模式中存在三种角色如下：门面角色（Facade）：是 “外观模式” 的核心，它熟悉子系统的功能，并被客户角色调用，内部实现了客户角色需求功能的组合；子系统角色（System）：实现了子系统的功能（多个），对于客户角色是未知的；客户角色（Client）：通过调用 Facede 来完成要实现的功能。外观模式 UML 图外观模式的实现上面已经介绍了 “外观模式” 的各个角色，下面是简单的代码实现。// 子系统角色 Sum class Sum { sum(a, b) { return a + b; } } // 子系统角色 Minus class Minus { minus(a, b) { return a - b; } } // 子系统角色 Multipy class Multipy { multipy(a, b) { return a * b; } } // 子系统角色 Divide class Divide { divide(a, b) { return a / b; } } // 门面角色 Calculator class Calculator { constructor() { this.sumObj = new Sum(); this.minusObj = new Minus(); this.multipyObj = new Multipy(); this.divideObj = new Divide(); } sum(...args) { return this.sumObj.sum(...args); } minus(...args) { return this.minusObj.minus(...args); } multipy(...args) { return this.multipyObj.multipy(...args); } divide(...args) { return this.divideObj.divide(...args); } } // 客户角色 const calculator = new Calculator(); console.log(calculator.sum(1, 2)); // 3 console.log(calculator.minus(1, 2)); // -1 console.log(calculator.multipy(1, 2)); // 2 console.log(calculator.divide(1, 2)); // 0.5 我们在上面代码中实现了一个计算器功能，计算器具备的功能为加、减、乘、除，我们把这四个功能分别拆分成为四个子系统，用门面类 Calculator 来进行连接，这样只需要调用 Calculator 的实例（客户角色）就可以调用四个子系统模块分别提供的功能，但是上面的代码实现功能比较简洁，并没达到 “外观模式” 的真正作用，就是可以随意组合各个子系统的功能。/* 组合子系统功能 */ // 子系统角色 CPU class CPU { start() { console.log(&#39;CPU 启动&#39;); } } // 子系统角色 Memory class Memory { start() { console.log(&#39;内存启动&#39;); } } // 子系统角色 Disk class Disk { start() { console.log(&#39;硬盘启动&#39;); } } // 门面角色 Computer class Computer { constructor() { this.cpu = new CPU(); this.memory = new Memory(); this.disk = new Disk(); } start() { // 组合子系统功能 this.cpu.start(); this.memory.start(); this.disk.start(); } } // 客户角色 const computer = new Computer(); computer.start(); // CPU 启动 // 内存启动 // 硬盘启动 上面代码打印了一个计算机的启动过程，功能来自于各个子系统，也可以通过门面角色实现子系统功能的多种组合。总结“外观模式” 的作用是可以对复杂功能解耦合，分散到各个子系统，使子系统与子系统互相独立，并对各个子系统提供外界访问的功能组合模块，这样既提高了子系统的维护性，又增加了外界访问功能的扩展性，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.overtaking.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 代理模式","date":"2018-09-28T18:56:41.000Z","path":"20180929025641/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式代理模式概念由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。代理模式 UML 图基本实现// 假设无法客户端无法直接使用这个类 class Google { get(url) { return url + &#39; is google&#39;; } } // 只能通过代理操作 Google 类 class Proxy { constructor() { this.google = new Google(); } get(url) { return this.google.get(url); } } const proxy = new Proxy(); const result = proxy.get(&#39;http://www.google.com&#39;); console.log(result); // http://www.google.com is google 假设 Google 类我们无法直接使用，只有 Proxy 可以使用 Google，我们可以通过 Proxy 类去操作使用 Google 类，此时 Proxy 类就是一个代理。ES6 的 Proxy在 ES6 标准以后，JavaScript 提供了原生的代理模式 Proxy 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。/* ES6 Proxy 的使用 */ const lucy = { name: &#39;lucy&#39;, age: 20, height: 165 }; const lucyMother = new Proxy(lucy, { get(target, key) { if (key === &#39;age&#39;) { return target.age - 2; } else if (key === &#39;height&#39;) { return target.height + 5; } else { return target[key]; } }, set(target, key, val) { if (key === &#39;boyfriend&#39;) { if (val.age &gt; 40) { console.log(&#39;太老了&#39;); } else if (val.salary &lt; 20000) { console.log(&#39;太穷了&#39;); } else { target[key] = val; } } } }); console.log(lucyMother.name); // lucy console.log(lucyMother.age); // 18 console.log(lucyMother.height); // 170 lucyMother.boyfriend = { age: 42, salary: 25000 } // 太老了 lucyMother.boyfriend = { age: 36, salary: 18000 } // 太穷了 上面是一个接地气的案例，创建一个对象存储 lucy 的基本信息，使用代理创建 lucyMother 为 lucy 找男朋友，通过代理对象获取 lucy 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。代理模式、适配器模式和装饰器模式从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来接口的功能；适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。代理模式的应用事件委托事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;事件委托&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const ulList = document.getElementById(&#39;list&#39;); ulList.addEventListener(&#39;click&#39;, function (event) { console.log(event.target.innerHTML); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 target 获取到具体触发事件的子元素。图片加载图片加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 loading 图片来过渡，这就是图片加载的基本需求。/* node 服务器 */ const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); const app = express(); app.get(&#39;/loading.gif&#39;, function (req, res) { res.sendFile(path.resolve(&#39;img&#39;, &#39;loading.gif&#39;)); }); app.get(&#39;/img/:name&#39;, function (req, res) { setTimeout(function () { res.sendFile(path.join(__dirname, req.path)); }, 3000); }); app.use(express.static(__dirname)); app.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 上面服务器模拟了加载图片响应慢的场景，loading 图片立即响应，其他图片则延迟 3s 响应。&lt;!-- Dom 结构 --&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li data-src=&quot;/img/bg1.jpg&quot;&gt;图片1&lt;/li&gt; &lt;li data-src=&quot;/img/bg2.jpg&quot;&gt;图片2&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;bgimg&quot;&gt;&lt;/div&gt; /* 没有实现 loading */ const menu = document.getElementById(&#39;menu&#39;); const bgimg = document.getElementById(&#39;bgimg&#39;); const background = (function () { const img = new Image(); bgimg.appendChild(img) return { setSrc(src) { img.src = src; } } })(); menu.addEventListener(&#39;click&#39;, function (event) { const src = event.target.dataset.src; background.setSrc(src); }); 上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 loading 图片过渡，之所以说图片加载应用了 “代理模式” 并不是指加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在事件监听的函数中增加 loading 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。/* 使用代理对象实现 loading 过渡 */ const menu = document.getElementById(&#39;menu&#39;); const bgimg = document.getElementById(&#39;bgimg&#39;); // 请求图片的对象 const background = (function () { const img = new Image(); bgimg.appendChild(img) return { setSrc(src) { img.src = src; } } })(); // 增加 loading 过度的代理对象 const proxyBackground = (function () { const img = new Image(); img.onload = function () { background.setSrc(this.src); } return { setSrc(src) { background.setSrc(&#39;./img/loading.gif&#39;); img.src = src; } } })(); // 监听获取图片的事件中使用的是代理对象 proxyBackground menu.addEventListener(&#39;click&#39;, function (event) { const src = event.target.dataset.src; // 防止缓存 proxyBackground.setSrc(src + &#39;?time=&#39; + Date.now()); }); 上面的实现方式就符合 “代理模式”，background 对象是提供基本功能，而proxyBackground（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 setSrc 方法去请求图片。防抖代理防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。&lt;!-- 未使用防抖代理处理 --&gt; &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt; &lt;script&gt; const ipt = document.getElementById(&#39;ipt&#39;); function post() { console.log(&#39;发送请求了&#39;); } ipt.addEventListener(&#39;input&#39;, post); &lt;/script&gt; 上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。&lt;!-- 使用防抖代理优化 --&gt; &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt; &lt;script&gt; const ipt = document.getElementById(&#39;ipt&#39;); function post() { console.log(&#39;发送请求了&#39;); } // 代理函数去执行 post const debouncePost = (function () { let timer = null; return function () { clearInterval(timer); timer = setTimeout(function () { post(); }, 500); } })(); ipt.addEventListener(&#39;input&#39;, debouncePost); &lt;/script&gt; 使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 500ms 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。总结使用 “代理模式” 的场景在后端会更多，比如代理跨域，Nginx 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.overtaking.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 装饰器模式","date":"2018-09-27T19:01:05.000Z","path":"20180928030105/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式装饰器模式概念“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。装饰器模式 UML 图装饰器模式和适配器模式/* 装饰器模式案例 */ // 类 Duck class Duck { constructor(name) { this.name = name; } eat(food) { console.log(this.name + &#39;吃&#39; + food); } } // 装饰器类 TangDuck，装饰 Duck 类 class TangDuck { constructor(name) { this.duck = new Duck(name); } eat(food) { this.duck.eat(food); console.log(&#39;说谢谢&#39;); } } const tangDuck = new TangDuck(&#39;唐老鸭&#39;); tangDuck.eat(&#39;苹果&#39;); // 唐老鸭吃苹果 // 说谢谢 /* 适配器模式案例 */ // 类 Power class Power { charge() { return &#39;220V&#39;; } } // 适配器 class Adaptor { constructor(Power) { this.power = new Power(); } chargeTransform() { return this.power.charge() + &#39; =&gt; 22v&#39;; } } // 类 Power 的使用者 class Notepad { constructor(Power) { this.adaptor = new Adaptor(Power); } use() { console.log(this.adaptor.chargeTransform()); } } 上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。装饰器模式和继承通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 Coffee，组成是咖啡加水，这个基础上可以加奶、糖、冰，需求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。/* 继承的实现方式 */ // 水 + 咖啡 class Coffee { make(water) { return water + &#39; + 咖啡&#39; } cost() { return 10; } } // 水 + 奶 + 咖啡 class MilkCoffee extends Coffee { constructor() { super(); } make(water) { return super.make(water) + &#39; + 奶&#39;; } cost() { return super.cost() + 3; } } // 水 + 糖 + 咖啡 class SugarCoffee extends Coffee { constructor() { super(); } make(water) { return super.make(water) + &#39; + 糖&#39;; } cost() { return super.cost() + 2; } } // 水 + 糖 + 奶 + 咖啡 class SugarMilkCoffee extends SugarCoffee { constructor() { super(); } make(water) { return super.make(water) + &#39; + 奶&#39;; } cost() { return super.cost() + 3; } } // 水 + 奶 + 糖 + 咖啡 class MilkSugarCoffee extends MilkCoffee { constructor() { super(); } make(water) { return super.make(water) + &#39; + 糖&#39;; } cost() { return super.cost() + 2; } } 从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。/* 装饰器模式的实现方式 */ class Coffee { make(water) { return water + &#39; + 咖啡&#39;; } cost() { return 10; } } class MilkCoffee { constructor(parent) { this.parent = parent; } make(water) { return this.parent.make(water) + &#39; + 奶&#39;; } cost() { return this.parent.cost() + 3; } } class SugarCoffee { constructor(parent) { this.parent = parent; } make(water) { return this.parent.make(water) + &#39; + 糖&#39;; } cost() { return this.parent.cost() + 2; } } class IceCoffee { constructor(parent) { this.parent = parent; } make(water) { return this.parent.make(water) + &#39; + 冰&#39;; } cost() { return this.parent.cost() + 1; } } const coffee = new Coffee(); const milkCoffee = new MilkCoffee(coffee); const sugarCoffee = new SugarCoffee(milkCoffee); const iceCoffee = new IceCoffee(sugarCoffee); console.log(milkCoffee.make(&#39;水&#39;), milkCoffee.cost()); console.log(sugarCoffee.make(&#39;水&#39;), sugarCoffee.cost()); console.log(iceCoffee.make(&#39;水&#39;), iceCoffee.cost()); // 水 + 咖啡 + 奶 13 // 水 + 咖啡 + 奶 + 糖 15 // 水 + 咖啡 + 奶 + 冰 16 从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。装饰器模式和 AOP 编程在软件业，AOP 为 Aspect Oriented Programming 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。在 JavaScript 中的 AOP 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。/* AOP 编程的案例 */ // 给函数扩展 before 方法 Function.prototype.before = function (beforeFn) { let _this = this; return function () { beforeFn.apply(this, arguments); _this.apply(this, arguments); } } // 给函数扩展 after 方法 Function.prototype.after = function (afterFn) { let _this = this; return function () { _this.apply(this, arguments); afterFn.apply(this, arguments); } } // 原函数 function buy(money, goods) { console.log(&#39;花&#39; + money + &#39;元钱买&#39; + goods); } // 使用 before 方法给函数增加前切面 buy = buy.before(function () { console.log(&#39;向媳妇要1元钱&#39;); }); // 使用 before 方法给函数增加后切面 buy = buy.after(function () { console.log(&#39;还给媳妇0.2元钱&#39;); }) buy(0.8, &#39;盐&#39;); // 向媳妇要1元钱 // 花0.8元钱买盐 // 还给媳妇0.2元钱 AOP 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 AOP 编程的一种。装饰器模式的应用监控埋点埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。&lt;!-- 一个埋点的简单案例 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;埋点&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button data-name=&quot;wetermelon&quot; id=&quot;wetermelon&quot;&gt;西瓜&lt;/button&gt; &lt;button data-name=&quot;apple&quot; id=&quot;apple&quot;&gt;苹果&lt;/button&gt; &lt;script&gt; const wetermelon = document.getElementById(&#39;wetermelon&#39;); const apple = document.getElementById(&#39;apple&#39;); // 添加切面 Function.prototype.after = function (afterFn) { let _this = this; return function () { _this.apply(this, arguments); afterFn.apply(this, arguments); } } // 事件处理函数 function click() { console.log(&#39;你点击了&#39; + this.dataset.name); } click = click.after(function () { // 向服务器发送统计数据 const img = new Image(); img.src = &#39;http://localhost:3000/report?name=&#39; + this.dataset.name; }); // 给所有的 Array.from(document.querySelectorAll(&#39;button&#39;)).forEach(button =&gt; { button.addEventListener(&#39;click&#39;, click); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; /* 负责统计点击次数的服务 */ const express = require(&#39;express&#39;); const app = express(); // 存储按钮的点击次数 const goods = {}; app.get(&#39;/report&#39;, function (req, res) { const name = req.query.name; if (goods[name]) { goods[name]++; } else { goods[name] = 1; } res.json(goods); }); app.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 上面的埋点就是通过 AOP 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 report 接口来获取当前各个按钮的点击次数。表单校验“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 submit 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 AOP 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。&lt;!-- 应用于表单校验 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单校验&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt; &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt; &lt;script&gt; const submitBtn = document.getElementById(&#39;submit-btn&#39;); // 添加切面函数 Function.prototype.before = function (beforeFn) { let _this = this; return function () { let result = beforeFn.apply(this, arguments); result &amp;&amp; _this.apply(this, arguments); } } // 表单提交事件 function submit() { console.log(&#39;提交表单&#39;); } // 验证用户名 submit = submit.before(function () { const username = document.getElementById(&#39;username&#39;).value; if (!username) { return alert(&#39;请输入用户名&#39;); } return true; }); // 验证 submit = submit.before(function () { const password = document.getElementById(&#39;password&#39;).value; if (!password) { return alert(&#39;请输入密码&#39;); } return true; }); submitBtn.addEventListener(&#39;click&#39;, submit); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结在 JavaScript 中 “装饰器模式” 和 AOP 编程非常相似，应用也非常多，如 axios 中对请求、响应的拦截方法，Koa 中间件，都包含这样的编程思想，而在 ES6 之后 JavaScript 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.overtaking.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 适配器模式","date":"2018-09-27T15:04:32.000Z","path":"20180927230432/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式适配器模式的概念“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。适配器模式 UML 图// 类 Power class Power { charge() { return &#39;220V&#39;; } } // 适配器 class Adaptor { constructor(Power) { this.power = new Power(); } chargeTransform() { return this.power.charge() + &#39; =&gt; 22V&#39;; } } // 类 Power 的使用者 class Notepad { constructor(Power) { this.adaptor = new Adaptor(Power); } use() { console.log(this.adaptor.chargeTransform()); } } const notepad = new Notepad(Power); notepad.use(); // 220V =&gt; 22V 上面代码中有三个类，Power 类为电源，提供 220V 电压，Notepad 为我们的电子设备，使用电压 22V，明显两个类是不匹配的，此时的 Adaptor 就是一个适配器，作用是连接 Power 与 Notepad，将 220V 转换为 22V。适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。适配器模式的应用适配参数和返回数据在浏览器通过 Ajax 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。在请求响应后，后端会返回给我们 JSON 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。// 请求方法 function ajax(options) { const defaultOptions = { method: &#39;GET&#39;, dataType: &#39;JSON&#39; }; initParams(options, defaultOptions); // 适配参数 } // 参数适配器 function initParams(options, defaultOptions) { for (let attr in options) { defaultOptions[attr] = options[attr] || defaultOptions[attr]; } return defaultOptions; } // 数据适配器 function tranformData(data) { return JSON.parse(data); } // 使用适配器 ajax({ url: &#39;www.pandashen.com&#39;, method: &#39;POST&#39;, success(json) { const result = tranformData(json); // 适配返回数据 console.log(result); } }); 适配转换 Promise在 Node.js 的 fs 模块中有很多异步的方法，比如 readFile，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 Promise 实例。const fs = require(&#39;fs&#39;); // 适配成 Promise function promisify(fn) { return function (...args) { return new Promise((resolve, reject) =&gt; { fn.call(null, ...args, (err, data) =&gt; { err ? reject(err) : resolve(data); }); }); } } // 使用适配后的方法 const readFile = promisify(fs.readFile); readFile(&#39;index.txt&#39;, &#39;utf-8&#39;).then(data =&gt; { console.log(data); // Hello world }); 适配技术栈变更后的旧代码在一些老项目是 jQuery 的技术栈，请求也使用的是自带的 $.ajax，如果一天项目中决定移除 jQuery，请求方法 $.ajax 自然也跟着移除了，假设我们想使用 fetch 来代替 $.ajax，则要修改大量的代码，这时 “适配器模式” 可以对 fetch 进行适配，让我们继续沿用 $.ajax 的写法。// 适配器 window.$ = { ajax(options) { return fetch(options.url, { method: options.type || &#39;GET&#39;, body: JSON.stringifily(options.data || {}) }).then(res =&gt; res.json()); } }; // $.ajax 的旧代码 $.ajax({ url: &#39;pandashen.com/info&#39;, type: &#39;POST&#39;, dataType: &#39;json&#39;, data: { id: 1 } }).then(function (data) { console.log(data); }); 总结“适配器模式” 是很常用的设计模式之一，Vue 的 computed 计算属性、Koa 兼容 1.x 和 2.x 版本的转换中间件 koa-convert 都应用了 “适配器模式”，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.overtaking.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 单例模式","date":"2018-09-26T12:14:47.000Z","path":"20180926201447/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 工厂模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式普通单例模式“单例模式” 就是通过类创建实例后，每次创建和获取都返回同一个实例，下面是 “单例模式” 最基本的实现。单例模式 UML 图/* ES6 写法 */ class Person { constructor(name) { this.name = name; } static getInstance(name) { if (!this.instance) { this.instance = new Person(name); } return this.instance; } } const w1 = Person.getInstance(&#39;hello&#39;); const w2 = Person.getInstance(&#39;world&#39;); console.log(w1 === w2); // true /* ES5 写法 */ function Person(name) { this.name = name; } Person.getInstance = (function () { let instance; return function (name) { if (!instance) { instance = new Person(name); } return instance; } })(); const w1 = Person.getInstance(&#39;hello&#39;); const w2 = Person.getInstance(&#39;world&#39;); console.log(w1 === w2); // true 上面分别用 ES6 和 ES5 的方式实现了一个基本的单例模式，创建 Person 的实例时需要通过 getInstance 静态方法，这样第一次会创建一个实例，再次调用时会将之前创建的实例返回，达到单例的目的。上面单例模式的缺点：类的使用者必须要知道这是一个单例的类，创建和获取实例必须通过调用 getInstance 方法；并不能真正阻止类的使用者通过 new 关键字创建出新的实例。透明单例模式“透明单例模式” 可以解决上面普通 “单例模式” 的不足，希望可以直接使用 new 关键字来创建类的实例，如果已经创建，再次通过 new 创建，则会返回之前创建的实例。/* 透明单例模式 */ const Person = (function () { let instance; return function (name) { if (instance) { return instance; } else { this.name = name; instance = this; } } })(); const w1 = new Person(&#39;hello&#39;); const w2 = new Person(&#39;world&#39;); console.log(w1 === w2); // true “透明单例模式” 的原理是创建一个自执行函数，内部创建一个私有变量 instance 用来存储创建的实例，并通过闭包返回一个构造函数，用变量 Person 接收，当使用 new 创建实例时，先检测私有变量 instance 是否有值，如果没值则创建实例，如果有值则直接返回 instance（利用 new 关键字和构造创建实例的原理实现）。缺点：违反了单一职责原则（一个函数只做一件事），自执行函数返回的构造函数已经不止单纯用作构建实例，同时处理了单例的判断逻辑。单例与构建分离针对上面 “透明单例模式” 的缺点，下面将构造函数单例处理与构建逻辑进行分离。/* 单例逻辑与构建逻辑分离 */ // 真正的构造函数 function Person(name) { this.name = name; } Person.prototype.getName = function () { console.log(this.name); } // 新的构造函数 const CreatePerson = (function () { let instance; return function (name) { if (!instance) { instance = new Person(name); } return instance; } })(); const w1 = new CreatePerson(&#39;hello&#39;); const w2 = new CreatePerson(&#39;world&#39;); console.log(w1 === w2); // true 上面代码将单例的逻辑与构造函数的逻辑进行了分离，真正用于构造实例的类是 Person，用于处理单例逻辑的是自执行函数返回的函数，使用 CreatePerson 变量接收，这个函数也同时约定好被当做构造函数使用（通过 new 关键字调用和直接执行效果相同）。缺点：生成的新构造函数名字（CreatePerson）是固定的，用来创建实例的这个类（Person）也是固定的，不够灵活。封装变化下面支持不同的构造函数创建实例，并且可以使用原本构造函数的对应方法，就是把上面案例不灵活的地方变得灵活。/* 封装变化 */ const CreateSingle = function (Constructor) { let instance; const SingleConstructor = function () { if (!instance) { Constructor.apply(this, arguments); instance = this; } return instance; } // 实现原型继承 SingleConstructor.prototype = Object.create(Constructor.prototype); return SingleConstructor; } /* 使用方式 */ // 构造函数 function Person(name, age) { this.name = name; this.age = age; } function Dailog(name) { this.name = name } // 原型方法 Person.prototype.sayHi = function () { console.log(this.name + &#39;：&#39; + this.age); } Dailog.prototype.getName = function () { console.log(this.name); } // 创建新的构造函数并生成实例 const CreatePerson = CreateSingle(Person); const w1 = new CreatePerson(&#39;hello&#39;, 18); const w2 = new CreatePerson(&#39;world&#39;, 20); const CreateDailog = CreateSingle(Dailog); const s1 = new CreateDailog(&#39;model&#39;); const s2 = new CreateDailog(&#39;view&#39;); console.log(w1 === w2); // true console.log(s1 === s2); // true 上面我们把创建单例的逻辑进行了封装变成了一个通用的逻辑，对于不同构造函数所创建实例，只需要传入这个构造函数并生成新的构造函数，需要注意的是，新的构造函数无法继承原构造函数的原型方法，所以通过继承实现的。单例模式的应用命名空间在编写代码时，我们有时候需要人为的创建命名空间，以防止变量的相互污染，这是可以使用 “单例模式” 来实现。/* 创建命名空间的方法 */ // 存储工具方法 const utils = {}; // 定义命名空间 utils.define = function (namespace, fn) { // 获取命名空间的数组 const namespaces = namespace.split(&#39;.&#39;); // 最后一项为设定方法的属性名 const methodName = namespaces.pop(); // 定义变量存储当前命名空间的引用，默认为 utils（根命名空间） let current = utils; for (let i = 0; i &lt; namespaces.length; i++) { const currentNamespace = namespaces[i]; // 当某一个命名空间没有时，则创建这个命名空间（单例模式） if (!current[currentNamespace]) { current[currentNamespace] = {}; } // 否则让当前命名空间指向已有的命名空间 current = current[currentNamespace]; } // 将传入的函数设定给最后一级命名空间的属性上 current[methodName] = fn; } /* 命名空间的创建和使用 */ // 通过命名空间定义方法 utils.define(&#39;dom.class.addClass&#39;, function () { console.log(&#39;dom.class.addClass&#39;); }); utils.define(&#39;string.trim&#39;, function () { console.log(&#39;string.trim&#39;); }); utils.define(&#39;event.prevent&#39;, function () { console.log(&#39;event.prevent&#39;); }); // 使用方法 utils.dom.class.addClass(&#39;title&#39;); // dom.class.addClass utils.string.trim(&#39; hello &#39;); // string.trim utils.event.prevent(); // event.prevent 上面代码的设计希望通过 utils 对象的 define 方法按照传入的表示命名空间的字符串去创建方法，基本实现思路和逻辑是，当一个属性是第一次出现时，创建一个对象作为该命名空间，当再次出现时则不会重复创建命名空间（因为会出现覆盖的问题），而是沿用之前创建的命名空间。LRU 缓存LRU 全称为 Least Recently Used，为最近使用的意思，缓存的方式为访问一个元素时，则将其标记为活跃，当存储时，如果超出容量则删除最不常用的元素。/* 创建 LRU 缓存类 */ class LRUCache { constructor(capacity) { this.capacity = capacity; this.members = []; } put(key, val) { let oldestIndex = -1; // 最不活跃项的索引 let oldestAge = -1; // 最不活跃项的活跃数值 let found = false; for (let i = 0; i &lt; this.members.length; i++) { const member = this.members[i]; // 如果找到当前最不活跃的项，将 oldestAge 和 oldestIndex 更新为该项对应值 if (member.age &gt; oldestAge) { oldestAge = member.age; oldestIndex = i; } // 如果添加项在原本 members 中已经存在，则更新 age 的值为 0 if (member.key === key) { this.members[i] = { key, val, age: 0 }; found = true; // 为了跳过 push 新增的环节 } else { // 否则其他所有项 age 自增 member.age++; } } if (!found) { if (this.members.length &gt;= this.capacity) { this.members.splice(oldestIndex, 1); } this.members.push({ key, val, age: 0 }); } } get(key) { for (let i = 0; i &lt; this.members.length; i++) { const member = this.members[i]; if (member.key === key) { member.age = 0; return member.val; } } return -1; } } 上面是一个创建 LRU 缓存的类，用数组管理成员，put 方法用于新增成员，get 方法用于访问成员，当访问成员时，成员的 age 清零，代表最近活跃，当新增元素时，如果该元素已存在，则做覆盖操作，如果不存在，则推入数组中，age 设置为零，其他成员 age 自增，若数组超出容量时，先找到 age 最大的元素删除，再将新的元素推入数组，上面是一个直观但性能较差的实现，如果有兴趣可以使用链表进行优化。/* 使用 LRU 缓存 */ const cache = new LRUCache(2); cache.put(&#39;1&#39;, 1); console.log(cache.members); // [ { key: &#39;1&#39;, val: 1, age: 0 } ] cache.put(&#39;2&#39;, 2); console.log(cache.members); // [ { key: &#39;1&#39;, val: 1, age: 1 }, { key: &#39;2&#39;, val: 2, age: 0 } ] cache.put(&#39;3&#39;, 3); console.log(cache.members); // [ { key: &#39;2&#39;, val: 2, age: 1 }, { key: &#39;3&#39;, val: 3, age: 0 } ] cache.put(&#39;2&#39;, &#39;hello&#39;); console.log(cache.members); // [ { key: &#39;2&#39;, val: &#39;hello&#39;, age: 0 }, { key: &#39;3&#39;, val: 3, age: 1 } ] 总结“单例模式” 是设计模式中非常好理解的一个，使用还是非常广泛的，在 Redux 等众多的第三方库中也有所体现，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.overtaking.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 JS 表现 —— 工厂模式","date":"2018-09-25T11:05:03.000Z","path":"20180925190503/","text":"前言这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 JavaScript 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 JavaScript 表现。系列文章链接：设计模式 JS 表现 —— 单例模式设计模式 JS 表现 —— 适配器模式设计模式 JS 表现 —— 装饰器模式设计模式 JS 表现 —— 代理模式设计模式 JS 表现 —— 外观模式设计模式 JS 表现 —— 发布/订阅和观察者模式设计模式 JS 表现 —— 状态模式设计模式 JS 表现 —— 策略模式简单工厂模式“简单工厂模式” 是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式 UML 图/* 直接创建子类实例 */ // 父类 class Plant { constructor(name) { this.name = name; } grow() { console.log(&#39;I am growing!&#39;); } } // 子类 —— Apple class Apple extends Plant { constructor(name, flavour) { super(name); this.flavour = flavour; } } // 子类 —— Orange class Orange extends Plant { constructor(name, flavour) { super(name); this.flavour = flavour; } } // 直接创建子类的实例 const apple = new Apple(&#39;苹果&#39;, &#39;甜&#39;); const orange = new Orange(&#39;橘子&#39;, &#39;酸&#39;); console.log(apple.flavour); // 甜 console.log(orange.flavour); // 酸 上面创建子类实例的方式是使用 new 关键字直接创建，这种创建方式使产生的实例和具体的类紧紧的耦合在一起，并依赖于类的具体实现，如果在子类可能随时发生变化的代码中，将对维护造成麻烦，使用 “简单工厂模式” 可以对产生的实例和具体的类进行解耦，且不必关心子类的具体实现和在未来是否发生变化。/* 使用简单工厂模式创建子类的实例 */ // 父类 class Plant { constructor(name) { this.name = name; } grow() { console.log(&#39;I am growing!&#39;); } } // 子类 —— Apple class Apple extends Plant { constructor(name, flavour) { super(name); this.flavour = flavour; } } // 子类 —— Orange class Orange extends Plant { constructor(name, flavour) { super(name); this.flavour = flavour; } } // 工厂类 class Factory { static create(type) { switch (type) { case &#39;apple&#39;: return new Apple(&#39;苹果&#39;, &#39;甜&#39;); case &#39;orange&#39;: return new Orange(&#39;桔子&#39;, &#39;酸&#39;); default: throw new Error(&#39;no constructor!&#39;); } } } // 使用简单工厂创建子类实例 const apple = Factory.create(&#39;apple&#39;); const orange = Factory.create(&#39;orange&#39;); console.log(apple.flavour); // 甜 console.log(orange.flavour); // 酸 从上面代码看，我们只需要通过类型就可以得到某一个子类的实例，不需要知道子类是谁，以及具体实现，并在工厂 Factory 中做了错误处理，可以不必担心未来某一个子类发生变化或者被删除的问题。/* 简单工厂经典案例 —— jQuery */ // jQuery 的构造函数 class JQuery { constructor (selector) { this.selector = selector; const elements = document.querySelectorAll(selector); this.length = elements.length; for (let i = 0; i &lt; this.length; i++) { this[i] = elements[i]; } } html() { return this[0].innerHTML; } } // 简单工厂函数 window.$ = function (selector) { return new JQuery(selector); } // 获取 li 标签并调用 html 方法 const html = $(&#39;li&#39;).html(); /* 简单工厂经典案例 —— React 虚拟 DOM */ // 创建虚拟 DOM 的构造函数 class VNode { constructor(tagName, attrs, children) { this.tagName = tagName; this.attrs = attrs; this.children = children; } } // 挂在 React 对象上的简单工厂函数 React.createElement = function (tagName, attrs, children) { return new VNode(tagName, attrs, children); } 简单工厂模式的缺点：不满足开放封闭原则，内部可以随意修改，新增、修改子类都需要修改工厂类内部代码，在扩展的过程中工厂类的代码将会越来越臃肿。工厂方法模式“工厂方法模式” 可以规避 “简单工厂模式” 的缺点，又称为 “多态性工厂模式”，核心的工厂类不再负责创建出哪一种产品类的实例，而是将具体创建的工作交给子类去做。工厂方法模式 UML 图/* 基本的工厂方法模式使用 */ // 父类 class Plant { constructor(name) { this.name = name; } } // 子类 —— Apple class Apple extends Plant { constructor (name, flavour) { super(name); this.flavour = flavour; } } // 子类 —— Orange class Orange extends Plant { constructor (name, flavour) { super(name); this.flavour = flavour; } } // 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现） class Factory { create () {} } // 子类工厂 —— AppleFactory class AppleFactory extends Factory { static create() { return new Apple(&#39;苹果&#39;, &#39;甜&#39;); } } // 子类工厂 —— OrangeFactory class OrangeFactory extends Factory { static create() { return new Orange(&#39;桔子&#39;, &#39;酸&#39;); } } // 创建实例 const apple = AppleFactory.create(); const orange = OrangeFactory.create(); console.log(apple.flavour); // 甜 console.log(orange.flavour); // 酸 上面是一个基础的 “工厂方法模式” 使用，解决了 “简单工厂模式” 扩展的问题（遵循开放封闭原则），创建实例虽然不耦合具体的类，但是耦合工厂的子类，下面可以通过文件拆分进行解耦。/* plant.js */ // 父类 class Plant { constructor(name) { this.name = name; } } module.exports = Plant; /* factory.js */ // 父类工厂（提供工厂类所共有的内容，依赖倒置原则，依赖抽象而不依赖实现） class Factory { create () {} } module.exports = Factory; /* apple.js */ const Plant = require(&#39;./plant&#39;); const Factory = require(&#39;./factory&#39;); // 子类 —— Apple class Apple extends Plant { constructor (name, flavour) { super(name); this.flavour = flavour; } } // 子类工厂 —— AppleFactory class AppleFactory extends Factory { static create() { return new Apple(&#39;苹果&#39;, &#39;甜&#39;); } } module.exports = AppleFactory; /* orange.js */ const Plant = require(&#39;./plant&#39;); const Factory = require(&#39;./factory&#39;); // 子类 —— Orange class Orange extends Plant { constructor (name, flavour) { super(name); this.flavour = flavour; } } // 子类工厂 —— OrangeFactory class OrangeFactory extends Factory { static create() { return new Orange(&#39;桔子&#39;, &#39;酸&#39;); } } module.exports = OrangeFactory; /* setting.js */ // 配置文件，将要创建实例的类型与对应的工厂关联起来 const setting = { apple: &#39;./apple&#39;, orange: &#39;./orange&#39;, }; module.exports = setting; /* use.js */ const setting = require(&#39;./setting&#39;); const apple = require(setting[&#39;apple&#39;]).create(); const orange = require(setting[&#39;orange&#39;]).create(); console.log(apple.flavour); // 甜 console.log(orange.flavour); // 酸 使用上面这样的 “工厂方法模式”，扩展时只需要新增一个文件，在文件中定义具体创建实例的类和工厂类就可以了，一般会有一个配置文件将要创建实例的类型和对应的工厂关联起来，创建对应的实例只需通过类型和配置文件找到对应的工厂执行 create 方法即可。抽象工厂模式“抽象工厂模式” 是指当有多个抽象角色时，可以提供一个接口，不必指定 “产品” 具体的情况下，创建多个产品族中的产品对象。抽象工厂模式 UML 图// 父类 —— Icon class Icon { render() {} } // 父类 —— Button class Button { render() {} } // 子类 —— AppleIcon 苹果图标 class AppleIcon extends Icon { render() { console.log(&#39;绘制 Mac 的图标&#39;); } } // 子类 —— AppleButton 苹果按钮 class AppleButton extends Button { render() { console.log(&#39;绘制 Mac 的按钮&#39;); } } // 子类 —— WindowsIcon Windows 图标 class WindowsIcon extends Icon { render() { console.log(&#39;绘制 Windows 的图标&#39;); } } // 子类 —— WindowsButton Windows 按钮 class WindowsButton extends Button { render() { console.log(&#39;绘制 Windows 的按钮&#39;); } } // 父类工厂 class Factory { createIcon() {} // 创建图标 createButton() {} // 创建按钮 } // 子类工厂 —— AppleFactory 用于创建苹果族产品实例 class AppleFactory extends Factory { createIcon() { return new AppleIcon(); } createButton() { return new AppleButton(); } } // 子类工厂 —— WindowsFactory 用于创建 Windows 族产品实例 class WindowsFactory extends Factory { createIcon() { return new WindowsIcon(); } createButton() { return new WindowsButton(); } } // 创建苹果工厂实例 const appleFactory = new AppleFactory(); // 创建苹果族产品 appleFactory.createIcon().render(); // 绘制 Mac 的图标 appleFactory.createButton().render(); // 绘制 Mac 的按钮 // 创建 Windows 工厂实例 const wondowsFactory = new WindowsFactory(); // 创建 Windows 族产品 wondowsFactory.createIcon().render(); // 绘制 Windows 的图标 wondowsFactory.createButton().render(); // 绘制 Windows 的按钮 在上面案例中，按照 “抽象工厂模式” 的说法，多个抽象角色指的是 Apple 和 Windows，Icon 和 Button，工厂分为 AppleFactory 和 WindowsFactory 两类，可以分别创建对应产品的 Icon 和 Button 实例。总结上面几种工厂模式中，“简单工厂模式” 在框架开发中使用居多，“工厂方法模式” 更多在一些比较老的且复杂的项目中用作业务模块封装和抽象，“抽象工厂模式” 在前端并不常用，应用于后端偏多，最后附上 案例地址。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.overtaking.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.overtaking.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"React 基础篇 —— Router 4.0 的基本使用","date":"2018-09-21T10:27:54.000Z","path":"20180921182754/","text":"React 路由简介在 Web 应用中，路由系统是不可或缺的一部分，尤其是单页面应用，在浏览器 URL 发生变化时，路由系统会做出一些响应，来控制组件的加载与切换，React 全家桶中也有配套的路由系统，在路由 2.0 版本时叫做 react-router，在路由 4.0 时更名为 react-router-dom，我们本次就针对较新版本的 Router 系统进行介绍。创建项目为了方便演示如何 Router，我们使用 create-react-app 创建一个 React 项目，并删除 src 文件夹内多余文件，创建我们需要的文件 index.js，目录结构如下： react-router |- public | |- favicon.ico | |- index.html | |- manifest.json |- src | |- pages | | |- Add.js | | |- Detail.js | | |- Home.js | | |- Index.js | | |- List.js | | |- Login.js | | |- Logo.js | | |- MenuLink.js | | |- Profile.js | | |- Protected.js | | |- User.js | |- App.js | |- index.css | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 其中主组件为 App，在 index.js 中渲染，index.js 代码如下：/* 路径：~react-router/src/index.js */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import App from &#39;./App&#39;; ReactDOM.render(&lt;App /&gt;, window.root); 而 App 组件主要用来渲染菜单导航和路由组件，我们将在下面完善代码。HashRouter 和 BrowserRouter在 React Router 中，给我们提供了一些路由相关的组件，其中最重要的就是实现路由的 HashRouter 和 BrowserRouter，我们知道浏览器的 hash 值发生变化会阻止页面的跳转，而 HashRouter 就是利用这个特性实现的，通过监听 onhanshchange 事件在 hash 值改变的时候做出响应，BrowserRouter 则是利用 H5 的新 History API 的 pushState 方法构造的的历史记录集合来实现的。通常情况下，在开发的时候使用 HashRouter 更多，而在真正上线时替换成 BrowserRouter，两种 Router 在地址栏上的表现上区别只是是否含有 #，两种 Router 的使用如下：/* 路径：~react-router/src/App.js —— HashRouter */ import React, { Component } from &#39;react&#39;; import { HashRouter } from &#39;react-router-dom&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; {/* 路由相关代码 */} &lt;/HashRouter&gt; ) } } /* 路径：~react-router/src/App.js —— BrowserRouter */ import React, { Component } from &#39;react&#39;; import { BrowserRouter } from &#39;react-router-dom&#39;; export default class App extends Component { render() { return ( &lt;BrowserRouter&gt; {/* 路由相关代码 */} &lt;/BrowserRouter&gt; ) } } 其实就是使用 React Router 中提供的这两种类型的路由组件对路由相关的 JSX 进行包裹。Route 和 Link 组件Route 组件是用来定义路由跳转切换组件的区域，通过 path 属性定义匹配的路由，component 属性来定义渲染的组件，渲染后就是一个 div 标签，Link 是用来点击跳转路由的，通常用来定义导航栏内容，通过 to 属性设置匹配的路由，需要与 Route 的 path 一一对应，点击后可切换到对应的路由组件，渲染后为一个 a 标签。创建路由跳转的组件下面我们来创建三个路由对应的组件，分别为首页、用户、个人中心，对应的组件分别为 Home.js、User.js、Profile.js/* 路径：~react-router/src/pages/Home.js */ import React, { Component } from &#39;react&#39;; export default class Home extends Component { render() { return ( &lt;div&gt;主页&lt;/div&gt; ) } } /* 路径：~react-router/src/pages/User.js */ import React, { Component } from &#39;react&#39;; export default class User extends Component { render() { return ( &lt;div&gt;用户&lt;/div&gt; ) } } /* 路径：~react-router/src/pages/Profile.js */ import React, { Component } from &#39;react&#39;; export default class Profile extends Component { render() { return ( &lt;div&gt;个人中心&lt;/div&gt; ) } } 配合使用 Route 和 Link使用 Link 和 Route 配合使用如下，点击 Link 会在类名 container 的元素种加载路由路径对应的组件。/* 路径：~react-router/src/App.js */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Link } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;div&gt; &lt;ul className=&quot;nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;container&quot;&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/HashRouter&gt; ) } } 启动项目后上面的代码已经可以帮助我们实现页面路由的切换，但是上面的代码 Link 和 Route 组件混在一起，我们其实可以将 App 拆分成两个组件，一个用来存放 Link 部分，一个用来存放 Route 部分，创建 Index 组件，将 Link 的部分抽取出去，代码修改如下：/* 路径：~react-router/src/App.js —— 修改后 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } /* 路径：~react-router/src/pages/Index.js */ import React, { Component } from &#39;react&#39;; import { Link } from &#39;react-router-dom&#39;; export default class Index extends Component { render() { return ( &lt;div&gt; &lt;a className=&quot;navbar-brand&quot;&gt;管理系统&lt;/a&gt; &lt;/div&gt; &lt;ul className=&quot;nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;container&quot;&gt; {this.props.children} &lt;/div&gt; ) } } 经过修改之后 Index 组件专门用来维护导航组件 Link，App 组件专门用来维护路由组件 Route，这样代码看起来就不那么混乱了。Route 组件的 exact 属性上面我们所定义的路由为一级路由，在路由匹配并成功加载对应组件后，如果组件又由多个组件组成，并有类似导航的操作（当然不仅限于导航）来控制其他的组件视图的切换，则需要匹配二级路由，这就出现了一个问题，我们以 /user 为例，假设添加一个新的路由 /user/add，那么 React 会由上到下依次匹配，/user/add 中包含 /user，因此会同时渲染两个组件，这不是我们希望的。在 React Router 内部给我们提供了解决方案，就是给路由设置严格匹配，我们只需要让 /user 对应的 Route 组件添加 exact 属性，并将值设置为 true 即可，所以匹配 /user/add 时就不会出现 /user 对应的路由组件也被渲染的情况，当然也可以将 exact 简写到 Route 组件上省略赋值为 true 的过程。/* 路径：~react-router/src/App.js —— 添加 exact */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; exact component={User} /&gt; &lt;Route path=&quot;/user/add&quot; component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } Switch 组件因为 React 的路由是由上至下依次进行匹配的，如果有两个同名路由进行匹配，会同时加载两个组件，这也是我们需要优化的，React Router 的 Switch 组件就是来做这件事的，只需要将多个 Route 组件包裹起来，就可以实现只要成功匹配一个路由就不再继续匹配。/* 路径：~react-router/src/App.js —— 添加 Switch 组件 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Switch } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; exact component={User} /&gt; &lt;Route path=&quot;/user/add&quot; component={User} /&gt; &lt;Route path=&quot;/user/add&quot; component={User} /&gt; {/* 同名路由 */} &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } 使用 Switch 组件优化后，启动项目就可以发现只渲染了一个 User 组件。Redirect 组件在 React 开发中经常遇到路径输入错误的情况，通常情况有两种处理方式，第一种是跳转到一个 404 页面，第二种方式是将页面路由重定向到主页，而 React Router 提供的 Redirect 组件就是帮助我们在所有路由都匹配失败时重定向的，使用时通常放在最后一个 Route 组件的下面用来 “兜底”，使用 to 属性来定义重定向的路由。/* 路径：~react-router/src/App.js —— 添加 Redirect 组件 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;Redirect to=&quot;/home&quot; /&gt; {/* 无法匹配路由时重定向 */} &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } 注意：Redirect 不能放在 Route 组件的上面，因为放在上面不会匹配任何的路由，而会直接重定向到设置的页面。对于路由都没有匹配而返回 404 页面我们这里也简单说一下，但是这样的用法非常少，使用 Redirect 重定向到指定页面的方式会更多一些。/* 路径：~react-router/src/App.js —— 匹配失败跳转 404 页面 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Switch } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;Route path=&quot;/&quot; component={Error} /&gt; {/* Error 组件代表 404 */} &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } 由于其他的路由都匹配失败，最后会和 / 匹配，所以会显示 Error 组件，这里处理 404 的 Route 的组件也必须放在最下面来 “兜底”。二级路由实现二级路由在了解 React Router 的基本使用后，我们用同样的知识点来给 User 组件写一个二级路由，User 中有一个子导航，分别对应用户列表 List 组件和添加用户 Add 组件，代码的套路与之前相同。/* 路径：~react-router/src/pages/User.js */ import React, { Component } from &#39;react&#39;; import { Link, Route, Switch } from &#39;react-router-dom&#39;; import Add from &#39;./Add&#39;; import List from &#39;./List&#39;; export default class User extends Component { render() { return ( &lt;div&gt; &lt;ul className=&quot;sub-nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;sub-container&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/user/list&quot; component={List} /&gt; &lt;Route path=&quot;/user/add&quot; component={Add} /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) } } 解决默认路径不匹配的问题当通过 React Router 访问 /user 的时候，会先加载 User 组件，再加载 User 内部的组件包括子导航，但是 /user 的路径既没有和 /user/add 匹配，也没有和 /user/list 匹配，这样渲染了一个空的类名为 sub-containe 的 div 标签，我们应该让 User 组件加载时子路由默认可以匹配一个路由组件，解决方式如下：/* 路径：~react-router/src/pages/User.js —— Redirect 组件重定向的方式 */ import React, { Component } from &#39;react&#39;; import { Link, Route, Switch, Redirect } from &#39;react-router-dom&#39;; import Add from &#39;./Add&#39;; import List from &#39;./List&#39;; export default class User extends Component { render() { return ( &lt;div&gt; &lt;ul className=&quot;sub-nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;sub-container&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/user/list&quot; component={List} /&gt; &lt;Route path=&quot;/user/add&quot; component={Add} /&gt; &lt;Redirect to=&quot;/user/list&quot; /&gt; {/* 重定向到 List 组件 */} &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) } } 上面的方式是使用 Redirect 组件重定向的方式实现的，但是这样访问的 /user，路径会自动改变为 /user/list，感觉上有一些奇怪，当然还有另外的解决方式。/* 路径：~react-router/src/pages/User.js —— Route 组件严格匹配 */ import React, { Component } from &#39;react&#39;; import { Link, Route, Switch } from &#39;react-router-dom&#39;; import Add from &#39;./Add&#39;; import List from &#39;./List&#39;; export default class User extends Component { render() { return ( &lt;div&gt; &lt;ul className=&quot;sub-nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;sub-container&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/user&quot; exact component={List} /&gt; &lt;Route path=&quot;/user/list&quot; component={List} /&gt; &lt;Route path=&quot;/user/add&quot; component={Add} /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) } } 上面的方式是当匹配到了 /user 的路由也加载默认要渲染的 List 组件实现的，但是为了防止向下继续匹配，可以添加 exact 设置严格匹配，进一步优化可以使用 Switch 组件，让路由成功匹配一次后不再向下匹配。编程式导航我们经常会遇到一个场景，就是在某些交互之后实现页面的自动跳转，而对于 React 搭建的单页面应用来说就是路由切换，在 React 中都最初是通过 Link 组件的点击手动实现的路由切换，那么怎么通过纯编程的方式在某些交互后自动切换路由呢，其实 React Router 的 Route 组件会给内部渲染的组件传递路由相关的三个参数 history、location 和 match。history 上存储了 length 属性代表当前支持存入历史记录的数量，也同样存储了 location，用来存储路由路径的相关信息，还有用来操作路由跳转的方法 go（传入数字代表前进或后退几页）、goBack（后退）、goForward（前进）、replace（用其他路由替换当前历史）、push，其中最常用的就是 push 方法，下面会着重介绍，match 中存储了一些路由匹配的相关信息，如 url，即浏览器输入的路径，真正匹配的路径 path 属性以及是代表否严格匹配的 isExact 属性，在 match 中最重要的是 params 属性，值为对象，用来存储路由参数，这个我们放在后面来说。下面在 Add 组件中添加一输入框和按钮，当点击按钮时将输入框的数据存入 localStorage 中，并自动将路由跳转到 /user/list，即渲染 List 组件，然后将数据取出渲染到 List 组件中，这是一个很常见的需求，添加数据然后跳到详情页的场景，下面是 Add 组件中的实现。/* 路径：~react-router/src/pages/Add.js */ import React, { Component } from &#39;react&#39;; export default class Add extends Component { input = React.createRef() // 非受控组件取值 // 表单提交事件 handleSubmit = (e) =&gt; { e.preventDefault(); // 取消默认的页面跳转事件 // 先从 localStorage 获取已有数据 const lists = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || []; // 添加新数据 lists.push({ id: lists.length + 1, username: this.input.current.value }); // 存入 localStorage localStorage.setItem(&#39;lists&#39;, JSON.stringify(lists)); // 编程式导航，自动跳转到 List this.props.history.push(&#39;/user/list&#39;); } render() { return ( &lt;div&gt; &lt;form className=&quot;form&quot; onSubmit={this.handleSubmit}&gt; &lt;label htmlFor=&quot;username&quot; className=&quot;control-label&quot;&gt;用户名&lt;/label&gt; &lt;input className=&quot;form-control&quot; type=&quot;text&quot; id=&quot;username&quot; ref={this.input} /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; className=&quot;btn btn-success&quot; /&gt; &lt;/form&gt; &lt;/div&gt; ) } } 在上面我们通过 Route 传递给渲染组件的 history 的 push 方法实现了路由的自动跳转，push 方法接收的参数就是将要跳转的路径字符串，List 组件代码如下：/* 路径：~react-router/src/pages/List.js */ import React, { Component } from &#39;react&#39;; export default class List extends Component { state = { users: [] } componentWillMount() { // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || []; this.setState({ users }); } render() { return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; { this.state.users.map(({ id, username }) =&gt; { return ( &lt;tr key={id}&gt; &lt;td&gt;{id}&lt;/td&gt; &lt;td&gt;{username}&lt;/td&gt; &lt;/tr&gt; ) }) } &lt;/tbody&gt; &lt;/table&gt; ) } } 取出 localStorage 中的数据在 List 中渲染时有两点注意，第一是取出数据和设置状态应该在 render 渲染 JSX 之前，这样在没有执行 render 时会合并状态并只渲染一次，也就是说 componentWillMount “钩子” 和 render “钩子” 的 return 语句前更新状态都是可以的，如果在 componentDidMount “钩子” 中更新会导致组件渲染两次，在 React 开发中如果获取数据的过程是同步的（localStorage 取值是同步的），不需要渲染两次。第二点是在使用表格元素 table 渲染时，必须要含有 thead 和 tbody，这是 React 规定的，不可以省略。路由参数的传递现在在我们的 List 组件表格中，点击每一行都可以跳转到学生 ID 对应的详情 Detail 组件中，由于每一个学生的 ID 不同渲染的详情也不相同，此时需要将学生 ID 作为路由参数进行传递，并在 Detail 内渲染对应的内容，由于 Detail 组件的渲染与 List 组件是同一区域，所以仍然是二级路由，我们需要在 User 组件中进行添加。/* 路径：~react-router/src/pages/User.js —— 增加 Detail 二级路由 */ import React, { Component } from &#39;react&#39;; import { Link, Route, Switch } from &#39;react-router-dom&#39;; import Add from &#39;./Add&#39;; import List from &#39;./List&#39;; import Detail from &#39;./Detail&#39;; export default class User extends Component { render() { return ( &lt;div&gt; &lt;ul className=&quot;sub-nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/user/list&quot;&gt;用户列表&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user/add&quot;&gt;添加用户&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;sub-container&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/user&quot; exact component={List} /&gt; &lt;Route path=&quot;/user/list&quot; component={List} /&gt; &lt;Route path=&quot;/user/add&quot; component={Add} /&gt; &lt;Route path=&quot;/user/detail/:id&quot; component={Detail} /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; ) } } 在 React Router 中，我们通过给路由后面添加 /:paramname 的方式添加参数，也可以通过 /:paramname/:paramname 传递多个参数（形参），由于在 List 中点击表格的的某行的单元格跳转路由，所以 List 组件修改如下：/* 路径：~react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数 */ import React, { Component } from &#39;react&#39;; import { Link } from &#39;react-router-dom&#39;; export default class List extends Component { state = { users: [] } componentWillMount() { // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || []; this.setState({ users }); } render() { return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; { this.state.users.map(({ id, username }) =&gt; { return ( &lt;tr key={id}&gt; &lt;td&gt;{id}&lt;/td&gt; &lt;td&gt; &lt;Link to={`/user/detail/${id}`}&gt;{username}&lt;/Link&gt; &lt;/td&gt; &lt;/tr&gt; ) }) } &lt;/tbody&gt; &lt;/table&gt; ) } } 在 List 组件中，同样使用 Link 组件对要点击切换路由的节点进行包裹，并用 to 属性设置跳转的路由和路由参数（实参），现在点击就可以实现从 List 组件到 Detail 组件的切换，如果我们有些 List 的数据想在跳转到 Detail 组件时直接带过去，则可以使用另一种写法如下：/* 路径：~react-router/src/pages/List.js —— 点击跳转 Detail 并传递路由参数和数据 */ import React, { Component } from &#39;react&#39;; import { Link } from &#39;react-router-dom&#39;; export default class List extends Component { state = { users: [] } componentWillMount() { // 取出 localStorage 数据并更新状态 const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || []; this.setState({ users }); } render() { return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户 ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; { this.state.users.map(({ id, username }) =&gt; { return ( &lt;tr key={id}&gt; &lt;td&gt;{id}&lt;/td&gt; &lt;td&gt; &lt;Link to={{ pathname: `/user/detail/${id}`, state: username }} &gt; {username} &lt;/Link&gt; &lt;/td&gt; &lt;/tr&gt; ) }) } &lt;/tbody&gt; &lt;/table&gt; ) } } 不同的是给 to 属性传入的值从一个代表路由的字符串变成了一个对象，而把路由的字符串作为了 pathname 属性的值，state 属性则代表了路由跳转传给渲染组件的数据，还记得渲染的组件使用 Route 组件包裹的，会传入 history、loacltion 和 match 三个属性，同样的，通过点击 Link 传递的路由参数和数据都可以在 props 上获取到，前者通过 location.state 或者 history.location.state 上获取到，后者可以通过 match.params 上获取到，那么 Detail 组件将传递过来的参数渲染，代码如下：/* 路径：~react-router/src/pages/Detail.js */ import React, { Component } from &#39;react&#39;; export default class Detail extends Component { state = { user: {} } componentWillMount() { // 有值说明是点击过来的，否则是地址栏输入的 const data = this.props.location.state; // 获取路由参数 const id = parseInt(this.props.match.params.id); // 如果是点击过来的直接将数据设置给 state，否则去 localStorage 取值设置给 state if (data) { this.setState({ user: { id, username: data }}); } else { const users = JSON.parse(localStorage.getItem(&#39;lists&#39;)) || []; const user = users.find(item =&gt; item.id === id); this.setState({ user: { id, username: user.username }}); } } render() { return ( &lt;div&gt; &lt;span&gt;{this.state.user.id}&lt;/span&gt; &lt;span&gt; ------- &lt;/span&gt; &lt;span&gt;{this.state.user.username}&lt;/span&gt; &lt;/div&gt; ) } } 这里有两点注意点：首先通过组件 props.match.params 获取的路由参数都是字符串格式，如果原本类型为数字，使用时应转换成数字类型；其次是传递的数据，也就是组件通过 props.location.state 获取的数据，只有在通过 Link组件点击过去才会存在，在地址栏输入为 undefined，所以防止用户刷新页面导致数据丢失，应该在两种情况下处理不同的获取数据的逻辑。withRouter 函数在之前的编程式导航中我们使用了 Route 传递给渲染组件的 props.history.push 方法实现的，现在假设我们要对一个不是路由跳转的组件，通过点击事件来获取 history、location 和 match 属性，并使用 history 上的路由设置方法进行跳转路由，这应该如何实现呢？其实 React Route 给我们提供了一个函数 withRouter 方法，在调用该方法时，则会返回一个新的组件，当然其实这是一个高阶组件的应用，withRouter 方法内部帮我们在传入的组件外层包装了一层 Route 组件，并传入了 history、location 和 match 属性作为参数，所以当我们使用返回的组件时可以通过 props 属性获取 history、location 和 match。下面针对我们之前的 Index 组件的内的 “管理系统” 的标签抽出一个新的组件，并将这个组件添加点击可以跳转到登录页 Login 组件的功能，Login 组件为一级路由，所以我们应该修改 App 组件，添加一个 /login 的路由，Login 和修改后的 App 组件如下：/* 路径：~react-router/src/App.js —— 添加 Login 组件路由 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; import Login from &#39;./pages/Login&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=&quot;/home&quot; component={Home }/&gt; &lt;Route path=&quot;/user&quot; exact={true} component={User} /&gt; &lt;Route path=&quot;/profile&quot; component={Profile} /&gt; &lt;Route path=&quot;/login&quot; component={Login}/&gt; {/* 添加登录页路由 */} &lt;Redirect to=&quot;/home&quot; /&gt; {/* 无法匹配路由时重定向 */} &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } /* 路径：~react-router/src/pages/Login.js —— 添加登录和退出功能 */ import React, { Component } from &#39;react&#39;; export default class Login extends Component { login = () =&gt; { localStorage.setItem(&#39;login&#39;, &#39;ok&#39;); } exit = () =&gt; { localStorage.removeItem(&#39;login&#39;); } render() { return ( &lt;div&gt; &lt;button onClick={this.login}&gt;登录&lt;/button&gt; &lt;button onClick={this.exit}&gt;退出&lt;/button&gt; &lt;/div&gt; ) } } 在 Login 中顺便添加了两个按钮来模拟 “登录” 和 “退出”，并给按钮添加了事件，在登录时向 localStorage 中添加 login 属性，在退出时清除这个属性，以模拟登录状态。抽取出 Logo 后的 Index 组件也应该添加一个新的导航为 “登录”，Login 组件和修改后的 Index 组件如下：/* 路径：~react-router/src/pages/Index.js —— 抽出 Logo 组件并添加登录导航 */ import React, { Component } from &#39;react&#39;; import { Link } from &#39;react-router-dom&#39;; import Logo from &#39;./Logo&#39;; export default class Index extends Component { render() { return ( &lt;div&gt; &lt;Logo /&gt; &lt;/div&gt; &lt;ul className=&quot;nav&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/profile&quot;&gt;个人中心&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/login&quot;&gt;登录&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;container&quot;&gt; {this.props.children} &lt;/div&gt; ) } } /* 路径：~react-router/src/pages/Logo.js */ import React, { Component } from &#39;react&#39;; import { withRouter } from &#39;react-router-dom&#39;; class Logo extends Component { change = () =&gt; { console.log(this.props); this.props.history.push(&#39;/login&#39;); } render() { return ( &lt;div className=&quot;navbar-brand&quot; onClick={this.change}&gt;管理系统&lt;/div&gt; ) } } export default withRouter(Logo); 通过 Logo 案例的代码我们可以看出，其实最后导出的并不是 Logo 组件，而是使用 withRouter 函数包装后返回的高阶组件，withRouter 方法内部帮我们搞定了 Logo 组件的 props 没有 history、location 和 match 属性的问题。受保护的路由以前在点击个人中心时会直接渲染 Profile 组件，在给 Login 组件添加 “登录” 和 “退出” 之后，再次点击个人中心时，应该先对登录状态进行验证，如果 localStorage 中存在 login 属性，则渲染 Profile 的 Route 组件，否则重定向到登录页，如果在登录页点击登录后再重新跳回个人中心（从哪来回哪去）。这就需要我对 App 组件路由部分的代码进行修改，使用高阶组件来添加登录验证逻辑，当然，这个高阶组件不是 React Router 提供的，需要我们自己来实现，这种做法被官方称作 “受保护的路由”。/* 路径：~react-router/src/App.js —— 添加受保护的路由 */ import React, { Component } from &#39;react&#39;; import { HashRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;; import Home from &#39;./pages/Home&#39;; import User from &#39;./pages/User&#39;; import Profile from &#39;./pages/Profile&#39;; import Index from &#39;./pages/Index&#39;; import Login from &#39;./pages/Login&#39;; import Protected from &#39;./pages/Protected&#39;; export default class App extends Component { render() { return ( &lt;HashRouter&gt; &lt;Index&gt; &lt;Switch&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/user&quot; exact component={User} /&gt; {/* 添加受保护的路由 */} &lt;Protected path=&quot;/profile&quot; component={Profile} /&gt; &lt;Route path=&quot;/login&quot; component={Login} /&gt; {/* 无法匹配路由时重定向 */} &lt;Redirect to=&quot;/home&quot; /&gt; &lt;/Switch&gt; &lt;/Index&gt; &lt;/HashRouter&gt; ) } } 我们重写了 App 组件中个人中心对应的路由，将原来的 Route 组件用高阶组件 Protected 代替，也就等于是将原本传入的参数 path 和 component 传入了高阶组件 Protected，下面来看一下高阶组件 Protected 的实现。/* 路径：~react-router/src/pages/Protected.js —— 添加受保护的路由 */ import React, { Component } from &#39;react&#39;; import { Route, Redirect } from &#39;react-router-dom&#39;; export default class Protected extends Component { render() { const login = localStorage.getItem(&#39;login&#39;); return login ? ( &lt;Route {...this.props} /&gt; ) : ( &lt;Redirect to={{ pathname: '/login', state: { 'from': '/profile' }}} /&gt; ) } } 在 Protected 获取登录状态，存在时直接渲染了 Route 组件，并将 path 和 component 参数传入，如果不存在则渲染 Redirect 组件重定向到登录页，传入的参数同 Link 组件的规则相同，pathname 代表重定向的路径，state 代表带过去的数据，我们这里添加了一个 from 属性，用来记录渲染登录页的来源，即个人中心。接下来就是 Login 组件中在点击登录后验证是否存在 state，如果存在则返回存储的 from 对应的路由，即个人中心，不存在则跳回首页，Login 修改如下：/* 路径：~react-router/src/pages/Login.js —— 完善登录功能 */ import React, { Component } from &#39;react&#39;; export default class Login extends Component { login = () =&gt; { localStorage.setItem(&#39;login&#39;, &#39;ok&#39;); // 获取上一个路由传递的 state const prevPathDate = this.props.location.state; // 存在 state 则返回来源对应的页面，否则回主页 if (prevPathDate) { this.props.history.push(prevPathDate.from); } else { this.props.history.push(&#39;/home&#39;); } } exit = () =&gt; { localStorage.removeItem(&#39;login&#39;); } render() { return ( &lt;div&gt; &lt;button onClick={this.login}&gt;登录&lt;/button&gt; &lt;button onClick={this.exit}&gt;退出&lt;/button&gt; &lt;/div&gt; ) } } 这样 “受保护的路由” 功能就实现了，其实就是在跳转路由之前起到了一个 “拦截” 的作用，经常的使用场景是权限管理，这是一个路由的应用，也是一个高阶组件的应用，这样的应用在大型复杂的 React 中会频繁使用，还是比较重要的。NavLink 组件在实际项目开发中，我们经常遇到导航标签被选中时被添加一个代表 “激活” 的类名，用于添加与其他导航选项不同的样式，React Router 已经给我们提供了 NavLink 组件用于实现这个功能，NavLink 组件具备 Link 组件所有的功能，唯一不同的就是 NavLink 组件在被选中时不止发生路由跳转，还会给渲染后的 a 标签添加一个名为 active 的 class 属性，而我们只需要通过 css 去给类名 active 设置样式即可。/* 路径：~react-router/src/index.css —— 激活样式 */ a.active { color: skyblue !important; } 设置好激活样式以后，我们只需要在 Index 组件中引入激活样式的 css 文件并将 Link 组件替换成 NavLink 组件即可。/* 路径：~react-router/src/pages/Index.js —— 将 Link 修改为 NavLink */ import React, { Component } from &#39;react&#39;; import { NavLink } from &#39;react-router-dom&#39;; import Logo from &#39;./Logo&#39;; // 引入激活样式 import &#39;../index.css&#39;; export default class Index extends Component { render() { return ( &lt;div&gt; &lt;Logo /&gt; &lt;/div&gt; &lt;ul className=&quot;nav&quot;&gt; &lt;li&gt; &lt;NavLink to=&quot;/home&quot;&gt;首页&lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to=&quot;/user&quot;&gt;用户&lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to=&quot;/profile&quot;&gt;个人中心&lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to=&quot;/login&quot;&gt;登录&lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=&quot;container&quot;&gt; {this.props.children} &lt;/div&gt; ) } } 自定义导航组件实现激活React Router 在给我们提供的导航组件 NavLink 功能有限，只会给内部的 a 标签在选中时添加 active 类名，如果我们想实现给一个 li 标签添加 active 就需要我们自己封装一个组件来实现这个功能，其实还是通过高阶组件来实现的，首先我们定义这个高阶组件的名字为 MenuLink，将 Index 组件中的 li 标签和 NavLink 组件统一替换成 MenuLink 组件，代码如下：/* 路径：~react-router/src/pages/Index.js —— 将 Link 修改为 NavLink */ import React, { Component } from &#39;react&#39;; import { NavLink } from &#39;react-router-dom&#39;; import Logo from &#39;./Logo&#39;; import MenuLink from &#39;./MenuLink&#39; export default class Index extends Component { render() { return ( &lt;div&gt; &lt;Logo /&gt; &lt;/div&gt; &lt;ul className=&quot;nav&quot;&gt; &lt;MenuLink to=&quot;/home&quot;&gt;首页&lt;/MenuLink&gt; &lt;MenuLink to=&quot;/user&quot;&gt;用户&lt;/MenuLink&gt; &lt;MenuLink to=&quot;/profile&quot;&gt;个人中心&lt;/MenuLink&gt; &lt;MenuLink to=&quot;/login&quot;&gt;登录&lt;/MenuLink&gt; &lt;/ul&gt; &lt;div className=&quot;container&quot;&gt; {this.props.children} &lt;/div&gt; ) } } 在实现 MenuLink 组件之前我们分析一下实现思路，首先我们依然模拟 NavLink 的方式给 MenuLink 传入了 to 属性，值为将要跳转的路由，所以我们应该在 MenuLink 组件中来接收这个路由，而 MenuLink 内部一定是包含 li 和 Link 组件的，我们可以将这个 to 属性传递给 Link 组件，如果想要通过激活状态给外层的 li 标签设置状态我们需要知道是否匹配了路由，并可以通过 match 属性获得，所以在 li 的外层应该有 Route 组件配合，因为只有 Route 组件才会将 history、location 和 match 作为参数传递给其内部渲染的组件。这就要说到 Route 组件的渲染模式，在传入 component 属性时，只有匹配组件才会渲染内部组件，我们显然是需要时时刻刻都渲染内部的 li 和 Link，并通过点击 Link 渲染真正的路由组件，所以我们需要用到第二种渲染方式，就是通过 children 属性指定时刻需要渲染的组件，实现代码如下：/* 路径：~react-router/src/pages/MenuLink.js */ import React, { Component } from &#39;react&#39;; import { Route, Link } from &#39;react-router-dom&#39;; import &#39;../index.css&#39;; export default class MenuLink extends Component { render() { return ( &lt;Route path={this.props.to} children={({ match }) =&gt; ( &lt;li className={match ? &#39;active&#39; : &#39;&#39;}&gt; &lt;Link to={this.props.to}&gt;{this.props.children}&lt;/Link&gt; &lt;/li&gt; )} /&gt; ) } } 上面代码中由于 children 组件并不需要操作状态和使用生命周期 “钩子”，所以我们直接使用了函数组件实现，因为 active 类名添加给了 li，所以我们需要在 MenuLink 组件中引入样式文件 index.css 并将修改，代码如下：/* 路径：~react-router/src/index.css —— 激活样式修改后 */ li.active a { color: skyblue !important; } 总结本篇通过一个简单的案例使用了由 React Router 所提供的、开发中常用的功能，但美中不足的是并没有使用一些 UI 库或者 CSS 样式来美化，为了更明显的看到 React Router 各个功能使用后的效果，建议大家在实现上面代码的同时自己添加一些 CSS 样式。","tags":[{"name":"React","slug":"React","permalink":"https://www.overtaking.top/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://www.overtaking.top/tags/Router/"}]},{"title":"React 基础篇 —— 组件间的参数传递","date":"2018-09-18T16:26:29.000Z","path":"20180919002629/","text":"单向数据流支持组件化开发的前端框架如 React、Vue，组件间的参数传递都是很重要的，而 React 中数据传递是单向的，也被称为单向数据流，即数据只能从父组件传递到子组件，而子组件只需要通过 props 属性渲染即可，如果顶层组件的某个属性的值改变了，React 将由外向内遍历整个组件树，将使用了该属性的组件重新渲染。创建项目首先使用 create-react-app 脚手架创建 React 项目，项目生成后删除 src 文件目录下的多余文件，留下 index.js，命令如下：# 安装脚手架 $ npm install -g create-react-app # 创建项目 $ create-react-app transfer-props 该项目最后的目录结构如下： transfer-props |- public | |- favicon.ico | |- index.html | |- manifest.json |- src | |- components | | |- App.js | | |- Child.js | | |- Parent.js | |- context.js | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 父组件传参给子组件创建一个最外层组件 App，并在 index.js 中进行渲染。/* 路径：~transfer-props/src/index.js */ import React from &#39;react&#39;; import ReactDOM from &#39;react&#39;; import App from &#39;./components/App&#39;; ReactDOM.render(&lt;App /&gt;, window.root); App 组件内部状态中含有 users 属性，值为数组，含有 title 属性，现在要将这两个参数传递给 Parent 组件，传参方式如下：/* 路径：~transfer-props/src/components/App.js */ import React, { Component } from &#39;react&#39;; import Parent from &#39;./Parent&#39;; export default class App extends Component { // 状态 state = { users: [ { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; }, { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; } ], title: &#39;学生信息&#39; } render() { return ( &lt;div&gt; &lt;Parent {...this.state} /&gt; &lt;/div&gt; ) } } Parent 组件中接收到参数，要根据参数中数组的数量来渲染下一个子组件 Child，Child 组件中需要使用父组件 users 数组的学生 id，传参如下：/* 路径：~transfer-props/src/components/Parent.js */ import React, { Component } from &#39;react&#39;; import Child from &#39;./Child&#39;; export default class App extends Component { render() { const { users, title } = this.props; return ( &lt;div&gt; &lt;h1&gt;{title}&lt;/h1&gt; {/* 显示标题 */} &lt;ul&gt; { // 循环创建 Child 组件 users.map(item =&gt; { return ( &lt;Child key={item.id} {...item} /&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } } 最后是 Child 组件，用来渲染学生的基本信息，在 Parent 中我们已经将参数传递，最后看看在 Child 中的接收。/* 路径：~transfer-props/src/components/Child.js */ import React, { Component } from &#39;react&#39;; export default class App extends Component { render() { const { id, name, age } = this.props; return ( &lt;li&gt; &lt;span&gt;{id}&lt;/span&gt; &lt;span&gt;{name}&lt;/span&gt; &lt;span&gt;{age}&lt;/span&gt; &lt;/li&gt; ) } } 注意：子组件接收父组件的 props 属性是只读的，不可以修改，修改会报错。其实在这个过程中参数经历了三个组件，都是由父组件传向子组件，可以看出 React 单向数据流的特点，但是子组件是不可以直接修改父组件的数据的，下面来看看子组件如何修改父组件的数据。子组件修改父组件的数据在 React 中如果要修改父组件的参数，可以给子组件传入一个修改父组件参数的函数，然后在子组件中执行这个函数，就可以实现父组件数据的更新。我们创建一个与 Parent 组件平行的 Input 组件，两个组件都是 App 的直接子组件，在 Input 组件内通过某些操作给父组件的状态中的 users 属性新增一条数据。/* 路径：~transfer-props/src/components/Input.js */ import React, { Component } from &#39;react&#39;; export default class Input extends Component { name = React.createRef(); age = React.createRef(); handleSubmit = e =&gt; { // 取消默认事件 e.preventDefault(); // 执行父组件方法，取出输入框的值构造成对象作为参数传入 this.props.addStudent({ name: this.name.current.value, age: this.age.current.value }); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; 姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt; &lt;br /&gt; 年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt; &lt;/form&gt; ) } } 上面是 Input 组件，在修改时没有直接使用按钮的点击事件，而是添加了 form 标签并使用 submit 事件，是因为可以使用 H5 的自带的校验功能，但是使用 form 会自动提交页面，所以在执行 submit 事件时应取消默认事件，然后调用父组件传来的方法 addStudent，并传入输入框获取的值（非受控组件的取值方式），父组件 App 修改如下：/* 路径：~transfer-props/src/components/App.js —— 修改后 */ import React, { Component } from &#39;react&#39;; import Parent from &#39;./Parent&#39;; import Input from &#39;./Input&#39;; export default class App extends Component { // 状态 state = { users: [ { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; }, { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; } ], title: &#39;学生信息&#39; } // 添加学生信息事件 addStudent = val =&gt; { // 使用 push 添加 // this.state.users.push({ id: this.state.users.length + 1, ...val }); // this.setState({}); // 使用 setState 添加 this.setState({ users: [ ...this.state.users, { id: this.state.users.length + 1, ...val } ] }); } render() { return ( &lt;div&gt; &lt;Parent {...this.state} /&gt; &lt;Input addStudent={this.addStudent} /&gt; &lt;/div&gt; ) } } 首先父组件 App 应该创建 addStudent 方法作为参数传递给子组件 Input，而在 addStudent 方法内部通过 push 和 setState 两种方式进行添加，发现都可以更新状态和视图，区别是 push 操作的原来的引用，而 setState 创建了新的引用空间。在 React 所有状态的更改都不建议操作原来的引用，通常做法都是通过 setState 返回一个新的 state（创建新的引用），使用解构赋值的方式来保留原始数据，用新数据覆盖旧数据，原因是在 React 类组件种有一个 PureComponent 纯组件类型，对 shouldComponentUpdate 生命周期 “钩子” 做了优化，使用了 props 和 state 的浅比较，所以在纯组件类型操作原来的引用是无法更新视图的。context 实现跨组件传参在上面的案例当中，父子组件关系的层级是三层，无论是普通的数据还是修改父组件的事件都是作为参数一级一级往下传的，如果组件的层级多了，当跨组件传参时是非常不方便的（通常三级还可以接受）。跨组件传参是指父级组件与非直接子组件的传参、同级组件之间的传参，同级之间可以找到相同的父级，没有相同的父级就创造相同的父级，最后将问题统一到了父级组件与非直接子组件的传参传递。在 React 中给我们提供了 context API 用来实现组件树数据的共享，分为新旧两个版本，这里旧版和新版的 API 都会介绍。旧版 context在旧版的 context 需要配合属性类型检测的 prop-types 模块共同使用，需要在共同的父组件上定义一个方法 getChildContext，返回值为一个对象，对象中存储的是当前要传递给其他子组件的数据，同时还有一个静态属性 childContextTypes，值为一个对象，属性的值与 getChildContext 方法内返回的对象的属性一一对应，并用 prop-types 模块对每一个传递给子组件属性的数据类型进行定义，在使用父组件传递属性的子组件中需要定义静态属性 contextTypes 对所使用的属性的数据类型进行校验，需要父组件与 childContextTypes 内的定义一致，然后可以通过子组件实例的 context 属性获取，我们可以使用 context 将上面的案例修改如下：/* 路径：~transfer-props/src/components/App.js —— 旧版 context */ import React, { Component } from &#39;react&#39;; import Parent from &#39;./Parent&#39;; import Input from &#39;./Input&#39;; import PropTypes from &#39;prop-types&#39;; // 引入参数类型检测模块 export default class App extends Component { // 状态 state = { users: [ { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; }, { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; } ], title: &#39;学生信息&#39; } // 定义参数类型 static childContextTypes = { state: PropTypes.object, addStudent: PropTypes.func } // 上下文对象传给子组件的参数 getChildContext() { return { state: this.state, addStudent: this.addStudent } } // 添加学生信息事件 addStudent = val =&gt; { // 使用 setState 添加 this.setState({ users: [ ...this.state.users, { id: this.state.users.length + 1, ...val } ] }); } render() { return ( &lt;div&gt; {/* 不再需要传参 */} &lt;Parent /&gt; &lt;Input /&gt; &lt;/div&gt; ) } } 上面只是将 APP 组件中原本传给子组件的参数去掉，按照要求添加了 getChildContext 方法和 childContextTypes 静态属性。/* 路径：~transfer-props/src/components/Input.js —— 旧版 context */ import React, { Component } from &#39;react&#39;; export default class Input extends Component { name = React.createRef(); age = React.createRef(); // 类型检测与父组件定义的类型对应 static contextTypes = { addStudent: PropTypes.func } handleSubmit = e =&gt; { // 取消默认事件 e.preventDefault(); // 从上下文对象上获取父组件的方法并执行 this.context.addStudent({ name: this.name.current.value, age: this.age.current.value }); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; 姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt; &lt;/form&gt; ) } } 在 Input 组件中定义 contextTypes 属性，将 addStudent 方法从原来的 props 获取改为了从 context 上获取。/* 路径：~transfer-props/src/components/Parent.js —— 旧版 context */ import React, { Component } from &#39;react&#39;; import Child from &#39;./Child&#39;; export default class Parent extends Component { // 类型检测与父组件定义的类型对应 static contextTypes = { state: PropTypes.object } render() { // 从 context 对象上获取 state 并解构 const { users, title } = this.context.state; return ( &lt;div&gt; &lt;h1&gt;{title}&lt;/h1&gt; {/* 显示标题 */} &lt;ul&gt; { // 循环创建 Child 组件 users.map(item =&gt; { return ( &lt;Child key={item.id} {...item} /&gt; ) }) } &lt;/ul&gt; &lt;/div&gt; ) } } 在 Parent 组件中同样定义 contextTypes 属性，将 state 属性从原来的 props 获取改为了从 context 上获取。新版 context新版 context 其实是 React 对象提供给我们的方法 createContext 实现的，方法在调用时返回一个对象，对象上有两个组件分别为 Provider（提供者）和 Consumer（消费者），由于两个配合使用的组件必须由同一次调用 createContext 时创建，所以我们单独创建文件 context.js 代码如下：/* 路径：~transfer-props/src/context.js —— 新版 context */ import React from &#39;react&#39;; // 创建上下文对象 const { Provider, Consumer } = React.createContext(); // 到处上下文对象的组件 export { Provider, Consumer }; 还是之前的案例，我们可以使用新版 context 修改如下：// 路径：~transfer-props/src/components/App.js —— 新版 context import React, { Component } from &#39;react&#39;; import Parent from &#39;./Parent&#39;; import Input from &#39;./Input&#39;; import { Provider } from &#39;../context&#39;; export default class App extends Component { // 状态 state = { users: [ { id: 1, name: &#39;panda&#39;, age: &#39;28&#39; }, { id: 2, name: &#39;shen&#39;, age: &#39;18&#39; } ], title: &#39;学生信息&#39; } // 添加学生信息事件 addStudent = val =&gt; { // 使用 setState 添加 this.setState({ users: [ ...this.state.users, { id: this.state.users.length + 1, ...val } ] }); } render() { return ( &lt;Provider value={{ addStudent: this.addStudent, state: this.state }}&gt; &lt;div&gt; &lt;Parent {...this.state} /&gt; &lt;Input addStudent={this.addStudent} /&gt; &lt;/div&gt; &lt;/Provider&gt; ) } } 提供参数的父组件 App 应该使用 Provider 进行包裹，将传入的参数以 value 为参数名（规定），传入 context 对象中。/* 路径：~transfer-props/src/components/Input.js —— 新版 context */ import React, { Component } from &#39;react&#39;; import { Consumer } from &#39;../context.js&#39;; export default class Input extends Component { name = React.createRef(); age = React.createRef(); handleSubmit = (e, addStudent) =&gt; { // 取消默认事件 e.preventDefault(); // 执行父组件方法，取出输入框的值构造成对象作为参数传入 addStudent({ name: this.name.current.value, age: this.age.current.value }); } render() { return ( &lt;Consumer&gt; { ({ addStudent }) =&gt; ( &lt;form onSubmit={e =&gt; handleSubmit(e, addStudent)}&gt; 姓名：&lt;input type=&quot;text&quot; required ref={this.name} /&gt; &lt;br/&gt; 年龄：&lt;input type=&quot;text&quot; required ref={this.age} /&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt; &lt;/form&gt; ) } &lt;/Consumer&gt; ) } } 在使用 “提供者” 提供数据的 “消费者” 子组件中，应该引入与 Provider 对应的 Consumer 组件，用 Consumer 组件替换原本组件返回的 JSX，内部传入一个函数，函数的形参即为 context 对象，函数内部返回值为原本子组件返回的 JSX，子组件使用父组件的属性可直接从函数的形参获取或解构。/* 路径：~transfer-props/src/components/Parent.js —— 新版 context */ import React, { Component } from &#39;react&#39;; import Child from &#39;./Child&#39;; import { Consumer } from &#39;../context.js&#39;; export default class App extends Component { render() { return ( &lt;Consumer&gt; { ({ states }) =&gt; ( &lt;div&gt; &lt;h1&gt;{states.title}&lt;/h1&gt; {/* 显示标题 */} &lt;ul&gt; { // 循环创建 Child 组件 states.users.map(item =&gt; ( &lt;Child {...item} key={item.id}&gt;&lt;/Child&gt; )) } &lt;/ul&gt; &lt;/div&gt; ) } &lt;/Consumer&gt; ) } } Parent 作为 App 的子组件，修改的方式同 Input 组件相同，如上面代码。总结关于 React 组件之间传参的各中放式上面基本介绍完了，但是这些传参方式并不能满足于所有的需求，如果是两个毫不相关的组件并且距离共同的父组件层级比较远，即使使用 context 的方式也会显得有些无力，组件间互相传参的需求比较多代码也会冗余和繁琐，因此就有了 Redux、Mobx 等数据状态管理工具，可以将各个组件的状态数据统一管理，各个组件的之间的参数都更容易获取。","tags":[{"name":"React","slug":"React","permalink":"https://www.overtaking.top/tags/React/"}]},{"title":"React 基础篇 —— 生命周期详解","date":"2018-09-15T11:44:39.000Z","path":"20180915194439/","text":"前言本篇文章主要内容针对 React 类组件的生命周期展开，会详细介绍生命周期 “钩子” 的执行和用法，如果一点也不了解 React 的同学建议先学习一下 React 比较基础的内容 React 基础篇 —— 带你走进 React 世界。创建项目首先使用 create-react-app 脚手架创建一个 React 项目，脚手架工具的安装和项目创建命令如下：# 安装脚手架 $ npm install -g create-react-app # 创建项目 $ create-react-app life-cycle 创建项目后删除 src 目录中的无用文件，只留下 index.js 入口文件即可。类组件的生命周期静态属性 defaultPropsdefaultProps 是用来给 React 类组件设置参数初始值的，也是最早执行的，算不算生命周期说法不一，但是觉得有必要说一下，因为在 React 15.x 版本的时候可以用 React.createClass 创建类组件，组件中有与 defaultProps 静态属性作用相同的生命周期 “钩子” getDefaultProps，随着 React 16.x 版本废弃了 React.createClass，也就使用 defaultProps 属性替代了 getDefaultProps。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { static defaultProps = { num: 0 } render() { return &lt;div&gt;{this.props.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); 启动项目后，发现页面上成功的渲染了节点中的数字，这说明设置初始值生效了。constructor 方法constructor 是 ES6 中类的写法中给实例设置属性的钩子，在类的实例被创建时执行，下面是对比 defaultProps 静态属性执行顺序的代码。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); console.log(props.number); // 0 } static defaultProps = { num: 0 } render() { return &lt;div&gt;{this.props.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); 从上面案例中可以看到当执行 constructor 时，props 对象中的 num 属性已经有值了，这也充分说明了说明 constructor 是晚于 defaultProps 执行的。状态对象 state在 React 中，每一个类组件都有一个属于自己的状态，可以使用 setState 方法更新状态，在 React 15.x 中，通过 React.createClass 创建类组件，使用对应的生命周期 “钩子” getInitialState 来创建，同样的，React 16.x 废弃了 React.createClass，创建 state 的过程自然由新的方式代替。创建 state 的方式大概有两种，分别是在 constructor 中创建或者直接创建 state 属性，代码如下：/* 第一种创建 state 的方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); this.state = { num: 0 }; } render() { return &lt;div&gt;{this.state.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); /* 第二种创建 state 的方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); console.log(this.state.num); // 0 } // 创建 state state = { num: 0 } render() { return &lt;div&gt;{this.state.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); 从上面可以看出直接创建 state 属性的方式与创建静态属性 defaultProps 类似，执行要早于 constructor。componentWillMount 钩子componentWillMount 生命周期 “钩子” 在组件将要挂载时执行，也就是说在组件挂载前会调用 componentWillMount，整个组件的生命周期中只执行一次，一般用于发送当前组件需要的 Ajax 请求获取数据。在 React 16.3 版本中标识了该 “钩子” 会被在未来版本中废弃，目前仍然可以使用，在 componentWillMount 的可以迁移到 constructor，但不能包含 setState 操作，因为 constructor 中无法调用 setState。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); console.log(&#39;constructor&#39;); } state = { num: 0 } componentWillMount() { console.log(&#39;componentWillMount&#39;); this.setState({ num: 3 }); } render() { return &lt;div&gt;{this.state.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); // constructor // componentWillMount 从上面的打印结果可以看出 componentWillMount “钩子” 的执行是晚于 constructor 的，从页面渲染 3 的结果来看，在 componentWillMount “钩子” 中已经可以使用 setState 更改状态了。render 钩子render 钩子的主要作用是返回组件内部要被渲染的 JSX，即所谓的挂载过程，将上面例子简单修改一下。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); console.log(&#39;constructor&#39;); } state = { num: 0 } componentWillMount() { console.log(&#39;componentWillMount&#39;); } render() { console.log(&#39;render&#39;); return &lt;div&gt;{this.state.num}&lt;/div&gt;; } } ReactDOM.render(&lt;Counter /&gt;, window.root); // constructor // componentWillMount // render 从打印结果可以看出 constructor 最先执行，其次是 componentWillMount，最后是 render，由于状态或属性的更新可能导致组件重新渲染，所以 render 可能会被执行多次。componentDidMount 钩子componentDidMount 生命周期 “钩子” 在组件挂载后执行，一般会将一些依赖于 DOM 的操作放在该 “钩子” 内执行，整个生命周期只执行一次。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { constructor(props) { super(); console.log(&#39;constructor&#39;); } state = { num: 0 } componentWillMount() { console.log(&#39;componentWillMount&#39;); } componentDidMount() { console.log(&#39;componentDidMount&#39;); } render() { console.log(&#39;render&#39;); return &lt;div&gt;{this.state.num}&lt;/div&gt; } } ReactDOM.render(&lt;Counter /&gt;, window.root); // constructor // componentWillMount // render // componentDidMount 执行顺序：constructor → componentWillMount → render → componentDidMount。componentWillUpdate 钩子在调用 setState 更新数据后会触发 render 钩子对组件重新渲染，在执行 render 前会调用 componentWillUpdate 钩子，即将要更新时执行（此时状态和页面都没更新），钩子默认有三个参数，分别为 nextProps、nextState 和 nextContext，即更新后的属性对象、状态对象和上下文对象。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;componentWillUpdate&#39;); console.log(&#39;nowState&#39;, this.state); console.log(&#39;nextProps&#39;, nextProps); console.log(&#39;nextState&#39;, nextState); console.log(&#39;nextContext&#39;, nextContext); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // componentWillUpdate // nowState { num: 0 } // nextProps {} // nextState { num: 1 } // nextContext {} // render 从执行点击事件后的结果来看，在重新渲染之前 componentWillUpdate 早于 render 执行，而在 componentWillUpdate 执行时 state 的状态还未更新。componentDidUpdate 钩子在调用 setState 更新数据后执行 render 钩子对组件重新渲染，渲染后会立即调用 componentDidUpdate 钩子，此时 state 状态和页面都已经更新，钩子默认有三个参数，分别为 prevProps、prevState 和 prevContext，即更新前的属性对象、状态对象和上下文对象。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;componentDidUpdate&#39;); console.log(&#39;nowState&#39;, this.state); console.log(&#39;prevProps&#39;, prevProps); console.log(&#39;prevState&#39;, prevState); console.log(&#39;prevContext&#39;, prevContext); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // componentWillUpdate // render // componentDidUpdate // nowState { num: 1 } // prevProps {} // prevState { num: 0 } // prevContext {} 触发点击事件后的执行顺序为：componentWillUpdate → render → componentDidUpdate。shouldComponentUpdate 钩子在使用 setState 更改状态时，其实还会默默的执行 shouldComponentUpdate “钩子”，该钩子有返回值，不使用该 “钩子” 的情况下默认返回值为 true，若使用该 “钩子” 必须指定布尔类型的返回值 true 或 false，当返回值为 true 时代表更新状态和视图，否则不更新，只要使用 setState 就会触发该 “钩子”，该钩子有三个参数，与 componentWillUpdate “钩子” 相同。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;componentDidUpdate&#39;); } shouldComponentUpdate(nextProps, nextState, nextContext) { console.log(&#39;shouldComponentUpdate&#39;); console.log(&#39;nowState&#39;, this.state); console.log(&#39;nextProps&#39;, nextProps); console.log(&#39;nextState&#39;, nextState); console.log(&#39;nextContext&#39;, nextContext); return true; } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // shouldComponentUpdate // nowState { num: 0 } // nextProps {} // nextState { num: 1 } // nextContext {} // componentWillUpdate // render // componentDidUpdate 当 shouldComponentUpdate “钩子” 返回值为 true 时，触发点击事件后的执行顺序为：shouldComponentUpdate → componentWillUpdate → render → componentDidUpdate。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;componentDidUpdate&#39;); } shouldComponentUpdate(nextProps, nextState, nextContext) { console.log(&#39;shouldComponentUpdate&#39;); console.log(&#39;nextState&#39;, nextState); return false; } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // shouldComponentUpdate // nextState { num: 1 } 不断更新 当 shouldComponentUpdate “钩子” 返回值为 false 时，触发点击事件后只有 shouldComponentUpdate 执行了，并且随着触发点击事件的次数增加，nextState 参数的状态不断变化，但是 state 和页面都不更新。componentWillUnmount 钩子componentWillUnmount “钩子” 会在组件卸载之前触发，卸载组件需调用 ReactDOM 的 unmountComponentAtNode 方法，并传入一个根节点，将会卸载这个根节点内部的所有组件。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { // 卸载组件 ReactDOM.unmountComponentAtNode(window.root); } componentWillUnmount () { console.log(&#39;componentWillUnmount&#39;); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;Kill&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // componentWillUnmount componentWillUnmount 钩子一般用来在卸载组件之前清除可能会调用 setState 的异步操作，为了防止在卸载组件后继续更新状态而报错。复合组件的生命周期上面着重介绍了单个类组件的生命周期，有的生命周期由于一个组件不容易演示，所以放在了这节中，这节也会将复合组件的生命周期执行顺序进行分析，并阐明一些使用的注意事项。复合组件渲染生命周期的执行顺序在复合组件中，父组件套着子组件，两个组件都有自己的生命周期，那么执行顺序会是怎么样的，看下面案例。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 子组件 class ChildCounter extends Component { state = { num: 0 } componentWillMount() { console.log(&#39;child-componentWillMount&#39;); } componentDidMount() { console.log(&#39;child-componentDidMount&#39;); } render() { console.log(&#39;child-render&#39;); return &lt;div&gt;{this.state.num}&lt;/div&gt; } } // 父组件 class Counter extends Component { componentWillMount() { console.log(&#39;parent-componentWillMount&#39;); } componentDidMount() { console.log(&#39;parent-componentDidMount&#39;); } render() { console.log(&#39;parent-render&#39;); return ( &lt;div&gt; &lt;ChildCounter /&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // parent-componentWillMount // parent-render // child-componentWillMount // child-render // child-componentDidMount // parent-componentDidMount 从上面的执行顺序可以看出，在执行父组件生命周期的时候，执行 render 会渲染子组件，渲染子组件会将子组件的生命周期优先执行，等子组件完成渲染继续父组件的渲染，即继续执行父组件渲染后的生命周期。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 子组件 class ChildCounter extends Component { state = { num: 0 } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;child-componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;child-componentDidUpdate&#39;); } handleClick = () =&gt; { this.setState({ num: this.state.num - 1 }); } render() { console.log(&#39;child-render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;update-child&lt;/button&gt; &lt;/div&gt; ) } } // 父组件 class Counter extends Component { componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;parent-componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;parent-componentDidUpdate&#39;); } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } render() { console.log(&#39;parent-render&#39;); return ( &lt;div&gt; &lt;ChildCounter /&gt; &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // 点击子组件更新按钮 // child-componentWillUpdate // clild-render // child-componentDidUpdate // 点击父组件更新按钮 // parent-componentWillUpdate // parent-render // child-componentWillUpdate // clild-render // child-componentDidUpdate // parent-componentDidUpdate 当子组件更新时，父组件不会重新渲染，只会执行子组件的生命周期，当父组件更新时，子组件也会重新渲染，此时当父组件执行 render 时会执行子组件更新相关的生命周期，在继续执行父组件更新相关的生命周期。点击父组件更新按钮生命周期的执行顺序：parent-componentWillUpdate → parent-render → child-componentWillUpdate → clild-render → child-componentDidUpdate → parent-componentDidUpdate。点击子组件更新按钮生命周期的执行顺序：child-componentWillUpdate → clild-render → child-componentDidUpdate。如果更新父组件时，不希望子组件重新渲染，可以通过子组件的 shouldComponentUpdate “钩子” 将返回值设置为 false 的方式来控制。componentWillReceiveProps 钩子当传入组件的参数，即 props 发生变化时，componentWillReceiveProps “钩子” 执行，该钩子有一个参数，代表下一次更新的 props 对象，执行该 “钩子” 时，props 并没有更新，也就是说是在 props 变化之前执行。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 子组件 class ChildCounter extends Component { componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;child-componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;child-componentDidUpdate&#39;); } shouldComponentUpdate(nextProps, nextState, nextContext) { console.log(&#39;child-shouldComponentUpdate&#39;); return true; } componentWillReceiveProps(nextProps) { console.log(&#39;child-componentWillReceiveProps&#39;); console.log(&#39;nowProps&#39;, this.props); console.log(&#39;nextProps&#39;, nextProps); } render() { console.log(&#39;child-render&#39;); return &lt;div&gt;{this.props.n}&lt;/div&gt; } } // 父组件 class Counter extends Component { state = { num: 0 } componentWillUpdate(nextProps, nextState, nextContext) { console.log(&#39;parent-componentWillUpdate&#39;); } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;parent-componentDidUpdate&#39;); } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } render() { console.log(&#39;parent-render&#39;); return ( &lt;div&gt; &lt;ChildCounter n={this.state.num} /&gt; &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // parent-componentWillUpdate // parent-render // child-componentWillReceiveProps // nowProps { n: 0 } // nextProps { n: 1 } // child-shouldComponentUpdate // child-componentWillUpdate // child-render // child-componentDidUpdate // parent-componentDidUpdate 点击父组件更新按钮后，父子组件生命周期的执行顺序如下：parent-componentWillUpdate → parent-render → child-componentWillReceiveProps → child-shouldComponentUpdate → child-componentWillUpdate → child-render → child-componentDidUpdate → parent-componentDidUpdate。由此可以说明 componentWillReceiveProps 钩子在 shouldComponentUpdate 之前执行。componentWillReceiveProps “钩子” 在第一次渲染父子组件时不执行，在 React 16.x 版本中被标记为 “已废弃”。关于 setState 在生命周期中的使用在 React 生命周期 “钩子” 中，只有 componentWillMount、componentDidMount 和 componentWillReceiveProps 中可以调用 setState。原因是 setState 方法会触发 render “钩子” 执行，而 shouldComponentUpdate、componentWillUpdate、componentDidUpdate 是在 render 后触发，包括在 render 中调用 setState，都会出现更新 “死循环” 的现象，最后造成堆栈溢出，而 componentWillUnmount “钩子” 执行时，组件将被卸载，在此时更新状态毫无意义。在 componentWillReceiveProps 中使用 setState，其目的是为了将新更改的属性更新为该组件的状态，但 React 官方不建议这样使用。React 生命周期流程图下面是一张关于目前版本比较常用的 React 生命周期 “钩子” 执行顺序的流程图，帮助大家快速理解 React 生命周期中各个钩子函数的执行过程。React 生命周期流程图React 16.3 新增生命周期getDerivedStateFromProps 静态方法getDerivedStateFromProps 是一个类组件的静态方法，用来替代 componentWillReceiveProps “钩子”，在传入的属性变化之前执行，方法的参数与 componentWillReceiveProps 相同，是更新的属性对象，该方法要求必须返回一个状态对象的返回值，且使用该方法的组件必须含有 state，不能和 componentWillMount “钩子” 同时使用。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 子组件 class ChildCounter extends Component { state = { num: 0 } componentDidUpdate(prevProps, prevState, prevContext) { console.log(&#39;child-componentDidUpdate&#39;); console.log(&#39;nowState&#39;, this.state); } static getDerivedStateFromProps(nextProps) { console.log(&#39;child-getDerivedStateFromProps&#39;); console.log(&#39;nextProps&#39;, nextProps); return { num: nextProps.n }; } render() { console.log(&#39;child-render&#39;); return &lt;div&gt;{this.props.n}&lt;/div&gt; } } // 父组件 class Counter extends Component { state = { num: 0 } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } render() { console.log(&#39;parent-render&#39;); return ( &lt;div&gt; &lt;ChildCounter n={this.state.num} /&gt; &lt;button onClick={this.handleClick}&gt;update-parent&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // parent-render // child-render // child-getDerivedStateFromProps // nextProps { n: 1 } // child-componentDidUpdate // nowState { num: 1 } 点击父组件的更新按钮钩子的执行顺序如下：parent-render → child-render → child-getDerivedStateFromProps → child-componentDidUpdate。getDerivedStateFromProps 除了上面叙述的用法的注意事项，与 componentWillReceiveProps 相比还有两个优势：第一点是默认第一次渲染时也会执行该 “钩子”；第二点是不需要再通过调用 setState 将新的 props 转换成组件的状态，可以直接通过返回值设置状态。getSnapshotBeforeUpdate 钩子getSnapshotBeforeUpdate “钩子” 用于替代 componentWillUpdate “钩子”，不能与 componentWillMount “钩子” 同时使用，必须与 componentDidUpdate “钩子” 同时使用，需返回一个值或者 null，该值会传给 componentDidUpdate “钩子” 的第三个参数。import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } // 点击事件 handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); } getSnapshotBeforeUpdate() { console.log(&#39;getSnapshotBeforeUpdate&#39;); return 123; } componentDidUpdate(prevProps, prevState, prop) { console.log(&#39;componentDidUpdate&#39;); console.log(&#39;prop&#39;, prop); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); // render // getSnapshotBeforeUpdate // componentDidUpdate // prop 123 点击更新按钮执行顺序为：render → getSnapshotBeforeUpdate → componentDidUpdate。总结以上就是关于 React 生命周期的内容，涵盖了在 React 开发中对生命周期大部分的应用，也是 React 知识体系中非常重要的部分，React 生命周期和 Vue 相比的特点是名字长，不容易记，希望大家在学习理解之后多巩固，孰能生巧。","tags":[{"name":"React","slug":"React","permalink":"https://www.overtaking.top/tags/React/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.overtaking.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"React 基础篇 —— 带你走进 React 世界","date":"2018-09-09T18:59:59.000Z","path":"20180910025959/","text":"React 介绍React 是前端最流行的框架之一，由 Facebook 产出，由于其独特的 JSX 语法与组件化开发模式，将原本前端基于 DOM 的编程方式变成了基于组件和数据编程，给前端带来的益处是颠覆性的，因为我们知道 DOM 操作是 “昂贵” 的，React 在提高应用性能的同时又大大提高了开发效率，所以受到很多前端开发者的支持，也就有了庞大的生态，如今 React 已经成为前端工程师之必备技术栈。创建 React 项目在创建 React 项目时，可以使用当下最流行的脚手架 create-react-app 和 generator-react-webpack，前者是由 Facebook 官方出品，后者是社区提供。create-react-appcreate-react-app 适用于大部分项目，集成了对 React、JSX、ES6 和 Flow 的支持，支持热更新，默认情况下无需对 Webpack 进行配置，如果要单独配置 Webpack，需要执行命令弹出配置项，下面命令分别对应安装脚手架工具、构建项目和弹出配置项。# 安装脚手架 $ npm install -g create-react-app # 创建项目 $ create-react-app project-name # 弹射 Webpack 配置文件 $ npm run eject 注意：创建 React 项目时，项目名称不能含大写字母，使用 eject 命令弹出配置项的过程不可逆。generator-react-webpackgenerator-react-webpack 适用于构建大型项目，它是需要 yeoman 的支持，几乎具备了 create-react-app 的全部功能，不同的是默认可以对 Webpack 进行配置，生成项目需要手动创建项目根目录，安装脚手架工具和构建项目的命令如下：# 安装脚手架及依赖 $ npm install -g yo generator-react-webpack # 创建项目根目录 $ mkdir project-name # 进入项目目录 $ cd project-name # 创建项目 $ yo react-webpack 目录结构我们本次使用 create-react-app 来构建一个项目，并弹出配置项，src 目录为我们主要的开发文件，必须含有一个入口文件 index.js，所以我们在构建项目后删除 src 中的无用文件，目录结构如下（可以通过 npm run start 启动项目）。 react-demo |- config | |- jest | | |- cssTransform.js | | |- fileTransform.js | |- env.js.js | |- paths.js | |- webpack.config.dev.js | |- webpack.config.prod.js | |- webpackDevServer.config.js |- public | |- favicon.ico | |- index.html | |- manifest.json |- scripts | |- build.js | |- start.js | |- test.js |- src | |- index.js |- .gitignore |- package.json |- README.md |- yarn.lock 探索 React引入 React 变量必须大写React 的核心模块分为两个，分别为 react 和 react-dom，前者为 React 的核心逻辑，后者为 React 的渲染逻辑，在 React 中规定引入 react 模块的变量名必须大写。/* 文件位置：~react-demo/src/index.js */ import react from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建一个 JSX const h1 = ( &lt;h1&gt;hello world&lt;/h1&gt; ) // 渲染到页面 ReactDOM.render(h1, window.root); 如果向上面代码中将引入 react 的变量小写，报错信息如下：React 变量错写报错该报错信息的意思是当前使用了 JSX，必须要有一个大写的 React，从而可以看出这是 React 所规定的，当将接收 react 的变量改成大写后，页面正常渲染。React 必须有 createElement 方法/* 文件位置：~react-demo/src/index.js */ // 创建一个大写的 React 对象 const React = {}; // 创建一个 JSX const h1 = ( &lt;h1&gt;hello world&lt;/h1&gt; ) 为了进一步验证，上面代码中创建一个名为 React 的对象，报错信息如下：React 没有 createElement 方法报错这个报错非常明显的在告诉我们，React 对象中缺少了 createElement 方法，我们将代码修改如下后发现报错信息消失。/* 文件位置：~react-demo/src/index.js */ // 创建一个大写的 React 对象 const React = { createElement() {} }; // 创建一个 JSX const h1 = ( &lt;h1&gt;hello world&lt;/h1&gt; ) 页面 “白屏” 是因为并没有使用 react-dom 进行渲染，我们定义的 h1 是一个组件，同时也是 JSX，所以会调用 createElement 对 JSX 进行解析。解析后的 JSX 长什么样/* 文件位置：~react-demo/src/index.js */ import React from &#39;react&#39;; // 创建一个 JSX const h1 = ( &lt;h1&gt;hello world&lt;/h1&gt; ) // 查看 JSX 解析后的结果 console.log(h1); 打开 Chorme 浏览器控制台查看打印结果如下：JSX 解析后的虚拟 DOM 结构从结果可以看出 createElement 方法最终将 JSX 解析成了一个对象结构，其中 props 带表属性对象，其中的 children 代表子元素，也就是文本节点 hello world，type 代表标签类型为 h1，这样用来表述 DOM 结构的对象被称为虚拟 DOM。模拟解析和渲染过程在上面我们知道了 React 可以自动将 JSX 转换成虚拟 DOM，而 ReactDOM 的 render 方法将虚拟 DOM 渲染成了真实的 DOM，用法如下：/* 文件位置：~react-demo/src/index.js */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建 JSX const el = ( &lt;h1 name=&quot;hi&quot;&gt; hello &lt;span&gt;world&lt;/span&gt; &lt;/h1&gt; ) // 渲染到页面 ReactDOM.render(el, window.root); 查看页面可以看到正常渲染了，现在就用前面对 React 的了解来简单模拟解析与渲染的过程，代码如下：/* 文件位置：~react-demo/src/index.js */ // 创建 React 对象和 createElement 方法 const React = { createElement(type, props, ...children) { return { type, props, children }; } }; // 创建 JSX const el = ( &lt;h1 name=&quot;hi&quot;&gt; hello &lt;span&gt;world&lt;/span&gt; &lt;/h1&gt; ) // 渲染的 render 方法 function render(vnode, container) { // 如果是字符串说明是文本节点，创建文本节点并插入到父元素中 if (typeof vnode === &#39;string&#39;) { return container.appendChild(document.createTextNode(vnode)); } // 如果不是字符串说明是元素节点，解构元素类型、属性和子元素的数组 const { type, props, children } = vnode; // 创建元素 const tag = document.createElement(type); // 循环添加属性 for (let key in props) { tag.setAttribute(key, props[key]); } // 循环子元素，并递归创建子元素 children.forEach(child =&gt; { render(child, tag); }); // 将元素插入到容器中，root container.appendChild(tag); } // 渲染虚拟 DOM render(el, window.root); 通过上面实现的代码同样可以完成渲染，当然仅限于简单结构，React 内部的实现更为复杂，兼容了多种组件类型和复杂的 DOM 结构。JSX 最外层只能有一个元素/* 文件位置：~react-demo/src/index.js */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建 JSX const el = ( &lt;h1 name=&quot;hi&quot;&gt;hello&lt;/h1&gt; &lt;div&gt;world&lt;/div&gt; ) ReactDOM.render(el, window.root); 在对上面代码中的 JSX 进行渲染时会有如下报错信息。JSX 没有唯一父元素包裹报错上面的报错信息告诉我们 JSX 元素必须包裹在一个闭合的标签内，所以说在写 JSX 语法的时候我们必须保证最外层只有一个元素节点。React 的基本使用在 JSX 全称为 JavaScript XML，但是和普通的 HTML 相比，有一些不同的用法，如元素属性 class、for、style、dangerouslyInnerHTML 以及注释写法等等。className 属性在 JSX 语法中，在标签中应使用 className 替代 HTML 中的 class 属性，因为在 JavaScript 中 class 为关键字。/* class 属性在 JSX 中的写法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; ReactDOM.render(&lt;h1 className=&quot;active&quot;&gt;hello&lt;/h1&gt;, window.root); htmlFor 属性在 HTML 中，通过点击 label 标签让 input 输入框获取焦点是很常见的，只需要让 label 标签 for 属性的值与 input 标签的 id 值相等即可，但是在 JSX 中这这样的写法会报错，必须将 label 标签的 for 属性使用 htmlFor 替代，代码如下：/* for 属性在 JSX 中的写法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const el = ( &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;label htmlFor=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt; &lt;/div&gt; ) ReactDOM.render(el, window.root); style 属性/* style 属性错误的写法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const el = ( &lt;h1 style=&quot;color: red;&quot;&gt;hello&lt;/h1&gt; ) ReactDOM.render(el, window.root); 在 JSX 中关于 style 属性的写法发生了变化，如果用 HTML 中的写法会报错，错误信息如下：JSX 中 style 属性错误写法报错报错信息中明确的告诉我们 style 属性必须是一个含有代表样式键值的对象，而不是一个字符串，并给出正确的结构，正确的写法如下：/* style 属性在 JSX 中的写法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const el = ( &lt;h1 style={{color: 'red'}}&gt;hello&lt;/h1&gt; ) ReactDOM.render(el, window.root); 注意：在解析 JSX 的过程中，&lt; 和 &gt; 包裹 JSX 元素，元素属性中最外层的 { 和 } 包裹 JS 代码，而内层的 { 和 } 则代表一个 JS 对象，所以 style 是被两层 “花括号” 所包裹，并不是 mustache 语法。取值表达式在 JSX 中，所有的 JS 代码都可以写在 JSX 元素起始和闭合标签中间的 { 和 } 内，会将执行结果渲染到该元素上。/* 取值表达式的使用 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const str = &#39;world&#39;; const obj = { hello: &#39;world&#39; }; const fn = () =&gt; &lt;p&gt;hello&lt;/p&gt;; const el = ( &lt;div&gt; &lt;h1&gt;{fn()}&lt;/h1&gt; &lt;div&gt;{str}&lt;/div&gt; &lt;div&gt;{JSON.stringify(obj)}&lt;/div&gt; &lt;div&gt;{true ? &lt;span&gt;nihao&lt;/span&gt; : null}&lt;/div&gt; &lt;/div&gt; ) ReactDOM.render(el, window.root); 启动项目可以看到页面上已经成功的渲染了 hello、world、{ hello: &#39;world&#39; } 和 nihao，上面三元运算符结果如果为 null 则不会渲染这个节点，viod 0 与 null 作用相同。dangerouslySetInnerHTML 属性在 JSX 中，如果想要把一个含有标签元素的字符串插入到某一个节点中，应该使用 dangerouslySetInnerHTML 替代原生 JS 中的 innerHTML。/* dangerouslySetInnerHTML 的用法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const str = &#39;&lt;h1&gt;hello&lt;/h1&gt;&#39;; const el = ( &lt;h1 dangerouslySetInnerHTML={{__html: str}}&gt;&lt;/h1&gt; ) ReactDOM.render(el, window.root); 在上面的代码中，dangerouslySetInnerHTML 属性的值为对象，将要插入的 HTML 字符串作为对象中 __html 属性的值即可，设置 dangerouslySetInnerHTML 属性的 JSX 元素中不能有任何的子元素。注意：dangerouslySetInnerHTML 属性非常危险，容易引发 XSS 攻击，轻易不要使用。JSX 中注释的写法在 JSX 的 DOM 结构中，如果需要对代码进行注释不能使用 JS 中的 // 注释，也不能使用 HTML 中的 &lt;!-- 注释 --&gt;，注释必须使用 { } 包裹，写法如下：/* 注释在 JSX 中的写法 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const el = ( &lt;div&gt; &lt;h1 name=&quot;hi&quot;&gt;hello&lt;/h1&gt; {/* 这是注释，支持多行 */} &lt;span&gt;world&lt;/span&gt; &lt;/div&gt; ) ReactDOM.render(el, window.root); Fragment 组件在 React 16.3 中提供了一个组件，类似于原生 JS 中的文档碎片，可以将多个元素包裹起来，却不会被渲染，用法如下：/* Fragment 组件的使用 */ import React, { Fragment } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const el = ( &lt;Fragment&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;div&gt;world&lt;/div&gt; &lt;/Fragment&gt; ) ReactDOM.render(el, window.root); 循环动态创建 JSX 结构在 React 中不存在过多的 API，最大的特点就是 JSX 语法可以将 JS 与 HTML 混写（函数式编程），借助原生 JS 的方法实现功能，比如可以使用循环创建 JSX 结构。/* 循环在 JSX 中的应用 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const arr = [1, 2, 3]; const el = ( arr.map((item, index) =&gt; { return ( &lt;li key={index}&gt;{item}&lt;/li&gt; ) }) ) ReactDOM.render(el, window.root); 上面成功的渲染除了一个列表，但是有两点需要注意：第一点是循环一定要使用具有返回值的方法，如 map、filter 等；第二点是每一个循环出来的 JSX 元素必须绑定一个 key 属性，可以使用数据的 id（优先），也可以使用数组的索引。组件在上面所有代码中的 JSX 都很不优雅，如果一个项目非常大，这样的混乱的结构是难以维护的，组件就是为了更好的维护和复用相同的 JSX 结构以及提高工作效率而存在的。函数组件在 React 中可以通过函数创建组件，函数名称就是组件名，必须大写，必须有返回值，可以为 JSX，也可以为 null，通过单闭合和双闭合两种方式调用组件，可以通过属性传参，并通过函数组件的第一个参数接收，实现代码如下：/* 函数组件 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建一个函数组件 function Build(props) { return ( &lt;div&gt; &lt;h1&gt;{props.title}&lt;/h1&gt; &lt;div&gt;{props.content}&lt;/div&gt; &lt;/div&gt; ) } // 渲染组件 ReactDOM.render(( &lt;div&gt; &lt;Build title=&#39;1&#39; content=&#39;1xx&#39;&gt;&lt;/Build&gt; {/* 双闭合 */} &lt;Build title=&#39;2&#39; content=&#39;2xx&#39; /&gt; {/* 单闭合 */} &lt;/div&gt; ), window.root); 函数组件缺点（16.3 以前）：在函数组件内部 this 为 undefined；在函数组件内部没有状态，即只能使用通过属性传递的参数，却没有更改的能力；函数组件没有生命周期，无法使用生命周期 “钩子” 完成一些操作。由于函数组件的缺陷，所以更适合渲染一些静态的不需要数据变化的结构，如果想要让传入的属性变化可以通过不断执行 React.render 的方式不断更新传入组件参数的值，下面是一个时钟案例，通过函数组件实现时间的变化。/* 函数组件多次渲染 */ import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建函数组件 function Clock(props) { return ( &lt;div&gt; &lt;h1&gt;当前时间&lt;/h1&gt; &lt;div&gt;{props.time}&lt;/div&gt; &lt;/div&gt; ) } // 每秒渲染一次组件 setInterval(() =&gt; { ReactDOM.render( &lt;Clock time={new Date().toLocaleString()} /&gt;, window.root ); }, 1000); 类组件类组件解决了函数组件所有的缺陷，是通过类声明的。/* 类组件 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { // constructor(props) { // super(props); // this.state = { // time: new Date().toLocaleString(); // } // } // 等价于 constructor 的写法，更简洁 state = { time: new Date().toLocaleString() } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); 在上面的类组件中，我们同样使用了一个简单的时钟功能，可以看出类组件即有 this，又能创建和更新状态，也可以通过生命周期进行一些操作。所有的类组件都需要继承 React.Component，这样就可以使用 React.Component 的原型方法 setState 对状态进行更新，每次更新，都会使组件重新渲染，但是只会重新渲染变化的 DOM，这是 ReactDOM 通过 diff 算法所做的优化。类组件中添加事件在平时开发中每个组件都会有一些对应的功能，这就需要事件的配合，在类组建中绑定事件大概有四种方式，我们还是用上面的时钟案例，给该组件添加一个按钮，在点击时卸载这个组件。/* 方式 1：使用箭头函数直接绑定事件 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { state = { time: new Date().toLocaleString() } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;button onClick={() =&gt; { // 卸载组件的方法 ReactDOM.unmountComponentAtNode(window.root); }}&gt; kill &lt;/button&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); /* 方式 2：使用 bind 绑定函数 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { state = { time: new Date().toLocaleString() } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 点击事件 handleClick() { ReactDOM.unmountComponentAtNode(window.root); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;button onClick={this.handleClick.bind(this)}&gt;kill&lt;/button&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); 上面两种方式都有一个共同的问题，箭头函数的方式在每次执行 render 时都会创建新的箭头函数，而将函数作为原型方法，通过 bind 是为了修正方法内部的 this 指向，但是每次执行 render 时，bind 也会返回一个新的函数。/* 方式 3：在方式 2 的基础上提前生成函数 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { constructor(props) { super(props); this.state = { time: new Date().toLocaleString() }; this.fn = this.handleClick.bind(this); } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 点击事件 handleClick() { ReactDOM.unmountComponentAtNode(window.root); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;button onClick={this.fn}&gt;kill&lt;/button&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); 这样就解决了上面每次执行 render 就创建新函数的问题，但是这样的写法并不优雅，又产生了新的问题，所有的事件执行函数全都添加到了组件的实例上，而且代码会随着事件的增加而越来越乱。/* 方式 4：使用 ES7 语法将原型方法使用箭头函数 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { state = { time: new Date().toLocaleString() } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 点击事件 handleClick = () =&gt; { ReactDOM.unmountComponentAtNode(window.root); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;button onClick={this.handleClick}&gt;kill&lt;/button&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); 使用 ES7 的新语法，既解决了事件处理函数方法内部 this 指向问题，又解决了每次执行 render 创建新函数的问题，但需要依赖 @babel/plugin-proposal-class-properties 插件来解析。卸载组件后不能再更新状态还是上面的时钟案例，我们知道卸载一个组件应该使用 ReactDOM.unmountComponentAtNode 方法，参数一个组件，执行后会卸载这个组件内部所有的组件。当真正点击时钟组件的按钮去卸载组件，组件虽然成功卸载了，但是控制台报错了，报错信息如下：卸载组件后更新状态报错这个报错信息的意思是告诉我们在组件卸载后不能再通过 setState 更新状态，所以我们要在组件卸载之前先清空调用 setState 的定时器，代码修改如下：/* 完整的时钟组件 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建类组件 class Clock extends Component { state = { time: new Date().toLocaleString() } // 生命周期 componentDidMount() { // Component 组件有一个 setState 方法可以更新状态，每次调用组件会重新渲染 this.timer = setInterval(() =&gt; { this.setState({ time: new Date().toLocaleString() }); }, 1000); } // 组件将要卸载时清空定时器 componentWillUnmount() { clearInterval(this.timer); } // 点击事件 handleClick = () =&gt; { ReactDOM.unmountComponentAtNode(window.root); } // 渲染这个组件会调用 render 方法 render() { return ( &lt;div&gt; 时间：&lt;span&gt;{this.state.time}&lt;/span&gt; &lt;button onClick={this.handleClick}&gt;kill&lt;/button&gt; &lt;/div&gt; ) } } // 渲染组件 ReactDOM.render(&lt;Clock /&gt;, window.root); 在这个组件中用到了两个生命周期 “钩子”，componentDidMount 钩子在组件挂载后执行，类似于原生 JS 的 window.onload，componentWillUnmount 钩子在组件将要卸载之前执行，后面会涉及更多生命周期钩子，我们会在这个 React 基础篇系列文章中一一说明。类组件的参数传递/* 类组件传参第一种方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const p = { name: &#39;panda&#39;, age: 28 }; class Person extends Component { constructor(props) { super(props); } render() { return ( &lt;div&gt; &lt;p&gt;{this.props.name}&lt;/p&gt; &lt;p&gt;{this.props.age}&lt;/p&gt; &lt;/div&gt; ) } } // 分别传入想要的属性 ReactDOM.render(&lt;Person name={p.name} age={p.age} /&gt;, window.root); /* 类组件传参第二种方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; const p = { name: &#39;panda&#39;, age: 28 }; class Person extends Component { render() { const { name, age } = this.props; return ( &lt;div&gt; &lt;p&gt;{name}&lt;/p&gt; &lt;p&gt;{age}&lt;/p&gt; &lt;/div&gt; ) } } // 传入整个对象 ReactDOM.render(&lt;Person {...p} /&gt;, window.root); 上面两种传参方式第一种是将对象中希望传入的属性传递给组件，第二种方式是将整个对象通过解构的方式直接传递给组件，而组件中可以在 constructor 中的第一个参数接收 props，也可以直接使用 this.props，因为 React 在组件创建实例调用 super 之前就已经将 props 作为了实例属性。组件参数的类型校验在 React 组件传递参数时，是通过 props 取出传入的参数直接使用，传入的值类型并没有做任何的校验，这就可能造成传参时出现错误，在 React 生态中有一个第三方模块 prop-types 可以规定参数的类型，并对传入的参数进行校验，使用前需安装。$ npm install prop-types /* 使用 prop-types 校验传给组件的参数 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import PropTypes from &#39;prop-types&#39;; const p = { name: &#39;panda&#39;, age: 28, gender: &#39;男&#39;, hobby: [&#39;basketball&#39;, &#39;swim&#39;], pos: { x: 433, y: 822 }, salary: 5000 } class Person extends Component { // 定义默认属性，React 自带 static defaultProps = { name: &#39;shen&#39; } // 定义属性类型 static propTypes = { name: PropTypes.string.isRequired, // 类型必须为字符串，必填项 age: PropTypes.number, // 类型必须为数字 gender: PropTypes.oneOf([&#39;男&#39;, &#39;女&#39;]), // 性别只能为男或女 hobby: PropTypes.arrayOf(PropTypes.string), // 数组成员类型必须是字符串 pos: PropTypes.shape({ // 限制模型内部类型 x: PropTypes.number.isRequired, y: PropTypes.number.isRequired }), // 第一个参数为原对象，第二个参数为当前属性，第三个参数为类 salary(obj, key, P) { // 自行校验 if (obj[key] &lt; 3000) { throw new Error(&#39;工资太低&#39;); } } } render() { const { name, age } = this.props; return ( &lt;div&gt; &lt;p&gt;{name}&lt;/p&gt; &lt;p&gt;{age}&lt;/p&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Person {...p} /&gt;, window.root); 使用 prop-types 必须在类组件上添加一个静态属性 propTypes，在内部定义属性的类型，其中 isRequired 为必填项，如果没有传参会报错，在检测是会优先检测 React 的静态属性 defaultProps，即默认属性，如果 defaultProps 存在则视为已经有该参数。oneOf 方法参数为一个数组，传给组件对应的参数值必须是传给 oneOf 数组中的其中一项，否则会报错，arrayOf 方法用于限制数组成员的类型，shape 方法用于限属性值为对象的内部属性类型，参数为对象。在 propTypes 静态属性中以传入的属性名作为方法名，则该方法为自定义校验该属性的函数，参数的前三项为原对象，属性名和所属类，可以在函数内部自行实现校验逻辑。setState 更新状态在前面的时钟组件中已经简单的使用过 setState，在这里我们会对 setState 的用法通过一个计数器案例来做详细说明。/* 计数器案例 1 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }); this.setState({ num: this.state.num + 1 }); } render() { return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); 在上面的计数器中，当我们点击按钮时会执行 handleClick，而在 handleClick 内部调用了两次 setState 更新状态，但是我们启动项目后发现只有一次是有效的，这也说明了一个问题，setState 是异步执行的，最后一次执行的会覆盖前一次，其实在 setState 方法调用时支持传入一个回调函数，代码如下：/* 计数器案例 2 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } handleClick = () =&gt; { this.setState({ num: this.state.num + 1 }, () =&gt; { this.setState({ num: this.state.num + 1 }); }); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;Counter /&gt;, window.root); setState 传入的回调会在更新状态成功后执行，所以将代码修改后两次 setState 都生效了，render 执行了两次，这样的写法如果调用 setState 次数多了就形成了 “回调地狱”，setState 还有另一种用法如下：/* 计数器案例 3 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Counter extends Component { state = { num: 0 } handleClick = () =&gt; { this.setState(prevState =&gt; ({ num: prevState.num + 1 })); this.setState(prevState =&gt; ({ num: prevState.num + 1 })); } render() { console.log(&#39;render&#39;); return ( &lt;div&gt; {this.state.num} &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;Counter /&gt;, window.root); setState 方法可直接传入一个函数，函数的参数为上一次更新的 state，也就是 this.state，此时执行 setState 只更新状态，不重新渲染，当最后一次更新状态后统一渲染一次（也叫 setState 合并）。触发组件重新渲染的两种方式：props 发生变化，如调用 render 并传入新的属性值；调用 setState 重新设置状态。受控组件和非受控组件对于组件的分类除了可以按照组件的创建方式分为函数组件和类组件，还有另外一种分类方式，就是受控组件和非受控组件，简单来说 “受控” 和 “非受控” 就是指是否受到状态的控制，这种分类方式多用于表单元素，同时也指对于表单元素数据的不同处理方式。受控组件下面是一个受控组件的写法，输入框的初始值是通过 value 和 defaultValue 属性绑定的状态的值。/* 受控组件 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Control extends Component { state = { msg1: &#39;hello&#39;, msg2: &#39;world&#39; } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.msg1} /&gt; {/* 报错 */} &lt;input type=&quot;text&quot; defaultValue={this.state.msg2} /&gt; {/* 不报错 */} &lt;/div&gt; ) } } ReactDOM.render(&lt;Control /&gt;, window.root); 上面的代码中是两种绑定初始值的方式，使用 defaultValue 属性可以正常的将状态中的属性作为初始值绑定到页面的输入框内，但是随着输入的变化并没更新状态的作用，而使用 value 做了同样的绑定后，虽然页面正常显示初始值，但是控制台报错了，报错信息如下：受控组件赋初始值报错输入框的值可以通过输入改变，但受控组件要求状态的值要随着输入框内的值改变而更新，而报错信息告诉我们想要达到这样的目的必须要给表单元素绑定一个 onChange 事件，这个功能其实就是输入框与数据的双向绑定，修改后的实现如下：/* 受控组件 —— 修改后 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Control extends Component { state = { msg: &#39;hello&#39; } changeHandler = e =&gt; { this.setState({ msg: e.target.value }); } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.msg} onChange={this.changeHandler} /&gt; {this.state.msg} &lt;/div&gt; ) } } ReactDOM.render(&lt;Control /&gt;, window.root); 上面的代码中在 onChange 事件中调用了 setState 并更新了状态，但是如果有多个输入框，要保证 onChange 事件的复用，实现不同的输入框输入时 onChange 事件时更新不同的状态，实现如下：/* 受控组件 —— 多个输入框复用 onChange */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class Control extends Component { state = { msg1: &#39;hello&#39;, msg2: &#39;world&#39; } changeHandler = e =&gt; { const val = e.target.name; this.setState({ [val]: e.target.value }); } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;msg1&quot; value={this.state.msg1} onChange={this.changeHandler} /&gt; {this.state.msg1} &lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;msg2&quot; value={this.state.msg2} onChange={this.changeHandler} /&gt; {this.state.msg2} &lt;/div&gt; ) } } ReactDOM.render(&lt;Control /&gt;, window.root); 上面通过给 input 标签添加和状态的变量名相同的 name 属性，在触发 onChange 事件时用 name 属性作为更新状态数据的键值。受控组件的好处是，可以实时对输入框输入的值进行校验，并可以随着输入框的内容更新而更新状态，进而更新视图。非受控组件非受控组件与受控组件相比就是直接操作 DOM 来操作表单元素，直接操作 DOM 可以在 componentDidMount 生命周期内（DOM 完全挂载），写法如下：/* 非受控组件 —— 直接操作 DOM（不建议） */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class UnControl extends Component { componentDidMount() { const username = document.getElementById(&#39;username&#39;); username.value = 123; console.log(username.value); } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;UnControl /&gt;, window.root); 当然在 React 中并不会这么写，React 专门给我们提供了操作 DOM 属性 ref，用法如下：/* 非受控组件 —— ref 常用写法 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class UnControl extends Component { handleClick = () =&gt; { // 打印输入框的值 console.log(this.userDom.value); } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; ref={dom =&gt; this.userDom = dom} /&gt; &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;UnControl /&gt;, window.root); 使用 ref 属性的方式通常会在其中传入一个函数，这个函数的参数就是当前表单元素对应的 DOM，通常情况下会使用类组件的一个属性来存储这个 DOM，方便在其他的事件或生命周期 “钩子” 中使用。在 React 16.3 中推出了操作非受控组件的新的 API React.createRef 方法，返回值是一个对象，将这个对象绑定在表单元素的 ref 上，则可以通过这个对象的 current 属性获取这个表单元素的 DOM 元素。/* 非受控组件 —— React 16.3 新 API */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; class UnControl extends Component { userDom = React.createRef(); handleClick = () =&gt; { // 打印输入框的值 console.log(this.userDom.current.value); } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; ref={this.userDom} /&gt; &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;UnControl&gt;&lt;/UnControl&gt;, window.root); 我们其实把 React.createRef 的返回值存储为了类组件的一个属性，并将这个属性传入 ref，这样可以在其他的事件或生命周期 “钩子” 中操作 DOM，如果存在多个这样的表单元素，许多次调用 React.createRef，并分别将存储返回值的类组件属性传入各个表单的 ref 中。非受控组件的好处是，操作 DOM 方便，可以与更多基于 DOM 操作的第三方库结合。复合组件复合组件指的就是存在父子关系的组件嵌套，在 React 中有三种形式的父子组件嵌套：父组件中返回 JSX 中直接包含子组件；children 的方式引入子组件；render props 的方式引入子组件。第一种是直接将子组件在父组件中引入，并放在父组件 render 方法返回的 JSX 中。/* 复合组件 —— 第一种方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 父组件 class Parent extends Component { render() { return ( &lt;div&gt; 这是父组件 &lt;Child /&gt; &lt;/div&gt; ) } } // 子组件 class Child extends Component { render() { return ( &lt;div&gt;这是子组件&lt;/div&gt; ) } } ReactDOM.render(&lt;Parent /&gt;, window.root); 我们前面提到过组件可以通过单闭合或者双闭合的方式调用，第二种方式就是利用双闭合的调用方式，在父组件中引入子组件，把父组件中某些 JSX 放在双闭合的子组件标签中，作为参数传递给子组件，在子组件中通过 props 的 children 属性进行接收，并放入对应的位置。/* 复合组件 —— 第二种方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 父组件 class Parent extends Component { render() { return ( &lt;div&gt; 这是父组件 &lt;Child&gt; &lt;div&gt;父组件传递给子组件的 JSX&lt;/div&gt; &lt;/Child&gt; &lt;/div&gt; ) } } // 子组件 class Child extends Component { render() { return ( &lt;div&gt; 这是子组件 {this.props.children} &lt;/div&gt; ) } } ReactDOM.render(&lt;Parent /&gt;, window.root); 第三种方式是将子组件作为一个函数的返回值，而函数作为父组件的 props 参数传入父组件，父组件返回的 JSX 中调用函数返回子组件，又叫 render props。/* 复合组件 —— 第三种方式 */ import React, { Component } from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 父组件 class Parent extends Component { render() { return ( &lt;div&gt; 这是父组件 {this.props.buildChild()} &lt;/div&gt; ) } } // 子组件 class Child extends Component { render() { return ( &lt;div&gt; 这是子组件 {this.props.children} &lt;/div&gt; ) } } // render props 函数 const buildChildFn = () =&gt; { return &lt;Child /&gt; } ReactDOM.render(&lt;Parent buildChild={buildChildFn} /&gt;, window.root); 总结这是系列关于 React 基础的文章，本篇是关于 React 的一些基础知识，也包含了一些 React 16 版本的一些新增内容，比较适合不了解 React 框架的同学们从零开始入门，在后面会陆续更新关于复合组件参数传递、生命周期等内容。","tags":[{"name":"ES7","slug":"ES7","permalink":"https://www.overtaking.top/tags/ES7/"},{"name":"React","slug":"React","permalink":"https://www.overtaking.top/tags/React/"},{"name":"脚手架","slug":"脚手架","permalink":"https://www.overtaking.top/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"Koa2 洋葱模型 —— compose 串联中间件的四种实现","date":"2018-09-06T09:08:54.000Z","path":"20180906170854/","text":"前言Koa 是当下主流 Node.js 框架，以轻量见长，与相对传统的 Express 比较，它的中间件机制支持了异步，所以编码时可以使用 async/await，将异步代码用同步的方式编写，提高了可读性，使代码变得更优雅，上一篇文章 Node.js 进阶 —— Koa2 源码分析，也对 “洋葱模型” 和实现它的 compose 进行分析，由于个人觉得 compose 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 compose。洋葱模型案例如果你已经使用过 Koa，对 “洋葱模型” 这个词一定不陌生，它就是 Koa 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。const Koa = require(&quot;koa&quot;); const app = new Koa(); app.use(async (ctx, next) =&gt; { console.log(1); await next(); console.log(2); }); app.use(async (ctx, next) =&gt; { console.log(3); await next(); console.log(4); }); app.use(async (ctx, next) =&gt; { console.log(5); await next(); console.log(6); }); app.listen(3000); // 1 // 3 // 5 // 6 // 4 // 2 上面的写法我们按照官方推荐，使用了 async/await，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 next，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 Koa 源码中，这一功能是靠一个 compose 方法实现的，我们本文四种实现 compose 的方式中实现同步和异步，并附带对应的案例来验证。准备工作在真正创建 compose 方法之前应该先做些准备工作，比如创建一个 app 对象来顶替 Koa 创建出的实例对象，并添加 use 方法和管理中间件的数组 middlewares。/* 文件：app.js */ // 模拟 Koa 创建的实例 const app = { middlewares: [] }; // 创建 use 方法 app.use = function(fn) { app.middlewares.push(fn); }; // app.compose..... module.exports = app; 上面的模块中导出了 app 对象，并创建了存储中间件函数的 middlewares 和添加中间件的 use 方法，因为无论用哪种方式实现 compose 这些都是需要的，只是 compose 逻辑的不同，所以后面的代码块中会只写 compose 方法。Koa 中 compose 的实现方式首先介绍的是 Koa 源码中的实现方式，在 Koa 源码中其实是通过 koa-compose 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 compose 的原理，所以 ctx 参数就被去掉了，因为我们不会使用它，重点是 next 参数。同步的实现/* 文件：app.js */ app.compose = function() { // 递归函数 function dispatch(index) { // 如果所有中间件都执行完跳出 if (index === app.middlewares.length) return; // 取出第 index 个中间件并执行 const route = app.middlewares[index]; return route(() =&gt; dispatch(++index)); } // 取出第一个中间件函数执行 dispatch(0); } 上面是同步的实现，通过递归函数 dispatch 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 dispatch，传入的参数 +1，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 1 3 5 6 4 2 的情况执行，测试例子如下（同步上、异步下）。/* 文件：sync-test.js */ const app = require(&quot;./app&quot;); app.use(next =&gt; { console.log(1); next(); console.log(2); }); app.use(next =&gt; { console.log(3); next(); console.log(4); }); app.use(next =&gt; { console.log(5); next(); console.log(6); }); app.compose(); // 1 // 3 // 5 // 6 // 4 // 2 /* 文件：async-test.js */ const app = require(&quot;./app&quot;); // 异步函数 function fn() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(); console.log(&quot;hello&quot;); }, 3000); }); } app.use(async next =&gt; { console.log(1); await next(); console.log(2); }); app.use(async next =&gt; { console.log(3); await fn(); // 调用异步函数 await next(); console.log(4); }); app.use(async next =&gt; { console.log(5); await next(); console.log(6); }); app.compose(); 我们发现如果案例中按照 Koa 的推荐写法，即使用 async 函数，都会通过，但是在给 use 传参时可能会传入普通函数或 async 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 Koa 中 compose 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。注意：后面 compose 的其他实现方式中，都是使用 sync-test.js 和 async-test.js 验证，所以后面就不再重复了。升级为支持异步/* 文件：app.js */ app.compose = function() { // 递归函数 function dispatch(index) { // 如果所有中间件都执行完跳出，并返回一个 Promise if (index === app.middlewares.length) return Promise.resolve(); // 取出第 index 个中间件并执行 const route = app.middlewares[index]; // 执行后返回成功态的 Promise return Promise.resolve(route(() =&gt; dispatch(++index))); } // 取出第一个中间件函数执行 dispatch(0); } 我们知道 async 函数中 await 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 async-test.js 进行测试，发现结果为 1 3 hello(3s后) 5 6 4 2。Redux 旧版本 compose 的实现方式同步的实现/* 文件：app.js */ app.compose = function() { return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})(); } 上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 middlewares 中存储的三个中间件函数分别为 fn1、fn2 和 fn3，由于使用的是 reduceRight 方法，所以是逆序归并，第一次 a 代表初始值（空函数），b 代表 fn3，而执行 fn3 返回了一个函数，这个函数再作为下一次归并的 a，而 fn2 作为 b，依次类推，过程如下。// 第 1 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn3(() =&gt; {}); // 第 2 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn2(() =&gt; fn3(() =&gt; {})); // 第 3 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {}))); 由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 fn1，如果调用 next 则会执行 fn2，如果同样调用 next 则会执行 fn3，fn3 已经是最后一个中间件函数了，再次调 next 会执行我们最初传入的空函数，这也是为什么要将 reduceRight 的初始值设置成一个空函数，就是防止最后一个中间件调用 next 而报错。经过测试上面的代码不会出现顺序错乱的情况，但是在 compose 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 use 的中间件函数既可以是普通函数，又可以是 async 函数，这就要我们的 compose 完全支持异步。升级为支持异步/* 文件：app.js */ app.compose = function() { return Promise.resolve( app.middlewares.reduceRight( (a, b) =&gt; () =&gt; Promise.resolve(b(a)), () =&gt; Promise.resolve() )() ); } 参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 next 后又调用了 then），都处理成了 Promise，保证了 reduceRight 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 async 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 compose 就可以调用 then 方法执行后续逻辑。Redux 新版本 compose 的实现方式同步的实现/* 文件：app.js */ app.compose = function() { return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {}); } Redux 新版本中将 compose 的逻辑做了些改动，将原本的 reduceRight 换成 reduce，也就是说将逆序归并改为了正序，我们不一定和 Redux 源码完全相同，是根据相同的思路来实现串行中间件的需求。个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 fn1、fn2 和 fn3，由于 reduce 并没有传入初始值，所以此时 a 为 fn1，b 为 fn2。// 第 1 次 reduce 的返回值，下一次将作为 a arg =&gt; fn1(() =&gt; fn2(arg)); // 第 2 次 reduce 的返回值，下一次将作为 a arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg)); // 等价于... arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg))); // 执行最后返回的函数连接中间件，返回值等价于... fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {}))); 所以在调用 reduce 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 fn3，也就是第三个中间件，这样保证了在最后一个中间件调用 next 时不会报错。升级为支持异步下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。/* 文件：app.js */ app.compose = function() { return Promise.resolve( app.middlewares.reduce((a, b) =&gt; { return arg =&gt; a(() =&gt; Promise.resolve(b(arg))); })(() =&gt; Promise.resolve()) ); } 实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 compose 也返回 Promise。使用 async 函数实现由于是利用 async 函数实现的，所以默认就是用同步的编码方式去支持异步的，因为 async 函数会返回一个 Promise。/* 文件：app.js */ app.compose = function() { // 自执行 async 函数返回 Promise return (async function () { // 定义默认的 next，最后一个中间件内执行的 next let next = async () =&gt; Promise.resolve(); // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题 function createNext(middleware, oldNext) { return async () =&gt; { await middleware(oldNext); } } // 反向遍历中间件数组，先把 next 传给最后一个中间件函数 // 将新的中间件函数存入 next 变量 // 调用下一个中间件函数，将新生成的 next 传入 for (let i = app.middlewares.length - 1; i &gt;= 0; i--) { next = createNext(app.middlewares[i], next); } await next(); })(); } 上面代码中的 next 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 next，而数组 middlewares 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 createNext 作用是返回一个新的可以执行数组中最后一个中间件的 async 函数，并传入了初始的 next，这个返回的 async 函数作为新的 next，再取到倒数第二个中间件，调用 createNext，又返回了一个 async 函数，函数内依然是倒数第二个中间件的执行，传入的 next 就是上次新生成的 next，这样依次类推到第一个中间件。因此执行第一个中间件返回的 next 则会执行传入的上一个生成的 next 函数，就会执行第二个中间件，就会执行第二个中间件中的 next，就这样直到执行完最初定义的 next，通过案例的验证，执行结果与洋葱模型完全相同。至于异步的问题，每次执行的 next 都是 async 函数，执行后返回的都是 Promise，而最外层的自执行 async 函数返回的也是 Promise，也就是说 compose 最后返回的是 Promise，因此完全支持异步。这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。总结或许你看完这几种方式会觉得，还是 Koa 对于 compose 的实现方式最容易理解，你也可能和我一样在感慨 Redux 的两种实现方式和 async 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"async/await","slug":"async-await","permalink":"https://www.overtaking.top/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.overtaking.top/tags/Koa/"}]},{"title":"Node.js 进阶 —— Koa2 源码分析","date":"2018-09-02T06:18:19.000Z","path":"20180902141819/","text":"前言Koa 2.x 版本是当下最流行的 Node.js 框架，同时社区涌现出一大批围绕 Koa 2.x 的中间件以及基于 Koa 2.x 封装的企业级框架，如 egg.js，然而 Koa 本身的代码却非常精简，精简到所有文件的代码去掉注释后还不足 2000 行，本篇就围绕着这 2000 行不到的代码抽出核心逻辑进行分析，并压缩成一版只有 200 行不到的简易版 Koa。Koa 分析过程在下面的内容中，我们将对 Koa 所使用的功能由简入深的分析，首先会给出使用案例，然后根据使用方式，分析实现原理，最后对分析的功能进行封装，封装过程会从零开始并一步一步完善，代码也是从少到多，会完整的看到一个简版 Koa 诞生的过程，在此之前我们打开 Koa 源码地址。Koa 文件目录通过上面对 Koa 源码目录的截图，发现只有 4 个核心文件，为了方便理解，封装简版 Koa 的文件目录结构也将严格与源码同步。搭建基本服务在引入 Koa 时我们需要创建一个 Koa 的实例，而启动服务是通过 listen 监听一个端口号实现的，代码如下。const Koa = require(&#39;koa&#39;); const app = new Koa(); app.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 通过使用我们可以分析出 Koa 导出的应该是一个类，或者构造函数，鉴于 Koa 诞生的时间以及基于 node v7.6.0 以上版本的情况来分析，正是 ES6 开始流行的时候，所以推测 Koa 导出的应该是一个类，打开源码一看，果然如此，所以我们也通过 class 的方式来实现。而从启动服务的方式上看，app.listen 的调用方式与原生 http 模块提供的 server.listen 几乎相同，我们分析，listen 方法应该是对原生 http 模块的一个封装，启动服务的本质还是靠 http 模块来实现的。/* 文件路径：~koa/application.js */ const http = require(&#39;http&#39;); class Koa { handleRequest(req, res) { // 请求回调 } listen(...args) { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); } } module.exports = Koa; 上面的代码初步实现了我们上面分析出的需求，为了防止代码冗余，我们将创建服务的回调抽取成一个 handleRequest 的实例方法，内部的逻辑在后面完善，现在可以创建这个 Koa 类的实例，通过调用实例的 listen 方法启动一个服务器。上下文对象 ctx 的封装基本使用Koa 还有一个很重要的特性，就是它的 ctx 上下文对象，我们可以调用 ctx 的 request 和 response 属性获取原 req 和 res 的属性和方法，也在 ctx 上增加了一些原生没有的属性和方法，总之 ctx 给我们要操作的属性和方法提供了多种调用方式，使用案例如下。const Koa = require(&#39;koa&#39;); const app = new Koa(); app.use((ctx, next) =&gt; { // 原生的 req 对象的 url 属性 console.log(ctx.req.url); console.log(ctx.request.req.url); console.log(ctx.response.req.url); // Koa 扩展的 url console.log(ctx.url); console.log(ctx.request.req.url); // 设置状态码和响应内容 ctx.response.status = 200; ctx.body = &#39;Hello World&#39;; }); app.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 创建 ctx 的引用关系从上面我们可以看出，ctx 为 use 方法的第一个参数，request 和 response 是 ctx 新增的，而通过这两个属性又都可以获取原生的 req 和 res 属性，ctx 本身也可以获取到原生的 req 和 res，我们可以分析出，ctx 是对这些属性做了一个集成，或者说特殊处理。源码的文件目录中正好有与 request、response 名字相对应的文件，并且还有 context 名字的文件，我们其实可以分析出这三个文件就是用于封装 ctx 上下文对象使用的，而封装 ctx 中也会用到 req 和 res，所以核心逻辑应该在 handleRequest 中实现。在使用案例中 ctx 是作为 use 方法中回调函数的参数，所以我们分析应该有一个数组统一管理调用 use 后传入的函数，Koa 应该有一个属性，值为数组，用来存储这些函数，下面是实现代码。/* 文件路径：~koa/application.js */ const http = require(&#39;http&#39;); // ************************** 以下为新增代码 ************************** const context = require(&#39;./context&#39;); const request = require(&#39;./request&#39;); const response = require(&#39;./response&#39;); // ************************** 以上为新增代码 ************************** class Koa { // ************************** 以下为新增代码 ************************** contructor() { // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); } use(fn) { // 将传给 use 的函数存入数组中 this.middlewares.push(fn); } createContext(req, res) { // 或取定义的上下文 const ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; } // ************************** 以上为新增代码 ************************** handleRequest(req, res) { // 创建 ctx 上下文对象 const ctx = this.createContext(req, res); } listen(...args) { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); } } module.exports = Koa; 首先，给实例创建了三个属性 context、request 和 response 分别继承了 context.js、request.js 和 response.js 导出的对象，之所以这么做而不是直接赋值是防止操作实例属性时 “污染” 原对象，而获取原模块导出对象的属性可以通过原型链进行查找，并不影响取值。其次，给实例挂载了 middlewares 属性，值为数组，为了存储 use 方法调用时传入的函数，在 handleRequest 把创建 ctx 属性及引用的过程单独抽取成了 createContext 方法，并在 handleRequest 中调用，返回值为创建好的 ctx 对象，而在 createContext 中我们根据案例中的规则构建了 ctx 的属性相关的各种引用关系。实现 request 取值上面构建的属性中，所有通过访问原生 req 或 res 的属性都能获取到，反之则是 undefined，这就需要我们去构建 request.js。/* 文件路径：~koa/request.js */ const url = require(&#39;url&#39;); // 给 url 和 path 添加 getter const request = { get url() { return this.req.url; }, get path() { return url.parse(this.req.url).pathname; } }; module.exports = request; 上面我们只构造了两个属性 url 和 path，我们知道 url 是原生所自带的属性，我们在使用 ctx.request.url 获取是通过 request 对象设置的 getter，将 ctx.request.req.url 的值返回了。path 是原生 req 所没有的属性，但却是通过原生 req 的 url 属性和 url 模块共同构建出来的，所以我们同样用了给 request 对象设置 getter 的方式获取 req 的 url 属性，并使用 url 模块将转换对象中的 pathname 返回，此时就可以通过 ctx.request.path 来获取访问路径，至于源码中我们没有处理的 req 属性都是通过这样的方式建立的引用关系。实现 response 的取值和赋值Koa 中 response 对象的真正作用是给客户端进行响应，使用时是通过访问属性获取，并通过重新赋值实现响应，但是现在 response 获取的属性都是 undefined，我们这里先不管响应给浏览器的问题，首先要让 response 下的某个属性有值才行，下面我们来实现 response.js。/* 文件路径：~koa/response.js */ // 给 body 和 status 添加 getter 和 setter const response = { get body() { return this._body; }, set body(val) { // 只要给 body 赋值就代表响应成功 this.status = 200; this._body = val; }, get status() { return this.res.statusCode; }, set status(val) { this.res.statusCode = val; } }; module.exports = response; 这里选择了 Koa 在使用时，response 对象上比较重要的两个属性进行处理，因为这两个属性是服务器响应客户端所必须的，并模仿了 request.js 的方式给 body 和 status 设置了 getter，不同的是响应浏览器所做的其实是赋值操作，所以又给这两个属性添加了 setter，对于 status 来说，直接操作原生 res 对象的 statusCode 属性即可，因为同为赋值操作。还有一点，响应是通过给 body 赋值实现，我们认为只要触发了 body 的 setter 就成功响应，所以在 body 的 getter 中将响应状态码设置为 200，至于 body 赋值是如何实现响应的，放在后面再说。ctx 代理 request、response 的属性上面实现了通过 request 和 response 对属性的操作，Koa 虽然给我们提供了多样的属性操作方式，但由于我们程序员们都很 “懒”，几乎没有人会在开发的时候愿意增加获取某个属性值的路径长度，大部分情况都是通过 ctx 直接操作 request 和 response 上的属性，这就是我们现在的问题所在，这些属性通过 ctx 访问不到。我们需要给 ctx 对象做一个代理，让 ctx 可以访问到 request 和 response 上的属性，这个场景何曾相识，不正是 Vue2 创建实例时，将传入参数对象 options 的 data 属性代理给实例本身的场景吗，既然如此，我们也通过相似的方式实现，还记得上面引入的 context 模块作为实例的 context 属性所继承的对象，而剩下的最后一个核心文件 context.js 正是用来做这件事的，代码如下。/* 文件路径：~koa/context.js */ const proto = {}; // 将传入对象属性代理给 ctx function defineGetter(property, key) { proto.__defineGetter__(key, function () { return this[property][key]; }); } // 设置 ctx 值时直接操作传入对象的属性 function defineSetter(property, key) { proto.__defineSetter__(key, function (val) { this[property][key] = val; }); } // 将 request 的 url 和 path 代理给 ctx defineGetter(&#39;request&#39;, &#39;url&#39;); defineGetter(&#39;request&#39;, &#39;path&#39;); // 将 response 的 body 和 status 代理给 ctx defineGetter(&#39;response&#39;, &#39;body&#39;); defineSetter(&#39;response&#39;, &#39;body&#39;); defineGetter(&#39;response&#39;, &#39;status&#39;); defineSetter(&#39;response&#39;, &#39;status&#39;); module.exports = proto; 在 Vue 中是使用 Object.defineProperty 来时实现的代理，而在 Koa 源码中借助了 delegate 第三方模块来实现的，并在添加代理时链式调用了 delegate 封装的方法，我们并没有直接使用 delegate 模块，而是将 delegate 内部的核心逻辑抽取出来在 context.js 中直接编写，这样方便大家理解原理，也可以清楚的知道是如何实现代理的。我们封装了两个方法 defineGetter 和 defineSetter 分别来实现取值和设置值时，将传入的属性（第二个参数）代理给传入的对象（第一个参数），函数内是通过 Object.prototype.__defineGetter__ 和 Object.prototype.__defineSetter__ 实现的。洋葱模型 —— 实现中间件的串行现在已经实现了 ctx 上下文对象的创建，但是会发现我们封装 ctx 之前所写的案例 use 回调中的代码并不能执行，也不会报错，根本原因是 use 方法内传入的函数没有调用，在使用 Koa 的过程中会发现，我们往往使用多个 use，并且传入 use 的回调函数除了 ctx 还有第二个参数 next，而这个 next 也是一个函数，调用 next 则执行下一个 use 中的回调函数，否则就会 “卡住”，这种执行机制被称为 “洋葱模型”，而这些被执行的函数被称为 “中间件”，下面我们就来分析这个 “洋葱模型” 并实现中间件的串行。洋葱模型执行过程洋葱模型分析下面来看看表述洋葱模型的一个经典案例，结果似乎让人匪夷所思，一时很难想到原因，不着急先看了再说。const Koa = require(&#39;koa&#39;); const app = new Koa(); app.use((ctx, next) =&gt; { console.log(1); next(); console.log(2); }); app.use((ctx, next) =&gt; { console.log(3); next(); console.log(4); }); app.use((ctx, next) =&gt; { console.log(5); next(); console.log(6); }); app.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); // 1 // 3 // 5 // 6 // 4 // 2 根据上面的执行特性我们不妨来分析以下，我们知道 use 方法执行时其实是把传入的回调函数放入了实例的 middlewares 数组中，而执行结果打印了 1 说明第一个回调函数被执行了，接着又打印了 2 说明第二个回调函数被执行了，根据上面的代码我们可以大胆的猜想，第一个回调函数调用的 next 肯定是一个函数，可能就是下一个回调函数，或者是 next 函数中执行了下一个回调函数，这样根据函数调用栈先进后出的原则，会在 next 执行完毕，即出栈后，继续执行上一个回调函数的代码。支持异步的中间件串行在实现中间件串行之前需要补充一点，中间件函数内调用 next 时，前面的代码出现异步，则会继续向下执行，等到异步执行结束后要执行的代码插入到同步代码中，这会导致执行顺序错乱，所以在官方推荐中告诉我们任何遇到异步的操作前都需要使用 await 进行等待（包括 next，因为下一个中间件中可能包含异步操作），这也间接的说明了传入 use 的回调函数只要有异步代码需要 await，所以应该是 async 函数，而了解 ES7 特性 async/await 的我们来说，一定能分析出 next 返回的应该是一个 Promise 实例，下面是我们在之前 application.js 基础上的实现。/* 文件路径：~koa/application.js */ const http = require(&#39;http&#39;); const context = require(&#39;./context&#39;); const request = require(&#39;./request&#39;); const response = require(&#39;./response&#39;); class Koa { contructor() { // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); } use(fn) { // 将传给 use 的函数存入数组中 this.middlewares.push(fn); } createContext(req, res) { // 或取定义的上下文 const ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; } // ************************** 以下为新增代码 ************************** compose(ctx, middles) { // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) { // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); } return dispatch(0); // 默认执行一次 } // ************************** 以上为新增代码 ************************** handleRequest(req, res) { // 创建 ctx 上下文对象 const ctx = this.createContext(req, res); // ************************** 以下为新增代码 ************************** // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares); // ************************** 以上为新增代码 ************************** } listen(...args) { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); } } module.exports = Koa; 仔细想想我们其实在利用循环执行每一个 middlewares 中的函数，而且需要把下一个中间件函数的执行作为函数体的代码包装一层成为新的函数，并作为参数 next 传入，那么在上一个中间件函数内部调用 next 就相当于先执行了下一个中间件函数，而下一个中间件函数内部调用 next，又先执行了下一个的下一个中间件函数，依次类推。直到执行到最后一个中间件函数，调用了 next，但是 middlewares 中已经没有下一个中间件函数了，这也是为什么我们要给下一个中间件函数外包了一层函数而不是直接将中间件函数传入的原因之一（另一个原因是解决传参问题，因为在执行时还要传入下一个中间件函数），但是防止递归 “死循环”，要配合一个终止条件，即指向 middlewares 索引的变量等于了 middlewares 的长度，最后只是相当于执行了一个只有一条判断语句的函数就 return 的函数，而并没有报错。在这整个过程中如果有任意一个 next 没有被调用，就不会向下执行其他的中间件函数，这样就 “卡住了”，完全符合 Koa 中间件的执行规则，而 await 过后也就是下一个中间件优先执行完成，则会继续执行当前中间件 next 调用下面的代码，这也就是 1、3、5、6、4、2 的由来。为了实现所描述的执行过程，将所有中间件串行的逻辑抽出了一个 compose 方法，但是我们没有使用普通的循环，而是使用递归实现的，首先在 compose 创建 dispatch 递归函数，参数为当前数组函数的索引，初始值为 0，函数逻辑是先取出第一个函数执行，并传入一个回调函数参数，回调函数参数中递归 dispatch，参数 +1，这样就会将整个中间件串行起来了。但是上面的串行也只是同步串行，如果某个中间件内部需要等待异步，则调用的 next 函数必须返回一个 Promise 实例，有些中间件没有执行异步，则不需要 async 函数，也不会返回 Promise，而 Koa 规定只要遇到 next 就需要等待，则将取出每一个中间件函数执行后的结果使用 Promise.resolve 强行包装成一个成功态的 Promise，就对异步进行了兼容。我们最后也希望 compose 返回一个 Promise 方便执行一些只有在中间件都执行后才会执行的逻辑，每次串行最后执行的都是一个只有一条判断逻辑就 return 了的函数（包含一个中间件也没有的情况），此时 compose 返回了 undefined，无法调用 then 方法，为了兼容这种情况也强行的使用相同的 “招数”，在判断条件的 return 关键字后面加上了 Promise.resolve()，直接返回了一个成功态的 Promise。注意：官方只是推荐我们在调用 next 的时候使用 await 等待，即使执行的 next 真的存在异步，也不是非 await 不可，我们完全可以使用 return 来代替 await，唯一的区别就是 next 调用后，下面的代码不会再执行了，类比 “洋葱模型”，形象地说就是 “下去了就上不来了”，这个完全可以根据我们的使用需要而定，同一个中间件中，如果 next 后面不再有任何逻辑需要执行，就可以这样去做。实现真正的响应在对 ctx 实现属性代理后，我们通过 ctx.body 重新赋值其实只是改变了 response.js 导出对象的 _body 属性，而并没有实现真正的响应，看下面这个 Koa 的例子。const Koa = require(&#39;koa&#39;); const fs = require(&#39;fs&#39;); const app = new Koa(); app.use(async (ctx, next) =&gt; { ctx.body = &#39;hello&#39;; await next(); }); app.use(async (ctx, next) =&gt; { ctx.body = fs.createReadStream(&#39;1.txt&#39;); ctx.body = await new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(&#39;panda&#39;), 3000); }); }); app.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 其实最后响应给客户端的值是 panda，正常在最后一个中间件执行后，由于异步定时器的代码没有执行完，ctx.body 最后的值应该是 1.txt 的可读流，这与客户端接收到的值相违背，通过这个猜想上的差异我们应该知道，compose 在串行执行中间件后为什么要返回一个 Promise 了，因为最后执行的只有判断语句的函数会等待我们例子中最后一个 use 传入的中间件函数执行完毕调用，也就是说在执行 compose 返回值的 then 时，ctx.body 的值已经是 panda 了。/* 文件路径：~koa/application.js */ const http = require(&#39;http&#39;); // ************************** 以下为新增代码 ************************** const Stream = require(&#39;stream&#39;); // ************************** 以上为新增代码 ************************** const context = require(&#39;./context&#39;); const request = require(&#39;./request&#39;); const response = require(&#39;./response&#39;); class Koa { contructor() { // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); } use(fn) { // 将传给 use 的函数存入数组中 this.middlewares.push(fn); } createContext(req, res) { // 或取定义的上下文 const ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; } compose(ctx, middles) { // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) { // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); } return dispatch(0); // 默认执行一次 } handleRequest(req, res) { // 创建 ctx 上下文对象 const ctx = this.createContext(req, res); // ************************** 以下为修改代码 ************************** // 设置默认状态码（Koa 规定默认状态码为 404），必须在调用中间件之前 ctx.status = 404; // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares).then(() =&gt; { // 获取最后 body 的值 const body = ctx.body; // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器 if (Buffer.isBuffer(body) || typeof body === &#39;string&#39;) { // 处理 Buffer 类型的数据 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); res.end(body); } else if (typeof body === &#39;object&#39;) { // 处理对象类型 res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); res.end(JSON.stringify(body)); } else if (body instanceof Stream) { // 处理流类型的数据 body.pipe(res); } else { res.end(&#39;Not Found&#39;); } }); // ************************** 以上为修改代码 ************************** } listen(...args) { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); } } module.exports = Koa; 处理 response 时，在 body 的 setter 中将状态码设置为了 200，就是说需要设置 ctx.body 去触发 setter 让响应成功，如果没有给 ctx.body 设置任何值，默认应该是无响应的，在官方文档也有默认状态码为 404 的明确说明，所以在 handleRequest 把状态码设置为了 404，但必须在 compose 执行之前才叫默认状态码，因为中间件中可能会操作 ctx.body，重新设置状态码。在 comose 的 then 中，也就是在所有中间件执行后，我们取出 ctx.body 的值，即为最后生效的响应值，对该值进行了数据类型验证，如 Buffer、字符串、对象和流，并分别用不同的方式处理了响应，但本质都是调用原生 res 对象的 end 方法。中间件错误处理在上面的逻辑当中我们实现了很多 Koa 的核心逻辑，但是只考虑了顺利执行的情况，并没有考虑如果中间件中代码执行出现错误的问题，如下面案例。const Koa = require(&#39;koa&#39;); const app = new Koa(); app.use((ctx, next) =&gt; { // 抛出异常 throw new Error(&#39;Error&#39;); }); // 添加 error 监听 app.on(&#39;error&#39;, err =&gt; { console.log(err); }); app.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 我们之所以让 compose 方法在执行所有中间件后返回一个 Promise 还有一个更重要的意义，因为在 Promise 链式调用中，只要其中任何一个环节出现代码执行错误或抛出异常，都会直接执行出现错误的 then 方法中错误的回调或者最后的 catch 方法，对于 Koa 中间件的串行而言，最后一个 then 调用 catch 方法就是 compose 的返回值调用 then 后继续调用的 catch，catch 内可以捕获到任意一个中间件执行时出现的错误。/* 文件路径：~koa/application.js */ const http = require(&#39;http&#39;); const Stream = require(&#39;stream&#39;); // ************************** 以下为新增代码 ************************** const EventEmitter = require(&#39;events&#39;); const httpServer = require(&#39;_http_server&#39;); // ************************** 以上为新增代码 ************************** const context = require(&#39;./context&#39;); const request = require(&#39;./request&#39;); const response = require(&#39;./response&#39;); // ************************** 以下为修改代码 ************************** // 继承 EventEmitter 后可以用创建的实例 app 添加 error 监听，可以通过 emit 触发监听 class Koa extends EventEmitter { contructor() { supper(); // ************************** 以上为修改代码 ************************** // 存储中间件 this.middlewares = []; // 为了防止通过 this 修改属性而导致影响原引入文件的导出对象，做一个继承 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); } use(fn) { // 将传给 use 的函数存入数组中 this.middlewares.push(fn); } createContext(req, res) { // 或取定义的上下文 const ctx = this.context; // 增加 request 和 response ctx.request = this.request; ctx.response = this.response; // 让 ctx、request、response 都具有原生的 req 和 res ctx.req = ctx.request.req = ctx.response.req = req; ctx.res = ctx.response.res = ctx.request.res = res; // 返回上下文对象 return ctx; } compose(ctx, middles) { // 创建一个递归函数，参数为存储中间件的索引，从 0 开始 function dispatch(index) { // 在所有中间件执行之后给 compose 返回一个 Promise（兼容一个中间件都没写的情况） if (index === middles.length) return Promise.resolve(); // 取出第 index 个中间件函数 const route = middles[index]; // 为了兼容中间件传入的函数不是 async，一定要包装成一个 Promise return Promise.resolve(route(ctx, () =&gt; dispatch(++index))); } return dispatch(0); // 默认执行一次 } handleRequest(req, res) { // 创建 ctx 上下文对象 const ctx = this.createContext(req, res); // 设置默认状态码（Koa 规定默认状态码为 404），必须在调用中间件之前 ctx.status = 404; // 执行 compose 将中间件组合在一起 this.compose(ctx, this.middlewares).then(() =&gt; { // 获取最后 body 的值 const body = ctx.body; // 检测 ctx.body 的类型，并使用对应的方式将值响应给浏览器 if (Buffer.isBuffer(body) || typeof body === &#39;string&#39;) { // 处理 Buffer 类型的数据 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); res.end(body); } else if (typeof body === &#39;object&#39;) { // 处理对象类型 res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); res.end(JSON.stringify(body)); } else if (body instanceof Stream) { // 处理流类型的数据 body.pipe(res); } else { res.end(&#39;Not Found&#39;); } // ************************** 以下为修改代码 ************************** }).catch(err =&gt; { // 执行 error 事件 this.emit(&#39;error&#39;, err); // 设置 500 状态码 ctx.status = 500; // 返回状态码对应的信息响应浏览器 res.end(httpServer.STATUS_CODES[ctx.status]); }); // ************************** 以上为修改代码 ************************** } listen(...args) { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 启动服务 server.listen(...args); } } module.exports = Koa; 在使用的案例当中，使用 app（即 Koa 创建的实例）监听了一个 error 事件，当中间件执行错误时会触发该监听的回调，这让我们想起了 Node.js 中一个重要的核心模块 events，这个模块帮我们提供了一个事件机制，通过 on 方法添加监听，通过 emit 触发监听，所以我们引入了 events，并让 Koa 类继承了 events 导入的 EventEmitter 类，此时 Koa 的实例就可以使用 EventEmitter 原型对象上的 on 和 emit 方法。在 compose 执行后调用的 catch 中，通过实例调用了 emit，并传入了事件类型 error 和错误对象，这样就是实现了中间件的错误监听，只要中间件执行出错，就会执行案例中错误监听的回调。让引入的 Koa 直接指向 application.js在上面我们实现了 Koa 大部分常用功能的核心逻辑，但还有一点美中不足，就是我们引入自己的简易版 Koa 时，默认会查找 koa 路径下的 index.js，想要执行我们的 Koa 必须要使用路径找到 application.js，代码如下。/* 现在的引入方式 */ const Koa = require(&#39;./koa/application&#39;); /* 希望的引入方式 */ const Koa = require(&#39;./koa&#39;); 我们更希望像直接引入指定 koa 文件夹，就可以找到 application.js 文件并执行，这就需要我们在 koa 文件夹创建 package.json 文件，并在动一点小小的 “手脚” 如下。/* 文件路径：~koa/package.js */ { // ... &quot;main&quot;: &quot;./application.js&quot;, // ... } Koa 原理图在文章最后一节送给大家一张 Koa 执行的原理图，这张图片是准备写这篇文章时在 Google 上发现的，把 Koa 的整个流程表达的非常清楚，所以这里拿来帮助大家理解 Koa 框架的原理和执行过程。Koa 原理图之所以没有在文章开篇放上这张图是因为觉得在完全没有了解过 Koa 的原理之前，可能有一部分小伙伴看这张图会懵，会打消学习的积极性，因为本篇的目的就是带着大家从零到有的，一步一步实现简易版 Koa，梳理 Koa 的核心逻辑，如果你已经看到了这里，是不是觉得这张图出现的不早不晚，刚刚好。总结最后还是在这里做一个总结，在 Koa 中主要的部分有 listen 创建服务器、封装上下文对象 ctx 并代理属性、use 方法添加中间件、compose 串行执行中间、让 Koa 继承 EventEmitter 实现错误监听，而我个人觉得最重要的就是 compose，它是一个事件串行机制，也是实现 “洋葱模型” 的核心，如今 compose 已经不再只是一个方法名，而是函数式编程的一个重要的特性，用于将多个程序串行在一起，或同步，或异步，在 Koa 中自不必多说，因为大家已经见识过了，compose 在 Redux 中也起着串联中间件的作用，如串联redux-saga, promise、redux-thunk、logger 等中间件，在 Webpack 源码依赖的核心模块 tapable 中也有所应用，在我们的学习过程中，这样优秀的编程思想是应该重点吸收的。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"async/await","slug":"async-await","permalink":"https://www.overtaking.top/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.overtaking.top/tags/Koa/"}]},{"title":"Express 中间件 body-parser 原理分析","date":"2018-08-27T18:21:47.000Z","path":"20180828022147/","text":"前言Express 是基于 Node.js 平台的 Web 框架，应用广泛，在 Express 社区中有着大量的开发者通过 Express 中间件的特性，开发了各种功能的中间件，用来处理某些响应以及给请求对象 req、响应对象 res 添加属性或方法，我们接下来就通过分析常用的 body-parser 中间件的原理来了解如何开发 Express 中间件。body-parser 的基本使用想分析一个中间件的原理，首先应该从使用入手，在足够了解用法的基础上去分析，现在搭建一个简易的 Express 服务，并使用 body-parser 中间件，使用前需安装。$ npm install express body-parser 使用 body-parser 代码如下：/* 使用 body-parser 中间件 */ const express = require(&#39;express&#39;); const bodyParser = require(&#39;body-parser&#39;); // 创建服务 const app = express(); // 使用 body-parser 中间 app.use(bodyParser.urlencoded({ extended: true })); app.use(bodyParser.json()); // 创建路由 app.post(&#39;/login&#39;, function (req, res) { console.log(req.body); res.send(req.body); }); // 监听服务 app.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 启动上面的服务器，通过 postman 工具分别通过表单提交和 json 的格式访问 http://localhost:3000/login，查看服务器控制后台的打印结果和 postman 的返回结果。body-parser 的实现原理分析从上面的使用案例我们可以分析出一下几点：首先，body-parser 中间件的作用是给 req 添加属性 body，值为对象，以键值对的形式存储请求体中的参数；其次，body-parser 只处理 POST 请求；最后，body-parser 模块导出一个对象，上面有两个方法 urlencoded 和 json，分别处理表单提交和 json 格式的请求体参数。分析 urlencoded、json 公共逻辑在实现之前我们先分析一下两个方法：首先都需要先读取请求体中的内容，数据传输的类型为 Buffer，转换成字符串后会根据提交方式不同而导致请求体中的内容是查询字符串或者是 json 字符串的区别；当解析失败时都需要做错误处理；当不是 POST 请求时都需要向下执行其他中间件；而最核心的事就是把请求体中的数据转换成对象挂在 req.body 上。使用的转换数据的方法不同是唯一的区别，能区分两者的就是请求头 Content-Type 的值，因此我们可以把所有的公共逻辑抽取出来用一个 acceptPost 函数来执行。模块的创建我们下面创建自己的 body-parser 模块，防止命名冲突，模块命名为 my-body-parser，处理参数需要使用 querystring 和 qs 两个模块，其中 qs 是第三方模块，使用前需安装。$ npm install qs qs 和 querystring 作用基本相同，就是处理查询字符串格式的参数，但是也有一点小小的区别，querystring 只能处理一级，而 qs 可以处理多级。/* 文件：my-body-parser.js */ const querystring = require(&#39;querystring&#39;); const qs = require(&#39;qs&#39;); // urlencoded 和 json 公共逻辑 function acceptPost() { // ... } // 处理表单提交的方法 function urlencoded() { // ... } // 处理请求体 json 的方法 function json() { // ... } // 导出对象 module.exports = { urlencoded, json }; 在把基本模块搭建好后，我们下面就实现 body-parser 模块内的公共逻辑函数 acceptPost。acceptPost 的实现为了兼容 urlencoded 方法和 json 方法设计了两个参数，一个是区分当前调用方法的 type，一个是针对 urlencoded 方法的 options。/* acceptPost 的实现 */ // urlencoded 方法和 json 方法的公共逻辑函数 function acceptPost(type, options) { // 返回一个中间件函数 return function (req, res, next) { // 获取请求头 const contentType = req.headers[&#39;content-type&#39;]; // 判断如果不符合两种提交的请求头直接交给其他中间件处理 if ( contentType === &#39;application/x-www-form-urlencoded&#39; || contentType === &#39;application/json&#39; ) { // 存储数据的数组 const buffers = []; req.on(&#39;data&#39;, function (data) { // 接收数据并存入数组中 buffers.push(data); }); req.on(&#39;end&#39;, function () { // 组合数据并转换成字符串 const result = Buffer.concat(buffers).toString(); // 处理数据并挂载 req.body 属性上 // 如果是表单提交则使用 querystring 或 qs，否则使用 JSON.parse if (type === &#39;form&#39;) { // 如果配置 extended 值为 true 使用 qs，否则使用 querystring req.body = options.extended ? qs.parse(result) : querystring.parse(result); } else if (type === &#39;json&#39;) { req.body = JSON.parse(result); } next(); // 向下执行 }); // 错误处理 req.on(&#39;err&#39;, function (err) { next(err); }); } else { next(); } } } urlencoded 和 json 方法的实现// 处理表单提交的方法 function urlencoded(options) { // 定义 type 值 const type = &#39;form&#39;; return acceptPost(type, options) } // 处理请求体 json 的方法 function json() { // 定义 type 值 const type = &#39;json&#39;; return acceptPost(type); } 当我们把所有的公共逻辑都抽取出去后发现，urlencoded 和 json 方法内部只需要定义不同的类型就可以执行自己的中间件逻辑。总结上面分析 body-parse 中间件的原理的目的在于理解 Express 中间件开发的模式，在此总结一下，Express 中间件返回的是一个函数，形参为 req、res 和 next，当功能无法处理某些情况时需要调用 next，当出现错误时调用 next 并传递错误，则交给 Express 内置的错误处理中间件，在中间件内部代码涉及异步操作时，须在异步完成的回调当中调用 next，这是不如 Koa 方便的一点，同时也是两者的区别，因为 Koa 中已经大量使用 async/await，在执行异步代码时可以等待。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"中间件","slug":"中间件","permalink":"https://www.overtaking.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Express","slug":"Express","permalink":"https://www.overtaking.top/tags/Express/"}]},{"title":"Express 源码分析及简易封装","date":"2018-08-25T08:21:29.000Z","path":"20180825162129/","text":"前言Express 是 Node.js 的 Web 框架，与 Koa 的轻量相比，功能要更多一些，依然是当前使用最广泛的 Node.js 框架，本篇参考 Express 的核心逻辑来实现一个简易版，Express 源码较多，逻辑复杂，看一周可能也看不完，如果你已经使用过 Express，又想快速的了解 Express 常用功能的原理，那读这篇文章算往前迈一小步，也可以为读真正的源码做铺垫，本篇内容每部分代码较多，因为按照 Express 的封装思想很难拆分，所以建议以星号标注区域为主其他代码为辅。搭建基本服务下面我们使用 Express 来搭建一个最基本的服务，只有三行代码，只能访问不能响应。/* 三行代码搭建的最基本服务 */ // 引入 Express const express = require(&#39;express&#39;); // 创建服务 const app = express(); // 监听服务 app.listen(3000); 从上面我们可以分析出，express 模块给我们提供了一个函数，调用后返回了一个函数或对象给上面有 listen 方法给我们创建了一个 http 服务，我们就按照官方的设计返回一个函数 app。/* 文件：express.js */ const http = require(&#39;http&#39;); function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) {} // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; 我们创建一个模块 express.js，导出了 createApplication 函数并返回在内部创建 app 函数，createApplication 等于我们引入 Express 模块时所调用的那个函数，返回值就是我们接收的 app，在 createApplication 返回的 app 函数上挂载了静态方法 listen，用于帮助我们启动 http 服务。createApplication 函数内我们使用引入的 http 模块创建了服务，并调用了创建服务 server 的 listen 方法，将 app.listen 的所有参数传递进去，这就等于做了一层封装，将真正创建服务器的过程都包在了 app.listen 内部，我们自己封装的 Express 模块只有在调用导出函数并调用 app.listen 时才会真正的创建服务器和启动服务器，相当于将原生的两步合二为一。路由的实现在 Express 框架中有多个路由方法，方法名分别对应不同的请求方式，可以帮助我们匹配路径和请求，在完全匹配时执行路由内部的回调函数，目的是在不同路由不同请求方法的情况下让服务器做出不同的响应，路由的使用方式如下。/* 路由的使用方式 */ // 引入 Express const express = require(&#39;express&#39;); // 创建服务 const app = express(); // 创建路由 app.get(&#39;/&#39;, function (req, res) { res.end(&#39;home&#39;); }); app.post(&#39;/about&#39;, function (req, res) { res.end(&#39;about&#39;); }); app.all(&#39;*&#39;, function (req, res) { res.end(&#39;Not Found&#39;); }); // 监听服务 app.listen(3000); 如果启动上面的服务，通过浏览器访问定义的路由时可以匹配到 app.get、app.post 或 app.all 并执行回调，但其实我们可以发现这些方法的名字是与请求类型严格对应的，不仅仅这几个，下面来看看实现路由的核心逻辑（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // ************************** 以下为新增代码 ************************** // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); // ************************** 以上为新增代码 ************************** function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // ************************** 以下为新增代码 ************************** // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) { // 循环取得每一层 const layer = app.routes[i]; // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } } // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath); // ************************** 以上为新增代码 ************************** } // ************************** 以下为新增代码 ************************** // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { const layer = { method, pathname, // 不包含查询字符串 handler }; // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // ************************** 以上为新增代码 ************************** // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; 我们的逻辑大体可以分为两个部分，路由方法的创建以及路由的匹配，首先是路由方法的创建阶段，每一个方法的内部所做的事情就是将路由的路径、请求方式和回调函数作为对象的属性，并将对象存入一个数组中统一管理，所以我们创建了 app.routes 数组用来存储这些路由对象。方法名对应请求类型，请类型有很多，我们不会一一的创建每一个方法，所以选择引入专门存储请求类型名称的 methods 模块，其实路由方法逻辑相同，我们封装了 createRouteMethod 方法用来生成不同路由方法的函数体，之所以这样做是因为有个特殊的路由方法 app.all，导致请求类型有差别，其他的可以从 methods 中取，app.all 我们定义类型为 all 通过 createRouteMethod 函数的参数传入。接着就是循环 methods 调用 createRouteMethod 函数创建路由方法，并单独创建 app.all 方法。路由匹配阶段实在函数 app 内完成的，因为启动服务接收到请求时会执行 createServer 中的回调，即执行 app，先通过原生自带的 req.method 取出请求方式并处理成小写，通过 req.path 取出完整路径并分成路由名和查询字符串两个部分。循环 app.routes 用取到请求的类型和路由名称匹配，两者都相等则执行对应路由对象上的回调函数，在判断条件中，请求方式兼容了我们之前定义的 all，为了所有的请求类型只要路由匹配都可以执行 app.all 的回调，请求路径兼容了 *，因为如果某个路由方法定义的路径为 *，则任意路由都可以执行这个路由对象上的回调。扩展请求对象属性且在路由内部可以通过 req 访问一些原生没有的属性如 req.path、req.query、req.host 和 req.params，这说明 Express 在实现的过程中对 req 进行了处理。/* req 属性的使用 */ // 引入 Express const express = require(&#39;express&#39;); // 创建服务 const app = express(); // 创建路由 app.get(&#39;/&#39;, function (req, res) { console.log(req.path); console.log(req.query); console.log(req.host); res.end(&#39;home&#39;); }); app.get(&#39;/about/:id/:name&#39;, function (req, res) { console.log(req.params); res.end(&#39;about&#39;); }); // 监听服务 app.listen(3000); 在上面的使用中我们写了两个路由，分别打印了原生所不具备而 Express 帮我们处理并新增的属性，下面我们就来在之前自己实现的 express.js 的基础上增加这些属性（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); // ************************** 以下为新增代码 ************************** const querystring = require(&#39;querystring&#39;); // ************************** 以上为新增代码 ************************** function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // *************************** 以下为修改代码 ************************** // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) { // 循环取得每一层 const layer = app.routes[i]; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = pathname.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } } // ************************** 以上为修改代码 ************************** } // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath); } // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { const layer = { method, pathname, // 不包含查询字符串 handler }; // ************************** 以下为新增代码 ************************** // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(&#39;:&#39;) !== -1) { const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // ************************** 以上为新增代码 ************************** // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; 上面代码有些长，我们一点一点分析，首先是 req.path，就是我们浏览器地址栏里查询字符串前的路径，值其实就是我们之前从 req.url 中解构出来的 pathname，我们只需要将 pathname 赋值给 req.path 即可。req.query 是浏览器地址栏的查询字符串传递的参数，就是我们从 req.url 解构出来的查询字符串，借助 querystring 模块将查询字符串处理成对象赋值给 req.query 即可。req.host 是访问的主机名，请求头中的 host 包含了主机名和端口号，我们只要截取出前半部分赋值给 req.host 即可。最复杂的是 req.params 的实现，大概分为两个步骤，首先是在路由方法创建时需要检查定义的路由是否含有路由参数，如果有则取出参数的键存入数组 paramNames 中，然后创建一个匹配路由参数的正则，通过 replace 实现正则字符串的创建，再通过 RegExp 构造函数来创建正则，并挂在路由对象上，之所以使用 replace 是因为创建的规则内的分组要和路由参数的个数是相同的，我们将这些逻辑完善进了 createRouteMethod 函数中。实现响应方法 send 和 sendFile之前的例子中我们都是用原生的 end 方法响应浏览器，我们知道 end 方法只能接收字符串和 Buffer 作为响应的值，非常不方便，其实在 Express 中封装了一个 send 方法挂在 res 对象下，可以接收数组、对象、字符串、Buffer、数字处理后响应给浏览器，在 Express 内部同样封装了一个 sendFile 方法用于读取请求的文件。/* send 响应 */ // 引入 Express const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); // 创建服务 const app = express(); // 创建路由 app.get(&#39;/&#39;, function (req, res) { res.send({ name: &#39;panda&#39;, age: 28 }); }); app.get(&#39;/test.txt&#39;, function (req, res) { // 必须传入绝对路径 res.sendFile(path.join(__dirname, req.path)); }); // 监听服务 app.listen(3000); 通过我们的分析，封装的 send 方法应该是将 end 不支持的类型数据转换成了字符串，在内部再次调用 end，而 sendFile 方法规定参数必须为绝对路径，内部实现应该是利用可读流读取文件内容相应给浏览器，下面是两个方法的实现（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); const querystring = require(&#39;querystring&#39;); // ************************** 以下为新增代码 ************************** const util = require(&#39;util&#39;); const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息 const fs = require(&#39;fs&#39;); // ************************** 以上为新增代码 ************************** function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // ************************** 以下为新增代码 ************************** // 响应方法 res.send = function (params) { // 设置响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); // 检测传入值得数据类型 switch (typeof params) { case &#39;object&#39;: res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case &#39;number&#39;: // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; } // 响应 res.end(params); } // 响应文件方法 res.sendFile = function (pathname) { fs.createReadStream(pathname).pipe(res); } // ************************** 以上为新增代码 ************************** // 循环匹配路径 for (let i = 0; i &lt; app.routes.lenth; i++) { // 循环取得每一层 const layer = app.routes[i]; // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = reqPath.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((reqPath === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } } } // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + reqPath); } // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { const layer = { method, pathname, // 不包含查询字符串 handler }; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(&#39;:&#39;) !== -1) { const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; 有一点需要注意，在 Node 环境中想把任何对象类型转换成字符串应该使用 util.inspect 方法，而当 send 方法输入数字类型时，要返回对应状态码的名称，可通过 _http_server 模块的 STATUS_CODES 对象获取。内置中间件的实现Express 最大的特点就是中间件机制，中间件就是用来处理请求的函数，用来完成不同场景的请求处理，一个中间件处理完请求后可以再传递给下一个中间件，具有回调函数 next，不执行 next 则会卡在一个位置，调用 next 则继续向下传递。/* use 的使用 */ // 引入 Express const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); // 创建服务 const app = express(); // 创建路由 app.use(function (req, res, next) { res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); next(); }); // 创建路由 app.get(&#39;/&#39;, function (req, res) { res.send({ name: &#39;panda&#39;, age: 28 }); }); // 监听服务 app.listen(3000); 在上面代码中使用 use 方法执行了传入的回调函数，实现公共逻辑，起到了中间件的作用，调用回调参数的 next 方法向下继续执行，下面来实现 use 方法（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); const querystring = require(&#39;querystring&#39;); const util = require(&#39;util&#39;); const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息 const fs = require(&#39;fs&#39;); function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // ************************** 以下为修改代码 ************************** // 循环匹配路径 let index = 0; function next(err) { // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) { // 将当前中间件函数的属性解构出来 const { method, pathname, handler } = layer; if (err) { // 如果存在错误将错误交给错误处理中间件，否则 if (method === &#39;middle&#39;, handle.length === 4) { return hanlder(err, req, res, next); } else { next(err); } } else { // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === &#39;middle&#39;) { // 匹配路径判断 if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) { handler(req, res, next); } else { next(); } } else { // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; ( method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index ) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } else { next(); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } else { next(); } } } } } else { // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; req.path); } } next(); // ************************** 以上为修改代码 ************************** } // ************************** 以下为新增代码 ************************** function init() { return function (req, res, next) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // 响应方法 res.send = function (params) { // 设置响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); // 检测传入值得数据类型 switch (typeof params) { case &#39;object&#39;: res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case &#39;number&#39;: // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; } // 响应 res.end(params); } // 响应文件方法 res.sendFile = function (pathname) { fs.createReadStream(pathname).pipe(res); } // 向下执行 next(); } } // ************************** 以上为新增代码 ************************** // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { const layer = { method, pathname, // 不包含查询字符串 handler }; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 // ************************** 以下为修改代码 ************************** if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) { // ************************** 以上为修改代码 ************************** const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // ************************** 以下为新增代码 ************************** // 添加中间件方法 app.use = function (pathname, handler) { // 处理没有传入路径的情况 if (typeof handler !== &#39;function&#39;) { handler = pathname; pathname = &#39;/&#39;; } // 生成函数并执行 createRouteMethod(&#39;middle&#39;)(pathname, handler); } // 将初始逻辑作为中间件执行 app.use(init()); // ************************** 以上为新增代码 ************************** // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; use 方法第一个参数为路径，与路由相同，不传默认为 /，如果不传所有的路径都会经过该中间件，如果传入指定的值，则匹配后的请求才会通过该中间件。中间件的执行可能存在异步的情况，但之前匹配路径使用的是 for 循环同步匹配，我们将其修改为异步并把路由匹配的逻辑与中间件路径匹配的逻辑进行了整合，并创建了 use 方法，对是否传了第一个参数做了一个兼容，其他将带有请求方式、路径和回调的逻辑统一使用 createRouteMethod 方法创建，并传入 middle 类型，createRouteMethod 中路由参数匹配的逻辑对 middle 类型做了一个排除。使用 Express 中间件调用 next 方法时，不传递参数和参数为 null 代表执行成功，如果传入了其他的参数，表示执行出错，会跳过所有正常的中间件和路由，直接交给错误处理中间件处理，并将 next 传入的参数作为错误处理中间件回调函数的第一个参数 err，后面三个参数分别为 req、res 和 next。代码种创建了 index 变量，默认调用了一次 next 方法，每次然后取出数组 app.routes 中的路由对象的回调函数执行，并在内部执行 handler，而 handler 回调中又调用了 next 方法，就这样将整个中间件和路由的回调串联起来。我们发现在第一次调用 next 之前的所有逻辑，如给 req 添加属性，给 res 添加方法，都是公共逻辑，是任何中间件和路由在匹配之前都会执行的逻辑，我们既然有了中间件方法 app.user，可以将这些逻辑抽取出来作为一个单独的中间件回调函数执行，所以创建了 init 函数，内部返回了一个函数作为回调函数，形参为 req、res 和 next，并在init 调用返回的函数内部调用 next 向下执行。内置模板引擎的实现在 Express 框架中内置支持了 ejs、jade 等模板，使用方法 “三部曲” 如下。/* 模板的使用 */ // 引入 Express const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); // 创建服务 const app = express(); // 1、指定模板引擎，其实就是模板文件的后缀名 app.set(&#39;view engine&#39;, &#39;ejs&#39;); // 2、指定模板的存放根目录 app.set(&#39;views&#39;, path.resolve(__dirname, &#39;views&#39;)); // 3、如果要自定义模板后缀和函数的关系 app.engine(&#39;.html&#39;, require(&#39;./ejs&#39;).__express); // 创建路由 app.get(&#39;/user&#39;, function (req, res) { //使用指定的模板引擎渲染 user 模板 res.render(&#39;user&#39;, { title: &#39;用户管理&#39; }); }); // 监听服务 app.listen(3000); 上面将模板根目录设置为 views 文件夹，并规定了模板类型为 ejs，可以同时给多种模板设置，并不冲突，如果需要将其他后缀名的模板按照另一种模板的渲染引擎渲染则使用 app.engine 进行设置，下面看一下实现代码（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); const querystring = require(&#39;querystring&#39;); const util = require(&#39;util&#39;); const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息 const fs = require(&#39;fs&#39;); // ************************** 以下为新增代码 ************************** const path = require(&#39;path&#39;); // ************************** 以上为新增代码 ************************** function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // 循环匹配路径 let index = 0; function next(err) { // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) { // 将当前中间件函数的属性解构出来 const { method, pathname, handler } = layer; if (err) { // 如果存在错误将错误交给错误处理中间件，否则 if (method === &#39;middle&#39;, handle.length === 4) { return hanlder(err, req, res, next); } else { next(err); } } else { // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === &#39;middle&#39;) { // 匹配路径判断 if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) { handler(req, res, next); } else { next(); } } else { // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } else { next(); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } else { next(); } } } } } else { // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + req.path); } } next(); } function init() { return function (req, res, next) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // 响应方法 res.send = function (params) { // 设置响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); // 检测传入值得数据类型 switch (typeof params) { case &#39;object&#39;: res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case &#39;number&#39;: // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; } // 响应 res.end(params); } // 响应文件方法 res.sendFile = function (pathname) { fs.createReadStream(pathname).pipe(res); } // ************************** 以下为新增代码 ************************** // 模板渲染方法 res.render = function (filename, data) { // 将文件名和模板路径拼接 let filepath = path.join(app.get(&#39;views&#39;), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) { extname = &#39;.&#39; + app.get(&#39;view engine&#39;) filepath += extname; } // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function (err, html) { res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); res.end(html); }); } // ************************** 以上为新增代码 ************************** // 向下执行 next(); } } // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { // ************************** 以下为修改代码 ************************** // 满足条件说明是取值方法 if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) { return app.settings[pathname]; } // ************************** 以上为修改代码 ************************** const layer = { method, pathname, // 不包含查询字符串 handler }; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) { const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // 添加中间件方法 app.use = function (pathname, handler) { // 处理没有传入路径的情况 if (typeof handler !== &#39;function&#39;) { handler = pathname; pathname = &#39;/&#39;; } // 生成函数并执行 createRouteMethod(&#39;middle&#39;)(pathname, handler); } // 将初始逻辑作为中间件执行 app.use(init()); // ************************** 以下为新增代码 ************************** // 存储设置的对象 app.setting ={}; // 存储模板渲染方法 app.engines = {}; // 添加设置的方法 app.set = function (key, value) { app.use[key] = value; } // 添加渲染引擎的方法 app.engine = function (ext, renderFile) { app.engines[ext] = renderFile; } // ************************** 以上为新增代码 ************************** // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } module.exports = createApplication; 在上面新增代码中设置了两个缓存 settings 和 engines，前者用来存储模板相关的设置，如渲染成什么类型的文件、读取模板文件的根目录，后者用来存储渲染引擎，即渲染模板的方法，这所以设置这两个缓存对象是为了实现 Express 多种不同模板共存的功能，可以根据需要进行设置和使用，而设置的方法分别为 app.set 和 app.engine，有设置值的方法就应该有取值的方法，但是 app.get 方法已经被设置为路由方法了，为了语义我们在 app.get 方法逻辑中进行了兼容，当参数为 1 个时，从 settings 中取值并返回，否则执行添加路由方法的逻辑。之前都是准备工作，在使用时无论是中间件还是路由中都是靠调用 res.render 方法并传入模板路径和渲染数据来真正实现渲染和响应的，render 方法是在 init 函数初始化时就挂在了 res 上，核心逻辑是取出传入的模板文件后缀名，如果存在则使用后缀名，将文件名与默认读取模板的文件夹路径拼接传递给设置的渲染引擎的渲染方法，如果不存在后缀名则默认拼接 .html 当作后缀名，再与默认读取模板路径进行拼接，在渲染函数的回调中将渲染引擎渲染的模板字符串响应给浏览器。内置静态资源中间件的实现在 Express 内部可以通过路由处理静态文件，但是如果可能请求多个文件不可能一个文件对应一个路由，因此 Express 内部实现了静态文件中间件，使用如下。/* 静态文件中间件的使用 */ // 引入 Express const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); // 创建服务 const app = express(); // 使用处理静态文件中间件 app.use(express.static(path.resolve(__dirname, &#39;public&#39;))); // 监听服务 app.listen(3000); 从上面使用可以看出，express.static 是一个函数，执行的时候传入了一个参数，为默认查找文件的根路径，而添加中间件的 app.use 方法传入的参数正好是回调函数，这说明 express.static 方法需要返回一个函数，形参为 req、res 和 next，通过调用方式我们能看出 static 是静态方法，挂在了模块返回的函数上，实现代码如下（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); const querystring = require(&#39;querystring&#39;); const util = require(&#39;util&#39;); const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // ************************** 以下为新增代码 ************************** const mime = require(&#39;mime&#39;); // ************************** 以上为新增代码 ************************** function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // 循环匹配路径 let index = 0; function next(err) { // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) { // 将当前中间件函数的属性解构出来 const { method, pathname, handler } = layer; if (err) { // 如果存在错误将错误交给错误处理中间件，否则 if (method === &#39;middle&#39;, handle.length === 4) { return hanlder(err, req, res, next); } else { next(err); } } else { // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === &#39;middle&#39;) { // 匹配路径判断 if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) { handler(req, res, next); } else { next(); } } else { // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } else { next(); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } else { next(); } } } } } else { // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method + &#39; &#39; + req.path); } } next(); } function init() { return function (req, res, next) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // 响应方法 res.send = function (params) { // 设置响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); // 检测传入值得数据类型 switch (typeof params) { case &#39;object&#39;: res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case &#39;number&#39;: // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; } // 响应 res.end(params); } // 响应文件方法 res.sendFile = function (pathname) { fs.createReadStream(pathname).pipe(res); } // 模板渲染方法 res.render = function (filename, data) { // 将文件名和模板路径拼接 let filepath = path.join(app.get(&#39;views&#39;), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) { extname = &#39;.&#39; + app.get(&#39;view engine&#39;)} filepath += extname; } // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function (err, html) { res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); res.end(html); }); } // 向下执行 next(); } } // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { // 满足条件说明是取值方法 if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) { return app.settings[pathname]; } const layer = { method, pathname, // 不包含查询字符串 handler }; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) { const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // 添加中间件方法 app.use = function (pathname, handler) { // 处理没有传入路径的情况 if (typeof handler !== &#39;function&#39;) { handler = pathname; pathname = &#39;/&#39;; } // 生成函数并执行 createRouteMethod(&#39;middle&#39;)(pathname, handler); } // 将初始逻辑作为中间件执行 app.use(init()); // 存储设置的对象 app.setting ={}; // 存储模板渲染方法 app.engines = {}; // 添加设置的方法 app.set = function (key, value) { app.use[key] = value; } // 添加渲染引擎的方法 app.engine = function (ext, renderFile) { app.engines[ext] = renderFile; } // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } // ************************** 以下为新增代码 ************************** createApplication.static = function (staticRoot) { return function (req, res, next) { // 获取文件的完整路径 const filename = path.join(staticRoot, req.path); // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应 fs.access(filename, function (err) { if (err) { next(); } else { // 设置响应头类型和响应文件内容 res.setHeader(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;); fs.createReadStream(filename).pipe(res); } }); } } // ************************** 以上为新增代码 ************************** module.exports = createApplication; 这个方法的核心逻辑是获取文件的路径，检查文件的权限，如果没有权限，则调用 next 交给其他中间件，这里注意的是 err 错误对象不要传递给 next，因为后面的中间件还要执行，如果传递后会直接执行错误处理中间件，有权限的情况下就正常读取文件内容，给 Content-Type 响应头设置文件类型，并将文件的可读流通过 pipe 方法传递给可写流 res，即响应给浏览器。实现重定向在 Express 中有一个功能在我们匹配到的某一个路由中调用可以直接跳转到另一个路由，即 302 重定向。/* 使用重定向 */ // 引入 Express const express = require(&#39;express&#39;); const path = require(&#39;path&#39;); // 创建服务 const app = express(); // 创建路由 app.get(&#39;/user&#39;, function (req, res, next) { res.end(&#39;user&#39;); }); app.get(&#39;/detail&#39;, function (req, res, next) { // 访问 /detail 重定向到 /user res.redirect(&#39;/user&#39;); }); // 监听服务 app.listen(3000); 看到上面的使用方式，我们根据前面的套路知道是 Express 在 res 对象上给挂载了一个 redirect 方法，参数为状态码（可选）和要跳转路由的路径，并且这个方法应该在 init 函数调用时挂在 res 上的，下面是实现的代码（直接找到星号提示新增或修改位置即可）。/* 文件：express.js */ const http = require(&#39;http&#39;); // methods 模块返回存储所有请求方法名称的数组 const methods = require(&#39;methods&#39;); const querystring = require(&#39;querystring&#39;); const util = require(&#39;util&#39;); const httpServer = require(&#39;_http_server&#39;); // 存储 node 服务相关信息 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const mime = require(&#39;mime&#39;); function createApplication() { // 创建 app 函数，身份类似 “总管家”，用于将请求分派给别人处理 const app = function (req, res) { // 循环匹配路径 let index = 0; function next(err) { // 获取第一个回调函数 const layer = app.routes[index++]; if (layer) { // 将当前中间件函数的属性解构出来 const { method, pathname, handler } = layer; if (err) { // 如果存在错误将错误交给错误处理中间件，否则 if (method === &#39;middle&#39;, handle.length === 4) { return hanlder(err, req, res, next); } else { next(err); } } else { // 如果不存在错误则继续向下执行 // 判断是中间件还是路由 if (method === &#39;middle&#39;) { // 匹配路径判断 if (pathname === &#39;/&#39; || pathname === req.path || req.path.startWidth(pathname)) { handler(req, res, next); } else { next(); } } else { // 如果路由对象上存在正则说明存在路由参数，否则正常匹配路径和请求类型 if (layer.regexp) { // 使用路径配置的正则匹配请求路径 const result = req.path.match(layer.regexp); // 如果匹配到结果且请求方式匹配 if (result &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { // 则将路由对象 paramNames 属性中的键与匹配到的值构建成一个对象 req.params = layer.paramNames.reduce(function (memo, key, index) { memo[key] = result[index + 1]; return memo; }, {}); // 执行对应的回调 return layer.hanlder(req, res); } else { next(); } } else { // 如果说路径和请求类型都能匹配，则执行该路由层的回调 if ((req.path === layer.pathname || layer.pathname === &#39;*&#39;) &amp;&amp; (method === layer.method || layer.method === &#39;all&#39;)) { return layer.hanlder(req, res); } else { next(); } } } } } else { // 如果都没有匹配上，则响应错误信息 res.end(&#39;CANNOT &#39; + req.method} + &#39;&#39; + req.path); } } next(); } function init() { return function (req, res, next) { // 获取方法名统一转换成小写 const method = req.method.toLowerCase(); // 访问路径解构成路由和查询字符串两部分 /user?a=1&amp;b=2 const [reqPath, query = &#39;&#39;] = req.url.split(&#39;?&#39;); // 将路径名赋值给 req.path req.path = reqPath; // 将查询字符串转换成对象赋值给 req.query req.query = querystring.parse(query); // 将主机名赋值给 req.host req.host = req.headers.host.split(&#39;:&#39;)[0]; // 响应方法 res.send = function (params) { // 设置响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf8&#39;); // 检测传入值得数据类型 switch (typeof params) { case &#39;object&#39;: res.setHeader(&#39;Content-Type&#39;, &#39;application/json;charset=utf8&#39;); // 将任意类型的对象转换成字符串 params = util.inspect(params); break; case &#39;number&#39;: // 数字则直接取出状态吗对应的名字返回 params = httpServer.STATUS_CODES[params]; break; default: break; } // 响应 res.end(params); } // 响应文件方法 res.sendFile = function (pathname) { fs.createReadStream(pathname).pipe(res); } // 模板渲染方法 res.render = function (filename, data) { // 将文件名和模板路径拼接 let filepath = path.join(app.get(&#39;views&#39;), filename); // 获取扩展名 let extname = path.extname(filename.split(path.sep).pop()); // 如果没有扩展名，则使用默认的扩展名 if (!extname) { extname = &#39;.&#39; + app.get(&#39;view engine&#39;) filepath += extname; } // 读取模板文件并使用渲染引擎相应给浏览器 app.engines[extname](filepath, data, function (err, html) { res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); res.end(html); }); } // ************************** 以下为新增代码 ************************** // 重定向方法 res.redirect = function (status, target) { // 如果第一个参数是字符串类型说明没有传状态码 if (typeof status === &#39;string&#39;) { // 将第二个参数（重定向的目标路径）设置给 target target = status; // 再把状态码设置成 302 status = 302; } // 响应状态码，设置重定向响应头 res.statusCode = status; res.setHeader(&#39;Location&#39;, target); res.end(); } // ************************** 以上为新增代码 ************************** // 向下执行 next(); } } // 存储路由层的请求类型、路径和回调 app.routes = []; // 返回一个函数体用于将路由层存入 app.routes 中 function createRouteMethod(method) { return function (pathname, handler) { // 满足条件说明是取值方法 if (method === &#39;get&#39; &amp;&amp; arguments.length === 1) { return app.settings[pathname]; } const layer = { method, pathname, // 不包含查询字符串 handler }; // 如果含有路由参数，如 /xxx/:aa/:bb // 取出路由参数的键 aa bb 存入数组并挂在路由对象上 // 并生匹配 /xxx/aa/bb 的正则挂在路由对象上 if (pathname.indexOf(&#39;:&#39;) !== -1 &amp;&amp; pathname.method !== &#39;middle&#39;) { const paramNames = []; // 存储路由参数 // 将路由参数取出存入数组，并返回正则字符串 const regStr = pathname.replace(/:(\\w+)/g, function (matched, attr) { paramNames.push(attr); return &#39;(\\\\w+)&#39;; }); const regexp = new RegExp(regStr); // 生成正则类型 layer.regexp = regexp; // 将正则挂在路由对象上 layer.paramNames = paramNames; // 将存储路由参数的数组挂载对象上 } // 把这一层放入存储所有路由层信息的数组中 app.routes.push(layer); } } // 循环构建所有路由方法，如 app.get app.post 等 methods.forEach(function (method) { // 匹配路由的 get 方法 app[method] = createRouteMethod(method); }); // all 方法，通吃所有请求类型 app.all = createRouteMethod(&#39;all&#39;); // 添加中间件方法 app.use = function (pathname, handler) { // 处理没有传入路径的情况 if (typeof handler !== &#39;function&#39;) { handler = pathname; pathname = &#39;/&#39;; } // 生成函数并执行 createRouteMethod(&#39;middle&#39;)(pathname, handler); } // 将初始逻辑作为中间件执行 app.use(init()); // 存储设置的对象 app.setting ={}; // 存储模板渲染方法 app.engines = {}; // 添加设置的方法 app.set = function (key, value) { app.use[key] = value; } // 添加渲染引擎的方法 app.engine = function (ext, renderFile) { app.engines[ext] = renderFile; } // 启动服务的 listen 方法 app.listen = function () { // 创建服务器 const server = http.createServer(app); // 监听服务，可能传入多个参数，如第一个参数为端口号，最后一个参数为服务启动后回调 server.listen(...arguments); } // 返回 app return app; } createApplication.static = function (staticRoot) { return function (req, res, next) { // 获取文件的完整路径 const filename = path.join(staticRoot, req.path); // 如果没有权限就向下执行其他中间件，如果有权限读取文件并响应 fs.access(filename, function (err) { if (err) { next(); } else { // 设置响应头类型和响应文件内容 res.setHeader(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;); fs.createReadStream(filename).pipe(res); } }); } } module.exports = createApplication; 其实 res.redirect 方法的核心逻辑就是处理参数，如果没有传状态码的时候将参数设置给 target，将状态码设置为 302，并设置重定向响应头 Location。总结到此为止 Express 的大部分内置功能就都简易的实现了，由于 Express 内部的封装思想，以及代码复杂、紧密的特点，各个功能代码很难单独拆分，总结一下就是很难表述清楚，只能通过大量代码来堆砌，好在每一部分实现我都标记了 “重点”，但看的时候还是要经历 “痛苦”，这已经将 Express 中的逻辑 “阉割” 到了一定的程度，读 Express 的源码一定比读这篇文章更需要耐心，当然如果你已经读到了这里证明困难都被克服了，继续加油。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"中间件","slug":"中间件","permalink":"https://www.overtaking.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Express","slug":"Express","permalink":"https://www.overtaking.top/tags/Express/"}]},{"title":"Koa2 中间件原理解析 —— 看了就会写","date":"2018-08-20T12:03:42.000Z","path":"20180820200342/","text":"前言Koa 2.x 版本是当下最流行的 Node.js 框架，Koa 2.0 的源码特别精简，不像 Express 封装的功能那么多，所以大部分的功能都是由 Koa 开发团队（同 Express 是一家出品）和社区贡献者针对 Koa 对 Node.js 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 Koa 的 use 方法使用在对应的位置，这样就可以通过在内部操作 ctx 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 Koa 中间件供自己和别人使用。Koa 的洋葱模型介绍我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。/* 洋葱模型特点 */ // 引入 Koa const Koa = require(&#39;koa&#39;); // 创建服务 const app = new Koa(); app.use(async (ctx, next) =&gt; { console.log(1); await next(); console.log(2); }); app.use(async (ctx, next) =&gt; { console.log(3); await next(); console.log(4); }); app.use(async (ctx, next) =&gt; { console.log(5); await next(); console.log(6); }); // 监听服务 app.listen(3000); // 1 // 3 // 5 // 6 // 4 // 2 我们知道 Koa 的 use 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 next 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 Koa 中都是建议使用 async/await 的，引入的中间件都是在 use 方法中调用，由此我们可以分析出每一个 Koa 的中间件都是返回一个 async 函数的。koa-bodyparser 中间件模拟想要分析 koa-bodyparser 的原理首先需要知道用法和作用，koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值，使用前需提前安装。$ npm install koa koa-bodyparser koa-bodyparser 具体用法如下：/* koa-bodyparser 的用法 */ const Koa = require(&#39;koa&#39;); const bodyParser = require(&#39;koa-bodyparser&#39;); const app = new Koa(); // 使用中间件 app.use(bodyParser()); app.use(async (ctx, next) =&gt; { if (ctx.path === &#39;/&#39; &amp;&amp; ctx.method === &#39;POST&#39;) { // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据 console.log(ctx.request.body); } }); app.listen(3000); 根据用法我们可以看出 koa-bodyparser 中间件引入的其实是一个函数，我们把它放在了 use 中执行，根据 Koa 的特点，我们推断出 koa-bodyparser 的函数执行后应该给我们返回了一个 async 函数，下面是我们模拟实现的代码。/* 文件：my-koa-bodyparser.js */ const querystring = require(&#39;querystring&#39;); module.exports = function bodyParser() { return async (ctx, next) =&gt; { await new Promise((resolve, reject) =&gt; { // 存储数据的数组 const dataArr = []; // 接收数据 ctx.req.on(&#39;data&#39;, data =&gt; dataArr.push(data)); // 整合数据并使用 Promise 成功 ctx.req.on(&#39;end&#39;, () =&gt; { // 获取请求数据的类型 json 或表单 const contentType = ctx.get(&#39;Content-Type&#39;); // 获取数据 Buffer 格式 const data = Buffer.concat(dataArr).toString(); if (contentType === &#39;application/x-www-form-urlencoded&#39;) { // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body ctx.request.body = querystring.parse(data); } else if (contentType === &#39;applaction/json&#39;) { // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body ctx.request.body = JSON.parse(data); } // 执行成功的回调 resolve(); }); }); // 继续向下执行 await next(); } } 在上面代码中由几点是需要我们注意的，即 next 的调用以及为什么通过流接收数据、处理数据和将数据挂在 ctx.request.body 要在 Promise 中进行。首先是 next 的调用，我们知道 Koa 的 next 执行，其实就是在执行下一个中间件的函数，即下一个 use 中的 async 函数，为了保证后面的异步代码执行完毕后再继续回到当前中间件，所以我们需要使用 await 进行等待。其次就是数据从接收到挂在 ctx.request.body 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 ctx.request.body 上，可以保证我们在下一个 use 的 async 函数中可以在 ctx.request.body 上拿到数据，所以我们使用 await 等待一个 Promise 成功后再执行 next。koa-better-body 中间件模拟koa-bodyparser 在处理表单提交时还是显得有一点弱，因为不支持文件上传，而 koa-better-body 则弥补了这个不足，但是 koa-better-body 为 Koa 1.x 版本的中间件，Koa 1.x 的中间件都是使用 Generator 函数实现的，我们需要使用 koa-convert 将 koa-better-body 转化成 Koa 2.x 的中间件。$ npm install koa koa-better-body koa-convert path uuid koa-better-body 具体用法如下：/* koa-better-body 的用法 */ const Koa = require(&#39;koa&#39;); const betterBody = require(&#39;koa-better-body&#39;); const convert = require(&#39;koa-convert&#39;); // 将 koa 1.0 中间转化成 koa 2.0 中间件 const path = require(&#39;path&#39;); const fs = require(&#39;fs&#39;); const uuid = require(&#39;uuid/v1&#39;); // 生成随机串 const app = new Koa(); // 将 koa-better-body 中间件从 koa 1.0 转化成 koa 2.0，并使用中间件 app.use(convert(betterBody({ uploadDir: path.resolve(__dirname, &#39;upload&#39;) }))); app.use(async (ctx, next) =&gt; { if (ctx.path === &#39;/&#39; &amp;&amp; ctx.method === &#39;POST&#39;) { // 使用中间件后 ctx.request.fields 属性自动加上了 post 请求的文件数据 console.log(ctx.request.fields); // 将文件重命名 const imgPath = ctx.request.fields.avatar[0].path; const newPath = path.resolve(__dirname, uuid()); fs.rename(imgPath, newPath); } }); app.listen(3000); 上面代码中 koa-better-body 的主要功能就是将表单上传的文件存入本地指定的文件夹下，并将文件流对象挂在了 ctx.request.fields 属性上，我们接下来就模拟 koa-better-body 的功能实现一版基于 Koa 2.x 处理文件上传的中间件。/* 文件：my-koa-better-body.js */ const fs = require(&#39;fs&#39;); const uuid = require(&#39;uuid/v1&#39;); const path = require(&#39;path&#39;); // 给 Buffer 扩展 split 方法预备后面使用 Buffer.prototype.split = function (sep) { const len = Buffer.from(sep).length; // 分隔符所占的字节数 const result = []; // 返回的数组 let start = 0; // 查找 Buffer 的起始位置 let offset = 0; // 偏移量 // 循环查找分隔符 while ((offset = this.indexOf(sep, start)) !== -1) { // 将分隔符之前的部分截取出来存入 result.push(this.slice(start, offset)); start = offset + len; } // 处理剩下的部分 result.push(this.slice(start)); // 返回结果 return result; } module.exports = function (options) { return async (ctx, next) =&gt; { await new Promise((resolve, reject) =&gt; { let dataArr = []; // 存储读取的数据 // 读取数据 ctx.req.on(&#39;data&#39;, data =&gt; dataArr.push(data)); ctx.req.on(&#39;end&#39;, () =&gt; { // 取到请求体每段的分割线字符串 const bondery = &#39;--&#39; + ctx.get(&#39;content-Type&#39;).split(&#39;=&#39;)[1]; // 获取不同系统的换行符 const lineBreak = process.platform === &#39;win32&#39; ? &#39;\\r\\n&#39; : &#39;\\n&#39;; // 非文件类型数据的最终返回结果 const fields = {}; // 分隔的 buffer 去掉没用的头和尾即开头的 &#39;&#39; 和末尾的 &#39;--&#39; dataArr = dataArr.split(bondery).slice(1, -1); // 循环处理 dataArr 中每一段 Buffer 的内容 dataArr.forEach(lines =&gt; { // 对于普通值，信息由包含键名的行 + 两个换行 + 数据值 + 换行组成 // 对于文件，信息由包含 filename 的行 + 两个换行 + 文件内容 + 换行组成 const [head, tail] = lines.split(lineBreak + lineBreak}); // 判断是否是文件，如果是文件则创建文件并写入，如果是普通值则存入 fields 对象中 if (head.includes(&#39;filename&#39;)) { // 防止文件内容含有换行而被分割，应重新截取内容并去掉最后的换行 let tail = lines.slice(head.length + 2 * lineBreak.length, -lineBreak.length); // 创建可写流并指定写入的路径： // 绝对路径 + 指定文件夹 + 随机文件名，最后写入文件 fs.createWriteStream(path.join(__dirname, options.uploadDir, uuid())).end(tail); } else { // 是普通值取出键名 const key = head.match(/name=&#39;(\\w+)&#39;/)[1]; // 将 key 设置给 fields tail 去掉末尾换行后的内容 fields[key] = tail.toString(&#39;utf8&#39;).slice(0, -lineBreak.length); } }); // 将处理好的 fields 对象挂在 ctx.request.fields 上，并完成 Promise ctx.request.fields = fields; resolve(); }); }); // 向下执行 await next(); } } 上面的内容逻辑可以通过代码注释来理解，就是模拟 koa-better-body 的功能逻辑，我们主要的关心点在于中间件实现的方式，上面功能实现的异步操作依然是读取数据，为了等待数据处理结束仍然在 Promise 中执行，并使用 await 等待，Promise 执行成功调用 next。koa-views 中间件模拟Node.js 模板是我们经常使用的工具，用来在服务端帮我们渲染页面，模板的种类繁多，因此出现了 koa-view 中间件，来兼容这些模板，先安装依赖的模块。$ npm install koa koa-views ejs 下面是一个 ejs 的模板文件：&lt;!-- 文件：index.ejs --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&#39;en&#39;&gt; &lt;head&gt; &lt;meta charset=&#39;UTF-8&#39;&gt; &lt;title&gt;ejs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= name %&gt; &lt;%= age %&gt; &lt;% if (name == &#39;panda&#39;) { %&gt; panda &lt;% } else { %&gt; shen &lt;% } %&gt; &lt;% arr.forEach(item =&gt; { %&gt; &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt; &lt;% }); %&gt; &lt;/body&gt; &lt;/html&gt; koa-views 具体用法如下：/* koa-views 的用法 */ const Koa = require(&#39;koa&#39;); const views = require(&#39;koa-views&#39;); const path = require(&#39;path&#39;); const app = new Koa(); // 使用中间件 app.use(views(path.resolve(__dirname, &#39;views&#39;), { extension: &#39;ejs&#39; })); app.use(async (ctx, next) =&gt; { await ctx.render(&#39;index&#39;, { name: &#39;panda&#39;, age: 20, arr: [1, 2, 3] }); }); app.listen(3000); 可以看出我们使用了 koa-views 中间件后，让 ctx 上多了 render 方法帮助我们实现对模板的渲染和响应页面，就和直接使用 ejs 自带的 render 方法一样，并且从用法可以看出 render 方法是异步执行的，所以需要使用 await 进行等待，接下来我们就来模拟实现一版简单的 koa-views 中间件。/* 文件：my-koa-views.js */ const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const { promisify } = require(&#39;util&#39;); // 将读取文件方法转换成 Promise const readFile = promisify(fs.readFile); // 到处中间件 module.exports = function (dir, options) { return async (ctx, next) =&gt; { // 动态引入模板依赖模块 const view = require(options.extension); ctx.render = async (filename, data) =&gt; { // 异步读取文件内容 const tmpl = await readFile(path.join(dir, filename + &#39;.&#39; + options.extension), &#39;utf8&#39;); // 将模板渲染并返回页面字符串 const pageStr = view.render(tmpl, data); // 设置响应类型并响应页面 ctx.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); ctx.body = pageStr; } // 继续向下执行 await next(); } } 挂在 ctx 上的 render 方法之所以是异步执行的是因为内部读取模板文件是异步执行的，需要等待，所以 render 方法为 async 函数，在中间件内部动态引入了我们使的用模板，如 ejs，并在 ctx.render 内部使用对应的 render 方法获取替换数据后的页面字符串，并以 html 的类型响应。koa-static 中间件模拟下面是 koa-static 中间件的用法，代码使用的依赖如下，使用前需安装。$ npm install koa koa-static mime koa-static 具体用法如下：/* koa-static 的用法 */ const Koa = require(&#39;koa&#39;); const static = require(&#39;koa-static&#39;); const path = require(&#39;path&#39;); const app = new Koa(); app.use(static(path.resolve(__dirname, &#39;public&#39;))); app.use(async (ctx, next) =&gt; { ctx.body = &#39;hello world&#39;; }); app.listen(3000); 通过使用和分析，我们知道了 koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，如果我们直接访问文件名的时候，会查找这个文件并直接响应，如果没有这个文件路径会当作文件夹，并查找文件夹下的 index.html，如果存在则直接响应，如果不存在则交给其他中间件处理。/* 文件：my-koa-static.js */ const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const mime = require(&#39;mime&#39;); const { promisify } = require(&#39;util&#39;); // 将 stat 和 access 转换成 Promise const stat = promisify(fs.stat); const access = promisify(fs.access) module.exports = function (dir) { return async (ctx, next) =&gt; { // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 / const realPath = path.join(dir, ctx.path); try { // 获取 stat 对象 const statObj = await stat(realPath); // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html if (statObj.isFile()) { ctx.set(&#39;Content-Type&#39;, mime.getType() + &#39;;charset=utf8&#39;); ctx.body = fs.createReadStream(realPath); } else { const filename = path.join(realPath, &#39;index.html&#39;); // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理 await access(filename); // 存在设置文件类型并响应内容 ctx.set(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); ctx.body = fs.createReadStream(filename); } } catch (e) { await next(); } } } 上面的逻辑中需要检测路径是否存在，由于我们导出的函数都是 async 函数，所以我们将 stat 和 access 转化成了 Promise，并用 try...catch 进行捕获，在路径不合法时调用 next 交给其他中间件处理。koa-router 中间件模拟在 Express 框架中，路由是被内置在了框架内部，而 Koa 中没有内置，是使用 koa-router 中间件来实现的，使用前需要安装。$ npm install koa koa-router koa-router 功能非常强大，下面我们只是简单的使用，并且根据使用的功能进行模拟。/* koa-router 的简单用法 */ const Koa = require(&#39;Koa&#39;); const Router = require(&#39;koa-router&#39;); const app = new Koa(); const router = new Router(); router.get(&#39;/panda&#39;, (ctx, next) =&gt; { ctx.body = &#39;panda&#39;; }); router.get(&#39;/pandashen&#39;, (ctx, next) =&gt; { ctx.body = &#39;pandashen&#39;; }); router.get(&#39;/shen&#39;, (ctx, next) =&gt; { ctx.body = &#39;shen&#39;; }) // 调用路由中间件 app.use(router.routes()); app.listen(3000); 从上面看出 koa-router 导出的是一个类，使用时需要创建一个实例，并且调用实例的 routes 方法将该方法返回的 async 函数进行连接，但是在匹配路由的时候，会根据路由 get 方法中的路径进行匹配，并串行执行内部的回调函数，当所有回调函数执行完毕之后会执行整个 Koa 串行的 next，原理同其他中间件，我下面来针对上面使用的功能简易实现。/* 文件：my-koa-router.js */ // 控制每一个路由层的类 class Layer { constructor(path, cb) { this.path = path; this.cb = cb; } match(path) { // 地址的路由和当前配置路由相等返回 true，否则返回 false return path === this.path; } } // 路由的类 class Router { constructor() { // 存放每个路由对象的数组，{ path: /xxx, fn: cb } this.layers = []; } get(path, cb) { // 将路由对象存入数组中 this.layers.push(new Layer(path, cb)); } compose(ctx, next, handlers) { // 将匹配的路由函数串联执行 function dispatch(index) { // 如果当前 index 个数大于了存储路由对象的长度，则执行 Koa 的 next 方法 if (index &gt;= handlers.length) return next(); // 否则调用取出的路由对象的回调执行，并传入一个函数，在传入的函数中递归 dispatch(index + 1) // 目的是为了执行下一个路由对象上的回调函数 handlers[index].cb(ctx, () =&gt; dispatch(index + 1)); } // 第一次执行路由对象的回调函数 dispatch(0); } routes() { return async (ctx, next) { // 当前 next 是 Koa 自己的 next，即 Koa 其他的中间件，筛选出路径相同的路由 const handlers = this.layers.filter(layer =&gt; layer.match(ctx.path)); this.compose(ctx, next, handlers); } } } 在上面我们创建了一个 Router 类，定义了 get 方法，当然还有 post 等，我们只实现 get 意思一下，get 内为逻辑为将调用 get 方法的参数函数和路由字符串共同构建成对象存入了数组 layers，所以我们创建了专门构造路由对象的类 Layer（方便扩展），在路由匹配时我们可以根据 ctx.path 拿到路由字符串，并通过该路由过滤出 layers 数组中与路由相匹配的路由对象，调用 compose 方法将过滤后的数组作为参数 handlers 传入，串行执行路由对象上的回调函数。compose 这个方法的实现思想非常的重要，在 Koa 源码中用于串联中间件，在 redux 源码中用于串行执行 promise、thunk 和 logger 等中间件，我们 compose 的实现是一个简版，并没有兼容异步，主要思想是递归 dispatch 函数，每次取出数组中下一个路由对象的回调函数执行，直到所有匹配的路由的回调函数都执行完，执行 Koa 的下一个中间件，即调用 next，注意此处的 next 不同于 layers 数组中回调函数的参数 next，layers 数组中路由对象回调函数的 next 代表下一个匹配路由的回调。Koa 相比 Express 框架关于中间件和使用上的一些优势：Express 中很多功能都是集成在框架内部，而这些功能不一定都用得到，应用相对简单的情况下显得冗余，Koa 就更轻量，只集成最核心功能，上手快，文档少；Koa 的一切扩展功能都可以通过引入中间件来实现，大大增加灵活性，中间件可以自己开发，也可以来自社区，插拔随意，即插即用；Koa 中间件的实现原理明确，与自身的 “洋葱模型” 结合机制清晰，更多的促进关于 Koa 中间件生态的建设。总结上面我们分析和模拟了一些中间件，发现 Koa 中间件的开发使用非常方便，需要的功能都可以用对应的中间件来实现，使用中间件可以给我们带来一些好处，比如能将我们处理好的数据和新方法挂载在 ctx 上，方便后面 use 传入的回调函数中使用，也可以帮我们处理一些公共逻辑，不至于在每一个 use 的回调中都去处理，大大减少了冗余代码，由此看来其实给 Koa 使用中间件的过程就是一个典型的 “装饰器” 模式，在通过上面的分析之后相信大家也了解了 Koa 的 “洋葱模型” 和异步特点，知道该如何开发自己的中间件了。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"async/await","slug":"async-await","permalink":"https://www.overtaking.top/tags/async-await/"},{"name":"Koa","slug":"Koa","permalink":"https://www.overtaking.top/tags/Koa/"},{"name":"中间件","slug":"中间件","permalink":"https://www.overtaking.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Node.js 使用 cookie 和 session","date":"2018-08-17T07:36:35.000Z","path":"20180817153635/","text":"前言由于浏览器无状态的特性，cookie 技术应运而生，cookie 是一个会话级的存储，大小 4KB 左右，用于浏览器将服务器设置的信息重新带给服务器进行验证，不支持跨域，在浏览器清空缓存或超过有效期后失效，不建议存放敏感信息，session 是专门用于存储最初设置给浏览器 cookie 数据的地方，我们本篇就来讨论一下 cookie 和 session 在 Node.js 中的使用方式。cookie 的基本使用Node.js 原生操作 cookie下面是 cookie 在 Node 原生中的读取和写入方法。/* 原生中操作 cookie */ const http = require(&#39;http&#39;); // 创建服务 http.createServer((req, res) =&gt; { if (req.url === &#39;/read&#39;) { // 读取 cookie console.log(req.headers.cookie); res.end(req.headers.cookie); } else if (req.url === &#39;/write&#39;) { // 设置 cookie res.setHeader(&#39;Set-Cookie&#39;, [ &#39;name=panda; domain=panda.com; path=/write; httpOnly=true&#39;, &#39;age=28; Expires=&#39; + new Date(Date.now() + 1000 * 10).toGMTString(), &#39;address=&#39; + encodeURIComponent(&#39;回龙观&#39;) + &#39;; max-age=10&#39; ]); res.end(&#39;Write ok&#39;); } else { res.end(&#39;Not Found&#39;); } }).listen(3000); 上面代码创建了一个 http 服务器，可以通过读取 cookie 请求头的值来获取浏览器发来的 cookie，服务器可以通过给浏览器设置响应头 Set-Cookie 实现对浏览器 cookie 的设置，多个 cookie 参数为数组，在数组内可以规定每一条 cookie 的规则，中间使用一个分号和一个空格隔开。domain 用来设置允许访问 cookie 的域；path 用来设置允许访问 cookie 的路径；httpOnly 用来设置是否允许浏览器中修改 cookie，如果通过浏览器修改设置过 httpOnly=true 的 cookie，则会增加一条同名 cookie，原来的 cookie 不会被修改；Expires 用来设置过期时间，绝对时间，值为一个 GMT 或 UTC 格式的时间；max-age 同样用来设置过期时间，相对时间，值为一个正整数，单位 s。cookie 默认不支持存储中文，如果存储中文需先使用 encodeURIComponent 方法进行转译，将转译后的结果存入 cookie，在浏览器获取 cookie 需使用 decodeURIComponent 方法转回中文。Koa 中操作 cookieKoa 是当下流行的 Node.js 框架，是对原生 Node 的一个轻量的封装，但是内部实现了快捷操作 cookie 的方法，下面是原生中对 cookie 的操作在 Koa 中的写法。/* Koa 中操作 cookie */ const Koa = require(&#39;koa&#39;); const Router = require(&#39;koa-router&#39;); // 创建服务和路由 const app = new Koa(); const router = new Router(); // 签名需要设置 key app.keys = [&#39;shen&#39;]; router.get(&#39;/read&#39;, (ctx, next) =&gt; { // 获取 cookie const name = ctx.cookies.get(name) || &#39;No name&#39;; const age = ctx.cookies.get(age) || &#39;No age&#39;; ctx.body = name + &#39;-&#39; + age; }); router.get(&#39;/write&#39;, (ctx, next) =&gt; { // 设置 cookie ctx.cookies.set(&#39;name&#39;, &#39;panda&#39;, { domain: &#39;panda.com&#39; }); ctx.cookies.set(&#39;age&#39;, 28, { maxAge: 10 * 1000, signed: true }); }); // 使用路由 app.use(router.routes()); app.listen(3000); 在 Koa 中将获取和设置 cookie 的方法都挂在了 ctx 上下文对象的 cookies 属性上，分别为 get 和 set。cookies.get 的参数为获取 cookie 的键名，返回值为键对应的值，cookies.set 的第一个参数同样为 cookie 的键名，第二个参数为键对应的值，第三个参数为一个对象，用来配置该条 cookie 的规则，如 domain、path 和过期时间等，这里 maxAge 值为毫秒数。注意：Koa 中设置的 cookie 默认不允许浏览器端通过 document.cookie 获取，但是服务器也可以被欺骗，比如使用 postman 发送一个带 Cookie 请求头的请求，服务器可以通过设置签名来预防，即添加 signed 选项并将值设置为 true。Koa 操作 cookie 方法的原理cookies 对象都是挂在 ctx 上来实现的，使用过 Koa 都知道如果要操作 ctx 就会用到中间件的思想，我们这就看看这两个方法使用原生封装的过程。/* Koa 中 ctx.cookies 对象 get 和 set 方法的原理 */ const Koa = require(&#39;koa&#39;); const querystring = require(&#39;querystring&#39;); const app = new Koa(); app.use(async (ctx, next) =&gt; { // 获取 cookie const get = key =&gt; { const cookies = ctx.get(&#39;cookie&#39;) || &#39;&#39;; return querystring.parse(result, &#39;; &#39;)[key]; }; // 设置 cookie，存储所有的 cookie，等于 setHeader 中的第二个参数 const cookies = []; const set = (key, val, options = {}) =&gt; { // 用于构造单条 cookie 和权限等设置的数组，默认存放这条 cookie 的键和值 const single = [key + &#39;=&#39; + encodeURIComponent(val)]; // 下面是配置 if (options.domain) { single.push(&#39;domain=&#39; + options.domain); } if (options.maxAge) { single.push(&#39;Max-Age=&#39; + options.maxAge); } if (options.path) { single.push(&#39;path=&#39; + options.path); } if (options.httpOnly) { single.push(&#39;HttpOnly=true&#39;); } // 将配置组合到 single 中后转为字符串存入 cookies cookies.push(single.join(&#39;; &#39;)); // 设置给浏览器 ctx.set(&#39;Set-Cookie&#39;, cookies); } // 将获取和设置 cookie 的方法挂在 cookies 对象上 ctx.cookies = { get, set }; await next(); }); 在 get 方法内部获取 cookie 请求头的值并根据传入的 key 获取值，set 方法内，将传入的键值和选项拼接成符合 cookie 的字符串，通过 Set-Cookie 响应头设置给浏览器。session 的基本使用Node.js 原生使用 session正常 session 是存放在数据库中的，我们这里为了方便就用一个名为 session 的对象来代替。/* 原生中使用 session */ const http = require(&#39;http&#39;); const uuid = require(&#39;uuid/v1&#39;); // 生成随字符串 const querystring = require(&#39;querystring&#39;); // 存放 session const session = {}; // 创建服务 http.createServer((req, res) =&gt; { if (req.url === &#39;/user&#39;) { // 取出 cookie 存储的用户 ID let userId = querystring.parse(req.headers[&#39;cookie&#39;], &#39;; &#39;)[&#39;study&#39;]; if (userId) { if (session[userId].studyCount === 0) res.end(&#39;您的学习次数已用完&#39;); session[userId].studyCount--; } else { // 生成 userId userId = uuid(); // 将用户信息存入 session session[userId] = { studyCount: 30 }; // 设置 cookie req.setHeader(&#39;Set-Cookie&#39;, [&#39;study=&#39; + userId]); } // 响应信息 res.end(&#39;您的用户 ID 为 &#39; + userId + &#39;，\\r\\n剩余学习次数为：&#39; + session[userId].studyCount); } else { res.end(&#39;Not Found&#39;); } }).listen(3000); 上面写的案例是一个网校的场景，一个新用户默认有 30 次学习机会，以后每次访问服务器学习次数减 1，如果 studyCount 值为 0，则提示学习次数用完，否则提示当前用户的 ID 和剩余学习次数，session 中存储的是每一个用户 ID 对应的剩余学习次数，这样就不会轻易的被修改学习剩余次数，因为服务器只认用户 ID，再通过 ID 去更改对应的剩余次数（当然忽略了别人冒充这个 ID 的情况，只能减，不能加），这样就不会因为篡改 cookie 而篡改用户存在 session 中的数据，除非连整个数据库都拖走。Koa 中使用 session我们接下来使用 Koa 实现和上面一摸一样的场景，在 Koa 的社区中提供了专门操作 session 的中间件 koa-session，使用前需安装。/* Koa 中使用 session */ const Koa = require(&#39;koa&#39;); const Router = require(&#39;koa-router&#39;); const session = requier(&#39;koa-session&#39;); const uuid = require(&#39;uuid/v1&#39;); // 创建服务和路由 const app = new Koa(); const router = new Router(); // cookie 的签名 app.keys = [&#39;panda&#39;]; // 使用 koa-session 中间件 app.use(session({ key: &#39;shen&#39;, maxAge: 10 * 1000 }, app)); router.get(&#39;/user&#39;, (ctx, next) =&gt; { // 取出 cookie 存储的用户 ID let userId = ctx.cookies.get(&#39;study&#39;); if (ctx.session.userId) { if (ctx.session[userId].studyCount === 0) res.end(&#39;您的学习次数已用完&#39;); ctx.session[userId].studyCount--; } else { // 生成 userId userId = uuid(); // 将用户信息存入 session ctx.session[userId] = { studyCount: 30 }; // 设置 cookie ctx.cookies.set(&#39;study&#39;, userId); } // 响应信息 ctx.body = &#39;您的用户 ID 为 &#39; + userId + &#39;，\\r\\n剩余学习次数为：&#39; + session[userId].studyCount }); // 使用路由 app.use(router.routes()); app.listen(3000); 使用 Koa 的 koa-session 以后，不再需要我们创建 session 对象进行存储，并且 cookie-session 中间件帮我们封装了 API 可以直接操作 mongo 和 MySQL 数据库，上面代码中与用原生相比还增加了 cookie 和 session 的签名和过期时间，比原生写起来要方便很多。总结本篇内容更偏向于 cookie 和 session 在 Node.js 中的使用，没有过多的叙述理论性的内容，cookie 和 session 是相互依存的，也就是说共同使用的，现在已经有 JWT 的方案来替代，因为相比较下有很多优点，但某些项目和特殊场景还在使用 cookie 和 session。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.overtaking.top/tags/cookie-session/"},{"name":"Koa","slug":"Koa","permalink":"https://www.overtaking.top/tags/Koa/"}]},{"title":"通过一个案例理解 JWT","date":"2018-08-16T06:11:46.000Z","path":"20180816141146/","text":"JWT 简述JWT（json web token）是为了在网络应用环境之间传递声明而基于 json 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。JWT 的应用场景JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 JWT，可以对用户身份、路由、服务和资源的访问权限进行验证。举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。而在 JWT 之前，这样的验证我们大多都是通过 cookie 和 session 去实现的，我们接下来就来对比以下这两种方式的不同。JWT 对比 cookie/sessioncookie/session 的过程：由于浏览器的请求是无状态的，cookie 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 session 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。cookie/session 的问题：从上面可以看出服务器植入 cookie 后每次请求都会带上 cookie，浪费带宽，而且 cookie 不支持跨域，不方便与其他的系统之间进行跨域访问，同时服务器会用 session 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 session 需要都拷贝过去。JWT 的过程：当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 session 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 sha256 和 RSA 等加密算法生成一个 token 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 token 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。JWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 cookie 不能跨域的问题。JWT 的结构JWT 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 token 就可以的，JWT 用于生成 token 的结构有三个部分，使用 . 隔开。HeaderHeader 头部中主要包含两部分，token 类型和加密算法，如 {typ: &#39;jwt&#39;, alg: &#39;HS256&#39;}，HS256 就是指 sha256 算法，会将这个对象转成 base64。PayloadPayload 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明。标准中注册的声明下面是标准中注册的声明，建议但不强制使用。iss：jwt 签发者；sub：jwt 所面向的用户；aud：接收 jwt 的一方；exp：jwt 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；nbf：定义在什么时间之前，该 jwt 都是不可用的；iat：jwt 的签发时间。上面的标准中注册的声明中常用的有 exp 和 nbf。公共声明公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 {&#39;id&#39;, username: &#39;panda&#39;, adress: &#39;Beijing&#39;}，会将这个对象转成 base64（可逆）。私有声明私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。SignatureSignature 这一部分指将 Header 和 Payload 通过密钥 secret 和加盐算法进行加密后生成的签名，secret 密钥保存在服务端，不会发送给任何人，所以 JWT 的传输方式是很安全的。最后将三部分使用 . 连接成字符串，就是要返回给浏览器的 token 浏览器一般会将这个 token 存储在 localStorge 以备其他需要验证用户身份的请求使用。经过上面对 JWT 的叙述可能还是没有完全的理解什么是 JWT，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 express 框架，数据库使用 mongo 来存储用户信息，前端使用 Vue 来实现，做一个登录页登录后进入订单页验证 token 的功能。文件目录 jwt-apply |- jwt-client | |- src | | |- views | | | |- Login.vue | | | |- Order.vue | | |- App.vue | | |- axios.js | | |- main.js | | |- router.js | |- .gitignore | |- babel.config | |- package.json |- jwt-server | |- model | | |- user.js | |- app.js | |- config.js | |- jwt-simple.js | |- package.json 服务端的实现在搭建服务端之前需要安装我们使用的依赖，这里我们使用 yarn 来安装，命令如下：$ yarn add express body-parse mongoose jwt-simple 配置文件/* 文件位置：~jwt-apply/jwt-server/config.js */ module.exports = { // 操作 mongo 自动生成这个数据库 &#39;db_url&#39;: &#39;mongodb://localhost:27017/jwt&#39;, &#39;secret&#39;: &#39;pandashen&#39; // 密钥 }; 上面配置文件中，db_url 存储的是 mango 数据库的地址，操作数据库自动创建，secret 是用来生成 token 的密钥。创建数据库模型/* 文件位置：~jwt-apply/jwt-server/model/user.js */ // 操作数据库的逻辑 const mongoose = require(&#39;mongoose&#39;); const { db_url } = require(&#39;../config&#39;); // 连接数据库，端口默认 27017 mongoose.connect(db_url, { useNewUrlParser: true // 去掉警告 }); // 创建一个骨架 Schema，数据会按照这个骨架格式存储 const UserSchema = new mongoose.Schema({ username: String, password: String }); // 创建一个模型 module.exports = mongoose.model(&#39;User&#39;, UserSchema); 我们将连接数据库、定义数据库字段和值类型以及创建数据模型的代码统一放在了 model 文件夹下的 user.js 当中，将数据模型导出方便在服务器的代码中进行查找操作。实现基本服务/* 文件位置：~jwt-apply/jwt-server/app.js */ const express = require(&#39;express&#39;); const bodyParser = require(&#39;body-parser&#39;); const jwt = require(&#39;jwt-simple&#39;); const User = require(&#39;./model/user&#39;); const { secret } = require(&#39;./config&#39;); // 创建服务器 const app = express(); /** * 设置中间件 */ /** * 注册接口 */ /** * 登录接口 */ /** * 验证 token 接口 */ // 监听端口号 app.listen(3000); 上面是一个基本的服务器，引入了相关的依赖，能保证启动，接下来添加处理 post 请求的中间件和实现 cors 跨域的中间件。添加中间件/* 文件位置：~jwt-apply/jwt-server/app.js */ // 设置跨域中间件 app.use((req, res, next) =&gt; { // 允许跨域的头 res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); // 允许浏览器发送的头 res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type,Authorization&#39;); // 允许哪些请求方法 res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;GET,POST,PUT,DELETE,OPTIONS&#39;); // 如果当前请求是 OPTIONS 直接结束，否则继续执行 req.method === &#39;OPTIONS&#39; ? res.end() : next(); }); // 设置处理 post 请求参数的中间件 app.use(bodyParser.json()); 之所以设置处理 post 请求参数中间件是因为注册和登录都需要使用 post 请求，设置跨域中间件是因为我们项目虽小也是前后端分离的，需要用前端的 8080 端口访问服务器的 3000 端口，所以需要服务端使用 cors 处理跨域问题。注册接口的实现/* 文件位置：~jwt-apply/jwt-server/app.js */ // 注册接口的实现 app.post(&#39;/reg&#39;, async (req, res, next) =&gt; { // 获取 post 请求的数据 let user = req.body; // 错误验证 try { // 存入数据库，添加成功后返回的就是添加后的结果 user = await User.create(user); // 返回注册成功的信息 res.json({ code: 0, data: { user: { id: user._id, username: user.username } } }); } catch (e) { // 返回注册失败的信息 res.json({ code: 1, data: &#39;注册失败&#39; }); } }); 上面将用户注册的信息存入了 mongo 数据库，返回值为存入的数据，如果存入成功，则返回注册成功的信息，否则返回注册失败的信息。登录接口的实现/* 文件位置：~jwt-apply/jwt-server/app.js */ // 用户能登录 app.post(&#39;/login&#39;, async (req, res, next) =&gt; { let user = req.body; try { // 查找用户是否存在 user = await User.findOne(user); if (user) { // 生成 token const token = jwt.encode({ id: user._id, username: user.username, exp: Date.now() + 1000 * 10 }, secret); res.json({ code: 0, data: { token } }); } else { res.json({ code: 1, data: &#39;用户不存在&#39; }); } } catch (e) { res.json({ code: 1, data: &#39;登录失败&#39; }); } }); 登录的过程中会先拿用户的账号和密码进数据库中进行验重和查找，如果存在，则登录成功并返回 token，如果不存在则登录失败。token 校验接口/* 文件位置：~jwt-apply/jwt-server/app.js */ // 只针对 token 校验接口的中间件 const auth = (req, res, next) =&gt; { // 获取请求头 authorization const authorization = req.headers[&#39;authorization&#39;]; // 如果存在，则获取 token if (authorization) { const token = authorization.split(&#39; &#39;)[1]; try { // 对 token 进行校验 req.user = jwt.decode(token, secret); next(); } catch (e) { res.status(401).send(&#39;Not Allowed&#39;); } } else { res.status(401).send(&#39;Not Allowed&#39;); } } // 用户可以校验是否登录过，通过请求头 authorization: Bearer token app.get(&#39;/order&#39;, auth, (req, res, next) =&gt; { res.json({ code: 0, data: { user: req.user } }); }); 在校验过程中，每次浏览器都会将 token 通过请求头 authorization 带给服务器，请求头的值为 Bearer token，这是 JWT 规定的，服务器取出 token 使用 decode 方法进行解码，并使用 try...catch 进行捕获，如果解码失败则会触发 try...catch，说明 token 过期、被篡改、或被伪造，返回 401 响应。前端的实现我们使用 3.0 版本的 vue-cli 脚手架生成 Vue 项目，并安装 axios 发送请求。$ yarn add global @vue/cli $ yarn add axios 入口文件/* 文件位置：~jwt-apply/jwt-client/src/main.js */ import Vue from &#39;vue&#39;; import App from &#39;./App.vue&#39;; import router from &#39;./router&#39;; // 是否为生产模式 Vue.config.productionTip = false new Vue({ router, render: h =&gt; h(App) }).$mount(&#39;#app&#39;); 上面这个文件是 vue-cli 自动生成的，我们并没有做改动，但是为了方便查看我们会将主要文件的代码一一贴出来。主组件 App&lt;!-- 文件位置：~jwt-apply/jwt-client/src/App.vue --&gt; &lt;template&gt; &lt;div id=&#39;app&#39;&gt; &lt;div id=&#39;nav&#39;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; | &lt;router-link to=&quot;/order&quot;&gt;订单&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;/template&gt; 在主组件中我们将 router-link 分别对应了 /login 和 /order 两个路由。路由配置/* 文件位置：~jwt-apply/jwt-client/src/router.js */ import Vue from &#39;vue&#39;; import Router from &#39;vue-router&#39;; import Login from &#39;./views/Login.vue&#39;; import Order from &#39;./views/Order.vue&#39;; Vue.use(Router); export default new Router({ mode: &#39;history&#39;, base: process.env.BASE_URL, routes: [ { path: &#39;/login&#39;, name: &#39;login&#39;, component: Login }, { path: &#39;/order&#39;, name: &#39;order&#39;, component: Order } ] }); 我们定义了两个路由，一个对应登录页，一个对应订单页，并引入了组件 Login 和 Order，前端并没有写注册模块，可以使用 postman 发送注册请求生成一个账户以备后面验证使用。登录组件 Login&lt;!-- 文件位置：~jwt-apply/jwt-client/src/views/Login.vue --&gt; &lt;template&gt; &lt;div class=&quot;login&quot;&gt; 用户名 &lt;input type=&quot;text&quot; v-model=&quot;user.username&quot;&gt; 密码 &lt;input type=&quot;text&quot; v-model=&quot;user.password&quot;&gt; &lt;button @click=&quot;login&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from &#39;../axios&#39; export default { data() { return { user: { username: &#39;&#39;, password: &#39;&#39; } } }, methods: { login() { // 发送请求访问服务器的登录接口 axios.post(&#39;/login&#39;, this.user).then(res =&gt; { // 将返回的 token 存入 localStorage，并跳转订单页 localStorage.setItem(&#39;token&#39;, res.data.token); this.$router.push(&#39;/order&#39;); }).catch(err =&gt; { // 弹出错误 alert(err.data); }); } } } &lt;/script&gt; Login 组件中将两个输入框的值同步到 data 中，用来存放账号和密码，当点击提交按钮时，触发点击事件 login 发送请求，请求成功后将返回的 token 存入 localStorage，并跳转路由到订单页，请求错误时弹出错误信息。订单组件 Order&lt;!-- 文件位置：~jwt-apply/jwt-client/src/views/Order.vue --&gt; &lt;template&gt; &lt;div class=&quot;order&quot;&gt; {{username}} 的订单 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from &#39;../axios&#39; export default { data() { return { username: &#39;&#39; } }, mounted() { axios.get(&#39;/order&#39;).then(res =&gt;{ this.username = res.data.user.username; }).catch(err =&gt; { alert(err); }); } } &lt;/script&gt; Order 页面显示的内容是 “XXX 的订单”，在加载 Order 组件被挂载时发送请求获取用户名，即访问服务器的验证 token 接口，因为订单页就是一个涉及到验证用户的页面，当请求成功时，将用户名同步到 data，否则弹出错误信息。在 Login 和 Order 两个组件中对请求的回调内似乎写的太简单了，其实是因为 axios 的返回值会在服务器返回的返回值外面包了一层，存放一些 http 响应的相关信息，两个接口访问时请求地址也是同一个服务器，而且在服务器响应时的错误处理都是对状态吗 401 的处理，在涉及验证用户信息的请求中需要设置请求头 Authorization 发送 token。这些逻辑我们似乎在组件请求相关的代码中都没有看到，是因为我们使用 axios 的 API 设置了 baseURL 请求拦截和响应拦截，细心可以发现其实引入的 axios 并不是直接从 node_modules 引入，而是引入了我们自己的导出的 axios。axios 配置/* 文件位置：~jwt-apply/jwt-client/src/axios.js */ import axios from &#39;axios&#39;; import router from &#39;./router&#39;; // 设置默认访问地址 axios.defaults.baseURL = &#39;http://localhost:3000&#39;; // 响应拦截 axios.interceptors.response.use(res =&gt; { // 报错执行 axios then 方法错误的回调，成功返回正确的数据 return res.data.code !== 0 ? Promise.reject(res.data) : res.data; }, res =&gt; { // 如果 token 验证失败则跳回登陆页，并执行 axios then 方法错误的回调 if (res.response.status === 401) { router.history.push(&#39;/login&#39;); } return Promise.reject(&#39;Not Allowed&#39;); }); // 请求拦截，用于将请求统一带上 token axios.interceptors.request.use(config =&gt; { // 在 localStorage 获取 token const token = localStorage.getItem(&#39;token&#39;); // 如果存在则设置请求头 if (token) { config.headers.Authorization = &#39;Bearer &#39; + token; } return config; }); export default axios; 访问服务器时会将 axios 中的第一个参数拼接在 axios.defaults.baseURL 的后面作为请求地址。axios.interceptors.response.use 为响应拦截，axios 发送请求后所有的响应都会先执行这个方法内部的逻辑，返回值为数据，作为参数传递给 axios 返回值的 then 方法。axios.interceptors.request.use 为请求拦截，axios 发送的所有请求都会先执行这个方法的逻辑，然后发送给服务器，一般用来设置请求头。jwt-simple 模块的实现原理相信通过上面的过程已经非常清楚 JWT 如何生成的，token 的格式是怎样的，如何跟前端交互去验证 token，我们在这些基础上再深入的研究一下 token 的整个生成过程和验证过程，我们使用的 jwt-simple 模块的 encode 方法如何生成 token，使用 decode 方法如何验证 token，下面就看看一看 jwt-simple 的实现原理。创建模块/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */ const crypto = require(&#39;crypto&#39;); /** * 其他方法 */ // 创建对象 module.exports = { encode, decode }; 我们知道 jwt-simple 我们使用的有两个方法 encode 和 decode，所以最后导出的对象上有这两个方法，使用加盐算法进行签名需要使用 crypto，所以我们提前引入。字符串和 Base64 互相转换/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */ // 将子子符串转换成 Base64 function stringToBase64(str) { return Buffer.from(str).toString(&#39;base64&#39;); } // 将 Base64 转换成字符串 function base64ToString(base64) { return Buffer.from(base64, &#39;base64&#39;).toString(&#39;utf8&#39;); } 从方法的名字相信很容易看出用途和参数，所以就一起放在这了，其实本质是在两种编码之间进行转换，所以转换之前都应该先转换成 Buffer。生成签名的方法/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */ function createSign(str, secret) { // 使用加盐算法进行加密 return crypto.createHmac(&#39;sha256&#39;, secret).update(str).digest(&#39;base64&#39;); } 这一步就是通过加盐算法使用 sha256 和密钥 secret 进行生成签名，但是为了方便我们把使用的加密算法给写死了，正常情况下是应该根据 Header 中 alg 字段的值去检索 alg 的值与加密算法名称对应的 map，去使用设置的算法生成签名。encode/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */ function encode(payload, secret) { // 头部 const = stringToBase64(JSON.stringify({ typ: &#39;JWT&#39;, alg: &#39;HS256&#39; })); // 负载 const content = stringToBase64(JSON.stringify(payload)); // 签名 const sign = createSign([header, content].join(&#39;.&#39;), secret); // 生成签名 return [header, content, sign].join(&#39;.&#39;); } 在 encode 中将 Header、Payload 转换成 base64，通过 . 连接在一起，然后使用 secret 密钥生成签名，最后将 Header 和 Payload 的 base64 通过 . 和生成的签名连接在一起，这就形成了 “明文” + “明文” + “暗文” 三段格式的 token。decode/* 文件位置：~jwt-apply/jwt-server/jwt-simple.js */ function decode(token, secret) { let [header, content, sign] = token.split(&#39;.&#39;); // 将接收到的 token 的前两部分（base64）重新签名并验证，验证不通过抛出错误 if (sign !== createSign([header, content].join(&#39;.&#39;), secret)) { throw new Error(&#39;Not Allow&#39;); } // 将 content 转成对象 content = JSON.parse(base64ToString(content)); // 检测过期时间，如果过去抛出错误 if (content.exp &amp;&amp; content.exp &lt; Date.now()) { throw new Error(&#39;Not Allow&#39;); } return content; } 在验证方法 decode 中，首先将 token 的三段分别取出，并用前两段重新生成签名，并与第三段 sign 对比，相同通过验证，不同说明篡改过并抛出错误，将 Payload 的内容重新转换成对象，也就是将 content 转换成对象，取出 exp 字段与当前时间对比来验证是否过期，如果过期抛出错误。总结在 JWT 生成的 token 中，前两段明文可解，这样别人拦截后知道了我们的加密算法和规则，也知道我们传输的信息，也可以使用 jwt-simple 加密一段暗文拼接成 token 的格式给服务器去验证，为什么 JWT 还这么安全呢，这就说到了最最重点的地方，无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证是因为无法获取服务器的密钥 secret，真正能保证安全的就是 secret，同时证明了 Header 和 Payload 并不安全，可以被破解，所以不能存放敏感信息。","tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.overtaking.top/tags/cookie-session/"},{"name":"JWT","slug":"JWT","permalink":"https://www.overtaking.top/tags/JWT/"},{"name":"Vue","slug":"Vue","permalink":"https://www.overtaking.top/tags/Vue/"}]},{"title":"MySQL —— 简单聊一聊数据库设计","date":"2018-08-14T05:12:41.000Z","path":"20180814131241/","text":"前言这是关于 MySQL 系列文章的第三篇，本篇在 MySQL 使用的基础上做一个小小的升华，来简单聊一聊数据库的设计，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。系列文章：MySQL —— 数据库基础MySQL —— SQL 语句总结为什么设计数据库说到为什么要设计数据库，就要说到数据的完整性，我们要在设计数据库时保证域的完整性和实体的完整性，同时从性能出发，我们要保证最大限度的节省存储空间，比如一张成绩表，上面没必要存储学生的姓名、年龄等信息，只需要存储成绩，如果一个数据库设计的合理，最后的结果就是方便我们对数据库的开发和扩展。如果是一个 “糟糕” 的数据库设计会造成一系列的不良反应，比如数据冗余，存储空间浪费，内存浪费，有时甚至会造成数据插入和更新的异常，比如学生表存了学生信息，而成绩表也存了，这样在修改时没有全部修改就会出现错误。软件项目开发中数据库设计的生命周期软件项目开发中数据库设计的生命周期可大概分为以下几个阶段：需求分析阶段，分析客户的业务和数据处理需求；概要设计阶段，设计数据库 E-R 模型图，确认需求的正确和完整性；详细设计阶段，应用三大范式审核数据库；代码编写阶段，物理实现数据库，编码实现应用；软件测试阶段；安装部署阶段。上面数据库的设计经历了从 “现实世界” 到 “信息世界” 到 “数据库模型” 再到 “数据库” 产生的一个完整过程。设计数据库的步骤收集信息：收集信息其实就是与相关人员进行交流、访谈、调研，充分了解用户需求，理解整个项目的完整流程，并理解数据库需要完成的任务，这部分工作大部分由需求人员完成，并根技术人员进行对接。标识实体和实体属性：开发人员在明确需求和流程之后，标识数据库的实体，比如学生信息表，每一条实体中应该由哪些字段组成，成绩表中实体由哪些字段组成等等。标识实体之间的关系：其实就是通过表之间的某字段对表进行关联，对表的实体之间建立对应关系，如学生表的 id 字段会关联成绩表的 student_id 字段，用来查找某个学生的成绩。数据库 E-R 图E-R 图基本概念E-R 图也叫做实体关系图，是指用实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据的概念模型。E-R 图的实体：即数据模型中的数据对象，每一张表就是一个 E-R 图的实体。E-R 图的属性：即数据对象中所具有的属性，例如学生表的学生、姓名、年龄等，属性又分为唯一属性和非唯一属性，唯一属性如经过唯一约束和主键约束的属性，不可重复，其他的都是非唯一属性。E-R 图的关系：用来表示每一个数据对象与数据对象之间的联系，即每一个实体之间的联系，例如学生表和成绩表之间的联系，因为每个学生都有自己的成绩。E-R 图的关联关系1 对 1 （1 : 1）1 对 1 关系是指对于实体集 A 和 实体集 B，A 中的每一个实体最多与 B 中的一个实体有关系，反之在实体集 B 中的每一个实体之多与实体集 A 中的一个实体有关系。1 对 1 关系图1 对多（1 : N）1 对多关系是指实体集 A 与实体集 B 中至少有 N (N &gt; 0) 个实体有关系，并且实体集 B 中最多与实体集 A 中的一个实体有关系。1 对多关系图多对多（M : N）多对多关系是指实体集 A 中的每一个实体与实体集 B 中至少有 M (M &gt; 0) 个实体有关系，并且实体集 B 中的每一个实体与实体集 A 中至少有 N (N &gt; 0) 个实体有关系。多对多关系图数据库设计的三大范式确保每列的原子性如果每列都是不可再分的最小单元信息，则满足第一范式，比如下图中，地址是由国家和城市组成的，显然可以继续在拆分成两个列，国家和城市，是不满足第一范式的，需要将地址列差分成国家和城市两个列。原子性事例举一个简单的例子，我们平时在淘宝购物的时候需要添加地址，在填写新地址时，都是让我们选择国家、省、城市、区、街道、小区这样的方式，而不是让我们自己将这些地址写在一起，其原因就是因为淘宝的数据库设计严格遵循每列的原子性，这样的提交可以方便后端获取每一个列的信息在数据库中进行存储。每张表只能描述一件事情如下图中所示，在左侧的表中，描述了学生信息和课程信息，这明显是两件事情，假设再有一张成绩表，也要描述学生信息，课程信息和成绩等多件事情，就会造成数据的重复、冗余，也可能会导致更新、插入、删除数据异常的现象。每个表描述一件所以正确的做法是应该将左侧表差分成两张表分别为学生表和课程表，并使用学生编号与课程编号进行关联。其他列都不传递依赖于主键列其他列都不传递依赖于主键列的意思是表中各列必须都与主键直接相关，不能间接相关，从下图左表可以看出，学生编号为主键，年级 ID 也应该为主键，正常应该通过学生编号找到年级 ID，再找到年级名称，这样年级名称与学生编号之间就形成了一个传递并且依赖于主键年级 ID，即年级 ID 做为主键在中间隔了一层，这样就使年级名称与主键学生编号间接相关，如果在同一张表中，所有的字段都是应该直接依赖于主键，而不是再通过其他的主键传递。其他列都不传递依赖于主键列如果一个表中表述了多件事情并有多个作为主键的列，与上一条的处理方式相同，应该拆成多张表，并且每张表只有一个主键列。RBAC 基于角色的访问控制RBAC 的含义RBAC（Role-Based Access Control）基于角色的访问控制，就是用户通过角色与权限进行关联，简单的说，一个用户拥若干个角色，每个角色拥有若干个权限，这样就构造成了 “用户 → 角色 → 权限 → 资源” 的授权模型，在这个模型中，用户与角色之间，角色与权限之间，权限与资源之间，一般都是多对多的关系，在 RBAC 中最重要的概念主要有四部分，就是用户（User）、角色（Role）、权限（Permission）和资源（Resource）。RBAC 的安全原则最小权限原则：最小权限原则之所以被 RBAC 所支持，是因为 RBAC 可以将其角色配置成完成任务所需要的最小的权限集；责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一个帐目；数据抽象原则：数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限。RBAC 的 E-R 图之前说 RBAC 最重要的概念由四部分，其实体现在数据库的表中有主要三部分，因为角色和用户是重叠的，那么主要有三张表分别为用户表、权限表和资源表，其中用户表与权限表之间有一张关联表，权限表与资源表之间有一张关联表，E-R 图如下。RBAC 的 E-R 图事务为什么需要事务？在生活中我们经常使用银行转账或者支付宝和微信支付，这种操作每一次至少影响两个用户的数据信息，比如一方给另一方转钱，如果成功则转钱方余额减去转出金额，而收钱方余额增加收到的金额，这应该是一个请求操作了数据表中的俩个实体，如果在两个操作数据的环节任意一个失败了，都会影响两个人数据的正确性，这种时候需要两个操作同时失败或同时成功，就是说有一个操作出现失败的情况，即使另一个成功了也需要进行回滚操作，这就是事务的由来。什么是事务事务是作为单个逻辑工作单元执行的一系列操作，多个操作作为一个整体向系统提交，要么都执行，要么都不执行，是一个不可分割的工作逻辑单元。转账过程就是一个整体，它需要两条 UPDATE 语句，如果任何一个出错，则整个转账业务取消，两个账户的余额都恢复到原来的数据（回滚），确保总余额不变。这里再举一个例子，有一个上传文件的功能，后端接收到文件流时是需要先写入的，当写入成功后，会将上传成功的结果返回给客户端，如果文件很大，写入的时间就会长，如果在此期间突然写入失败，则会删除之前写入的内容，将整个操作回滚到写入之前，这里面主要两步操作，创建一个新文件并写入，写入成功删除旧文件，如果写入失败，两个操作将会同时失败，即不会删除旧文件，这也是一个事务的例子，只是没有转账那么明显。事务的特性 ACID事务具有以下特性，被简称为 ACID：原子性（Atomicity）：事务是一个完整的操作，事务各个部分是不可分的，要么都执行，要么都不执行；一致性（Consistency）：当事务完成后，数据必须处理完整的状态；隔离性（Isolation）：并发事务彼此隔离、独立，它不应该以任何方式依赖于其它事务；持久性（Durability）：事务完成后，它对数据库的修改被永久保持。如何创建事务创建表创建表 account，id 列为主键列，name 列为姓名，balance 为余额。CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL, `balance` INT(11) DEFAULT 0 PRIMARY KEY (`id`) ); 添加数据将表 account 添加两条数据，分别为 “张三” 和 “李四”，余额都为 100。INSERT INTO `student` (`name`, `balance`) VALUES (&quot;张三&quot;, 100); INSERT INTO `student` (`name`, `balance`) VALUES (&quot;李四&quot;, 100); 使用 Node.js 实现事务/* 一个非常简单的事务 */ const mysql = require(&#39;mysql&#39;); // 创建数据库连接 const connection = mysql.createConnection({ host: &#39;localhost&#39;, // 主机名 port: &#39;3306&#39;, // 数据库服务端口号 username: &#39;root&#39;, // 数据库名称 pwd: &#39;123456&#39;, // 数据库密码 database: &#39;school&#39; // 连接的数据库名称 }); connection.connect(); // 开启事务 connection.beginTransaction(err =&gt; { // 回调参数为错误对象，返回结果，返回字段描述 connection.query(&#39;UPDATE account SET balance - 50 WHERE id = 1&#39;, (err, result, fields) =&gt; { if (err) { connection.rollback(); // 如果失败直接回归 } else { connection.query(&#39;UPDATE account SET balance + 50 WHERE id = 1&#39;, (err, result, fields) =&gt; { err ? connection.rollback() : connection.commit(); }); } }); }); 总结到此关于 MySQL 的系列文章就告一段落了，希望前端的同学们在看了这几篇文章后对你们入门 MySQL 有一些帮助，那这几篇的文章就达到目的了，也欢迎后端的小伙伴来指出文章中的错误和不足。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.overtaking.top/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.overtaking.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL —— SQL 语句总结","date":"2018-08-09T03:52:45.000Z","path":"20180809115245/","text":"前言这是关于 MySQL 系列文章的第二篇，本篇大部分内容都贴近开发中的实际操作，，还有一句话不得不再次赘述，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门，这也是我的学习笔记，希望可以帮助大家。系列文章：MySQL —— 数据库基础MySQL —— 简单聊一聊数据库设计准备数据还记得在上一篇的最后我们使用 DDL 创建了完整的表关系，student、score 和 course 三张表如下图。完整表关系图其中 score 是外键表，创建外键约束关联了两张主键表 scudent 和 cource，接下来的 SQL 语句都是基于这几张表来进行的。SQL 的组成DDLDDL（data definition language）是数据定义语言，主要命令有 CREATE、ALTER、DROP 等，DDL 主要用在定义或改变数据表（TABLE）的结构、数据类型、表之间的链接和约束等初始化工作上，大多数在建立表时使用，在上一篇中 DDL 操作表的部分着重做了介绍并创建数据表，也可以将存储 DDL 语句的文件存储在 .sql 后缀名结尾的文件当中，在 DBMS 数据管理系统中导入，直接创建数据库。DMLDML（data manipulation language）是数据操做语言，通过 DML 语句对数据库数据表中的实体进行增、删、改、查，数据量非常大时，我们不可能使用 DBMS 一条一条的操作数据，所以都是通过代码完成操作，DML 是在学习 MySQL 数据库中最最重要的内容，也是本篇的重点，后面会非常详细的说明。DCLDCL（data control language）是数据库控制语言，用来设置或更改数据库用户或角色权限的语句，包括 grant、revoke 等，grant 是授权命令，revoke 是收回权限命令。SQL 运算符SQL 元算符分为算术运算符、逻辑运算符和比较运算符，是用来完成列之间或者变量之间的比较和运算的。算术运算符运算符说明+加运算，求两个数或表达式相加的和，如 1 + 1-减运算，求两个数或表达式相减的差，如 4 - 1\\*乘运算，求两个数或表达式相乘的积，如 2 * 2\\除运算，求两个数或表达式相除的商，如 6 / 4%取模运算，求两个数或表达式相除的余数，如 6 % 4逻辑运算符运算符说明AND当且仅当两个布尔表达式都为 true 时，返回 trueOR当且仅当两个布尔表达式都为 false 时，返回 falseNOT布尔表达式的值取反比较运算符运算符说明=等于&gt;大于&lt;小于&gt;=大于等于&lt;=小于等于&lt;&gt;不等于!=不等于&lt;=&gt;安全不等于SQL 语句之数据增、删、改插入数据行语法：INSERT [INTO] 表名 [(列名)] VALUES (值列表) 给上面的 student 表插入一条数据，姓名为张三，卡号为 100，年龄为 20，城市默认为北京。INSERT INTO `student` (`name`, `idcard`, `age`, `city`) VALUES (&quot;张三&quot;, &quot;100&quot;, 20, NULL); 注意事项：每次插入一行数据，不能只插入一部分数据，即不能只插入了一个实体的某几列，插入的数据是否有效将严格按照实体的完整性要求来检验；每个数据值的数据类型、精度、位数必须要与对应的列名精确匹配，严格按照域的完整性要求来检验；不能为标识符指定值（规定），例如作为主键自增的标识列；如果某字段设置非空约束，则该列必须插入不为 null 的数据；插入数据时还要符合检查性约束的要求，如非空约束、唯一约束等；设置了默认值的列，有缺省值时，可以使用 DEFAULT 关键字来代替插入的实际值。更新数据行语法：UPDATE 表名 SET 列名 = 更新值 [WHERE &lt;更新条件&gt;] 将 student 表中 id 为 1 的实体的 idcard 列值改为 200，age 列值改为 24。UPDATE `student` SET `idcard` = &quot;200&quot;, `age` = 24 WHERE `id` = 1 AND `name` = &quot;张三&quot;; 将 student 表中 city 列为空的实体 city 列的值设置为 “上海”。UPDATE `student` SET `city` = &quot;上海&quot; WHERE `city` IS NULL; 注意事项：更新多列时，列赋值语句之间使用逗号分隔，一定要加更新条件，否则会更新所有的行；多个联合条件根据逻辑关系使用 AND 或 OR 连接。删除数据行语法：DELETE [FROM] 表名 [WHERE &lt;删除条件&gt;] 删除 student 表中 age 列值为 24 或者 idcard 列值为 200 的实体。DELETE FROM `student` WHERE `age` = 24 OR `idcard` = 200; 注意事项：删除的是一整行的数据，所以不需要提供列名；如果要删除主表数据，则要先删除外键连接对应的子表数据。SQL 语句之数据查询在 SQL 语句的增、删、改、查中，最繁琐和复杂的就是查询语句，在实际开发中七分查询三分增、删、改的说法一点也不为过，查询语句是在业务中使用最多的语句，所以我们将查询语句与增、删、改分离出来，用这单独的一节来叙述。查询简介查询就是从客户端发出查询，请求数据库服务器，并从数据库返回查询结果的过程，每次执行查询只是从数据表中提取数据，并按照表的方式呈现出来，查询产生的虚拟表并不会保存。查询语法SELECT &lt;列名&gt; FROM &lt;表名&gt; [WHERE &lt;查询条件表达式&gt;] [ORDER BY &lt;排序的列名&gt; [ASC 或 DESC]] LIMIT &lt;起始索引&gt;, &lt;查询条数&gt;; 我们继续操作之前的三张表，查询 “北京” 的学生并按 id 的正序排序。SELECT * FROM `student` WHERE `city` = &quot;北京&quot; ORDER BY `id` ASC; 上面 SQL 语句中的 * 代表查询表中所有的列，如果查找某些列，列名之间用 , 分隔。别名在查询数据表的某个列的时候可以通过别名改变查询到虚拟表列的名称，在列的后面使用 AS 关键字加上别名，AS 可以省略。SELECT `name`, `age`, `city` AS `城市` FROM `student` WHERE `city` = &quot;北京&quot; ORDER BY `id` DESC; 查询空行假设表中的某一列值为 null，我们可以通过 IS 关键字查询这一列值为空的数据。SELECT `name`, `age`, `city` FROM `student` WHERE `city` IS NULL ORDER BY `id` DESC; 常量列查询一个数据表中没有的列，我们可以在查询时将这一列增加为常量列，如 city 的值都是中国的，我们可以增加一个常量列值都为 “中国”，列名为 country。SELECT `name`, `age`, `city`, &quot;中国&quot; AS `country` FROM `student`; 查询列的不重复数据假设查询 student 表中同学们来自那些城市，正常按照 city 列查询，有多条数据的 city 列都来自同一个城市，我们可以使用 DISTINCT 关键字，只保留一个。SELECT DISTINCT `city` FROM `student`; 限制查询条数LIMIT 关键字用来限制查询返回的条数，后面的值为数字，下面查询 student 表，只返回 3 条数据。SELECT * FROM `student` LIMIT 3; 当 LIMIT 参数大于一个时，第一个参数代表起始的索引（跳过的条数），第二个参数代表返回的条数，中间用 , 隔开，还是查询 student 表，返回第 4 到 6 条数据。SELECT * FROM `student` LIMIT 3, 3; 运算符在查询中的使用SELECT 1 + 1; -- 2 SELECT 1 + &quot;1&quot;; -- 2 SELECT 1 + &quot;panda&quot;; -- 1 SELECT 1 + NULL; -- NULL 通过上面的例子可以看出在 SQL 语句中，使用算术运算符相加无法起到字符串拼接的作用，会将值转化为数字进行计算，字符串转为数字 0，数字与 null 相加结果为 null，没意义。查询语句练习案例首先我们将上面的三张表 student，cource 和 score 三张表插入数据。-- 给 student 表插入数据 INSERT INTO `student` VALUES (&quot;1&quot;, &quot;郭靖&quot;, &quot;1&quot;, &quot;40&quot;, &quot;济南&quot;, &quot;山东省&quot;, &quot;1978-09-03&quot;, 1, &quot;1@qq.com&quot;); INSERT INTO `student` VALUES (&quot;2&quot;, &quot;黄蓉&quot;, &quot;2&quot;, &quot;36&quot;, &quot;济南&quot;, &quot;山东省&quot;, &quot;1982-09-03&quot;, 0, &quot;2@qq.com&quot;); INSERT INTO `student` VALUES (&quot;3&quot;, &quot;杨过&quot;, &quot;3&quot;, &quot;22&quot;, &quot;终南山&quot;, &quot;陕西省&quot;, &quot;1996-09-03&quot;, 1, &quot;3@qq.com&quot;); INSERT INTO `student` VALUES (&quot;4&quot;, &quot;小龙女&quot;, &quot;4&quot;, &quot;28&quot;, &quot;终南山&quot;, &quot;陕西省&quot;, &quot;1990-09-03&quot;, 0, &quot;4@qq.com&quot;); INSERT INTO `student` VALUES (&quot;5&quot;, &quot;欧阳锋&quot;, &quot;5&quot;, &quot;70&quot;, &quot;白驼山&quot;, &quot;新疆&quot;, &quot;1948-09-03&quot;, 1, &quot;5@qq.com&quot;); -- 给 cource 表插入数据 INSERT INTO `course` VALUES (&quot;1&quot;, &quot;语文&quot;); INSERT INTO `course` VALUES (&quot;2&quot;, &quot;数学&quot;); INSERT INTO `course` VALUES (&quot;3&quot;, &quot;英语&quot;); -- 给 score 表插入数据 INSERT INTO `score` VALUES (&quot;1&quot;, &quot;1&quot;, &quot;100&quot;); INSERT INTO `score` VALUES (&quot;1&quot;, &quot;2&quot;, &quot;90&quot;); INSERT INTO `score` VALUES (&quot;1&quot;, &quot;3&quot;, &quot;70&quot;); INSERT INTO `score` VALUES (&quot;2&quot;, &quot;1&quot;, &quot;100&quot;); INSERT INTO `score` VALUES (&quot;2&quot;, &quot;2&quot;, &quot;40&quot;); INSERT INTO `score` VALUES (&quot;2&quot;, &quot;3&quot;, &quot;80&quot;); INSERT INTO `score` VALUES (&quot;3&quot;, &quot;1&quot;, &quot;100&quot;); INSERT INTO `score` VALUES (&quot;3&quot;, &quot;2&quot;, &quot;60&quot;); INSERT INTO `score` VALUES (&quot;3&quot;, &quot;3&quot;, &quot;80&quot;); 添加数据后的三张表如下图：表的具体数据查询山东省学生的全部信息：SELECT * FROM `student` WHERE `province` = &quot;山东&quot;; 查询山东省男学生的全部信息：SELECT * FROM `student` WHERE `province` = &quot;山东&quot; AND `gender` = 1; 查询没填写电子邮箱学生的姓名和身份证号：SELECT `name`, `idcard` FROM `student` WHERE `email` IS NULL; 把学生的成绩按升序排列：SELECT * FROM `score` ORDER BY `grade` ASC; 课程编号升序排列，成绩降序排列：SELECT * FROM `score` ORDER BY `course_id` ASC, `grade` DESC; SQL 语句之模糊查询在上一节中我们所使用的查询叫 “完整查询” 或 “精准查询”，而本节的 “模糊查询” 是指查询条件不明确，可以尽量多的匹配满足查询条件的数据。通配符“通配符” 用于代替一个或多个真正的字符，与 LIKE 关键字一起使用，通配符的解释、示例如下表。通配符解释示例符合条件的值_一个任意字符LIKE \"a_\"as、ad 等%任意长度的字符串LIKE \"c%\"code、cat 等[ ]括号中所指定范围内的一个字符LIKE \"1[35]5\"135 或 155[^]不再括号中所指定范围内的一个字符LIKE \"1[^1-2]5\"135 或 155 等查询 student 表中 email 列是 qq 邮箱的学生信息。SELECT * FROM `student` WHERE `emai` LIKE `%qq%`; 查询 student 表中姓杨的名字为两个字的所有学生信息。SELECT * FROM `student` WHERE `name` LIKE &quot;杨_&quot;; BETWEEN…AND…BETWEEN...AND... 用于查询某一列在指定范围内的记录，包括两个边界。查询 score 表中成绩在 80 到 90 范围内的所有学生信息。-- 精准查询 SELECT * FROM `score` WHERE `grade` &gt;= 80 AND `grade` &lt;= 90; -- 模糊查询 SELECT * FROM `score` WHERE `grade` BETWEEN 80 AND 90; IN查询某一列中的值在列出的内容列表中。查询 student 表中 city 列为 “北京” 或 “上海” 或 “杭州” 所有学生的信息。-- 精准查询 SELECT * FROM `student` WHERE `city` = &quot;北京&quot; OR `city` = &quot;上海&quot; OR `city` = &quot;杭州&quot;; -- 模糊查询 SELECT * FROM `student` WHERE `city` IN (&quot;北京&quot;, &quot;上海&quot;, &quot;杭州&quot;); 截断表作为主键的标识列，值是会随着数据的增加，自动递增的，且具有 “断号保留” 的特性，随着表中数据的增删，标识列的值会非常混乱，我们可以通过截断表来解决该问题。截断表有两个作用如下：使表中数据的标识列的值重新从 1 开始计数；清空表中数据。使用截断表时，表的列和约束不会改动，使用的前提是表与表之间不能存在外键约束，表之间如果通过外键进行关联，无法清空主表中数据，即无法截断表。语法：TRUNCATE TABLE 表名 截断 student 表：TRUNCATE TABLE `student`; 截断表操作轻易不要使用，因为普通的 SQL 操作会记录日志，并且可以还原，而 TRUNCATE 操作不会记录日志，并且不可还原，万一删错，彻底完蛋。函数在 MySQL 中有很多内置的函数帮我们实现一些功能，函数大类可分为普通函数和聚合函数，我们本节主要介绍普通函数，常用的普通函数大概可分为字符函数、数字函数、日期函数和流程控制函数等，还有一些与数据库相关的辅助函数以及自定义函数，都会在本节一一介绍。字符函数LENGTHLENGTH 函数的作用是返回输入字符串的长度。SELECT LENGTH(&quot;panda&quot;); -- 5 SELECT LENGTH(&quot;你好啊&quot;); -- 9 CONCAT 和 CONCAT_WSCONCAT 函数用于将多个字符串拼接成一个字符串，CONCAT_WS 函数用于使用分隔符将多个字符串拼接成一个字符串，第一个参数为分隔符。SELECT CONCAT(&quot;Panda&quot;, &quot;Shen&quot;); -- PandaShen SELECT CONCAT_WS(&quot;-&quot;, &quot;Hello&quot;, &quot;Panda&quot;, &quot;Shen&quot;); -- Hello-Panda-Shen UPPER 和 LOWERUPPER 函数用于将字符串转换为大写，LOWER 函数用于将字符串转换为小写。SELECT UPPER(&quot;panda&quot;); -- PANDA SELECT LOWER(&quot;PANDA&quot;); -- panda SUBSTRSUBSTR 函数用于截取字符串，第一个参数为源字符串，第二个参数为起始的索引（从 1 开始），第三个参数为截取的长度，不传默认截取后面全部字符串。SELECT SUBSTR(&quot;panda&quot;, 3); -- nda SELECT SUBSTR(&quot;panda&quot;, 3, 2); -- nd LEFT 和 RIGHTLEFT 函数和 RIGHT 函数分别代表在字符串取左边或右边的规定位数，第一个参数为源字符串，第二个参数为规定的位数。SELECT LEFT(&quot;panda12345&quot;, 5); -- panda SELECT RIGHT(&quot;panda12345&quot;, 5); -- 12345 INSTRINSTR 函数用于查找某个字符串在一个源字符串中的起始（第一个匹配到的）索引，第一个参数为源字符串，第二个参数为查询字符串，查询不到返回 0。SELECT INSTR(&quot;panda&quot;, &quot;a&quot;); -- 2 SELECT INSTR(&quot;panda&quot;, &quot;x&quot;); -- 0 LTRIM、RTRIM 和 TRIMLTRIM 函数用于去掉字符串左侧空格，RTRIM 用于去掉字符串右侧空格，TRIM 用于去掉字符串两侧的空格，如果 TRIM 的参数将两个字符串使用 FROM 连接，则代表去掉右侧字符串左右两侧的左侧字符串（说的有点绕，看例子）。SELECT LTRIM(&quot; panda&quot;); -- panda SELECT RTRIM(&quot;panda &quot;); -- panda SELECT TRIM(&quot; panda &quot;); -- panda SELECT TRIM(&quot;@&quot; FROM &quot;@@panda@@&quot;); -- panda LPAD 和 RPADLPAD 函数和 RPAD 函数分别用于向源字符串的左、右按照规定字符串的长度填充定义的字符。SELECT LPAD(&quot;panda&quot;, 10, &quot;@&quot;); -- @@@@@panda SELECT RPAD(&quot;panda&quot;, 10, &quot;@&quot;); -- panda@@@@@ REPLACEREPLACE 函数用于替换某字符串的部分字符，第一个参数为源字符串，第二个参数为被替换字符，第三个参数为替换字符。SELECT REPLACE(&quot;panda&quot;, &quot;a&quot;, &quot;e&quot;); -- pende 综合练习查询 id 为 3 学生的邮箱域名。SELECT SUBSTR(`email`, INSTR(`email`, &quot;@&quot;) + 1) FROM `student` WHERE `id` = 3; -- qq.com 将 student 表中的邮箱地址全部由小写改成大写。UPDATE `student` SET `email` = UPPER(`email`); 给 student 表新增一列 level，类型为 varchar，值为 1-1、1-2、1-3、2-1、2-2 等，按照 level 列值中 - 的前半段正序排列，后半段逆序排列。SELECT `level`, SUBSTR(`level`, 1, INSTR(`level`, &quot;-&quot;) - 1), SUBSTR(`level`, INSTR(`level`, &quot;-&quot;) + 1) FROM `student` ORDER BY SUBSTR(`level`, 1, INSTR(`level`, &quot;-&quot;) - 1) ASC, SUBSTR(`level`, INSTR(`level`, &quot;-&quot;) + 1) DESC; 将 pandashen 转换成 Panda_Shen，将两个单词拆开，并实现首字母大写，其他字符小写，然后用 _ 拼接。SELECT CONCAT( CONCAT( UPPER(SUBSTR(SUBSTR(&quot;pandashen&quot;, 1, 5), 1, 1)), SUBSTR(SUBSTR(&quot;pandashen&quot;, 1, 5), 2) ), &quot;_&quot;, CONCAT( UPPER(SUBSTR(SUBSTR(&quot;pandashen&quot;, 6), 1, 1)), SUBSTR(SUBSTR(&quot;pandashen&quot;, 6), 2) ) ); -- Panda_Shen 数学函数FORMATFORMAT 函数用于将数字格式化，第一个参数为要格式化的数字，第二个参数为保留的小数位数，返回值为字符串，整数部分每三位使用 , 分隔。SELECT FORMAT(100000, 2); -- 100,000.00 SELECT FORMAT(100.31111, 3); -- 100.311 SELECT FORMAT(100.31111, 0); -- 100 SELECT FORMAT(423423234.65534453, 2); -- 423,423,234.66 CEIL 和 FLOORCEIL 函数为向上取整，FLOOR 函数为向下取整。SELECT CEIL(2.4); -- 3 SELECT FLOOR(2.4); -- 2 ROUND 和 TRUNCATEROUND 函数为四舍五入，TRUNCATE 函数为小数截断，第一个参数为截断的数字，第二个参数为保留的小数位数。SELECT ROUND(2.1); -- 2 SELECT ROUND(2.5); -- 3 SELECT TRUNCATE(1.66, 0); -- 1 SELECT TRUNCATE(1.66, 1); -- 1.6 SELECT TRUNCATE(1.66, 2); -- 1.66 SELECT TRUNCATE(1.66, 3); -- 1.66 POWERPOWER 函数用于幂运算，第一个参数为底数，第二个参数为指数。SELECT POWER(2, 3); -- 8 MODMOD 函数用于取余运算，第一个参数为被除数，第二个参数为除数。SElECT MOD(10, 3); -- 1 日期函数NOW、CURDATE 和 CURTIMENOW 函数用于获取当前的时间，格式为 yyyy-mm-dd hh:mm:ss，CURDATE 函数用于获取当前日期，格式为 yyyy-mm-dd hh:mm:ss，CURTIME 函数用于获取当前时间，格式为 hh:mm:ss，返回类型均为日期格式。SELECT NOW(); -- 2018-08-09 19:23:18 SELECT CURDATE(); -- 2018-08-09 SELECT CURTIME(); -- 19:25:31 DATE_ADDDATE_ADD 函数用于增加时间，即将时间求和，第一个参数为 yyyy-mm-dd hh:mm:ss 格式的时间，第二个参数为时间间隔，INTERVAL 关键字代表时间间隔，后面跟上数字，单位为 DAY、MONTH、YEAR 等，返回类型为字符串。SELECT DATE_ADD(NOW(), INTERVAL 365 DAY); -- 2019-08-09 19:30:15 SELECT DATE_ADD(NOW(), INTERVAL 1 MONTH); -- 2018-09-09 19:30:15 SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR); -- 2019-08-09 19:30:15 STR_TO_DATESTR_TO_DATE 函数可以将一个日期格式的字符串转换成日期，第一个参数为日期格式的字符串，第二个参数为日期的格式描述，如 %Y-%m-%d，传入的日期字符串的格式与日期格式描述必须保持一致。SELECT STR_TO_DATE(&quot;2018-08-09&quot;, &quot;%Y-%m-%d&quot;); -- 2018-08-09 SELECT STR_TO_DATE(&quot;2018/08/09&quot;, &quot;%Y/%m/%d&quot;); -- 2018-08-09 SELECT STR_TO_DATE(&quot;2018.08.09&quot;, &quot;%Y.%m.%d&quot;); -- 2018-08-09 从 student 表中查询一个生日（列名为 birthday）为 1982 年 9 月 3 的学生信息。SELECT * FROM `student` WHERE `birthday` = STR_TO_DATE(&#39;09-03 1982&#39;,&#39;%m-%d %Y&#39;); -- 结果查到了黄蓉的信息 格式描述参考下表：序号格式符功能1%Y4 位的年份2%y2 位的年份3%m月份（01，02）4%c月份（1，2）5%d日（01，02）6%H小时（24 小时制）7%h小时（12 小时制）8%i分钟（00，01）9%s秒（00，01）DATE_FORMATDATE_FORMAT 函数与 STR_TO_DATE 作用正好相反，是将一个日期类型按照格式描述转换成日期字符串，第一个参数为日期对象，第二个参数为日期的格式描述。SELECT DATE_FORMAT(STR_TO_DATE(&quot;2018-08-09&quot;, &quot;%Y-%m-%d&quot;), &quot;%Y年%m月%d日&quot;); -- 2018年08月09日 DATEDIFFDATEDIFF 函数用于计算时间间隔，两个参数均为日期对象，得到的结果为第一个与第二个的差值，单位为 “天”。SELECT DATEDIFF(NOW(), STR_TO_DATE(&quot;2018-08-08&quot;, &quot;%Y-%m-%d&quot;)); -- 1 通过查询 student 的 birthday 列计算每个人的年龄（周岁）。SELECT FLOOR(DATEDIFF(NOW(), `birthday`) / 365) FROM `student`; 返回日期中指定的部分下面方法传入参数均为日期对象，返回的时间中对应的部分均为字符串：YEAR：返回年；MONTH：返回月；DAY：返回日；HOUR：返回小时；MINUTE：返回分钟；SECOND：返回秒；MONTHNAME：返回月份名称（英文）。SELECT YEAR(NOW()); -- 2018 SELECT MONTH(NOW()); -- 8 SELECT DAY(NOW()); -- 9 SELECT HOUR(NOW()); -- 19 SELECT MINUTE(NOW()); -- 48 SELECT SECOND(NOW()); -- 53 SELECT MONTHNAME(NOW()); -- August 综合练习查询 student 表中出生月份是 9 月的学生。SELECT * FROM `student` WHERE MONTH(`birthday`) = 9; 查询 student 表中生日是今天的学生。SELECT * FROM `student` WHERE MONTH(NOW()) = MONTH(`birthday`) AND DAY(NOW()) = DAY(`birthday`); 在 student 表中查询年龄超过 18 岁的男同学。-- 写法 1：求生日与现在时间的差值转换成年与年龄比较 SELECT * FROM `student` WHERE DATEDIFF(NOW(), `birthday`) / 365 &gt; 18; -- 写法 2：给生日加上 18 年看看是否大于今天的时间 SELECT * FROM `student` WHERE DATE_ADD(`birthday`, INTERVAL 18 YEAR) &lt; NOW(); -- 写法 3：获取今天时间的年份和生日的年份做差，看是否大于 18 SELECT * FROM `student` WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; 18; 数据库辅助函数CONNECTION_ID连接每个数据库都会分配对应的连接号，我们称为连接 ID，CONNECTION_ID 函数可以帮我们获取连接 ID。SELECT CONNECTION_ID(); -- 10 DATABASEDATABASE 函数用于查看当前的连接的数据库，返回数据库名称。SELECT DATABASE(); -- school VERSIONVERSION 函数用来查看当前 MySQL 数据库的版本号。SELECT VERSION(); -- 5.5.61 LAST_INSERT_IDLAST_INSERT_ID 可以获取上次向表中（任意表）插入数据时，插入数据的 id 号。select LAST_INSERT_ID(); -- 0 USER 和 PASSWORDUSER 用于查询当前数据库登录的用户。SELECT USER(); -- root@ 在 MySQL 数据库中存在一张表存放着 MySQL 当前所有的用户，可以通过下面命令查询。SELECT * FROM mysql.user; 通过查询结果可以看出密码的位置存储的是密文，如果要修改密码需要将设置的密码转换成密文进行存储，PASSWORD 函数就是来做这件事的，修改密码命令如下。UPDATE FROM mysql.user SET `password` = PASSWORD(&quot;123456&quot;); MD5MD5 可以将传入的字符串进行一个 MD5 散列算法的转换并输出。SELECT MD5(&quot;panda&quot;); -- ce61649168c4550c2f7acab92354dc6e 流程控制函数IFIF 函数可以根据传入的判断条件在两个结果中进行选择输出。SELECT IF(1 &gt; 2, &quot;yes&quot;, &quot;no&quot;); -- no CASE、WHEN、THEN、ELSE 和 ENDCASE、WHEN、THEN、ELSE 和 END 共同组成了一个流程控制函数，可以代替多个 IF，CASE 为条件判断起始关键字，WHEN 为判断条件关键字（可以有多个），THEN 为输出结果关键字，ELSE 为默认输出关键字，END 为流程结束关键字。SELECT `grade`, CASE WHEN `grade` &gt; 90 THEN &quot;优&quot; WHEN `grade` &gt; 80 THEN &quot;良&quot; WHEN `grade` &gt; 70 THEN &quot;中&quot; WHEN `grade` &gt; 60 THEN &quot;及格&quot; ELSE &quot;不及格&quot; END FROM `score`; 自定义函数规则自定义函数是对 MySQL 的扩展，使用方式和内置函数相同；函数必须要有参数和返回值，函数可以接收任意类型的值和参数，返回值只能有一个；函数体由合法的 SQL 语句组成，可以包含声明、循环和流程控制，也可以是 SELECT 或 INSERT 语句，如果函数体是复合结构（多条语句）要用 BEGIN...END。语法CREATE FUNCTION FUNC_NAME RETURNS {String|Integer} BODY RETURN VALUE CREATE FUNCTION 为创建函数关键字，FUNC_NAME 为函数的名字，RETURNS 为返回类型关键字，{ } 中的内容为返回值类型，如 varchar 等，BODY 代表函数体，RETURN VALUE 代表返回值。实例写一个自定义函数用于获取中文格式的当前时间。-- 函数 ZHNOW CREATE FUNCTION ZHNOW() RETURNS VARCHAR(64) RETURN DATE_FORMAT(NOW(), &quot;%Y年%m月%d日&quot;); -- 使用 ZHNOW SELECT ZHNOW(); -- 2018年08月10日 实现一个自定义函数对两个数字进行相乘运算并将结果返回。-- 函数 MYPRODUCT，参数为两个数字 CREATE FUNCTION MYPRODUCT(n INT, m INT) RETURNS INT RETURN n * m; -- 使用 MYPRODUCT SELECT MYPRODUCT(2, 5); -- 10 针对上面的 course 学科表，写一个自定义函数用来增加学科并返回增加数据的 id 值。-- 函数 ADD_COURSE，参数为添加课程的名称 CREATE FUNCTION ADD_COURSE(name VARCHAR(32)) RETURNS INT BEGIN INSERT INTO `course` (`name`) VALUES (name); RETURN LAST_INSERT_ID(); END -- 使用 ADD_COURSE SELECT ADD_COURSE(&quot;体育&quot;); -- 4 聚合函数上一节中的函数都是普通函数，多用于操作表达式后返回结果，而聚合函数更多是对一组值进行计算，并返回计算后的值，一般用来统计数据，使用难度要大于普通函数。SUMSUM 函数用于累加所有行的值。还是以上面的 score 表为例，我们取出 student_id 值为 1 的学生全部科目的总成绩。SELECT SUM(`grade`) FROM `score` WHERE `student_id` = 1; -- 260 其实上面的操作是分为两部分进行，首先先查出 student_id 为 1 的所有学科的成绩，在对这些成绩进行求和计算后返回。AVGAVG 函数用于计算所有行的平均值。在 score 表中查询 student_id 值为 3 的学生全部科目成绩的平均值。SELECT AVG(`grade`) FROM `score` WHERE `student_id` = 3; -- 80 MAX 和 MINMAX 和 MIN 分别用于计算所有行的最大值和最小值。在 score 表中查询 student_id 值为 2 的学生全部科目成绩的最大值和最小值。SELECT MAX(`grade`), MIN(`grade`) FROM `score` WHERE `student_id` = 2; -- 100 40 COUNTCOUNT 按照某一列统计所有行的总条数，如果参照的列值为 null 则不统计在内。在 score 表中查询 student_id 值为 1 的学生成绩总数。SELECT COUNT(`grade`) FROM `score` WHERE `student_id` = 1; -- 3 SQL 语句之分组聚合分组分组查询就是按某一列或某几列的值进行分组，相同的值分为一组，然后可以对组内使用聚合函数分别进行统计。以 score 表为例，分组表示图如下：成绩表分组数据语法：SELECT 列名, 查询表达式 FROM &lt;表名&gt; GROUP BY &lt;分组字段&gt; GROUP BY 关键字用于对筛选后的结果进行分组。例子：统计 score 表中每位同学的平均成绩（单列分组，对 student_id 进行分组）。SELECT `student_id`, AVG(`grade`) FROM `score` GROUP BY `student_id`; 统计 score 表中每门课程的最高分（单列分组，对 course_id 进行分组），并按照分数从低到高排序。SELECT `course_id`, MAX(`grade`) FROM `score` GROUP BY `course_id` ORDER BY `grade` ASC; 统计 student 表中各省男女同学人数（多列分组，按照 province 和 gender 进行分组）。SELECT `province`, `gender`, COUNT(*) FROM `student` GROUP BY `province`, `gender`; COUNT 中的 * 代表任意一列。分组筛选语法：SELECT 列名, 查询表达式 FROM &lt;表名&gt; WHERE &lt;条件&gt; GROUP BY &lt;分组字段&gt; HAVING 分组后的过滤条件 ORDER BY 列名 [ASC, DESC] LIMIT 偏移量, 条数 WHERE 用于过滤掉不符合条件的记录，HAVING 用于过滤分组后的记录。注意：上面查询的关键字不一定每条查询语句都要有，但是如果有其中的某些关键字，一定要按照上面的顺序进行。例子：统计 student 表中学生人数多于一个的省份。SELECT `province`, COUNT(*) FROM `student` GROUP BY `province` HAVING COUNT(*) &gt; 1; 统计 score 表中不及格次数大于 1 的学生按逆序排列并取前 3 条。SELECT `student_id`, COUNT(*) FROM `score` WHERE `grade` &lt; 60 GROUP BY `student_id` HAVING COUNT(`grade`) &gt; 1 ORDER BY COUNT(`grade`) DESC LIMIT 0, 3; SQL 语句之子查询子查询的注意点：子查询是出现在其他 SQL 语句中的 SELECT 语句；子查询嵌套在查询内部，且必须写在圆括号中，外层可以是 SELECT、INSERT、UPDATE、SET 等；子查询可以包含多个关键字或条件；子查询可以返回常量、一行数据、一列数据或其它子查询（返回多行数据需使用其他关键字处理）。比较运算符连接子查询在查询通过 WHERE 进行条件筛选时，可以使用比较运算符连接子查询。查询年龄大于平均年龄的学生。SELECT * FROM `student` WHERE YEAR(NOW()) - YEAR(`birthday`) &gt; ( SELECT AVG(YEAR(NOW()) - YEAR(`birthday`)) FROM `student` ); IN 和 NOT IN当查询一张表的数据需要另一张表中的数据作为筛选条件时，可以在查询时通过 IN 和 NOT IN 关键字连接子查询。查询 student 有不及格成绩的学生信息。SELECT * FROM `student` WHERE `id` IN ( SELECT DISTINCT `student_id` FROM `score` WHERE `grade` &lt; 60 ); -- 结果查到了黄蓉 上面例子查到了 “黄蓉” 同学的信息，如果将 IN 修改为 NOT IN 则会查询到除 “黄蓉” 以外其他同学的信息。查询 student 表中在 score 表中有成绩的学生信息。SELECT * FROM `student` WHERE student.id IN ( SELECT DISTINCT `student_id` FROM `score` ); EXISTS 和 NOT EXISTSEXISTS 和 NOT EXISTS 关键字用于连接子查询，代表 “存在” 或 “不存在” 的意思，接收的子查询返回为数据为布尔值。拿上面查询 student 表在 score 表中有成绩学生信息的例子，使用 EXISTS 实现查询。SELECT * FROM `student` WHERE EXISTS ( SELECT `student_id` FROM `score` WHERE score.student_id = student.id ); IN、NOT IN 与 EXISTS、NOT EXISTS 比较，后者的性能更高，查询速度更快，因为判断是在子查询内部，EXISTS、NOT EXISTS 只需要判断布尔值就可以了，IN、NOT IN 在子查询返回数据的基础上还要再次过滤。ALL、SOME 和 ANY当子查询返回了多条数据的时候，可以使用 ALL、SOME 和 ANY 关键字作为比较运算符和子查询之间的连接。ALL 关键字代表全部，即查询的数据筛选条件要去和所有子查询返回的比较并都满足；SOME 关键字代表某些，查询数据筛选条件只要满足子查询返回数据的某些条即可；ANY 关键字代表任何一个，查询数据的筛选条件只要满足子查询返回数据的任意一条即可。查询 student 表中年龄大于等于所有人的学生信息。SELECT * FROM `student` WHERE `age` &gt;= ALL ( SELECT `age` FROM `student` ); -- 结果查到了欧阳锋 查询 student 表中年龄大于某些人的学生信息。SELECT * FROM `student` WHERE `age` &gt; SOME ( SELECT `age` FROM `student` ); -- 结果查到除杨过以外的所有人（因为杨过年龄最小） 查询 student 表中年龄大于任意一个人的学生信息。SELECT * FROM `student` WHERE `age` &gt; ANY ( SELECT `age` FROM `student` ); -- 返回结果同 SOME 没区别 表连接连接类型在 MySQL 中的表连接类型：INNER JOIN：内连接，代表取两张关联表的交集，可以用 JOIN 关键字代替；LEFT：左外连接，代表取两张表的交集后再和左侧表求并集，即包含左侧表全部数据；RIGHT：右外连接，代表取两张表的交际后再和右侧表求并集，即包含右侧表全部数据。三种连接类型表示如下图：表连接类型韦恩图连接条件 ONON 关键字用来设定表的连接条件，也可以使用 WHERE 对结果进行过滤的方式来代替。内连接对 student 和 score 两张表使用内连接。SELECT * FROM `student` INNER JOIN `score` ON student.id = score.student_id; 查询结果如下：内连接查询结果左外连接对 student 和 score 两张表使用左外连接。SELECT * FROM `student` LEFT JOIN `score` ON student.id = score.student_id; 查询结果如下：左外连接查询结果右外连接对 student 和 score 两张表使用右外连接。SELECT * FROM `student` RIGHT JOIN `score` ON student.id = score.student_id; 查询结果如下：右外连接查询结果多表连接案例连接 student、score 和 course 三张表，分别查询学生姓名、学科和分数。SELECT student.name, course.name, score.grade FROM `score` INNER JOIN `student` ON student.id = score.student_id INNER JOIN `course` ON course.id = score.course_id; 总结到此 MySQL 系列文章的第二篇就结束了，本篇的大部分都是和操作数据库的 SQl 语句相关的知识点，里面涵盖了基本的增、删、改、查以及函数、聚合函数的应用等，如果记不住的话（当然我也记不住，只是负责替大家和我自己整理）建议收藏，在使用时随时查阅，这一篇的内容对于前端而言，可以说基本够用了。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.overtaking.top/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.overtaking.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL —— 数据库基础","date":"2018-08-07T17:23:03.000Z","path":"20180808012303/","text":"前言MySQL 是目前使用最广泛的关系型数据库，是在软件开发中所必备的技能之一，这是关于 MySQL 的系列文章，将从 MySQL 的基本概念、基本使用、SQL 语句、函数、聚合函数、表连接以及表设计等多方面对 MySQL 进行总结，而本篇是数据库基础部分，大多都是一些概念性的内容和表的创建，数据库博大精深，本系列文章内容较浅，适合于前端的同学们对 MySQL 的入门。系列文章：MySQL —— SQL 语句总结MySQL —— 简单聊一聊数据库设计MySQL 的基本概念MySQL 的特点：开源免费、性能高、安装使用简单。MySQL 的作用：存储大量数据，方便检索和访问；保持数据信息的一致、完整；实现数据的共享和安全；通过组合分析产生新的有用信息。实体：只要是客观存在，能够被描述出来的都是实体，每一条数据都是一个实体。DB：是数据库的意思，就是存储数据的仓库，可以存放结构化的数据。DBMS：代表数据管理系统，是一种系统软件，提供操作数据库的环境，如 Navicat for MySQL，可以通过数据库管理系统对数据进行增、删、改、查。SQL：结构化查询语言，专门用来和数据库进行交流的语言，几乎所有的 DBMS 都支持 SQL。数据表：表是数据库中包含所有数据的数据库对象，也是其他对象的基础；表定义是一个集合，数据在表中是按行和列的格式组织的，用来存放数据；行被称为记录，用来存放一个实体，列称为字段用来描述实体的某一个属性。MySQL 的配置和命令MySQL 配置在 MySQL 的默认安装目录中 my.ini 文件是专门用来配置的，常用配置项如下：port：端口号；basedir：安装目录；datadir：数据存放目录；charcter-set-server：字符集；default-storage-engine：存储引擎；sql-mode：语法模式；max-connections：最大连接数。MySQL 命令MySQL 服务启动和停止：net start MySQL net stop MySQL 连接和退出数据库：mysql -h 127.0.0.1 -P 3306 -uroot -p123456 exit -h 代表主机名，-p 代表端口号，-u 和 -p 分别代表当前 MySQL 服务的账号和密码。查看当前 MySQL 中的数据库：show dbs; show database; 切换数据库：use dataname; 查看数据库的表：show tables; show tables from mysql; 查看当前所在的数据库：select database(); 查询表结构：desc tablename; 数据完整性数据完整性是指，数据库种所有数据值均为正确状态，如果数据存储有不正确的的数据值，则该数据库丧失数据完整性，为了实现数据完整性，需要检验数据库表中每行每列的数据是否符合要求，在创建表时，应该保证以后输入的数据都是正确的，错误的数据不允许输入。域（列）完整性域完整性是对数据表中字段属性的约束，通常指数据的有效性，它包括字段的值域、字段的类型及字段的有效规则等约束，它是由确定关系结构时所定义的字段的属性决定的，如关于年龄的字段，数据类型应为 int，关于普通的字符串值得类型应该为 varchar 等等，并在规定值类型时相应得规定值的长度，即所占的字节数。数据类型图如下：数据类型图数值类型整数型：tinyint：存储所占 1 字节，无符号可以存储 0 ~ 255，有符号可以存储 -128 ~ 127；smallint：存储所占 2 字节，无符号可以存储 0 ~ 65535，有符号可以存储 -32768 ~ 32767；mediumint：存储所占 3 字节，无符号可以存储 0 ~ 16777215，有符号可以存储 -8388608 ~ 8388607；int：存储所占 4 字节，无符号可以存储 0 ~ 4294967295，有符号可以存储 -2147483648 ~ 2147483647；bigint：存储所占 8 字节，无符号可以存储 0 ~ 18446744073709551615，有符号可以存储 -9223372036854775808 ~ 9223372036854775807。上面的整数型用来规定字段存储的数据必须为整数，从上到下需要占用的空间越来越多，能表示的数字也越来越大，定义字段时选择满足需求的数字范围即可。数值类型小数型：float：单精度浮点型，存储所占 4 字节，数值范围为 -3.4E38 ~ 3.4E38，7 个有效位；double：双精度浮点型，存储所占 8 字节，数值范围为 -1.7E308~1.7E308，15 个有效位；decimal：定点型，存储所占 16 字节，28 个有效位，不存在精度损失，常用于银行账目计算。数值存储范围越小，精度越高，范围越大，精度越不准确，既要求精度，又固定小数点位数的数值存储，建议使用 decimal，优点在于可以自定义小数点位数，精度高，特殊情况，数值范围巨大，只能使用 float 类型，该类型一般不建议使用。字符串类型：set：存储字符串对象，最多包含 64 个元素，并且可以取到集合中任意元素；enum：存储字符串对象，最多包含 65536 个元素，只能取到集合中一个元素；blob：用于存储二进制字符串，有子类型；text：用于存储大文本，有子类型；char：定长，最大 255 字节，存储空间未满，会在数据右侧填充空格；varchar：不定长，最大 65536 字节，当长度小于 4 时，会自动转换成 char。上面类型中最常用的为 varchar 可以根据字段内容的自定义长度。时间类型：year：yyyy 格式表示的年份值；timestamp：yyyymmddhhmmss 格式表示的时间戳；time：hh:mm:ss 格式表示的时间值；date：yyyy-mm-dd 格式表示的日期值；datetime：yyyy-mm-dd hh:mm:ss 格式表示的日期和时间。默认值：默认值是指如果某个字段没有指定值的情况下，会为该字段指定一个预先设定的值。非空约束：我们可以指定某个字段不能不输入，必须提供一个非空的值，即不能为 null。实体（行）完整性实体完整性是对关系中的记录唯一性，也就是主键的约束，准确地说，实体完整性是指关系中的主属性值不能为 null 且不能有相同值，定义表中的所有行唯一的标识，一般用主键。主键：表中一列或者几列组合的值能用来唯一标识表中的每一行，这样的列或者列组合称为表的主键，主键表的数据不能重复，如果两列或者多列组合起来唯一标识表中的每一行，则该主键又称为 “组合主键”。主键的选择标准：最少性：尽量选择单个键作为主键；稳定性：由于主键是用来在两个表之间建立关联的，不能经常更新或者说一般不更新，所以最好选择无意义的列作为主键，如各种 id 值。引用完整性引用完整性意思是对关系型数据库中建立关联关系的数据表之间数据参照引用的约束，也就是对外键的约束，准确地说，是指关系中的外键必须是另一个关系的主键有效值，或者是 null，参考完整性，维护表间数据的有效性，完整性，通常通过建立外部键联系另一张关联表的主键实现。外键：用于连接两张表的字段称为外键，属于外键表，通常要关联的主键表的字段作为外键，保证了引用完整性。外键约束：外键表的外键必须引用主键表的主键，主表没有记录。如果一个表的外键引用了一个表的主键会有以下限制：在外键表里不能添加主键表里没有的数据，外键表的数据与主键表的数据必须通过外键一一对应；要想删除主键表的数据必须删除所有外键表的数据。唯一约束：唯一约束是指某个字段值是唯一的，在所有的记录中不能有重复的值，如某个人的身份证号，需将外键的索引类型设置为 Unique。标识列：当表中没有适合做主键的列时，此时创建作为主键的无意义列称为标识列，标识列的值是自动生成的，不能输入修改，且是自增的，可以设置每次的增量，具有 “断号保留” 的特性，当某一个实体被删除时，该标识列的值是永久保存的，其他新增实体会在这个标识列的基础上继续自增。DDL 数据定义语言的使用我们可以通过两种方式创建表，可以使用 DDL（data defintion language）数据定义语言来创建，也可以使用 DBMS 数据管理系统来创建，使用 DBMS 还是很方便的，而且也是最常用的方式，但 DDL 创建方式我们不得不说，就是通过代码的方式来实现表的创建和操作，因为这是最原始的方式，即使图形化的操作会更方便，我们也应该了解。SQL 规范SQL 语句的规范如下：SQL 语句不区分大小写，建议 SQL 关键字大写，表名和列表小写；命令用分号结尾；命令可以缩进和换行，一种类型的关键字放在一行；可以写单行和多行注释 , # 和 -- 是单行注释， /*/ 是多行注释。使用 DDL 操作表在 DBMS 中的查询编辑器可以代替命令行实现命令的编写，为了视觉效果，我们都使用 Navicat for MySQL 的查询编辑器，操作界面如下图。Navicat For MySQL 操作界面创建表创建表 student，创建一个标识列 id 不为空，设为主键并自增，创建 name 列，varchar 类型，64 位，不为空，创建 age 列，int 类型，不为空，创建 city 列，varchar 类型，32 位，默认值为 “北京”。CREATE TABLE `student` ( `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL, `age` INT NOT NULL, `city` VARCHAR(32) DEFAULT &quot;北京&quot; ); 操作表的列给上面的表 student 增加 idcard 列，值为空，将 idcard 列类型大小修改为 32 位，添加 province 列，插入到 city 列前面，查询表结构，删除 idcard 列，删除表 student。ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL; ALTER TABLE `student` MODIFY COLUMN `idcard` VARCHAR(32) NULL; ALTER TABLE `student` ADD COLUMN `province` VARCHAR(32) AFTER `age`; DESC `student`; ALTER TABLE `student` DROP COLUMN `idcard`; DROP TABLE `student`; 添加主键约束重新创建上面的 student 表，city 不设置默认值，不添加主键约束和标识列，再通过命令添加主键约束。CREATE TABLE `student` ( `id` INT NOT NULL, `name` VARCHAR(64) NOT NULL, `age` INT NOT NULL, `city` VARCHAR(32) ); ALTER TABLE `student` ADD PRIMARY KEY(id); 添加唯一约束将上面我们 student 表中的 idcard 列再加回来，给 idcard 列添加唯一约束，外键名为 uq_idcard。ALTER TABLE `student` ADD COLUMN `idcard` VARCHAR(18) NULL; ALTER TABLE `student` ADD UNIQUE INDEX uq_idcard(`idcard`); 添加默认约束将 student 表 city 列的默认值设置为 “北京”。ALTER TABLE `student` MODIFY COLUMN `city` VARCHAR(64) DEFAULT &quot;北京&quot;; 添加外键约束创建一个子表 score，添加 student_id 列，添加外键 fk_student_id，将 student_id 与 student 表的主键 id 相关联，此时 student 为主表（主键表），score 为子表（外键表）。CREATE TABLE `score` ( `student_id` INT ); ALTER TABLE `score` ADD CONSTRAINT `fk_student_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`); 注意：在项目中一般不会添加这个约束，因为在开发时会频繁操作表和修改数据，会经常报错，非常麻烦，不添加这个约束并不影响数据的检索和修改。删除约束删除 score 表与 student 表的外键约束，即删除外键 fk_student_id。ALTER TABLE `score` DROP FOREIGN KEY `fk_student_id`; 使用 DDL 创建一个完整的表关系完整的表关系图如下：完整表关系图DDL 命令如下：-- 创建表 student CREATE TABLE `student` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) NOT NULL, `idcard` VARCHAR(18) DEFAULT NULL, `age` INT(11) DEFAULT NULL, `city` VARCHAR(50) DEFAULT &quot;北京&quot;, PRIMARY KEY (`id`) ); -- 创建表 course CREATE TABLE `course` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) DEFAULT NULL, PRIMARY KEY (`id`) ); -- 创建表 score，并添加外键约束 CREATE TABLE `score` ( `student_id` INT(11) NOT NULL DEFAULT &quot;0&quot;, `course_id` INT(11) NOT NULL DEFAULT &quot;0&quot;, `grade` FLOAT DEFAULT NULL, PRIMARY KEY (`student_id`, `course_id`), KEY `fk_courseid` (`course_id`), CONSTRAINT `fk_courseid` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`), CONSTRAINT `fk_student_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 在实际开发当中使用 DDL 对表的编辑并不多，因为命令繁琐，在效率上，使用 DBMS 效率更高，但是 DDL 是学习 MySQL 数据库的根本之一，应该会写。总结到此 MySQL 系列文章的第一篇就结束了，里面大部分内容都是关于 MySQL 数据库的概念以及表的创建，非常枯燥，但又是初学 MySQL 所必须要懂的知识点，相信大家通过本节已经对 MySQL 有了一定的认识，那么下一篇将是重中之重，是在开发中经常使用的 DML 数据库操作语言，也就是我们平时所说的 SQL 语句，在此期待我们的下一篇 《MySQL —— SQL 语句总结》。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.overtaking.top/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://www.overtaking.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Webpack 核心模块 tapable 解析","date":"2018-08-06T10:44:12.000Z","path":"20180806184412/","text":"前言Webpack 是一个现代 JavaScript 应用程序的静态模块构建工具，是对前端项目实现工程化和优化必不可少的工具，Webpack 的 loader（加载器）和 plugin（插件）是由 Webpack 开发者和社区开发者共同贡献的，而目前又没有比较系统的开发文档，想写加载器和插件最好对要 Webpack 的原理有所了解，tapable 则是 Webpack 依赖的核心库，是 Webpack 中很重要的部分，所以本篇会对 tapable 提供的类进行解析和模拟。tapable 介绍Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。打开 Webpack 4.0 的源码中一定会看到下面这些以 Sync、Async 开头，以 Hook 结尾的方法，这些都是 tapable 核心库的类，为我们提供不同的事件流执行机制，我们称为 “钩子”。/* 引入 tapable 如下 */ const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } = require(&#39;tapable&#39;); 上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。Sync 类型的钩子SyncHookSyncHook 为串行同步执行，不关心事件处理函数的返回值，在触发事件之后，会按照事件注册的先后顺序执行所有的事件处理函数。/* SyncHook 钩子的使用 */ const { SyncHook } = require(&#39;tapable&#39;); // 创建实例 const syncHook = new SyncHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 syncHook.tap(&#39;1&#39;, (name, age) =&gt; console.log(&#39;1&#39;, name, age)); syncHook.tap(&#39;2&#39;, (name, age) =&gt; console.log(&#39;2&#39;, name, age)); syncHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age)); // 触发事件，让监听函数执行 syncHook.call(&#39;panda&#39;, 18); // 1 panda 18 // 2 panda 18 // 3 panda 18 在 tapable 解构的 SyncHook 是一个类，注册事件需先创建实例，创建实例时支持传入一个数组，数组内存储事件触发时传入的参数名称，实例的 tap 方法用于注册事件，支持传入两个参数：第一个参数为事件名称，在 Webpack 中一般用于存储事件对应的插件名称（名字随意，只是起到注释作用）；第二个参数为事件处理函数，在实例调用 call 后执行，形参为创建实例时所定义，通过 call 调用传入实参；/* 模拟 SyncHook 类 */ class SyncHook { constructor(args) { this.args = args; this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 也可在参数不足时抛出异常 if (args.length &lt; this.args.length) throw new Error(&#39;参数不足&#39;); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数 this.tasks.forEach(task =&gt; task(...args)); } } tasks 数组用于存储事件处理函数，call 方法调用时传入参数超过创建 SyncHook 实例传入的数组长度时，多余参数可处理为 undefined，也可在参数不足时抛出异常，不灵活，后面的例子中就不再这样写了。SyncBailHookSyncBailHook 同样为串行同步执行，如果事件处理函数执行时有一个返回值不为空（即返回值不为 undefined），则跳过剩下未执行的事件处理函数（如类的名字，意义在于保险）。/* SyncBailHook 钩子的使用 */ const { SyncBailHook } = require(&#39;tapable&#39;); // 创建实例 const syncBailHook = new SyncBailHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 syncBailHook.tap(&#39;1&#39;, (name, age) =&gt; console.log(&#39;1&#39;, name, age)); syncBailHook.tap(&#39;2&#39;, (name, age) =&gt; { console.log(&#39;2&#39;, name, age); return &#39;2&#39;; // 返回值不为空 }); syncBailHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age)); // 触发事件，让监听函数执行 syncBailHook.call(&#39;panda&#39;, 18); // 1 panda 18 // 2 panda 18 通过上面的用法可以看出，SyncHook 和 SyncBailHook 在逻辑上只是 call 方法不同，导致事件的执行机制不同，对于后面其他的 “钩子”，也是 call 的区别，接下来实现 SyncBailHook 类。/* 模拟 SyncBailHook 类 */ class SyncBailHook { constructor(args) { this.args = args; this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，如果返回值不为空，则停止向下执行 let i = 0, ret; do { ret = this.tasks[i++](...args); } while (!ret); } } 在上面代码的 call 方法中，我们设置返回值为 ret，第一次执行后没有返回值则继续循环执行，如果有返回值则立即停止循环，即实现 “保险” 的功能。SyncWaterfallHookSyncWaterfallHook 为串行同步执行，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，依次类推，正因如此，只有第一个事件处理函数的参数可以通过 call 传递，而 call 的返回值为最后一个事件处理函数的返回值。/* SyncWaterfallHook 钩子的使用 */ const { SyncWaterfallHook } = require(&#39;tapable&#39;); // 创建实例 const syncWaterfallHook = new SyncWaterfallHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 syncWaterfallHook.tap(&#39;1&#39;, (name, age) =&gt; { console.log(&#39;1&#39;, name, age); return &#39;1&#39;; }); syncWaterfallHook.tap(&#39;2&#39;, data =&gt; { console.log(&#39;2&#39;, data); return &#39;2&#39;; }); syncWaterfallHook.tap(&#39;3&#39;, data =&gt; { console.log(&#39;3&#39;, data); return &#39;3&#39; }); // 触发事件，让监听函数执行 const ret = syncWaterfallHook.call(&#39;panda&#39;, 18); console.log(&#39;call&#39;, ret); // 1 panda 18 // 2 1 // 3 2 // call 3 SyncWaterfallHook 名称中含有 “瀑布”，通过上面代码可以看出 “瀑布” 形象生动的描绘了事件处理函数执行的特点，与 SyncHook 和 SyncBailHook 的区别就在于事件处理函数返回结果的流动性，接下来看一下 SyncWaterfallHook 类的实现。/* 模拟 SyncWaterfallHook 类 */ class SyncWaterfallHook { constructor(args) { this.args = args; this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，事件处理函数的返回值作为下一个事件处理函数的参数 const [first, ...others] = this.tasks; return others.reduce((ret, task) =&gt; task(ret), first(...args)); } } 上面代码中 call 的逻辑是将存储事件处理函数的 tasks 拆成两部分，分别为第一个事件处理函数，和存储其余事件处理函数的数组，使用 reduce 进行归并，将第一个事件处理函数执行后的返回值作为归并的初始值，依次调用其余事件处理函数并传递上一次归并的返回值。SyncLoopHookSyncLoopHook 为串行同步执行，事件处理函数返回 true 表示继续循环，即循环执行当前事件处理函数，返回 undefined 表示结束循环，SyncLoopHook 与 SyncBailHook 的循环不同，SyncBailHook 只决定是否继续向下执行后面的事件处理函数，而 SyncLoopHook 的循环是指循环执行每一个事件处理函数，直到返回 undefined 为止，才会继续向下执行其他事件处理函数，下一个事件处理函数执行机制同理。/* SyncLoopHook 钩子的使用 */ const { SyncLoopHook } = require(&#39;tapable&#39;); // 创建实例 const syncLoopHook = new SyncLoopHook([&#39;name&#39;, &#39;age&#39;]); // 定义辅助变量 let total1 = 0; let total2 = 0; // 注册事件 syncLoopHook.tap(&#39;1&#39;, (name, age) =&gt; { console.log(&#39;1&#39;, name, age, total1); return total1++ &lt; 2 ? true : undefined; }); syncLoopHook.tap(&#39;2&#39;, (name, age) =&gt; { console.log(&#39;2&#39;, name, age, total2); return total2++ &lt; 2 ? true : undefined; }); syncLoopHook.tap(&#39;3&#39;, (name, age) =&gt; console.log(&#39;3&#39;, name, age)); // 触发事件，让监听函数执行 syncLoopHook.call(&#39;panda&#39;, 18); // 1 panda 18 0 // 1 panda 18 1 // 1 panda 18 2 // 2 panda 18 0 // 2 panda 18 1 // 2 panda 18 2 // 3 panda 18 通过上面的执行结果可以清楚的看到 SyncLoopHook 的执行机制，但有一点需要注意，返回值必须严格是 true 才会触发循环，多次执行当前事件处理函数，必须严格返回 undefined，才会结束循环去执行后面的事件处理函数，如果事件处理函数的返回值不是 true 也不是 undefined，则会死循环。在了解 SyncLoopHook 的执行机制以后，我们接下来看看 SyncLoopHook 的 call 方法是如何实现的。/* 模拟 SyncLoopHook 类 */ class SyncLoopHook { constructor(args) { this.args = args; this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 依次执行事件处理函数，如果返回值为 true，则继续执行当前事件处理函数 // 直到返回 undefined，则继续向下执行其他事件处理函数 this.tasks.forEach(task =&gt; { let ret; do { ret = this.task(...args); } while (ret === true || !(ret === undefined)); }); } } 在上面代码中可以看到 SyncLoopHook 类 call 方法的实现更像是 SyncHook 和 SyncBailHook 的 call 方法的结合版，外层循环整个 tasks 事件处理函数队列，内层通过返回值进行循环，控制每一个事件处理函数的执行次数。注意：在 Sync 类型 “钩子” 下执行的插件都是顺序执行的，只能使用 tab 注册。Async 类型的钩子Async 类型可以使用 tap、tapAsync 和 tapPromise 注册不同类型的插件 “钩子”，分别通过 call、callAsync 和 promise 方法调用，我们下面会针对 AsyncParallelHook 和 AsyncSeriesHook 的 async 和 promise 两种方式分别介绍和模拟。AsyncParallelHookAsyncParallelHook 为异步并行执行，通过 tapAsync 注册的事件，通过 callAsync 触发，通过 tapPromise 注册的事件，通过 promise 触发（返回值可以调用 then 方法）。tapAsync/callAsynccallAsync 的最后一个参数为回调函数，在所有事件处理函数执行完毕后执行。/* AsyncParallelHook 钩子：tapAsync/callAsync 的使用 */ const { AsyncParallelHook } = require(&#39;tapable&#39;); // 创建实例 const asyncParallelHook = new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 console.time(&#39;time&#39;); asyncParallelHook.tapAsync(&#39;1&#39;, (name, age, done) =&gt; { settimeout(() =&gt; { console.log(&#39;1&#39;, name, age, new Date()); done(); }, 1000); }); asyncParallelHook.tapAsync(&#39;2&#39;, (name, age, done) =&gt; { settimeout(() =&gt; { console.log(&#39;2&#39;, name, age, new Date()); done(); }, 2000); }); asyncParallelHook.tapAsync(&#39;3&#39;, (name, age, done) =&gt; { settimeout(() =&gt; { console.log(&#39;3&#39;, name, age, new Date()); done(); console.timeEnd(&#39;time&#39;); }, 3000); }); // 触发事件，让监听函数执行 asyncParallelHook.callAsync(&#39;panda&#39;, 18, () =&gt; { console.log(&#39;complete&#39;); }); // 1 panda 18 2018-08-07T10:38:32.675Z // 2 panda 18 2018-08-07T10:38:33.674Z // 3 panda 18 2018-08-07T10:38:34.674Z // complete // time: 3005.060ms 异步并行是指，事件处理函数内三个定时器的异步操作最长时间为 3s，而三个事件处理函数执行完成总共用时接近 3s，所以三个事件处理函数是几乎同时执行的，不需等待。所有 tabAsync 注册的事件处理函数最后一个参数都为一个回调函数 done，每个事件处理函数在异步代码执行完毕后调用 done 函数，则可以保证 callAsync 会在所有异步函数都执行完毕后执行，接下来看一看 callAsync 是如何实现的。/* 模拟 AsyncParallelHook 类：tapAsync/callAsync */ class AsyncParallelHook { constructor(args) { this.args = args; this.tasks = []; } tabAsync(name, task) { this.tasks.push(task); } callAsync(...args) { // 先取出最后传入的回调函数 const finalCallback = args.pop(); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 定义一个 i 变量和 done 函数 // 每次执行检测 i 值和队列长度，决定是否执行 callAsync 的回调函数 let i = 0; const done = () =&gt; { if (++i === this.tasks.length) { finalCallback(); } }; // 依次执行事件处理函数 this.tasks.forEach(task =&gt; task(...args, done)); } } 在 callAsync 中，将最后一个参数（所有事件处理函数执行完毕后执行的回调）取出，并定义 done 函数，通过比较 i 和存储事件处理函数的数组 tasks 的 length 来确定回调是否执行，循环执行每一个事件处理函数并将 done 作为最后一个参数传入，所以每个事件处理函数内部的异步操作完成时，执行 done 就是为了检测是不是该执行 callAsync 的回调，当所有事件处理函数均执行完毕满足 done 函数内部 i 和 length 相等的条件时，则调用 callAsync 的回调。tapPromise/promise要使用 tapPromise 注册事件，对事件处理函数有一个要求，必须返回一个 Promise 实例，而 promise 方法也返回一个 Promise 实例，callAsync 的回调函数在 promise 方法中用 then 的方式代替。/* AsyncParallelHook 钩子：tapPromise/promise 的使用 */ const { AsyncParallelHook } = require(&#39;tapable&#39;); // 创建实例 const asyncParallelHook = new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 console.time(&#39;time&#39;); asyncParallelHook.tapPromise(&#39;1&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;1&#39;, name, age, new Date()); resolve(&#39;1&#39;); }, 1000); }); }); asyncParallelHook.tapPromise(&#39;2&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;2&#39;, name, age, new Date()); resolve(&#39;2&#39;); }, 2000); }); }); asyncParallelHook.tapPromise(&#39;3&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;3&#39;, name, age, new Date()); resolve(&#39;3&#39;); console.timeEnd(&#39;time&#39;); }, 3000); }); }); // 触发事件，让监听函数执行 asyncParallelHook.promise(&#39;panda&#39;, 18).then(ret =&gt; { console.log(ret); }); // 1 panda 18 2018-08-07T12:17:21.741Z // 2 panda 18 2018-08-07T12:17:22.736Z // 3 panda 18 2018-08-07T12:17:23.739Z // time: 3006.542ms // [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ] 上面每一个 tapPromise 注册事件的事件处理函数都返回一个 Promise 实例，并将返回值传入 resolve 方法，调用 promise 方法触发事件时，如果所有事件处理函数返回的 Promise 实例结果都成功，会将结果存储在数组中，并作为参数传递给 promise 的 then 方法成功的回调，如果有一个失败就是将失败的结果返回作为参数传递给失败的回调。/* 模拟 AsyncParallelHook 类 tapPromise/promise */ class AsyncParallelHook { constructor(args) { this.args = args; this.tasks = []; } tapPromise(name, task) { this.tasks.push(task); } promise(...args) { // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 将所有事件处理函数转换成 Promise 实例，并发执行所有的 Promise return Promise.all(this.tasks.map(task =&gt; task(...args))); } } 其实根据上面对于 tapPromise 和 promise 使用的描述就可以猜到，promise 方法的逻辑是通过 Promise.all 来实现的。AsyncSeriesHookAsyncSeriesHook 为异步串行执行，与 AsyncParallelHook 相同，通过 tapAsync 注册的事件，通过 callAsync 触发，通过 tapPromise 注册的事件，通过 promise 触发，可以调用 then 方法。tapAsync/callAsync与 AsyncParallelHook 的 callAsync 方法类似，AsyncSeriesHook 的 callAsync 方法也是通过传入回调函数的方式，在所有事件处理函数执行完毕后执行 callAsync 的回调函数。/* AsyncSeriesHook 钩子：tapAsync/callAsync 的使用 */ const { AsyncSeriesHook } = require(&#39;tapable&#39;); // 创建实例 const asyncSeriesHook = new AsyncSeriesHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 console.time(&#39;time&#39;); asyncSeriesHook.tapAsync(&#39;1&#39;, (name, age, next) =&gt; { settimeout(() =&gt; { console.log(&#39;1&#39;, name, age, new Date()); next(); }, 1000); }); asyncSeriesHook.tapAsync(&#39;2&#39;, (name, age, next) =&gt; { settimeout(() =&gt; { console.log(&#39;2&#39;, name, age, new Date()); next(); }, 2000); }); asyncSeriesHook.tapAsync(&#39;3&#39;, (name, age, next) =&gt; { settimeout(() =&gt; { console.log(&#39;3&#39;, name, age, new Date()); next(); console.timeEnd(&#39;time&#39;); }, 3000); }); // 触发事件，让监听函数执行 asyncSeriesHook.callAsync(&#39;panda&#39;, 18, () =&gt; { console.log(&#39;complete&#39;); }); // 1 panda 18 2018-08-07T14:40:52.896Z // 2 panda 18 2018-08-07T14:40:54.901Z // 3 panda 18 2018-08-07T14:40:57.901Z // complete // time: 6008.790ms 异步串行是指，事件处理函数内三个定时器的异步执行时间分别为 1s、2s 和 3s，而三个事件处理函数执行完总共用时接近 6s，所以三个事件处理函数执行是需要排队的，必须一个一个执行，当前事件处理函数执行完才能执行下一个。AsyncSeriesHook 类的 tabAsync 方法注册的事件处理函数参数中的 next 可以与 AsyncParallelHook 类中 tabAsync 方法参数的 done 进行类比，同为回调函数，不同点在于 AsyncSeriesHook 与 AsyncParallelHook 的 callAsync 方法的 “并行” 和 “串行” 的实现方式。/* 模拟 AsyncSeriesHook 类：tapAsync/callAsync */ class AsyncSeriesHook { constructor(args) { this.args = args; this.tasks = []; } tabAsync(name, task) { this.tasks.push(task); } callAsync(...args) { // 先取出最后传入的回调函数 const finalCallback = args.pop(); // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 定义一个 i 变量和 next 函数，每次取出一个事件处理函数执行，并维护 i 的值 // 直到所有事件处理函数都执行完，调用 callAsync 的回调 // 如果事件处理函数中没有调用 next，则无法继续 let i = 0; const next = () =&gt; { const task = this.tasks[i++]; task ? task(...args, next) : finalCallback(); }; next(); } } AsyncParallelHook 是通过循环依次执行了所有的事件处理函数，done 方法只为了检测是否已经满足条件执行 callAsync 的回调，如果中间某个事件处理函数没有调用 done，只是不会调用 callAsync 的回调，但是所有的事件处理函数都执行了。而 AsyncSeriesHook 的 next 执行机制更像 Express 和 Koa 中的中间件，在注册事件的回调中如果不调用 next，则在触发事件时会在没有调用 next 的事件处理函数的位置 “卡死”，即不会继续执行后面的事件处理函数，只有都调用 next 才能继续，而最后一个事件处理函数中调用 next 决定是否调用 callAsync 的回调。tapPromise/promise与 AsyncParallelHook 类似，tapPromise 注册事件的事件处理函数需要返回一个 Promise 实例，promise 方法最后也返回一个 Promise 实例。/* AsyncSeriesHook 钩子：tapPromise/promise 的使用 */ const { AsyncSeriesHook } = require(&#39;tapable&#39;); // 创建实例 const asyncSeriesHook = new AsyncSeriesHook([&#39;name&#39;, &#39;age&#39;]); // 注册事件 console.time(&#39;time&#39;); asyncSeriesHook.tapPromise(&#39;1&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;1&#39;, name, age, new Date()); resolve(&#39;1&#39;); }, 1000); }); }); asyncSeriesHook.tapPromise(&#39;2&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;2&#39;, name, age, new Date()); resolve(&#39;2&#39;); }, 2000); }); }); asyncParallelHook.tapPromise(&#39;3&#39;, (name, age) =&gt; { return new Promise((resolve, reject) =&gt; { settimeout(() =&gt; { console.log(&#39;3&#39;, name, age, new Date()); resolve(&#39;3&#39;); console.timeEnd(&#39;time&#39;); }, 3000); }); }); // 触发事件，让监听函数执行 asyncSeriesHook.promise(&#39;panda&#39;, 18).then(ret =&gt; { console.log(ret); }); // 1 panda 18 2018-08-07T14:45:52.896Z // 2 panda 18 2018-08-07T14:45:54.901Z // 3 panda 18 2018-08-07T14:45:57.901Z // time: 6014.291ms // [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ] 分析上面的执行过程，所有的事件处理函数都返回了 Promise 的实例，如果想实现 “串行”，则需要让每一个返回的 Promise 实例都调用 then，并在 then 中执行下一个事件处理函数，这样就保证了只有上一个事件处理函数执行完后才会执行下一个。/* 模拟 AsyncSeriesHook 类 tapPromise/promise */ class AsyncSeriesHook { constructor(args) { this.args = args; this.tasks = []; } tapPromise(name, task) { this.tasks.push(task); } promise(...args) { // 传入参数严格对应创建实例传入数组中的规定的参数，执行时多余的参数为 undefined args = args.slice(0, this.args.length); // 将每个事件处理函数执行并调用返回 Promise 实例的 then 方法 // 让下一个事件处理函数在 then 方法成功的回调中执行 const [first, ...others] = this.tasks; return others.reduce((promise, task) =&gt; { return promise.then(() =&gt; task(...args)); }, first(...args)); } } 上面代码中的 “串行” 是使用 reduce 归并来实现的，首先将存储所有事件处理函数的数组 tasks 解构成两部分，第一个事件处理函数和存储其他事件处理函数的数组 others，对 others 进行归并，将第一个事件处理函数执行后返回的 Promise 实例作为归并的初始值，这样在归并的过程中上一个值始终是上一个事件处理函数返回的 Promise 实例，可以直接调用 then 方法，并在 then 的回调中执行下一个事件处理函数，直到归并完成，将 reduce 最后返回的 Promise 实例作为 promise 方法的返回值，则实现 promise 方法执行后继续调用 then 来实现后续逻辑。对其他异步钩子补充在上面 Async 异步类型的 “钩子中”，我们只着重介绍了 “串行” 和 “并行”（AsyncParallelHook 和 AsyncSeriesHook）以及回调和 Promise 的两种注册和触发事件的方式，还有一些其他的具有一定特点的异步 “钩子” 我们并没有进行分析，因为他们的机制与同步对应的 “钩子” 非常的相似。AsyncParallelBailHook 和 AsyncSeriesBailHook 分别为异步 “并行” 和 “串行” 执行的 “钩子”，返回值不为 undefined，即有返回值，则立即停止向下执行其他事件处理函数，实现逻辑可结合 AsyncParallelHook 、AsyncSeriesHook 和 SyncBailHook。AsyncSeriesWaterfallHook 为异步 “串行” 执行的 “钩子”，上一个事件处理函数的返回值作为参数传递给下一个事件处理函数，实现逻辑可结合 AsyncSeriesHook 和 SyncWaterfallHook。总结在 tapable 源码中，注册事件的方法 tab、tapAsync、tapPromise 和触发事件的方法 call、callAsync、promise 都是通过 compile 方法快速编译出来的，我们本文中这些方法的实现只是遵照了 tapable 库这些 “钩子” 的事件处理机制进行了模拟，以方便我们了解 tapable，为学习 Webpack 原理做了一个铺垫，在 Webpack 中，这些 “钩子” 的真正作用就是将通过配置文件读取的插件与插件、加载器与加载器之间进行连接，“并行” 或 “串行” 执行，相信在我们对 tapable 中这些 “钩子” 的事件机制有所了解之后，再重新学习 Webpack 的源码应该会有所头绪。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"tapable","slug":"tapable","permalink":"https://www.overtaking.top/tags/tapable/"},{"name":"Hooks","slug":"Hooks","permalink":"https://www.overtaking.top/tags/Hooks/"}]},{"title":"Node.js 多进程和集群","date":"2018-07-27T06:02:33.000Z","path":"20180727140233/","text":"进程和线程“进程” 是计算机系统进行资源分配和调度的基本单位，我们可以理解为计算机每开启一个任务就会创建至少一个进程来处理，有时会创建多个，如 Chrome 浏览器的选项卡，其目的是为了防止一个进程挂掉而应用停止工作，而 “线程” 是程序执行流的最小单元，Node.js 默认是单进程、单线程的，我们将这个进程称为主进程，也可以通过 child_process 模块创建子进程实现多进程，我们称这些子进程为 “工作进程”，并且归主进程管理，进程之间默认是不能通信的，且所有子进程执行任务都是异步的。spawn 实现多进程spawn 创建子进程在 Node.js 中执行一个 JS 文件，如果想在这个文件中再同时（异步）执行另一个 JS 文件，可以使用 child_process 模块中的 spawn 来实现，spawn 可以帮助我们创建一个子进程，用法如下。/* 文件：process.js */ const { spawn } = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;, &#39;--port&#39;, &#39;3000&#39;], { cwd: path.join(__dirname, &#39;test&#39;) // 指定子进程的当前工作目录 }); // 出现错误触发 child.on(&#39;error&#39;, err =&gt; console.log(err)); // 子进程退出触发 child.on(&#39;exit&#39;, () =&gt; console.log(&#39;exit&#39;)); // 子进程关闭触发 child.on(&#39;close&#39;, () =&gt; console.log(&#39;close&#39;)); // exit // close spawn 方法可以帮助我们创建一个子进程，这个方法的返回值就是子进程 id，spawn 接收以下几个参数：command：要运行的命令；args：类型为数组，数组内第一项为文件名，后面项依次为执行文件的命令参数和值；options：选项，类型为对象，用于指定子进程的当前工作目录和主进程、子进程的通信规则等，具体可查看 官方文档。error 事件在子进程出错时触发，exit 事件在子进程退出时触发，close 事件在子进程关闭后触发，在子进程任务结束后 exit 一定会触发，close 不一定触发。/* 文件：~test/sub_process.js */ // 打印子进程执行 sub_process.js 文件的参数 console.log(process.argv); 通过上面代码打印了子进程执行时的参数，但是我们发现主进程窗口并没有打印，我们希望的是子进程的信息可以反馈给主进程，要实现通信需要在创建子进程时在第三个参数 options 中配置 stdio 属性定义。spawn 定义输入、输出/* 文件：process.js */ const { spawn } = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;, &#39;--port&#39;, &#39;3000&#39;], { cwd: path.join(__dirname, &#39;test&#39;) // 指定子进程的当前工作目录 // stdin: [process.stdin, process.stdout, process.stderr] stdio: [0, 1, 2] // 配置标准输入、标准输出、错误输出 }); // C:\\Program Files\\Node.js\\node.exe,g:\\process\\test\\sub_process.js,--port,3000 /* 文件：~test/sub_process.js */ // 使用主进程的标准输出，输出 sub_process.js 文件执行的参数 process.stdout.write(process.argv.toString()); 通过上面配置 options 的 stdio 值为数组，上面的两种写法作用相同，都表示子进程和主进程共用了主进程的标准输入、标准输出、和错误输出，实际上并没有实现主进程与子进程的通信，其中 0 和 stdin 代表标准输入，1 和 stdout 代表标准输出，2 和 stderr 代表错误输出。上面这样的方式只要子进程执行 sub_process.js 就会在窗口输出，如果我们希望是否输出在主进程里面控制，即实现子进程与主进程的通信，看下面用法。/* 文件：process.js */ const { spawn } = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: [&#39;pipe&#39;] }); child.stdout.on(&#39;data&#39;, data =&gt; console.log(data.toString())); // hello world /* 文件：~test/sub_process.js */ // 子进程执行 sub_process.js process.stdout.write(&#39;hello world&#39;); 上面将 stdio 内数组的值配置为 pipe（默认不写就是 pipe），则通过流的方式实现主进程和子进程的通信，通过子进程的标准输出（可写流）写入，在主进程通过子进程的标准输出通过 data 事件读取的流在输出到窗口（这种写法很少用），上面都只在主进程中开启了一个子进程，下面举一个开启多个进程的例子。例子的场景是主进程开启两个子进程，先运行子进程 1 传递一些参数，子进程 1 将参数取出返还给主进程，主进程再把参数传递给子进程 2，通过子进程 2 将参数写入到文件 param.txt 中，这个过程不代表真实应用场景，主要目的是体会主进程和子进程的通信过程。/* 文件：process.js */ const { spawn } = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child1 = spawn(&#39;node&#39;, [&#39;sub_process_1.js&#39;, &#39;--port&#39;, &#39;3000&#39;], { cwd: path.join(__dirname, &#39;test&#39;), }); const child2 = spawn(&#39;node&#39;, [&#39;sub_process_2.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), }); // 读取子进程 1 写入的内容，写入子进程 2 child1.stdout.on(&#39;data&#39;, data =&gt; child2.stdout.write(data.toString)); /* 文件：~test/sub_process_1.js */ // 获取 --port 和 3000 process.argv.slice(2).forEach(item =&gt; process.stdout.write(item)); /* 文件：~test/sub_process_2.js */ const fs = require(&#39;fs&#39;); // 读取主进程传递的参数并写入文件 process.stdout.on(&#39;data&#39;, data =&gt; { fs.writeFile(&#39;param.txt&#39;, data, () =&gt; { process.exit(); }); }); 有一点需要注意，在子进程 2 写入文件的时候，由于主进程不知道子进程 2 什么时候写完，所以主进程会卡住，需要子进程在写入完成后调用 process.exit 方法退出子进程，子进程退出并关闭后，主进程会随之关闭。在我们给 options 配置 stdio 时，数组内其实可以对标准输入、标准输出和错误输出分开配置，默认数组内为 pipe 时代表三者都为 pipe，分别配置看下面案例。/* 文件：process.js */ const { spawn } = require(&#39;spawn&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: [0, &#39;pipe&#39;, 2] }); // world /* 文件：~test/sub_process.js */ console.log(&#39;hello&#39;); console.error(&#39;world&#39;); 上面代码中对 stderr 实现了默认打印而不通信，对标准输入实现了通信，还有一种情况，如果希望子进程只是默默的执行任务，而在主进程命令窗口什么类型的输出都禁止，可以在数组中对应位置给定值 ignore，将上面案例修改如下。/* 文件：process.js */ const { spawn } = require(&#39;spawn&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;] }); /* 文件：~test/sub_process.js */ console.log(&#39;hello&#39;); console.error(&#39;world&#39;); 这次我们发现无论标准输出和错误输出都没有生效，上面这些方式其实是不太方便的，因为输出有 stdout 和 stderr，在写法上没办法统一，可以通过下面的方式来统一。标准进程通信/* 文件：process.js */ const { spawn } = require(&#39;spawn&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;, &#39;ipc&#39;] }); child.on(&#39;message&#39;, data =&gt; { console.log(data); // 回复消息给子进程 child.send(&#39;world&#39;); // 杀死子进程 // process.kill(child.pid); }); // hello /* 文件：~test/sub_process.js */ // 给主进程发送消息 process.send(&#39;hello&#39;); // 接收主进程回复的消息 process.on(&#39;message&#39;, data =&gt; { console.log(data); // 退出子进程 process.exit(); }); // world 这种方式被称为标准进程通信，通过给 options 的 stdio 数组配置 ipc，只要数组中存在 ipc 即可，一般放在数组开头或结尾，配置 ipc 后子进程通过调用自己的 send 方法发送消息给主进程，主进程中用子进程的 message 事件进行接收，也可以在主进程中接收消息的 message 事件的回调当中，通过子进程的 send 回复消息，并在子进程中用 message 事件进行接收，这样的编程方式比较统一，更贴近于开发者的意愿。退出和杀死子进程上面代码中子进程在接收到主进程的消息时直接退出，也可以在子进程发送给消息给主进程时，主进程接收到消息直接杀死子进程，代码如下。/* 文件：process.js */ const { spawn } = require(&#39;spawn&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: [0, &#39;pipe&#39;, &#39;ignore&#39;, &#39;ipc&#39;] }); child.on(&#39;message&#39;, data =&gt; { console.log(data); // 杀死子进程 process.kill(child.pid); }); // hello world /* 文件：~test/sub_process.js */ // 给主进程发送消息 process.send(&#39;hello&#39;); 从上面代码我们可以看出，杀死子进程的方法为 process.kill，由于一个主进程可能有多个子进程，所以指定要杀死的子进程需要传入子进程的 pid 属性作为 process.kill 的参数。注意：退出子进程 process.exit 方法是在子进程中操作的，此时 process 代表子进程，杀死子进程 process.kill 是在主进程中操作的，此时 process 代表主进程。独立子进程我们前面说过，child_process 模块创建的子进程是被主进程统一管理的，如果主进程挂了，所有的子进程也会受到影响一起挂掉，但其实使用多进程一方面为了提高处理任务的效率，另一方面也是为了当一个进程挂掉时还有其他进程可以继续工作，不至于整个应用挂掉，这样的例子非常多，比如 Chrome 浏览器的选项卡，比如 VSCode 编辑器运行时都会同时开启多个进程同时处理任务，其实在 spawn 创建子进程时，也可以实现子进程的独立，即子进程不再受主进程的控制和影响。/* 文件：process.js */ const { spawn } = require(&#39;spawn&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = spawn(&#39;node&#39;, [&#39;sub_process.js&#39;], { cwd: path.join(__dirname, &#39;test&#39;), stdio: &#39;ignore&#39;, detached: true }); // 与主进程断绝关系 child.unref(); /* 文件：~test/sub_process.js */ const fs = require(&#39;fs&#39;); setInterval(() =&gt; { fs.appendFileSync(&#39;test.txt&#39;, &#39;hello&#39;); }); 要想创建的子进程独立，需要在创建子进程时配置 detached 参数为 true，表示该子进程不受控制，还需调用子进程的 unref 方法与主进程断绝关系，但是仅仅这样子进程可能还是会受主进程的影响，要想子进程完全独立需要保证子进程一定不能和主进程共用标准输入、标准输出和错误输出，也就是 stdio 必须设置为 ignore，这也就代表着独立的子进程是不能和主进程进行标准进程通信，即不能设置 ipc。fork 实现多进程fork 的使用fork 也是 child_process 模块的一个方法，与 spawn 类似，是在 spawn 的基础上又做了一层封装，我们看一个 fork 使用的例子。/* 文件：process.js */ const fork = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 创建子进程 const child = fork(&#39;sub_process.js&#39;, [&#39;--port&#39;, &#39;3000&#39;], { cwd: path.join(__dirname, &#39;test&#39;), silent: true }); child.send(&#39;hello world&#39;); /* 文件：~test/sub_process.js */ // 接收主进程发来的消息 process.on(&#39;message&#39;, data =&gt; console.log(data)); fork 的用法与 spawn 相比有所改变，第一个参数是子进程执行文件的名称，第二个参数为数组，存储执行时的参数和值，第三个参数为 options，其中使用 slilent 属性替代了 spawn 的 stdio，当 silent 为 true 时，此时主进程与子进程的所有非标准通信的操作都不会生效，包括标准输入、标准输出和错误输出，当设为 false 时可正常输出，返回值依然为一个子进程。fork 创建的子进程可以直接通过 send 方法和监听 message 事件与主进程进行通信。fork 的原理其实 fork 的原理非常简单，只是在子进程模块 child_process 上挂了一个 fork 方法，而在该方法内调用 spawn 并将 spawn 返回的子进程作为返回值返回，下面进行简易实现。/* 文件：fork.js */ const childProcess = require(&#39;child_process&#39;); const path = require(&#39;path&#39;); // 封装原理 childProcess.fork = function(modulePath, args, options) { const stdio = options.silent ? [&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;, &#39;ipc&#39;] : [0, 1, 2, &#39;ipc&#39;]; return childProcess.spawn(&#39;node&#39;, [modulePath, ...args], { ...options, stdio }); } // 创建子进程 const child = fork(&#39;sub_process.js&#39;, [&#39;--port&#39;, &#39;3000&#39;], { cwd: path.join(__dirname, &#39;test&#39;), silent: false }); // 向子进程发送消息 child.send(&#39;hello world&#39;); /* 文件：~test/sub_process.js */ // 接收主进程发来的消息 process.on(&#39;message&#39;, data =&gt; console.log(data)); // hello world spawn 中的有一些 fork 没有传的参数（如使用 node 执行文件），都在内部调用 spawn 时传递默认值或将默认参数与 fork 传入的参数进行整合，着重处理了 spawn 没有的参数 silent，其实就是处理成了 spawn 的 stdio 参数两种极端的情况（默认使用 ipc 通信），封装 fork 就是让我们能更方便的创建子进程，可以更少的传参。execFile 和 exec 实现多进程execFile 和 exec 是 child_process 模块的两个方法，execFile 是基于 spawn 封装的，而 exec 是基于 execFile 封装的，这两个方法用法大同小异，execFile 可以直接创建子进程进行文件操作，而 exec 可以直接开启子进程执行命令，常见的应用场景如 http-server 以及 weboack-dev-server 等命令行工具在启动本地服务时自动打开浏览器。/* execFile 和 exec */ const { execFile, exec } = require(&#39;child_process&#39;); const execFileChild = execFile(&#39;node&#39;, [&#39;--version&#39;], (err, stdout, stderr) =&gt; { if (error) throw error; console.log(stdout); console.log(stderr); }); const execChild = exec(&#39;node --version&#39;, (err, stdout, stderr) =&gt; { if (err) throw err; console.log(stdout); console.log(stderr); }); exec 与 execFile 的区别在于传参，execFile 第一个参数为文件的可执行路径或命令，第二个参数为命令的参数集合（数组），第三个参数为 options，最后一个参数为回调函数，回调函数的形参为错误、标准输出和错误输出。exec 在传参上将 execFile 的前两个参数进行了整合，也就是命令与命令参数拼接成字符串作为第一参数，后面的参数都与 execFile 相同。cluster 集群开启进程需要消耗内存，所以开启进程的数量要适合，合理运用多进程可以大大提高效率，如 Webpack 对资源进行打包，就开启了多个进程同时进行，大大提高了打包速度，集群也是多进程重要的应用之一，用多个进程同时监听同一个服务，一般开启进程的数量跟 CPU 核数相同为好，此时多个进程监听的服务会根据请求压力分流处理，也可以通过设置每个子进程处理请求的数量来实现 “负载均衡”。使用 ipc 实现集群ipc 标准进程通信使用 send 方法发送消息时第二个参数支持传入一个服务，必须是 http 服务或者 tcp 服务，子进程通过 message 事件进行接收，回调的参数分别对应发送的参数，即第一个参数为消息，第二个参数为服务，我们就可以在子进程创建服务并对主进程的服务进行监听和操作（listen 除了可以监听端口号也可以监听服务），便实现了集群，代码如下。/* 文件：server.js */ // os 模块用于获取系统信息 const os = require(&#39;os&#39;); const http = require(&#39;http&#39;); const path = require(&#39;path&#39;); const { fork } = rquire(&#39;child_process&#39;); // 创建服务 const server = createServer((res, req) =&gt; { res.end(&#39;hello&#39;); }).listen(3000); // 根据 CPU 个数创建子进程 os.cpus().forEach(() =&gt; { fork(&#39;child_server.js&#39;, { cwd: path.join(__dirname) }).send(&#39;server&#39;, server); }); /* 文件：child_server.js */ const http = require(&#39;http&#39;); // 接收来自主进程发来的服务 process.on(&#39;message&#39;, (data, server) =&gt; { // // 子进程共用主进程的服务 http.createServer((req, res) =&gt; { res.end(&#39;child&#39; + process.pid); }).listen(server); }); 上面代码中由主进程处理的请求会返回 hello，由子进程处理的请求会返回 child 加进程的 pid 组成的字符串。使用 cluster 实现集群cluster 模块是 Node.js 提供的用来实现集群的，他将 child_process 创建子进程的方法集成进去，实现方式要比使用 ipc 更简洁。/* 文件：cluster.js */ const cluster = require(&#39;cluster&#39;); const http = require(&#39;http&#39;); const os = require(&#39;os&#39;); // 判断当前执行的进程是否为主进程，为主进程则创建子进程，否则用子进程监听服务 if (cluster.isMaster) { // 创建子进程 os.cpus().forEach(() =&gt; cluster.fork()); } else { // 创建并监听服务 http.createServer((req, res) =&gt; { res.end(&#39;child&#39; + process.pid); }).listen(3000); } 上面代码既会执行 if 又会执行 else，这看似很奇怪，但其实不是在同一次执行的，主进程执行时会通过 cluster.fork 创建子进程，当子进程被创建会将该文件再次执行，此时则会执行 else 中对服务的监听，还有另一种用法将主进程和子进程执行的代码拆分开，逻辑更清晰，用法如下。/* 文件：cluster.js */ const cluster = require(&#39;cluster&#39;); const path = require(&#39;path&#39;); const os = require(&#39;os&#39;); // 设置子进程读取文件的路径 cluster.setupMaster({ exec: path.join(__dirname, &#39;cluster-server.js&#39;) }); // 创建子进程 os.cpus().forEach(() =&gt; cluster.fork()); /* 文件：cluster-server.js */ const http = require(&#39;http&#39;); // 创建并监听服务 http.createServer((req, res) =&gt; { res.end(&#39;child&#39; + process.pid); }).listen(3000); 通过 cluster.setupMaster 设置子进程执行文件以后，就可以将主进程和子进程的逻辑拆分开，在实际的开发中这样的方式也是最常用的，耦合度低，可读性好，更符合开发的原则。总结本篇着重的介绍了 Node.js 多进程的实现方式以及集群的使用，之所以在开头长篇大论的介绍 spawn，是因为其他的所有跟多进程相关的方法包括 fork、exec 等，以及模块 cluster 都是基于 spawn 的封装，如果对 spawn 足够了解，其他的也不在话下，希望大家通过这篇可以在 Node.js 多进程相关的开发中起到一个 “路标” 的作用。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"process","slug":"process","permalink":"https://www.overtaking.top/tags/process/"},{"name":"Cluster","slug":"Cluster","permalink":"https://www.overtaking.top/tags/Cluster/"}]},{"title":"Webpack —— tree-staking 解析","date":"2018-07-26T04:21:46.000Z","path":"20180726122146/","text":"tree-shaking 简介tree-shaking 是 Webpack 2 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，tree-shaking 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。AST 语法树分析假设我们现在使用了 ElementUI 组件库的两个组件，通常会使用解构赋值来引入。/* 优化前 */ import { Button, Alert } from &#39;element-ui&#39;; 这样引用资源，Webpack 在打包的时候会找到 element-ui 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，tree-shaking 是通过在 Webpack 中配置 babel-plugin-import 插件来实现的，它可以将解构的代码转换成下面的形式。/* 优化后 */ import Button from &#39;element-ui/lib/button&#39;; import Alert from &#39;element-ui/lib/Alert&#39;; 转化后会去 node_modules 中的 element-ui 模块找到 Button 和 Alert 两个组件对应的文件，并打包到出口文件中。通过上面的转换可以看出，其实 tree-shaking 的实现原理是通过改变 AST 抽象语法树 的结构来实现的，我们可以通过在线转换网站 http://esprima.org/demo/parse.html 将 JS 代码装换成 AST 语法树。/* 优化前的 AST 语法树 */ { &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ { &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ { &quot;type&quot;: &quot;ImportSpecifier&quot;, &quot;local&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; }, &quot;imported&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; } }, { &quot;type&quot;: &quot;ImportSpecifier&quot;, &quot;local&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; }, &quot;imported&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; } } ], &quot;source&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui&quot;, &quot;raw&quot;: &quot;\\&quot;element-ui\\&quot;&quot; } } ], &quot;sourceType&quot;: &quot;module&quot; } /* 优化后的 AST 语法树 */ { &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ { &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ { &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;, &quot;local&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; } } ], &quot;source&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui/lib/button&quot;, &quot;raw&quot;: &quot;\\&quot;element-ui/lib/button\\&quot;&quot; } }, { &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ { &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;, &quot;local&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; } } ], &quot;source&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui/lib/Alert&quot;, &quot;raw&quot;: &quot;\\&quot;element-ui/lib/Alert\\&quot;&quot; } } ], &quot;sourceType&quot;: &quot;module&quot; } 从上面的语法树对比，可以看出在优化前 body 里面只有一个对象，使用的组件信息存在 specifiers 里，source 指向了 element-ui，而在优化后，将两个组件分别拆成了两个对象存在 body 中，每个对象的的 specifiers 只存储一个组件，并在 source 里面指向了当前组件对应的路径。tree-shaking 主要秉持着几个原则分为不同的处理方式，如代码不可触达，死变量只写不读等，我们上面描述的多用于 UI 组件库，也叫按需加载，其他的情况目前均由 Webpack 底层逻辑实现，我们本篇重点介绍按需加载的实现。模拟 tree-staking既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 tree-shaking 功能，对语法树的操作是依赖于 babel-core 和 babel-types 两个核心模块的，下面先安装依赖。$ npm install babel-core babel-types /* 文件：babel-plugin-my-import.js */ const babel = require(&#39;babel-core&#39;); const types = require(&#39;babel-types&#39;); const code = `import { Button, Alert } from &#39;element-ui&#39;`; const importPlugin = { visitor: { ImportDeclaration(path) { const node = path.node; const source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) { // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; { // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral(source + &#39;/lib/&#39; + specifier.local.name.toLowerCase()) ) }); // 替换树结构 path.replaceWithMultiple(specifiers); } } } }; const result = babel.transform(code, { plugins: [importPlugin] }); console.log(result.code); // import Button from &#39;element-ui/lib/button&#39;; // import Alert from &#39;element-ui/lib/alert&#39;; 通过上面的代码可以发现我们使用 babel-core 和 babel-types 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 https://github.com/babel/babel/tree/6.x/packages/babel-types。结合 Webpack 使用插件前面只是验证了 tree-shaking 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 tree-shaking 的工作过程。/* 文件：~node_modules/babel-plugin-my-import.js */ const babel = require(&#39;babel-core&#39;); const types = require(&#39;babel-types&#39;); const importPlugin = { visitor: { ImportDeclaration(path) { const node = path.node; const source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) { // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; { // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral(source + &#39;/lib/&#39; + specifier.local.name.toLowerCase()) ); }); // 替换树解构 path.replaceWithMultiple(specifiers); } } } }; module.exports = importPlugin; 上面删掉了多余的测试代码，将模块中的 importPlugin 插件导出，并把 babel-plugin-my-import.js 移入了 node_modules 当中。接下来安装需要的依赖：$ npm install webpack webpack-cli babel-loader babel-presets-env $ npm install vue element-ui --save 安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。/* 文件：import.js */ import Vue from &#39;vue&#39;; import { Button, Alert } from &#39;element-ui&#39;; 一个简单的 Webpack 配置文件如下：/* 文件：webpcak.config.js */ module.exports = { mode: &#39;development&#39;, entry: &#39;import.js&#39;, output: { filename: &#39;bundle.js&#39;, path: __dirname }, module: { rules: [{ test: /\\.js$/, use: { loader: &#39;babel-loader&#39;, options: { presets: [ &#39;env&#39;, ], plugins: [ // 插件：不使用插件打包注释掉该行即可 [&#39;my-import&#39;, { libararyName: &#39;element-ui&#39; }] ] } }, exclude: /node_modules/ }] } }; 为了防止 babel 相关的依赖升级 7.0 后出现一些问题导致 Webpack 无法启动，再此贴出 package.json 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。/* 文件：package.json */ { &quot;name&quot;: &quot;ast-lesson&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;tree-staking&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;babel-types&quot;: &quot;^6.26.0&quot;, &quot;escodegen&quot;: &quot;^1.10.0&quot;, &quot;esprima&quot;: &quot;^4.0.0&quot;, &quot;estraverse&quot;: &quot;^4.2.0&quot;, &quot;webpack&quot;: &quot;^4.16.0&quot;, &quot;webpack-cli&quot;: &quot;^3.0.8&quot; }, &quot;devDependencies&quot;: { &quot;vue&quot;: &quot;^2.5.17&quot;, &quot;element-ui&quot;: &quot;^2.4.6&quot; } } 对比使用插件前后的出口文件接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 bondle.js 的大小。$ npx webpack 使用 babel-plugin-my-import 前：使用 tree-staking 之前使用 babel-plugin-my-import 后：使用 tree-staking 之后通过对比，可以看到使用 tree-shaking 即我们自己实现的 babel-plugin-my-import 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。总结上面对 Webpack 的 tree-shaking 进行了分析，并模拟 babel-plugin-import 简易的实现了一版 tree-shaking 的优化插件，这个过程中相信大家已经了解了 tree-shaking 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，tree-shaking 优化的方式是根据 ES6 语法 import “静态” 引入的特性实现的，如果要说 tree-shaking 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 tree-shaking 只支持遍历一层 import 关键字。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Babel","slug":"Babel","permalink":"https://www.overtaking.top/tags/Babel/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"AST","slug":"AST","permalink":"https://www.overtaking.top/tags/AST/"},{"name":"tree-staking","slug":"tree-staking","permalink":"https://www.overtaking.top/tags/tree-staking/"}]},{"title":"AST 抽象语法树","date":"2018-07-25T05:02:33.000Z","path":"20180725130233/","text":"AST 抽象语法树简介AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。JavaScript 语法的 AST 语法树JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，可以通过 http://esprima.org/demo/parse.html 来实现 JavaScript 语法的在线转换。通过在线编译工具，可以将 function fn(a, b) {} 编译为下面的结构。{ &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ { &quot;type&quot;: &quot;FunctionDeclaration&quot;, &quot;id&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;fn&quot; }, &quot;params&quot;: [ { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;a&quot; }, { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;b&quot; } ], &quot;body&quot;: { &quot;type&quot;: &quot;BlockStatement&quot;, &quot;body&quot;: [] }, &quot;generator&quot;: false, &quot;expression&quot;: false, &quot;async&quot;: false } ], &quot;sourceType&quot;: &quot;script&quot; } 将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。esprima、estraverse 和 escodegenesprima、estraverse 和 escodegen 模块是操作 AST 的三个重要模块，也是实现 babel 的核心依赖，下面是分别介绍三个模块的作用。esprima 将 JS 转换成 ASTesprima 模块的用法如下：/* 文件：esprima-test.js */ const esprima = require(&#39;esprima&#39;); const code = &#39;function fn() {}&#39;; // 生成语法树 const tree = esprima.parseScript(code); console.log(tree); // Script { // type: &#39;Program&#39;, // body: // [ FunctionDeclaration { // type: &#39;FunctionDeclaration&#39;, // id: [Identifier], // params: [], // body: [BlockStatement], // generator: false, // expression: false, // async: false } ], // sourceType: &#39;script&#39; } 通过上面的案例可以看出，通过 esprima 模块的 parseScript 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 parseModule 方法转换一个模块。estraverse 遍历和修改 AST查看遍历过程：/* 文件：estraverse-test.js */ const esprima = require(&#39;esprima&#39;); const estraverse = require(&#39;estraverse&#39;); const code = &#39;function fn() {}&#39;; // 遍历语法树 estraverse.traverse(esprima.parseScript(code), { enter(node) { console.log(&#39;enter&#39;, node.type); }, leave() { console.log(&#39;leave&#39;, node.type); } }); // enter Program // enter FunctionDeclaration // enter Identifier // leave Identifier // enter BlockStatement // leave BlockStatement // leave FunctionDeclaration // leave Program 上面代码通过 estraverse 模块的 traverse 方法将 esprima 模块转换的 AST 进行了遍历，并打印了所有的 type 属性并打印，每含有一个 type 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。其实深度遍历 AST 就是在遍历每一层的 type 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 estraverse 的 traverse 方法中分别用参数指定的 entry 和 leave 两个函数监听，但是我们一般只使用 entry。escodegen 将 AST 转换成 JS下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。/* 文件：escodegen-test.js */ const esprima = require(&#39;esprima&#39;); const estraverse = require(&#39;estraverse&#39;); const escodegen = require(&#39;escodegen&#39;); const code = &#39;function fn() {}&#39;; // 生成语法树 const tree = esprima.parseScript(code); // 遍历语法树 estraverse.traverse(tree, { enter(node) { // 修改函数名 if (node.type === &#39;FunctionDeclaration&#39;) { node.id.name = &#39;ast&#39;; } } }); // 编译语法树 const result = escodegen.generate(tree); console.log(result); // function ast() { // } 在遍历 AST 的过程中 params 值为数组，没有 type 属性。实现 Babel 语法转换插件实现语法转换插件需要借助 babel-core 和 babel-types 两个模块，其实这两个模块就是依赖 esprima、estraverse 和 escodegen 的。使用这两个模块需要安装，命令如下：$ npm install babel-core babel-types 模拟 plugin-transform-arrow-functionsplugin-transform-arrow-functions 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。/* 文件：plugin-transform-arrow-functions.js */ const babel = require(&#39;babel-core&#39;); const types = require(&#39;babel-types&#39;); // 箭头函数代码块 const sumCode = ` const sum = (a, b) =&gt; { return a + b; }`; const minusCode = `const minus = (a, b) =&gt; a - b;`; // 转化 ES5 插件 const ArrowPlugin = { // 访问者（访问者模式） visitor: { // path 是树的路径 ArrowFunctionExpression(path) { // 获取树节点 const node = path.node; // 获取参数和函数体 const params = node.params; const body = node.body; // 判断函数体是否是代码块，不是代码块则添加 return 和 {} if (!types.isBlockStatement(body)) { const returnStatement = types.returnStatement(body); body = types.blockStatement([returnStatement]); } // 生成一个函数表达式树结构 const func = types.functionExpression(null, params, body, false, false); // 用新的树结构替换掉旧的树结构 path.replaceWith(func); } } }; // 生成转换后的代码块 const sumResult = babel.transform(sumCode, { plugins: [ArrowPlugin] }); const minusResult = babel.transform(minusCode, { plugins: [ArrowPlugin] }); console.log(sumResult.code); console.log(minusResult.code); // const sum = function (a, b) { // return a + b; // }; // const minus = function (a, b) { // return a - b; // }; 我们主要使用 babel-core 的 transform 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 plugins 值为数组，存储修改 babal-core 转换的 AST 的插件（对象），使用 transform 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 code 属性为转换后的代码块（字符串）。内部修改通过 babel-types 模块提供的方法实现，API 可以到 https://github.com/babel/babel/tree/6.x/packages/babel-types 中查看。ArrowPlugin 就是传入 transform 方法的插件，必须含有 visitor 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。在 types.functionExpression 方法中参数分别代表，函数名（匿名函数为 null）、函数参数（必填）、函数体（必填）、是否为 generator 函数（默认 false）、是否为 async 函数（默认 false），返回值为修改后的 AST，path.replaceWith 方法用于替换 AST，参数为新的 AST。模拟 plugin-transform-classesplugin-transform-classes 也是 Babel 家族中的成员之一，用于将 ES6 的 class 类转换成 ES5 的构造函数。/* 文件：plugin-transform-classes.js */ const babel = require(&#39;babel-core&#39;); const types = require(&#39;babel-types&#39;); // 类 const code = ` class Person { constructor(name) { this.name = name; } getName () { return this.name; } }`; // 将类转化 ES5 构造函数插件 const ClassPlugin = { visitor: { ClassDeclaration(path) { const node = path.node; const classList = node.body.body; // 将取到的类名转换成标识符 { type: &#39;Identifier&#39;, name: &#39;Person&#39; } const className = types.identifier(node.id.name); const body = types.blockStatement([]); let func = types.functionDeclaration(className, [], body, false, false); path.replaceWith(func); // 用于存储多个原型方法 const es5Func = []; // 获取 class 中的代码体 classList.forEach((item, index) =&gt; { // 函数的代码体 const body = classList[index].body; // 获取参数 let params = item.params.length ? item.params.map(val =&gt; val.name) : []; // 转化参数为标识符 params = types.identifier(params); // 判断是否是 constructor，如果构造函数那就生成新的函数替换 if (item.kind === &#39;constructor&#39;) { // 生成一个构造函数树结构 func = types.functionDeclaration(className, [params], body, false, false); } else { // 其他情况是原型方法 const proto = types.memberExpression(className, types.identifier(&#39;prototype&#39;)); // 左侧层层定义标识符 Person.prototype.getName const left = types.memberExpression(proto, types.identifier(item.key.name)); // 右侧定义匿名函数 const right = types.functionExpression(null, [params], body, false, false); // 将左侧和右侧进行合并并存入数组 es5Func.push(types.assignmentExpression(&#39;=&#39;, left, right)); } }); // 如果没有原型方法，直接替换 if (es5Func.length === 0) { path.replaceWith(func); } else { es5Func.push(func); // 替换 n 个节点 path.replaceWithMultiple(es5Func); } } } }; // 生成转换后的代码块 const result = babel.transform(code, { plugins: [ClassPlugin] }); console.log(result.code); // Person.prototype.getName = function () { // return this.name; // } // function Person(name) { // this.name = name; // } 上面这个插件的实现要比 plugin-transform-arrow-functions 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 babel-types 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 path.replaceWithMultiple 与 path.replaceWith 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。总结通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 Node.js 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 babel-core 和 babel-types 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Babel","slug":"Babel","permalink":"https://www.overtaking.top/tags/Babel/"},{"name":"Webpack","slug":"Webpack","permalink":"https://www.overtaking.top/tags/Webpack/"},{"name":"AST","slug":"AST","permalink":"https://www.overtaking.top/tags/AST/"}]},{"title":"命令行工具 —— 手写类似 http-server 的静态服务器","date":"2018-07-22T03:01:47.000Z","path":"20180722110147/","text":"前言npm 生态中的 http-server 模块，是一个简单的、零配置的 HTTP 服务，它非常强大，同时非常简单，可以方便的帮助我们开启本地服务器，以及局域网共享，可以用来做调试、开发、学习时的环境配置，我们本节就模拟 http-server 实现一个启动本地服务的命令行工具。http-server 使用http-server 服务器通过命令行启动，使用时需要安装，命令如下：$ npm install http-server -g 启动本地服务器时在根目录下执行下面命令即可：$ http-server [path] [option] path 默认情况下是 ./public，否则是 ./，启动后可以通过 http://localhost:8080 来访问服务器，options 为其他参数， npm 官方文档 https://www.npmjs.com/package/http-server 有详细说明。功能：当通过浏览器访问 http://localhost:8080 以后，会将我们服务器根目录的目录结构显示在浏览器页面上，当点击文件夹时，可以继续显示内部的文件和文件夹，当点击文件时会直接通过服务器访问文件，并将文件内容显示在浏览器页面上。实现命令行工具依赖的模块chalk 模块chalk 模块是用来控制命令行输出的文字颜色的第三方模块，使用前需要安装，安装命令如下：$ npm install chalk chalk 模块的用法如下，模块支持的颜色和更多的 API 可以在 npm 官方文档 https://www.npmjs.com/package/chalk 中查看。/* 文件位置：~static/tests/staticchalk-test.js */ const chalk = require(&#39;chalk&#39;); // 在命令行打印绿色和红色的 hello console.log(chalk.green(&#39;hello&#39;)); console.log(chalk.red(&#39;hello&#39;)); 在命令行窗口输入 node chalk-test.js 查看命令行打印 hello 的颜色。debug 模块debug 模块可以匹配当前环境变量 DEBUG 的值并输出相关信息，作用在于命令行工具可以根据不同情况输出的信息进行调试，是第三方模块，使用前需安装，命令如下：$ npm install debug debug 的简单使用如下，如果想了解更详细的 API 可以在 npm 官方文档 https://www.npmjs.com/package/debug 中查看。/* 文件位置：~static/tests/debug-test1.js —— 用法 1 */ const debug = require(&#39;debug&#39;)(&#39;hello&#39;); debug(&#39;hi panda&#39;); 当我们在命令行中执行 node debug-test1.js 时发现命令窗口什么也没有打印，那是因为当前根目录的环境变量 DEBUG 的值必须和我们设置的 hello 相匹配才会打印相关信息。设置环境变量，Windows 系统通过 set DEBUG=hello 设置，Mac 系统通过 export DEBUG=hello 设置，设置环境变量后再次执行 node debug-test.js，我们会发现命令行打印出了下面内容。hello hi panda +0ms 其中 hello 为我们设置 DEBUG 环境变量的值，hi panda 为 debug 调试方法打印的信息，+0ms 为距离上次执行的间隔时间。/* 文件位置：~static/tests/debug-test2.js —— 用法 2 */ const debugA = require(&#39;debug&#39;)(&#39;hello:a&#39;); const debugB = require(&#39;debug&#39;)(&#39;hello:b&#39;); debugA(&#39;hi panda&#39;); debugB(&#39;hello panda&#39;); 上面的代码目的是可以让我们不同的 debug 方法可以匹配不同的环境变量，所以需要重新将环境变量的值设置为 hello:*，这样再次执行 node debug-test2.js 发现命令窗口打印了如下内容。hello:a hi panda +0ms hello:b hello panda +0ms 使用 debug 的好处就是可以在开发的时候打印一些调试用的信息，在开发完成后因为匹配不到环境变量，这些信息就会被隐藏。commander 模块commander 是一个开发命令行工具的解决方案（的作者是 Node 大神 tj），提供了用户命令行输入和参数解析的强大功能，commander 是第三方模块，使用时需要安装，命令如下：$ npm install commander 基本用法如下：/* 文件位置：~static/tests/commander-test1.js */ const commander = require(&#39;commander&#39;); // 解析 Node 进程执行时的参数 commander.version(&#39;1.0.0&#39;).parse(process.argv); 上面文件中 version 方法代表当前执行文件模块的版本，parse 是解析当前命令行进程参数的方法，process.argv 是参数集合（数组），第一个参数为执行的 Node 环境程序执行文件的绝对路径，第二个参数是 node 命令执行文件的绝对路径，后面为通过命令行传入的参数，如 --host、--port 等。在命令行执行 node commander-test.js --help 时默认会在命令行输出如下信息：Usage: [options] Options: -V, --version output the version number -h, --help output usage information 当然在我们的命令行工具中，参数不只 --version 和 --help 两个，我们希望更多的参数更多的功能，并且可定制的描述信息，使用案例如下：/* 文件位置：~static/tests/commander-test2.js */ const commander = require(&#39;commander&#39;); // 解析 Node 进程执行时的参数 commander .version(&#39;1.0.0&#39;) .usage(&#39;[options]&#39;) .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;) .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;) .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;) .parse(process.argv); console.log(commander.port); // 3000 console.log(commander.host); // localhost console.log(commander.dir); // public 在执行命令 node commander-test2.js --help 后会在命令窗口输出如下信息：Usage: yourname-http-server [options] ptions: -V, --version output the version number -p, --port &lt;n&gt; server port -o, --host &lt;n&gt; server host -d, --dir &lt;n&gt; server dir -h, --help output usage information usage 方法可以让我们详细的定制参数的类型和描述，option 方法可以让我们添加执行 --help 指令时打印的命令以及对应的描述信息。执行下面命令：$ node commander-test2.js --port 3000 --host localhost --dir public 执行命令后我们发现其实给我们的参数挂在了 commander 对象上，方便我们取值。在我们使用别人的命令行工具时会发现在上面输出信息的时候经常会在下面输出 How to use 的列表，更详细的描述了每条命令的作用及用法。/* 文件位置：~static/tests/commander-test3.js */ const commander = require(&#39;commander&#39;); // 必须写到 parse 方法的前面 commander.on(&#39;--help&#39;, function () { console.log(&#39;\\r\\n How to use:&#39;) console.log(&#39; yourname-http-server --port &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --host &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --dir &lt;val&gt;&#39;); }); // 解析 Node 进程执行时的参数 commander .version(&#39;1.0.0&#39;) .usage(&#39;[options]&#39;) .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;) .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;) .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;) .parse(process.argv); 再次执行命令 node commander-test2.js --help 后会在命令窗口输出如下信息：Usage: yourname-http-server [options] Options: -V, --version output the version number -p, --port &lt;n&gt; server port -o, --host &lt;n&gt; server host -d, --dir &lt;n&gt; server dir -h, --help output usage information How to use: yourname-http-server --port &lt;val&gt; yourname-http-server --host &lt;val&gt; yourname-http-server --dir &lt;val&gt; 以上是 commander 模块的基本用法，如想了解更详细的 API 和使用案例可以到 npm 官方文档查看，地址如下 https://www.npmjs.com/package/commander 。实现静态服务的功能文件目录 static |- bin | |- yourname-http-server.js |- public | |- css | | |- style.css | |- index.html | |- 1.txt |- tests | |- chalk-test.js | |- commander-test1.js | |- commander-test2.js | |- commander-test3.js | |- debug-test1.js | |- debug-test2.js |- config.js |- index.html |- index.js |- package-lock.json |- package.json 配置文件在启动静态服务的时候，我们希望可以通过命令行传参的形式来定义当前启动服务的主机名端口号，以及默认检索的文件根目录，所以需要配置文件来实现灵活传参。/* 文件位置：~static/config.js */ module.exports = { port: 3000, host: &#39;localhost&#39;, dir: process.cwd() } 在上面的配置中，默认端口号为 3000，默认主机名为 localhost，我们设置默认检索文件的根目录为通过命令行启动服务器的目录，而 process.cwd() 的值就是我们启动命令行执行命令的目录的绝对路径。创建服务器 Server 类因为我们的命令行工具启动本地服务可能是在系统的任意位置，或者指定启动服务访问的域，提高可配置性，并且要更方便给服务器扩展更多的方法处理不同的逻辑，所以需要创建一个 Server 类。/* 文件位置：~static/index.js —— Server 类的创建 */ // 引入依赖 const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const path = require(&#39;path&#39;); const fs = require(&#39;mz/fs&#39;); const mime = require(&#39;mime&#39;); const zlib = require(&#39;zlib&#39;); const chalk = require(&#39;chalk&#39;); const ejs = require(&#39;ejs&#39;); const debug = require(&#39;debug&#39;)(&#39;http:a&#39;); // 引入配置文件 const config = require(&#39;./config&#39;); // 读取模板文件 const templateStr = fs.readFileSync(path.join(__dirname, &#39;index.html&#39;),&#39;utf8&#39;); class Server { constructor() { this.config = config; // 配置 this.template = templateStr; // 模板 } } 我们在上面代码中引入了 config.js 配置文件，读取了用于启动服务后展示页面 index.html 的内容，并都挂在了 Server 类的实例上，目的是方便内部的方法使用以及达到不轻易操作全局变量的目的。启动服务器的 start 方法后面为了方便代码的拆分，我们将原型上的方法统一使用 Server.prototype.xxx 的方式来书写，实际上是写在 Server 类里面的。/* 文件位置：~static/index.js —— start 方法 */ Server.prototype.start = function () { // 创建服务 const server = http.createServer(this.handleRequest.bind(this)); // 从配置中解构端口号和主机名 const { port, host } = this.config; // 启动服务 server.listen(port, host, () =&gt; { debug(&#39;server start http://&#39; + host + &#39;:&#39; + chalk.green(port)); }); } 在 start 方法中创建了服务，在启动服务时只需要创建 Server 的实例并调用 start 方法，由于服务的回调中会处理很多请求响应的逻辑，会导致 start 方法的臃肿，所以将服务的回调函数抽取成 Server 类的一个实例方法 handleRequest，需要注意的是 handleRequest 内部的 this 指向需要我们修正。在启动服务时我们根据配置可以灵活的设置服务的地址，当设置 host 后，服务将只能通过 host 的值作为主机名的地址访问静态服务器，启动服务的提示我们通过匹配环境变量 DEBUG 的 debug 方法来打印，并将端口号设置成绿色。服务回调 handleRequest 方法在实现 handleRequest 之前我们应该了解要实现的功能：在 http-server 中，如果访问的服务地址路径后面指定具体要访问的文件，并且当前启动服务根目录按照访问路径可以查找到文件，将文件内容读取后响应给客户端；如果没指定文件，应该检索当前启动服务根目录或默认设置的目录结构，并将文件的结构通过模板渲染成超链接后将页面响应给客户端；再次点击页面的上的链接，如果是文件，直接读取并响应文件内容，如果是文件夹，则继续检索内部结构通过模板渲染成页面。/* 文件位置：~static/index.js —— handleRequest 方法 */ Server.prototype.handleRequest = async function (req, res) { // 获取访问的路径，默认为 / this.pathname = url.parse(req.url, true).pathname; // 将访问的路径名转换成绝对路径，取到的 dir 就是绝对路径 this.realPath = path.join(this.config.dir, this.pathname); debug(realPath); // 打印当前访问的绝对路径，用于调试 try { // 获取 statObj 对象，如果 await 同步使用 try...catch 捕获非法路径 const statObj = await fs.stat(this.realPath); if (statObj.isFile()) { // 如果是文件，直接返回文件内容 this.sendFile(req, res, statObj); } else { // 如果是文件夹则检索文件夹通过模板渲染后返回页面 this.sendDirDetails(req, res, statObj); } } catch (e) { // 如果路径非法，发送错误响应 this.sendError(req, res, e); } } handleRequest 由于内部需要使用异步操作获取 statObj 对象，所以我们使用了 async 函数，为了函数内部可以使用 await 避免异步回调嵌套，由于 await 会等待到异步执行完毕后继续向下执行，我们可以使用 try...catch... 捕获非法的访问路径，并做出错误响应。如果路径合法，我们需要检测访问路径对应的是文件还是文件夹，如果是文件则执行响应内容的逻辑，是文件夹执行检索文件夹渲染内部文件列表返回页面的逻辑。所以我们将错误处理逻辑、响应文件内容逻辑和返回文件夹详情页面的逻辑分别抽离成 Server 类的三个实例方法 sendError、sendFile 和 sendDirDetails，使得 handleRequest 方法逻辑清晰且不那么臃肿。错误响应 sendError 方法在服务器处理不同的请求和响应时可能需要处理不同的错误，这些错误的不同就是捕获错误对象的不同，所以我们的 sendError 方法为了更方便的或取请求参数、处理响应以及更好的复用，将参数设置为请求对象、响应对象和错误对象。/* 文件位置：~static/index.js —— sendError 方法 */ Server.prototype.sendError = function (req, res, err) { // 打印错误对象，方便调试 console.log(chalk.red(err)); // 设置错误状态码并响应 Not Found res.statusCode = 404; res.end(&#39;Not Found&#39;); } 渲染目录 sendDirDetails 方法在渲染文件夹详情之前我们首先要做的就是异步读取文件目录，所以我们同样使用 async 函数来实现，Node.js 中有很多渲染页面的模板，我们本次使用 ejs，语法简单，比较常用，ejs 为第三方模块，使用前需安装，更详细的用法可参照 npm 官方文档 https://www.npmjs.com/package/ejs。$ npm install ejs sendDirDetails 的参数为请求对象、响应对象和 statObj。/* 文件位置：~static/index.js —— sendDirDetails 方法 */ Server.prototype.sendDirDetails = async function (req, res, statObj) { // 读取当前文件夹 let dirs = await fs.readdir(this.realPath); // 构造模板需要的数据 dirs = dirs.map(dir =&gt; ({ name: dir, path: path.join(this.pathname, dir) })); // 渲染模板 const pageStr = ejs.render(this.template, { dirs }); // 响应客户端 res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); res.end(pageStr); } 还记得 Server 类的实例属性 template 存储的就是我们的模板（字符串），里面写的就是 ejs 的语法，我们使用 ejs 模块渲染的 render 方法可以将模板中的 JS 执行，并用传给该方法的参数的值替换掉模板中的变量，返回新的字符串，我们直接将字符串响应给客户端即可。注意：在构建模板数据的时候 path 为超链接标签要跳转的路径，如果直接使用 dir 的值，多级访问还是会在根目录去查找，所以路径非法会返回 Not Found，我们需要在每次访问的时候都将上一次访问的路径与当前访问的文件夹或文件名进行拼接，保证路径的正确性。ejs 模板 index.html上面已经知道了该怎样使用 ejs 对模板进行渲染，也对模板构造了数据，接下来就是使用 ejs 的语法编写我们的模板内容。&lt;!-- 文件位置：~static/index.html —— 模板 --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Server&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% dirs.forEach(function (item) { %&gt; &lt;li&gt; &lt;a href=&quot;&lt;%= item.path%&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% }) %&gt; &lt;/body&gt; &lt;/html&gt; 模板中 JS 逻辑使用 &lt;% %&gt; 包裹，使用 &lt;%= %&gt; 输出变量。返回文件内容 sendFile 方法由于都是根据路径查找或操作文件目录并做出响应，sendFile 方法与 sendDirDetails 方法的参数相同，分别为 req、res 和 statObj。/* 文件位置：~static/index.js —— sendFile 方法 */ Server.prototype.sendFile = function (req, res, statObj) { // 设置和处理缓存 if (this.cache(req, res, statObj)) { res.statusCode = 304; return res.end(); } // 创建可读流 const rs = fs.createReadStream(this.realPath); // 响应文件类型 res.setHeader(&#39;Content-Type&#39;, mime.getType(this.realPath) + &#39;;charset=utf8&#39;); // 压缩 const zip = this.compress(req, res, statObj); if (zip) return rs.pipe(zip).pipe(res); // 处理范围请求 if (this.range(req, res, statObj)) return; // 响应文件内容 rs.pipe(res); } 其实上面的方法在根目录执行 node index.js 启动服务后，通过我们默认配置的地址访问服务器，表面上就已经实现了 http-server 的功能，但是我们为了服务器的性能和功能更强大，又在这基础上实现了缓存策略、服务器压缩和处理范围请求的逻辑。推荐阅读：HTTP 缓存的那些事儿Node.js 服务器实现 gzip 压缩Node.js 使用 Range 请求实现下载功能我们将上面的三个功能分别抽离成了 Server 类的三个原型方法，cache、compress 和 range，并且这三个方法的参数都为 req、res 和 statObj。缓存策略 cache 方法我们本次的缓存兼容 HTTP 1.0 和 HTTP 1.1 版本，并且同时使用强制缓存和协商缓存共同存在的策略。/* 文件位置：~static/index.js —— cache 方法 */ Server.prototype.cache = function (req, res, statObj) { // 创建协商缓存标识 const etag = statObj.ctime.toGMTString() + statObj.size; const lastModified = statObj.ctime.toGMTString(); // 设置强制缓存 res.setHeader(&#39;Cache-Control&#39;, &#39;max-age=30&#39;); res.setHeader(&#39;Expires&#39;, new Date(Date.now() + 30 * 1000).toUTCString()); // 设置协商缓存 res.setHeader(&#39;Etag&#39;, etag); res.setHeader(&#39;Last-Modified&#39;, lastModified); // 获取协商缓存请求头 const { &#39;if-none-match&#39;: ifNodeMatch, &#39;if-modified-since&#39;: ifModifiedSince } = req.headers; if (etag !== ifNodeMatch &amp;&amp; lastModified !== ifModifiedSince) { return false; } else { return true; } } 我们使用的缓存策略为同时设置强制缓存和协商缓存，当强制缓存有效期内再次请求不会访问服务器，待强制缓存过期再次请求执行协商缓存策略，带标识访问服务器进行确认，确认的同时重新设置强制缓存和协商缓存的响应头信息，如果协商缓存任然生效，则直接返回 304 状态码，如果协商缓存失效则读取文件内容返回浏览器。服务器压缩 compress 方法为了减少文件数据在传输过程中消耗的流量和时间，我们在浏览器支持解压的情况下使用服务器压缩功能，浏览器会在请求时默认发送请求头 Accept-Encoding 通知我们的服务器当前支持的压缩格式，我们要做的就是按照压缩格式的优先级进行匹配，按照最高优先级的压缩格式进行压缩，将压缩后的数据返回，并通过响应头 Content-Encoding 通知浏览器当前的压缩格式（压缩流的本质为转化流）。/* 文件位置：~static/index.js —— compress 方法 */ Server.prototype.compress = function (req, res, statObj) { // 获取浏览器支持的压缩格式 const encoding = req.headers[&#39;accept-encoding&#39;]; // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩 if (encoding &amp;&amp; encoding.match(/\\bgzip\\b/)) { res.setHeader(&#39;Content-Encoding&#39;, &#39;gzip&#39;); return zlib.createGzip(); } else if (encoding &amp;&amp; encoding.match(/\\bdeflate\\b/)) { res.setHeader(&#39;Content-Encoding&#39;, &#39;deflate&#39;); return zlib.createDeflate(); } else { return false; // 不支持压缩返回 false } } 当浏览器支持压缩时，compress 方法返回的为优先级最高压缩格式的压缩流，不支持返回 false，存在压缩流，则将数据压缩并响应浏览器，与不压缩响应不同的是，需要使用压缩流将可读流转化为可写流写入响应 res 中，所以可读流执行了两次 pipe 方法。处理范围请求 range 方法range 方法处理的场景为客户端发送请求只想获取文件的某个范围的数据，此时通过 range 方法读取文件范围对应的内容响应给客户端，通过响应头 Accept-Ranges 通知浏览器当前响应范围请求，通过响应头 Content-Range 通知客户端响应的范围以及文件的总字节数。/* 文件位置：~static/index.js —— range 方法 */ Server.prototype.range = function (req, res, statObj) { // 获取 range 请求头 const range = req.headers[&#39;range&#39;]; if (range) { // 获取范围请求的开始和结束位置 let [, start, end] = range.match(/(\\d*)-(\\d*)/); // 处理请求头中范围参数不传的问题 start = start ? ParseInt(start) : 0; end = end ? ParseInt(end) : statObj.size - 1; // 设置范围请求响应 res.statusCode = 206; res.setHeader(&#39;Accept-Ranges&#39;, &#39;bytes&#39;); res.setHeader(&#39;Content-Range&#39;, &#39;bytes &#39; + start + &#39;-&#39; + end + &#39;/&#39; + statObj.size); fs.createReadStream(this.realPath, { start, end }).pipe(res); return true; } else { return false; } } range 方法默认返回值为布尔值，当不是范围请求时返回值为 false，则直接向下执行 sendFile 中的代码，正常读取文件全部内容并响应给浏览器，如果是范围请求则会处理范围请求后在直接结束后返回 true，会在 sendFile 中直接 return，不再向下执行。将静态服务器关联到命令行命令行启动服务器http-server 实际上是通过命令行启动、并传参的，我们需要将我们的程序与命令行关联，关联命令行只需以下几个步骤。首先，在根目录 package.json 文件中加入 bin 字段，值为对象，对象内属性为命令名称，值为对应执行文件的路径。// 文件位置：~static/package.json { &quot;name&quot;: &quot;yourname-http-server&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: { &quot;chalk&quot;: &quot;^2.4.1&quot;, &quot;commander&quot;: &quot;^2.17.1&quot;, &quot;debug&quot;: &quot;^3.1.0&quot;, &quot;ejs&quot;: &quot;^2.6.1&quot;, &quot;mime&quot;: &quot;^2.3.1&quot;, &quot;mz&quot;: &quot;^2.7.0&quot; }, &quot;bin&quot;: { &quot;yourname-http-server&quot;: &quot;bin/yourname-http-server.js&quot; }, &quot;devDependencies&quot;: {}, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 其次，在 yourname-http-server.js 文件中首行加入注释 #! /usr/bin/env node，在命令行执行命令时，默认会以 Node 执行 yourname-http-server.js 文件。最后，想要使用我们的命令启动 yourname-http-server.js 文件，则需要将这条命令连接到全局（与 -g 安装效果相同），在当前根目录下执行以下命令。$ npm link 当在命令行执行 yourname-http-server 时，Node 会默认执行 yourname-http-server.js 文件。命令行的参数传递我们现在知道在命令行执行命令后用 Node 启动的文件为 yourname-http-server.js，在启动文件时我们应该启动我们的服务器，并结合 commander 模块的参数解析，则需要用命令行传递的参数替换掉 config.js 中的默认参数。/* 文件位置：~static/bin/yourname-http-server.js —— 命令行执行文件 */ const commander = require(&#39;commander&#39;); const Server = require(&#39;../index&#39;); // 增加 How to use commander.on(&#39;--help&#39;, function () { console.log(&#39;\\r\\n How to use: \\r\\n&#39;) console.log(&#39; yourname-http-server --port &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --host &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --dir &lt;val&gt;&#39;); }); // 解析 Node 进程执行时的参数 commander .version(&#39;1.0.0&#39;) .usage(&#39;[options]&#39;) .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;) .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;) .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;) .parse(process.argv); // 创建 Server 实例传入命令行解析的参数 const server = new Server(commander); // 启动服务器 server.start(); 我们之前把 config.js 的配置直接挂在了 Server 实例的 config 属性上，创建服务使用的参数也是直接从该属性上获取的，因此我们要用 commander 对象对应的参数覆盖实例上 config 的参数，所以在创建 Server 实例时传入了 commander 对象，下面稍微修改 Server 类的部分代码。/* 文件位置：~static/index.js —— Server 类 */ class Server { constructor(options) { // 通过解构赋值将 options 的参数覆盖 config 的参数 this.config = { ...config, ...options }; // 配置 this.template = templateStr; // 模板 } } 执行下面命令，并通过浏览器访问 http://127.0.0.1:4000 来测试服务器功能。$ yourname-http-server --port 4000 --host 127.0.0.1 在启动服务时自动打开浏览器由于 JS 是单线程的，在命令行输入命令启动服务的同时不能去做其他的事，此时要靠多进程来帮助我们打开浏览器，在 JS 中开启一个子进程来打开浏览器。/* 文件位置：~static/bin/yourname-http-server.js —— 命令行执行文件 */ const commander = require(&#39;commander&#39;); const Server = require(&#39;../index&#39;); // 增加 How to use commander.on(&#39;--help&#39;, function () { console.log(&#39;\\r\\n How to use: \\r\\n&#39;) console.log(&#39; yourname-http-server --port &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --host &lt;val&gt;&#39;); console.log(&#39; yourname-http-server --dir &lt;val&gt;&#39;); }); // 解析 Node 进程执行时的参数 commander .version(&#39;1.0.0&#39;) .usage(&#39;[options]&#39;) .option(&#39;-p, --port &lt;n&gt;&#39;, &#39;server port&#39;) .option(&#39;-o, --host &lt;n&gt;&#39;, &#39;server host&#39;) .option(&#39;-d, --dir &lt;n&gt;&#39;, &#39;server dir&#39;) .parse(process.argv); // 创建 Server 实例传入命令行解析的参数 const server = new Server(commander); // 启动服务器 server.start(); // ********** 以下为新增代码 ********** const { exec } = require(&#39;child_process&#39;); // 判断系统执行不同的命令打开浏览器 const systemOrder = process.platform === &#39;win32&#39; ? &#39;start&#39; : &#39;open&#39;; exec(systemOrder + &#39;http://&#39; + commander.localhost + &#39;:&#39; + commander.port); // ********** 以上为新增代码 ********** 发布命令行工具到 npm在发布我们自己实现的 npm 模块之前需要先做一件事，就是解除当前模块与全局环境的 link，我们可以通过两种方式，第一种方式是直接到系统存储命令文件的文件夹删除模块对应命令的 yourname-http-server.cmd （Windows）文件，第二种方式是在模块根目录启动命令行并输入如下命令。$ npm unlink 输入下面命令进行登录：$ npm login 登录成功后执行下面命令进行发布：$ npm publish 发布成功后再次使用自己的模块需要通过 npm 下载并全局安装，命令如下：$ npm install yourname-http-server -g 任意文件夹内打开命令行，并执行命令启动服务验证。在发布模块之前如果使用 nrm 切换过其他的源，必须切换回 npm，再进行登录和发布操作。总结其实我们实现的静态服务器核心还在于处理请求和响应的逻辑上，只是不再手动输入 node 命令启动，而是借助一些第三方模块关联到了命令行并通过命令启动，开发其他类型的命令行工具也需要借助这些第三方模块，静态服务器只是其中之一，其实类似这种命令行工具在开发的角度来讲属于 “造轮子” 系列，可以独立开发命令行工具是一个成为前端架构的必备技能，希望通过本篇文章可以了解命令行工具的开发流程，在未来 “造轮子” 的道路上提供帮助。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"命令行","slug":"命令行","permalink":"https://www.overtaking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"http-server","slug":"http-server","permalink":"https://www.overtaking.top/tags/http-server/"},{"name":"npm","slug":"npm","permalink":"https://www.overtaking.top/tags/npm/"}]},{"title":"HTTP 缓存的那些事儿","date":"2018-07-20T03:06:47.000Z","path":"20180720110647/","text":"前言HTTP 缓存机制作为 Web 应用性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系的基础环节，也是想要成为前端架构的必备技能。缓存的作用我们为什么使用缓存，是因为缓存可以给我们的 Web 项目带来以下好处，以提高性能和用户体验。加快了浏览器加载网页的速度；减少了冗余的数据传输，节省网络流量和带宽；减少服务器的负担，大大提高了网站的性能。由于从本地缓存读取静态资源，加快浏览器的网页加载速度是一定的，也确实的减少了数据传输，就提高网站性能来说，可能一两个用户的访问对于减小服务器的负担没有明显效果，但如果这个网站在高并发的情况下，使用缓存对于减小服务器压力和整个网站的性能都会发生质的变化。缓存规则简介为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。缓存流程图当浏览器地址栏输入地址后请求的 index.html 是不会被缓存的，但 index.html 内部请求的其他资源会遵循缓存策略，HTTP 缓存有多种规则，根据是否需要向服务器发送请求主要分为两大类，强制缓存和协商缓存。强制缓存强制缓存流程强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据，强制缓存的流程如下。强制缓存流程图强制缓存判断到期时间那么如何判断缓存是否到期呢？其实还是根据第一次访问时服务器的响应头来实现的，在 HTTP 1.0 版本和 HTTP 1.1 版本有所不同。在 HTTP 1.0 版本，服务器使用的响应头字段为 Expires，值是将来的绝对时间（时间戳），浏览器请求时的当前时间超过了 Expires 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。-在 HTTP 1.1 版本，服务器使用的响应头字段为 Cache-Control，有多个值，意义各不相同。private：客户端可以缓存；public：客户端和代理服务器都可以缓存（对于前端而言，可以认为与 private 效果相同）；max-age=xxx：缓存的内容将在 xxx 秒后过期（相对时间，秒为单位）；no-cache：需要使用协商缓存（后面介绍）来验证数据是否过期；no-store：所有内容都不会缓存，强制缓存和协商缓存都不会触发。Cache-Control 的值中最常用的为 max-age=xxx，缓存本身就是为了数据传输的优化和性能而存在的，所以 no-store 很少使用。注意：在 HTTP 1.0 版本中，Expires 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 HTTP 1.1 版本中，因为 Cache-Control 的值 max-age=xxx 中的 xxx 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，两种响应头会同时使用，HTTP 1.1 版本优先级高于 HTTP 1.0。通过 Network 查看强制缓存我们通过 Chrome 浏览器的开发者工具，打开 NetWork 查看强制缓存的相关信息。缓存响应头上面是百度网站 Logo 图片的响应，我们可以清楚的看到，其中兼容了 HTTP 1.0 和 HTTP 1.1 版本，并使用强制缓存存储了 10 年。下面看一看通过缓存取出的数据在 Network 中与其他资源的区别。命中缓存其实缓存的储存是内存和磁盘两个位置，由当前浏览器本身的策略决定，比较随机，从内存的缓存中取出的数据会显示 (from memory cache)，从磁盘的缓存中取出的数据会显示 (from disk cache)。Node.js 服务器实现强制缓存/* 强制缓存 */ const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const path = require(&#39;path&#39;); const mime = require(&#39;mime&#39;); const fs = require(&#39;fs&#39;); const server = http.createServer((req, res) =&gt; { let { pathname } = url.parse(req.url, true); pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;; // 获取读取文件的绝对路径 const filePath = path.join(__dirname, pathname); // 查看路径是否合法 fs.access(filePath, err =&gt; { // 路径不合法则直接中断连接 if (err) return res.end(&#39;Not Found&#39;); // 设置强制缓存 res.setHeader(&#39;Expires&#39;, new Date(Date.now() + 30000).toGMTString()); res.setHeader(&#39;Cache-Control&#39;, &#39;max-age=30&#39;); // 设置文件类型并响应给浏览器 res.setHeader(&#39;Content-Type&#39;, mime.getType(filePath) + &#39;;charset=utf8&#39;); fs.createReadStream(filePath).pipe(res); }); }); server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 上面 mime 模块的 getType 方法可以成功返回传入路径下文件对应的文件类型，如 text/html 和 application/javascript 等，是第三方模块，使用之前需要安装。$ npm install mime 协商缓存协商缓存流程协商缓存又叫对比缓存，设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，响应浏览器通知数据未更改，浏览器会去缓存中获取数据，如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中，协商缓存的流程如下。协商缓存流程图协商缓存和强制缓存不同的是，协商缓存每次请求都需要跟服务器通信，而且命中缓存服务器返回状态码不再是 200，而是 304。协商缓存判断标识强制缓存是通过过期时间来控制是否访问服务器，而协商缓存每次都要与服务器交互对比缓存标识，同样的，对于协商缓存的实现在 HTTP 1.0 版本和 HTTP 1.1 版本也有所不同。在 HTTP 1.0 版本中，服务器通过 Last-Modified 响应头来设置缓存标识，通常取请求数据的最后修改时间（绝对时间）作为值，而浏览器将接收到返回的数据和标识存入缓存，再次请求会自动发送 If-Modified-Since 请求头，值为之前返回的最后修改时间（标识），服务器取出 If-Modified-Since 的值与数据的上次修改时间对比，如果上次修改时间大于了 If-Modified-Since 的值，说明被修改过，则通过 Last-Modified 响应头返回新的最后修改时间和新的数据，否则未被修改，返回状态码 304 通知浏览器命中缓存。在 HTTP 1.1 版本中，服务器通过 Etag 响应头来设置缓存标识（唯一标识，像一个指纹一样，生成规则由服务器来决定），浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 If-None-Match 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，返回新标识和数据，相同，则返回状态码 304 通知浏览器命中缓存。HTTP 协商缓存策略流程图如下：缓存策略流程图注意：使用协商缓存时 HTTP 1.0 版本还是不太靠谱，假设一个文件增加了一个字符后又删除了，文件相当于没更改，但是最后修改时间变了，会被当作修改处理，本应该命中缓存，服务器却重新发送了数据，因此 HTTP 1.1 中使用的 Etag 唯一标识是根据文件内容或摘要生成的，保证了只要文件内容不变，则一定会命中缓存，为了兼容低版本 HTTP 协议，开发中两种响应头也会同时使用，同样 HTTP 1.1 版本的实现优先级高于 HTTP 1.0。通过 Network 查看协商缓存我们同样通过 Chrome 浏览器的开发者工具，打开 NetWork 查看协商缓存的相关信息。再次请求服务器的请求头信息：再次请求服务器的请求头信息命中协商缓存的响应头信息：命中协商缓存的响应头信息下面看一看通过协商缓存取出的数据在 Network 中与第一次加载的区别。第一次请求：第一次请求缓存后请求：缓存后请求通过两图的对比，我们可以发现，协商缓存生效时的状态码为 304，并且报文大小和请求时间大大减少，原因是服务端在进行标识比对后只返回了 header 部分，通过状态码来通知浏览器使用缓存，不再需要将报文主体部分一起返回给浏览器。Node.js 服务器实现协商缓存/* 协商缓存 */ const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const path = require(&#39;path&#39;); const mime = require(&#39;mime&#39;); const fs = require(&#39;fs&#39;);0 const crytpo = require(&#39;crytpo&#39;); const server = http.createServer((req, res) =&gt; { let { pathname } = url.parse(req.url, true); pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;; // 获取读取文件的绝对路径 const filePath = path.join(__dirname, pathname); // 查看路径是否合法 fs.stat(filePath, (err, statObj) =&gt; { // 路径不合法则直接中断连接 if (err) return res.end(&#39;Not Found&#39;); const md5 = crypto.createHash(&#39;md5&#39;); // 创建加密的转换流 const rs = fs.createReadStream(filePath); // 创建可读流 // 读取文件内容并加密 rs.on(&#39;data&#39;, data =&gt; md5.update(data)); rs.on(&#39;end&#39;, () =&gt; { const ctime = statObj.ctime.toGMTString(); // 获取文件最后修改时间 const flag = md5.digest(&#39;hex&#39;); // 获取加密后的唯一标识 // 获取协商缓存的请求头 const ifModifiedSince = req.headers[&#39;if-modified-since&#39;]; const ifNoneMatch = req.headers[&#39;if-none-match&#39;]; if (ifModifiedSince === ctime || ifNoneMatch === flag) { res.statusCode = 304; res.end(); } else { // 设置协商缓存 res.setHeader(&#39;Last-Modified&#39;, ctime); res.setHeader(&#39;Etag&#39;, flag); // 设置文件类型并响应给浏览器 res.setHeader(&#39;Content-Type&#39;, mime.getType(filePath) + &#39;;charset=utf8&#39;); rs.pipe(res); } }); }); }); server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 在上面的代码中是通过可读流读取文件内容，并通过 crypto 模块进行了 md5 加密后的结果作为了唯一标识，这样就能保证只要文件内容不变，就会命中缓存，其中兼容了 HTTP 1.0 和 HTTP 1.1 两个版本，只要满足一个则直接返回 304 通知浏览器命中缓存。注意：其实读取文件内容加密这种做法并不可取，假如读取的是大文件，在读取文件内容和进行 md5 加密这个过程会非常消耗时间，所以在开发中要针对业务的实际情况选择可以保证服务器性能的方式生成唯一标识，比如根据文件的摘要。总结为了使缓存策略更加健壮、灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求头 If-None-Match 和 If-Modified-Since 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 304 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"性能优化","slug":"性能优化","permalink":"https://www.overtaking.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"}]},{"title":"Node.js 加密 —— crypto 模块","date":"2018-07-19T11:05:51.000Z","path":"20180719190551/","text":"加密简介加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义，通过这种方式提高网络数据传输的安全性，加密算法常见的有哈希算法、HMAC 算法、签名、对称性加密算法和非对称性加密算法，加密算法也分为可逆和不可逆，比如 md5 就是不可逆加密，只能暴力破解（撞库），我们在 Node.js 开发中就可以通过 crypto 模块直接使用这些加密算法，是包含对 OpenSSL 的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装，核心模块，使用时不需安装。哈希算法哈希算法也叫散列算法，用来把任意长度的输入变换成固定长度的输出，常见的有 md5、sha1 等，这类算法实现对原数据的转化过程是否能被称为加密备受争议，为了后面叙述方便我们姑且先叫做加密。/* 查看哈希加密算法的种类 */ const crypto = require(&#39;crypto&#39;); // getHashes 方法用于查看支持的加密算法 console.log(crypto.getHashes()); // [ &#39;DSA&#39;, &#39;DSA-SHA&#39;, &#39;DSA-SHA1&#39;, &#39;DSA-cSHA1-old&#39;, // &#39;RSA-MD4&#39;, &#39;RSA-MD5&#39;, &#39;RSA-MDC2&#39;, &#39;RSA-RIPEMD160&#39;, // &#39;RSA-SHA&#39;, &#39;RSA-SHA1&#39;, &#39;RSA-SHA1-2&#39;, &#39;RSA-SHA224&#39;, // &#39;RSA-SHA256&#39;, &#39;RSA-SHA384&#39;, &#39;RSA-SHA512&#39;, // &#39;dsaEncryption&#39;, &#39;dsaWithSHA&#39;, &#39;dsaWithSHA1&#39;, &#39;dss1&#39;, // &#39;ecdsa-with-SHA1&#39;, &#39;md4&#39;, &#39;md4WithRSAEncryption&#39;, // &#39;md5&#39;, &#39;md5WithRSAEncryption&#39;, &#39;mdc2&#39;, &#39;mdc2WithRSA&#39;, // &#39;ripemd&#39;, &#39;ripemd160&#39;, &#39;ripemd160WithRSA&#39;, &#39;rmd160&#39;, // &#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, &#39;sha224&#39;, // &#39;sha224WithRSAEncryption&#39;, &#39;sha256&#39;, // &#39;sha256WithRSAEncryption&#39;, &#39;sha384&#39;, // &#39;sha384WithRSAEncryption&#39;, &#39;sha512&#39;, // &#39;sha512WithRSAEncryption&#39;, &#39;shaWithRSAEncryption&#39;, // &#39;ssl2-md5&#39;, &#39;ssl3-md5&#39;, &#39;ssl3-sha1&#39;, &#39;whirlpool&#39; ] md5 是开发中经常使用的算法之一，官方称为摘要算法，具有以下几个特点：不可逆；不管加密的内容多长，最后输出的结果长度都是相等的；内容不同输出的结果完全不同，内容相同输出的结果完全相同。由于相同的输入经过 md5 加密后返回的结果完全相同，所以破解时通过 “撞库” 进行暴力破解，当连续被 md5 加密 3 次以上时就很难被破解了，所以使用 md5 一般会进行多次加密。/* md5 加密 —— 返回 Buffer */ const crytpo = require(&#39;crytpo&#39;); // createHash 创建 MD5，update 传入加密信息并加密，digest 获取加密后结果 const md5 = crytpo.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest(); console.log(md5); // &lt;Buffer 5d 41 40 2a bc 4b 2a 76 b9 71 9d 91 10 17 c5 92&gt; digest 方法参数用于指定加密后的返回值的格式，不传参默认返回加密后的 Buffer，常用的参数有 hex 和 Base64，hex 代表十六进制，加密后长度为 32，Base64 的结果长度为 24，以 == 结尾。/* md5 加密 —— 返回十六进制 */ const crypto = require(&#39;crypto&#39;); const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest(&#39;hex&#39;); console.log(md5); // 5d41402abc4b2a76b9719d911017c592 /* md5 加密 —— 返回 Base64 */ const crypto = require(&#39;crypto&#39;); const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;hello&#39;).digest(&#39;Base64&#39;); console.log(md5); // XUFAKrxLKna5cZ2REBfFkg== update 方法的返回值就是 this，即当前实例，所以支持链式调用，较长的信息也可以多次调用 update 方法进行分段加密，调用 digest 方法同样会返回整个加密后的值。/* 链式调用和分段加密 */ const crypto = require(&#39;crypto&#39;); const md5 = crypto.createHash(&#39;md5&#39;).update(&#39;he&#39;).update(&#39;llo&#39;).digest(&#39;hex&#39;); console.log(md5); // 5d41402abc4b2a76b9719d911017c592 由于可以使用 update 进行分段加密，就可以结合流来使用，其实 crypto 的本质是创建 Transform 类型的转化流，可以将可读流转化成可写流。/* 对可读流读取的数据进行 md5 加密 */ const crypto = require(&#39;crypto&#39;); const fs = require(&#39;fs&#39;); const md5 = crypto.createHash(&#39;md5&#39;); const rs = fs.createReadSteam(&#39;./readme.txt&#39;, { highWaterMark: 3 }); // 连续读取数据并分段加密 rs.on(&#39;data&#39;, data =&gt; md5.update(data)); rs.on(&#39;end&#39;, () =&gt; { const result = md5.digest(&#39;hex&#39;); console.log(result); }); 使用场景：经常被使用在数据的校验，比如服务器与服务器之间进行通信发送的明文摘要加 md5 加密摘要后的暗文，接收端拿到数据以后将明文摘要按照相同的 md5 算法加密后与暗文摘要对比验证，目的是防止数据传输过程中被劫持并篡改。在浏览器缓存策略中，可以通过对静态资源的信息摘要使用 md5 加密，每次向服务器发送加密后的密钥进行比对就可以了，不至于对整个文件内容进行比较。缺点：由于规定使用 md5 的哈希算法加密，别人可以使用同样的算法对信息进行伪造，安全性不高。Hmac 算法Hmac 算法的使用Hmac 算法又称加盐算法，是将哈希算法与一个密钥结合在一起，用来阻止对签名完整性的破坏，同样具备 md5 加密的几个特点。/* 使用加盐算法加密 */ const crytpo = require(&#39;crytpo&#39;); const hmac = crytpo.createHmac(&#39;sha1&#39;, &#39;panda&#39;).update(&#39;hello&#39;).digest(&#39;Base64&#39;); console.log(hmac); // 7spMLxN8WJdcEtQ8Hm/LR9pUE3YsIGag9Dcai7lwioo= crytpo.createHmac 第一个参数同 crytpo.createHash，为加密的算法，常用 sha1 和 sha256，第二个参数为密钥。digest 方法生成的加密结果长度要大于 md5，hex 生成的结果长度为 64，Base64 生成的结果长度为 44，以 = 结尾。安全性高于 md5，通过密钥来加密，不知道密钥无法破解，缺点是密钥传输的过程容易被劫持，可以通过一些生成随机密钥的方式避免。创建密钥的方法可以安装 openSSH 客户端，并通过命令行生成存储密钥的文件，命令如下:$ openssl genrsa -out rsa_private.key 1024 openssl genrsa 代表生成密钥，-out 代表输出文件，rsa_private.key 代表文件名，1024 代表输出密钥的大小。/* 直接读取密钥文件配合加盐算法加密 */ const fs = require(&#39;fs&#39;); const crytpo = require(&#39;crytpo&#39;); const path = require(&#39;path&#39;); const key = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;)); const hmac = crytpo.createHmac(&#39;sha256&#39;, key).update(&#39;hello&#39;).digest(&#39;Base64&#39;); console.log(hmac); // bmi2N+6kwgwt5b+U+zSgjL/NFs+GsUnZmcieqLKBy4M= 对称性加密对称性加密是发送数据时使用密钥和加密算法进行加密，接收数据时需要使用相同的密钥和加密算法的逆算法（解密算法）进行解密，也就是说对称性加密的过程是可逆的，crytpo 中使用的算法为 blowfish。/* 对称性加密 */ const fs = require(&#39;fs&#39;); const crypto = require(&#39;crypto&#39;); const path = require(&#39;path&#39;); const key = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;)); // 加密 const cipher = crypto.createCipher(&#39;blowfish&#39;, key); cipher.update(&#39;hello&#39;); // final 方法不能链式调用 const result = cipher.final(&#39;hex&#39;); console.log(result); // 3eb9943113c7aa1e // 解密 const decipher = crypto.createDecipher(&#39;blowfish&#39;, key); decipher.update(result, &#39;hex&#39;); const data = decipher.final(&#39;utf8&#39;); console.log(data); // hello 加密使用 crypto.createCipher 方法，解密使用 crypto.createDecipher 方法，但是使用的算法和密钥必须相同，需要注意的是解密过程中 update 中需要在第二个参数中指定加密时的格式（其实在加密的时候 update 也存在第二个参数，默认值为 utf8）如 hex，在 final 还原数据时需要指定加密字符的编码格式，如 utf8。注意：使用对称性加密的字符串有长度限制，不得超过 7 个字符，否则虽然可以加密成功，但是无法解密。缺点：密钥在传输过程中容易被截获，存在安全风险。非对称性加密非对称性加密相也是可逆的，较于对称性加密要更安全，消息传输方和接收方都会在本地创建一对密钥，公钥和私钥，互相将自己的公钥发送给对方，每次消息传递时使用对方的公钥加密，对方接收消息后使用他的的私钥解密，这样在公钥传递的过程中被截获也无法解密，因为公钥加密的消息只有配对的私钥可以解密。接下来我们使用 openSSH 对之前生成的私钥 rsa_private.key 产生一个对应的公钥，命令如下。$ openssl rsa -in rsa_private.key -pubout -out rsa_public.key 上面的命令意思根据一个私钥生成对应的公钥，-pubout -out 代表公钥输出，rsa_public.key 为公钥的文件名。/* 非对称性加密 */ const fs = require(&#39;fs&#39;); const crypto = require(&#39;crypto&#39;); const path = require(&#39;path&#39;); // 获取公钥和私钥 const publicKey = fs.readFileSync(path.join(__dirname, &#39;/rsa_public.key&#39;)); const privateKey = fs.readFileSync(path.join(__dirname, &#39;/rsa_private.key&#39;)); // 加密 const secret = crytpo.publicEncrypt(publicKey, Buffer.from(&#39;hello&#39;)); // 解密 const result = crytpo.provateDecrypt(privateKey, secret); console.log(result); // hello 使用公钥加密的方法是 crytpo.publicEncrypt，第一个参数为公钥，第二个参数为加密信息（必须是 Buffer），使用私钥解密的方法是 crytpo.provateDecrypt，第一个参数为私钥，第二个参数为解密的信息。签名签名与非对称性加密非常类似，同样有公钥和私钥，不同的是使用私钥加密，对方使用公钥进行解密验证，以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。签名我们还使用 rsa_public.key 和 rsa_private.key 作为公钥和私钥，crypto 实现签名代码如下。/* 签名 */ const fs = require(&#39;fs&#39;); const crypto = require(&#39;crypto&#39;); const path = require(&#39;path&#39;); // 获取公钥和私钥 const publicKey = fs.readFileSync(path.join(__dirname, &#39;rsa_public.key&#39;), &#39;ascii&#39;); const privateKey = fs.readFileSync(path.join(__dirname, &#39;rsa_private.key&#39;), &#39;ascii&#39;); // 生成签名 const signed = crypto.createSign(&#39;RSA-SHA256&#39;).update(&#39;panda&#39;).sign(privateKey, &#39;hex&#39;); // 验证签名 const verify = crypto.createVerify(&#39;RSA-SHA256&#39;).update(&#39;panda&#39;).verify(publicKey, signed, &#39;hex&#39;); console.log(verify); // true 生成签名的 sign 方法有两个参数，第一个参数为私钥，第二个参数为生成签名的格式，最后返回的 signed 为生成的签名（字符串）。验证签名的 verify 方法有三个参数，第一个参数为公钥，第二个参数为被验证的签名，第三个参数为生成签名时的格式，返回为布尔值，即是否通过验证。使用场景：经常用于对 cookie 签名返回浏览器，当浏览器访问同域服务器将 cookie 带过来时再进行验证，防止 cookie 被篡改和 CSRF 跨站请求伪造。总结各种项目在数据传输时根据信息的敏感度以及用途进行不同的加密算法和加密方式，在 Node.js 中，crypto 的 API 完全可以实现我们的加密需求，也可以将上面的加密方案组合使用实现更复杂的加密方案。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"加密","slug":"加密","permalink":"https://www.overtaking.top/tags/%E5%8A%A0%E5%AF%86/"},{"name":"crypto","slug":"crypto","permalink":"https://www.overtaking.top/tags/crypto/"}]},{"title":"Node.js 服务器实现 gzip 压缩","date":"2018-07-18T10:18:23.000Z","path":"20180718181823/","text":"概述在浏览器向服务器请求静态资源时，服务器为了减小在网络传输过程中消耗的流量和时间，都是将静态资源经过压缩后返回给服务器的，实现压缩的算法有 deflate 和 gzip 等，最常用的是 gzip 压缩。gzip 简介在浏览器和服务器之间通过 gzip 压缩流实现传输的过程可以用下图表示。gzip 压缩工作原理当浏览器向服务器请求静态资源，服务器会将静态资源经过处理转换为压缩流，大大减小文件体积，然后将压缩流返回给浏览器，浏览器通过压缩的类型重新将压缩流解析成静态文件。zlib 模块的使用压缩在 Node.js 中通过 zlib 模块帮助我们实现不同类型的压缩，其实压缩的过程就是创建流的过程，创建的压缩流是 Transform 类型（转化流），读取文件的内容经过转化流创建一个新类型的文件。/* 文件：gzip.js */ const zlib = require(&#39;zlib&#39;); const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 压缩 function gzip(source) { // 处理输入和输出的文件路径 const sourcePath = path.join(__dirname, source); const gzipPath = sourcePath + &#39;.gz&#39;; // 创建转化流 const gzip = zlib.createGzip(); // 创建可读流 const rs = fs.createReadStream(sourcePath); // 创建可写流 const ws = fs.createWriteStream(gzipPath); // 实现转化 rs.pipe(gzip).pipe(ws); } gzip(&#39;index.html&#39;); 执行上面代码查看根目路是否出现 index.gz 压缩包。解压压缩的过程是可逆的，可以压缩就可以解压，无论是在浏览器还是在服务器，我们下面实现解压的方法。/* 文件：gunzip.js */ const zlib = require(&#39;zlib&#39;); const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 解压 function gunzip(source) { // 处理输入和输出的文件路径 const sourcePath = path.join(__dirname, source); const filePath = path.join(__dirname, path.basename(source, &#39;.gz&#39;)); // 创建转化流 const unzip = zlib.createGunzip(); // 创建可读流 const rs = fs.createReadStream(sourcePath); // 创建可写流 const ws = fs.createWriteStream(filePath); // 实现转化 rs.pipe(unzip).pipe(ws); } gunzip(&#39;index.html.gz&#39;); 删除原来 index.html，执行解压代码，查看文件根目录是否生成 index.html。服务器的实现在浏览器与服务器的交互中，浏览器其实会通过请求头 Accept-Encoding 告诉服务器当前支持解压的压缩格式，值为 gzip, deflate, br，多个压缩格式用 , 隔开，服务器在接收到浏览器请求后，会按照请求头的格式压缩资源，将压缩后的资源返回，并通过响应头 Content-Encoding 告诉浏览器当前服务器压缩的格式。/* 文件：server.js */ // 引入依赖 const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const path = require(&#39;path&#39;); const fs = require(&#39;fs&#39;); const zlib = require(&#39;zlib&#39;); // 创建服务器 const server = http.createServer((req, res) =&gt; { // 处理 pathname，&#39;/&#39; 时默认读取 &#39;/index.html&#39; let { pathname } = url.parse(req.url, true); pathname = pathname !== &#39;/&#39; ? pathname : &#39;/index.html&#39;; // 获取读取文件的绝对路径 const filePath = path.join(__dirname, pathname); // 查看路径是否合法 fs.access(filePath, err =&gt; { // 路径不合法则直接中断连接 if (err) return res.end(&#39;Not Found&#39;); // 创建压缩流变量，压缩类型变量 let compress, compressType // 获取浏览器支持的压缩格式 const encoding = req.headers[&#39;accept-encoding&#39;]; // 创建可读流 const rs = fs.createReadStream(filePath); // 支持 gzip 使用 gzip 压缩，支持 deflate 使用 deflate 压缩 if (encoding &amp;&amp; encoding.match(/\\bgzip\\b/)) { compress = zlib.createGzip(); compressType = &#39;gzip&#39;; } else if (encoding &amp;&amp; encoding.match(/\\bdeflate\\b/)) { compress = zlib.createDeflate(); compressType = &#39;deflate&#39;; } else { // 否则直接返回可读流 return rs.pipe(res); } // 将压缩流返回并设置响应头 res.setHeader(&#39;Content-Encoding&#39;, compressType); rs.pipe(compress).pipe(res); }); }); server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 在上面服务器代码中如果不通过响应头通知浏览器当前资源的压缩格式，浏览器会不知道该如何解压，默认会当成文件下载，如 Chrome，所以在返回压缩流时必须通过 Content-Encoding 响应头通知浏览器当前的压缩格式。测试服务器压缩我们在文件根目录创建一个 index.html 文件，代码如下。&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;gzip&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Hello GZIP!&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 启动服务器 server.js，然后通过浏览器访问 localhost:3000，查看页面能否正确返回，并查看开发者工具 Network 中的响应头 Content-Encoding 的值是否正确。总结服务器压缩其实是客户端与服务器在网络传输时的一种优化手段，可以大大减小流量的消耗和响应时间，而 gzip 只是目前最常用的一种压缩格式，即压缩算法。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.overtaking.top/tags/http-headers/"},{"name":"gzip","slug":"gzip","permalink":"https://www.overtaking.top/tags/gzip/"}]},{"title":"Node.js 实现简易的多语言服务","date":"2018-07-17T03:18:07.000Z","path":"20180717111807/","text":"什么是多语言？我们平时访问一些文档类型的网站时，经常可以看到页面右上角有一个下拉框用来选择当前页面支持的语言，并在选中后将整个网页的内容切换为选中的语言，这就是项目中的多语言，多语言可以根据浏览器请求发送的语言类型在服务器进行设置，也可以在请求服务器时返回多种语言，并根据权重和浏览器的支持情况进行选择和渲染。功能描述在本文中我们通过客户端向服务器发送请求告诉服务器客户端所支持的语言及权重，服务器检索语言包并根据客户端发送的语言类型和权重返回对应语言的内容。在这个过程中客户端向服务器发送请求需要使用请求头 Accept-Language，值中设置语言类型和权重，语言与语言之间使用 , 隔开，语言与权重之间使用 ; 隔开，权重用 q 表示，与值用 = 隔开，如果权重值为 1 则可省略（最大值），值的格式为 zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1。服务器响应时，应通过响应头告诉浏览器返回的内容为何种语言，响应头为 Content-Language, 值的格式为 zh-CN, en，多个语言之间使用 , 隔开。服务器的实现/* 文件：server.js */ const http = require(&#39;http&#39;); const querystring = require(&#39;querystring&#39;); // 语言包 const languagesPackage = { &#39;zh-CN&#39;: &#39;你好&#39;, &#39;en&#39;: &#39;Hello&#39;, &#39;fr&#39;: &#39;Bonjour&#39; }; // 默认语言为英语 languagesPackage.defaultLanguage = &#39;en&#39;; // 创建服务器 const server = http.createServer((req, res) =&gt; { // 获取请求头中的语言和权重 const languages = req.headers[&#39;accept-language&#39;]; // 如果客户端设置了语言 if (languages) { // 解析语言为 [{ name: &#39;zh-CN&#39;, q: 1 }, { name: &#39;en&#39;, q: &#39;0.8&#39; }] 格式 const lans = languages.split(&#39;,&#39;).map(lang =&gt; { const [name, q = 1] = Object.keys(querystring.parse(lang.tirm(), &#39;;q=&#39;, true)); return { name, q }; }).sort((a, b) =&gt; b.q - a.q); // 并按照权重逆序排序 // 循环检测 languagesPackage 是否存在客户端的语言 for (let i = 0; i &lt; lans.length; i++) { const { name } = lans[i]; const content = languagesPackage[name]; // 如果存在直接设置响应头并返回内容 if (content) { res.setHeader(&#39;Content-Type&#39;, name); return res.end(content); } } } // 如果客户端没设置语言活语言找不到时返回服务器设置的默认语言 res.setHeader(&#39;Content-Type&#39;, languagesPackage.defaultLanguage); res.end(languagesPackage[languagesPackage.defaultLanguage]); }); server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 其实上面服务器和客户端配合实现多语言的思路就是客户端向服务器发送 Accept-Language 告诉服务器需要的语言和权重，服务器解析后根据权重从大到小排序，然后循环判断语言包中是否含有客户端需要的语言，如果有，则中断循环直接设置响应头和返回对应内容，如果不存在客户端的需要的语言或者客户端没有向后台发送 Accept-Language 则返回服务器默认设置的语言类型和内容。通常多语言的语言包是通过其他服务和一些其他的规则请求回来的，我们为了方便是在服务里通过 config 写死了。验证多语言为了方便我们使用 curl 模拟客户端向服务器发送请求查看返回内容是否正确，之所以使用 curl 是因为只发送验证的请求，方便设置 Accept-Language 请求头，更灵活的控制多语言的类型和权重。启动服务器 server.js，打开命令行窗口，输入下面的命令执行，查看返回命令行响应体中的内容和设置的语言是否对应。$ curl -v --header &quot;Accept-Language: zh-CN, zh;q=0.7, en;q=0.8, fr;q=0.1&quot; http://localhost:3000 总结这样我们就实现了一个简单的多语言服务，其实真正的多语言在服务器是需要做繁琐的解析和性能优化（只解析界面有的单词返回，保证响应体中的内容最小），也可以通过配合成熟的 il8n（国际化语言包）库来实现。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.overtaking.top/tags/http-headers/"},{"name":"multi-language","slug":"multi-language","permalink":"https://www.overtaking.top/tags/multi-language/"}]},{"title":"Node.js 服务器数据处理（表单、json 字符串和普通字符串）","date":"2018-07-16T07:59:48.000Z","path":"20180716155948/","text":"前言从浏览器向服务器提交数据时，常见有表单提交，json 字符串提交和普通字符串提交，不同情况需要附带不同的请求头信息，告诉服务器客户端可以直接解析的数据格式，如果发送的数据为 json 字符串，后两种类型都可以成功发送到服务器，只是加上请求头信息服务器更容易判断该以什么格式返回数据。querystring 模块解析请求体在 get 请求中，我们可以通过 url 模块的 parse 方法来解析，如果是带有请求体的请求类型，如 post、put 我们应该使用 querystring 模块的 parse 方法将请求体中的数据解析成对象，在这个方法中有三个参数。str：要解析的查询字符串；sep：查询字符串中键值对之间的分隔符，默认为 &amp;；eq：查询字符串中的键与值的分隔符，默认为 =。/* 文件：querystring-test.js */ const querystring = require(&#39;querystring&#39;); const query1 = &#39;name=pandashen&amp;age=27&#39;; const query2 = &#39;name*pandashen!&amp;age*27&#39;; const params1 = querystring.parse(query1); const params2 = querystring.parse(query2, &#39;!&amp;&#39;, &#39;*&#39;); console.log(params1); // { name: &#39;pandashen&#39;, age: &#39;27&#39;} console.log(params2); // { name: &#39;pandashen&#39;, age: &#39;27&#39;} querystring 也是很常用的模块，就在这里多说几句关于 querystring 模块常用方法 parse 的实现。/* 文件：my-querystring.js */ exports.parse = (str, sep = &#39;&amp;&#39;, eq = &#39;=&#39;) =&gt; { // 存储解析出键值的对象 const query = {}; // 先将查询字符串切割成 [k=v, k=b] 的形式 const fields = str.split(sep); // 循环将每一项切割成 k 和 v 并存入 queryObj 中 fields.forEach(field =&gt; { const [key, value] = field.split(eq); query[key] = value; }); // 返回 query 对象 return query; }; 服务器的实现向服务器发送请求的请求头为 Content-Type，表单提交、json 和字符串作为请求体时，在 Content-Type 中对应的值分别为 application/x-www-form-urlencoded、application/json 和 text/plain。其中 text/plain 为 Ajax 的默认提交方式，我们在服务器中针对上面这几种类型的请求头和 get 请求做处理，将发来的数据再次返回客户端。/* 文件：server.js */ const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const querystring = require(&#39;querystring&#39;); const server = http.createServer((req, res) =&gt; { // 获取 get 请求参数 const { query } = url.parse(req.url, true); // 获取数据类型请求头 const type = req.headers[&#39;content-type&#39;]; // 接收数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { // 合并数据并设置默认响应头和返回数据 let data = Buffer.concat(buffers).toString(); let contentType = &#39;application/json&#39;; // 判断是否为 get 请求，是则直接返回解析后的数据，不是则判断请求类型 if (req.method.toLowerCase() === &#39;get&#39;) { data = JSON.stringify(query); } else { // 判断请求数据类型并做相应处理 if (type === &#39;application/x-www-form-urlencoded&#39;) { data = JSON.stringify(querystring.parse(data)); } else if (type === &#39;application/json&#39;) { data = JSON.stringify(JSON.parse(data)); } else { contentType = &#39;text/plain&#39;; } } // 设置响应头并返回数据 res.setHeader(&#39;Content-Type&#39;, contentType); res.end(data); }); }); server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); } 当请求类型为 get，将查询字符串通过 url 模块解析后再处理成字符串返回客户端。当请求类型为 post，设置默认响应头为 application/json，如果是表单提交，请求体中的内容为查询字符串格式，使用 querystring 解析后再使用 JSON.stringify 处理成字符串返回，如果是 json，则使用 JSON.parse 解析，并使用 JSON.stringify 处理成字符串返回，如果是默认值 text/plain，则设置响应头的值为 text/plain 并将读取的结果直接返回。使用客户端进行测试在这里我们为了方便就不用浏览器访问了（需要创建各种不同类型提交的页面），因为上面的服务器代码比较简单，只处理了数据，并没有处理静态文件请求，所以我们通过 Node.js 来实现客户端。get 请求/* 文件：get.js */ const http = require(&#39;http&#39;); const config = { host: &#39;localhost&#39;, port: 3000, path: &#39;/?name=pandashen&amp;age=27&#39; }; // 发送 get 请求 http.get(config, res =&gt; { // 接收服务器返回的数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { const data = Buffer.concat(buffers).toString(); console.log(data); }); }); 启动服务器 server.js，通过命令行执行 node get.js 查看命令窗口中输出的结果。post 请求表单提交/* 文件：post-from.js */ const http = require(&#39;http&#39;); const config = { host: &#39;localhost&#39;, port: 3000, method: &#39;post&#39; headers: { &#39;Content-type&#39;: &#39;application/x-www-form-urlencoded&#39; } }; http.request(config, res =&gt; { // 接收服务器返回的数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { const data = Buffer.concat(buffers).toString(); console.log(data); }); }).end(&#39;name=pandashen&amp;age=27&#39;); 启动服务器 server.js，通过命令行执行 node post-form.js 查看命令窗口中输出的结果。post 请求 json 字符串数据/* 文件：post-json.js */ const http = require(&#39;http&#39;); const config = { host: &#39;localhost&#39;, port: 3000, method: &#39;post&#39;, headers: { &#39;Content-Type&#39;: &#39;application/json&#39; } }; http.request(config, res =&gt; { // 接收服务器返回的数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { const data = Buffer.concat(buffers).toString(); console.log(data); }); }).end(&#39;{ name: pandashen, age: 27 }&#39;); 启动服务器 server.js，通过命令行执行 node post-json.js 查看命令窗口中输出的结果。post 请求普通字符串数据/* 文件：post-string.js */ const http = require(&#39;http&#39;); const config = { host: &#39;localhost&#39;, port: 3000, method: &#39;post&#39;, headers: { &#39;Content-Type&#39;: &#39;text/plain&#39; } }; http.request(config, res =&gt; { // 接收服务器返回的数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { let data = Buffer.concat(buffers).toString(); console.log(data); }); }).end(&#39;pandashen27&#39;); 启动服务器 server.js，通过命令行执行 node post-string.js 查看命令窗口中输出的结果。总结通过本篇的内容可以了解 HTTP 在数据传输中的类型，即请求头类型，服务端通过请求头类型可以返回客户端可以直接解析的数据，上面的几种类型只是向服务器提交数据的最常见类型，涵盖表单提交和 Ajax 等（在上传文件时还存在二进制传输）。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.overtaking.top/tags/http-headers/"}]},{"title":"Node.js 服务器实现资源防盗链","date":"2018-07-14T07:00:09.000Z","path":"20180714150009/","text":"什么是 “盗链”？“盗链” 说白了就是利用别人网站的资源链接放在自己的站点，在未经允许的情况下去获取别人网站里面的图片或者视频等资源，导致资源所有者的网站的流量费用增加或收入减少，为了防止资源链接随意被人盗用的手段被称为 “防盗链”。模拟 “盗链” 场景我们先来模拟一下 “盗链” 场景，在本地启动服务运行 hotlinking.html 文件，并在文件中盗用百度视频的图片资源，看看效果。&lt;!-- 文件：hotlinking.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;盗链&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://c.hiphotos.baidu.com/c9f1faaf51f2de66ad.jpg&quot;&gt; &lt;/body&gt; &lt;/html&gt; 我们通过 http-server 来启动服务器访问 hotlinking.html，使用 http-server 需全局安装。$ http-server install -g 在服务中打开 hotlinking.html 后我们发现图片并不是我们盗用链接的资源，而是变成了下面这张图片。百度盗链返回图片这张图用来提醒我们盗用了别人资源，是因为百度的服务器做了防盗链处理，如果所有盗用别人的资源都变成这样，盗用也就没有实际意义了，我们本篇就通过 Node.js 来实现防盗链处理，用来保护自己站点的资源。注意：具备防盗链处理的网站的资源链接可以直接通过浏览器地址栏访问，也可以在文件域（file 协议）访问，限制的是在未经允许的情况下其他服务器的访问。Node.js 服务器实现防盗链模拟两个域名在本地的 hosts 文件中加入两个域名：127.0.0.1 panda.com 127.0.0.1 shen.com 准备图片资源在根目录创建文件夹 public 并存入两张图片，success.png 是正常请求的图片资源，error.png 是经过防盗链处理后返回的图片资源，两张图片如下。正常返回的图片资源 success.png正常返回资源防盗链处理后返回的图片资源 error.png盗链返回资源页面 index.html在页面当中通过 img 标签分别访问 shen.com、panda.com 和 localhost 域下的 success.png 文件。&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;盗链&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://panda.com:3000/success.png&quot;&gt; &lt;img src=&quot;http://shen.com:3000/success.png&quot;&gt; &lt;img src=&quot;http://localhost:3000/success.png&quot;&gt; &lt;/body&gt; &lt;/html&gt; 服务端 server.js在写服务端代码之前需要介绍两个重要的请求头：host：资源所在的域referer：请求来源的域其实资源防盗就是设置白名单，通过检测 referer 是否在白名单中，如果在则正常返回资源，不存在则返回经过防盗链处理的资源。注意：referer 请求头在地址栏输入地址时发送的请求是不存在的（如请求 index.html 页面），在旧版本的 HTTP 协议中 referer 的写法为 referered，所以为了兼容旧版本协议应该做兼容处理。/* 文件：server.js */ // 引入依赖 const http = require(&#39;http&#39;); const url = require(&#39;url&#39;); const path = require(&#39;path&#39;); const fs = require(&#39;mz/fs&#39;); const server = http.createServer(responseImages); // 创建服务器 const static = path.resolve(__dirname, &#39;public&#39;); // 静态资源目录 const whiteList = [&#39;shen.com&#39;]; // 白名单 async function responseImages(req, res) { // 解析 url 中的文件目录处理成绝对路径 let imgPath = path.join(static, url.parse(req.url).pathname); // 检测文件路径是否合法，不合法直接返回 Not Found const isExist = await fs.exists(imgPath); if (isExist) { // 获取 referer const refer = req.headers[&#39;referer&#39;] || req.headers[&#39;referered&#39;]; // 存在 referer 继续检测 if (refer) { // 请求资源存在 referer，做防盗链处理 const referHost = url.parse(refer).hostname; const host = req.headers[&#39;host&#39;].split(&#39;:&#39;)[0]; // 当访问源的域和资源所在的域不是同一个域，做防盗链处理 if (referHost !== host) { const isInWhiteList = whiteList.includes(refer); imgPath = isInWhiteList ? imgPath : path.join(static, &#39;error.png&#39;); } } // 第一次访问请求页面 index.html，不存在 referer，将静态资源返回 // 第二次访问请求图片资源，如果 referer 和资源所本就是同一个域，直接将资源返回 fs.createReadStream(imgPath).pipe(res); } else { res.statusCode = 404; res.end(&#39;Not Found&#39;); } } server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 其实上面的服务器是 shen.com、panda.com 和 localhost 所共用的，只是通过不同的域名访问。启动服务器，然后通过 localhost:3000 访问，此时由于与 shen.com 和 panda.com 为不同域，所以只有第三张图片返回 success.png。通过 shen.com:3000 访问，由于存在白名单中，所以三张图片都返回 success.png。通过 panda.com:3000 访问，由于 shen.com 在不同域，所以没有返回 success.png。无论通过 shen.com 还是 panda.com 访问 localhost 的资源都是在同域的，所以都能获取到。总结在上面我们利用本地服务实现了一个最基本的防盗链，思路就是 referer 与资源同域，正常返回，不同域检测白名单，在真实的开发场景可能会更细化，更复杂一些，其实整个防盗链实现的核心就是利用 HTTP 的 referer 和 host 请求头做检测，希望通过本篇的学习，大家可以对资源防盗链有所了解，并在后面开发类似功能时提供思路。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.overtaking.top/tags/http-headers/"},{"name":"资源防盗链","slug":"资源防盗链","permalink":"https://www.overtaking.top/tags/%E8%B5%84%E6%BA%90%E9%98%B2%E7%9B%97%E9%93%BE/"}]},{"title":"Node.js 使用 Range 请求实现下载功能","date":"2018-07-13T05:08:08.000Z","path":"20180713130808/","text":"前言本篇使用 Node.js 的 HTTP 服务创建客户端，使用 Range 请求实现下载功能，并通过本篇的 Demo 扩展在业务中实现断点续传等功能的思路。服务端的实现我们通过 http 模块创建服务器处理 Range 请求，在服务器代码中我们为了减少回调嵌套使用 async 函数，所以需要将异步的操作方法转换成 Promise， util 的 promisify 来可以将异步方法一个一个转换，比较麻烦，可以直接使用第三方模块 mz 并直接引入转换好的替代模块。使用 mz 之前需要先安装：$ npm install mz 服务端代码如下：/* 文件：server.js */ const http = require(&#39;http&#39;); const path = require(&#39;path&#39;); const url = require(&#39;url&#39;); // 引入 mz 模块转换成 Promise 的 fs 模块 const fs = require(&#39;mz/fs&#39;); // 请求处理函数 async function listener(req, res) { // 获取 range 请求头，格式为 Range:bytes=0-5 const range = req.headers[&#39;range&#39;]; // 下载文件路径 const downloadPath = path.resovle(__dirname, url.parse(req.url, true).pathname); // 存在 range 请求头将返回范围请求的数据 if (range) { // 获取范围请求的开始和结束位置 let [, start, end] = range.match(/(\\d*)-(\\d*)/); // 错误处理 try { const statObj = await fs.stat(downloadPath); } catch (e) { res.end(&#39;Not Found&#39;); } // 文件总字节数 const total = statObj.size; // 处理请求头中范围参数不传的问题 start = start ? ParseInt(start) : 0; end = end ? ParseInt(end) : total - 1; // 响应客户端 res.statusCode = 206; res.setHeader(&#39;Accept-Ranges&#39;, &#39;bytes&#39;); res.setHeader(&#39;Content-Range&#39;, &#39;bytes &#39; + start + &#39;-&#39; + end + &#39;/&#39; + total); fs.createReadStream(downloadPath, { start, end }).pipe(res); } else { // 没有 range 请求头时将整个文件内容返回给客户端 fs.createReadStream(downloadPath).pipe(res); } } // 创建服务器 const server = http.createServer(listener); // 监听端口 server.listen(3000, () =&gt; { console.log(&#39;server start 3000&#39;); }); 在上面服务端的代码中，需要兼容 Range 请求和普通请求，两种请求的区别是，如果客户端发送的是 Range 请求，会携带 Range:bytes=0-5 格式的请求头，我们可以通过 req 的 headers 属性获取，在获取请求头时，原本大写字母开头 Node.js 统一处理成小写，所以获取时应小写。如果是 Range 请求则通过可读流读取对应的内容返回客户端，如果不是，则通过可读流读取整个文件返回客户端，在响应 Range 请求的过程中需要设置响应状态为 206，需要设置响应头 Accept-Ranges 值为 bytes，需要设置响应头 Content-Range 值为 byte 0-5/100 的格式，0 为返回数据开始的索引，5 为结束的索引（包含），100 为文件的总字节数。在通过 url 和 path 模块解析和拼接下载文件路径时，应该进行错误检测，如果文件不存在则直接返回客户端 Not Found。我们可以使用 curl 命令来检测我们的服务端代码，在命令行工具中输入下面命令，在命令窗口查看返回值是否正确。$ curl -v --header &quot;Range:bytes=0-5&quot; http://localhost:3000 客户端的实现在上面使用 curl 命令来访问我们的服务器时，只能请求固定范围的数据，而不是类似于下载功能，每次都下载一个范围的数据，但是想要多次下载并自动维护 Range 的范围需要借助我们自己实现的客户端逻辑。为了简便，我们的下载客户端是在命令行窗口运行的，通过指令来模拟实际项目中的开始下载、暂停和恢复按钮，当在窗口中输入 s 指令时开始下载，输入 p 指令时暂停下载，输入 r 指令时恢复下载。/* 文件：client.js */ const http = require(&#39;http&#39;); const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 请求配置 const config = { host: &#39;localhost&#39;, port: 3000, path: &#39;/download.txt&#39; }; let start = 0; // 请求初始值 let step = 5; // 每次请求字符个数 let pause = false; // 暂停状态 let total; // 文件总长度 // 创建可写流 const ws = fs.createWriteStream(path.resolve(__dirname, config.path.slice(1))); // 下载函数 function download() { // 配置，每次范围请求 step 个字节 config.headers = { Range: &#39;bytes=&#39; + start + &#39;-&#39; + (start + step - 1); }; // 维护下次 start 的值 start += step; // 发送请求 http.request(config, res =&gt; { // 获取文件总长度 if (typeof total !== &#39;number&#39;) { total = res.headers[&#39;content-ranges&#39;].match(/\\/(\\d*)/)[1]; } // 读取返回数据 const buffers = []; res.on(&#39;data&#39;, data =&gt; buffers.push(data)); res.on(&#39;end&#39;, () =&gt; { // 合并数据并写入文件 const buf = Buffer.concat(buffers); ws.write(buf); // 递归进行下一次请求 if (!pause &amp;&amp; start &lt; total) { download(); } }); }).end(); } // 监控输入 process.stdin.on(&#39;data&#39;, data =&gt; { // 获取指令 const ins = data.toString().match(/(\\w*)\\/r/)[1]; switch (ins) { case &#39;s&#39;: case &#39;r&#39;: pause = false; download(); break; case &#39;p&#39;: pause = true; break; } }); 在上面代码中下载的文件通过 config 中的 path 属性配置，每次调用 download 函数下载时都会重新计算当前范围请求的初始位置和结束位置，并设置 Range 请求头，下一次请求靠递归 download 来实现。在执行时需先启动我们的服务器，在通过命令行输入 node client.js 来启动客户端，在命令窗口输入对应的指令进行开始下载、暂停下载和恢复下载操作。总结相信现在已经了解什么是范围请求，范围请求客户端和服务端需要做些什么，其实说白了就是对应的请求头和响应头的使用，需要注意的是范围请求的响应状态码为 206，这样的需求在一些上传、下载资源的网站也很常见，其目的就是为了让我们实现断点续传，不至于一次没有上传或下载完成的资源文件，在下一次的做同样操作时需要重新来过，可以接着上次的位置继续，范围请求在视频网站上也广泛应用，边请求边观看，不至于一次加载整个视频资源，节省流量，节省时间。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"范围请求","slug":"范围请求","permalink":"https://www.overtaking.top/tags/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82/"},{"name":"http-headers","slug":"http-headers","permalink":"https://www.overtaking.top/tags/http-headers/"}]},{"title":"Node.js 搭建 HTTP 服务器","date":"2018-07-12T11:55:14.000Z","path":"20180712195514/","text":"前言Node.js 可以用 http 模块来创建 Web 服务，本篇就来介绍关于使用 http 模块搭建 HTTP 服务和客户端的方法，以及模块的基本 API。HTTP 服务器创建 HTTP 服务器在 Node.js 中，创建 HTTP 服务可以与 net 模块创建 TCP 服务对比（可以阅读 基于 TCP 实现简易聊天室），创建服务有也两种方式。方式 1：const http = require(&#39;http&#39;); const server = http.createServer(function (req, res) { // ...... }); server.listen(3000); 方式 2：const http = require(&#39;http&#39;); const server = http.createServer(); server.on(&#39;request&#39;, function (req, res) { // ...... }); server.listen(3000); 在 createServer 的回调和 request 事件的回调函数中有两个参数，req（请求）、res（响应），基于 socket，这两个对象都是 Duplex 类型的可读可写（双工）流。http 模块是基于 net 模块实现的，所以 net 模块原有的事件在 http 中依然存在。const http = require(&#39;http&#39;); const server = http.createServer(); // net 模块事件 server.on(&#39;connection&#39;, function (socket) { console.log(&#39;连接成功&#39;); }); server.listen(3000); 获取请求信息在请求对象 req 中存在请求的方法、请求的 url（包含参数，即查询字符串）、当前的 HTTP 协议版本和请求头等信息。const http = require(&#39;http&#39;); const server = http.createServer(); server.on(&#39;request&#39;, function (req, res) { console.log(req.method); // 获取请求方法 console.log(req.url); // 获取请求路径（包含查询字符串） console.log(req.httpVersion); // 获取 HTTP 协议版本 console.log(req.headers); // 获取请求头（对象） // 获取请求体的内容 const buffers = []; req.on(&#39;data&#39;, function (data) { buffers.push(data); }); req.on(&#39;end&#39;, function () { console.log(Buffer.concat(buffers).toString()); }); }); server.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 通过 req 对应的属性可以拿到请求行和请求首部的信息，请求体内的内容通过流操作来获取，其中 url 中存在多个常用的参数，我们自己处理会很麻烦，可以通过 Node.js 自带的 url 模块进行解析。const url = require(&#39;url&#39;); const str = &#39;http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash&#39;; // parse 方法帮助我们解析 url 路径 const info = url.parse(str, true); console.log(info); // { // protocol: &#39;http:&#39;, // slashes: true, // auth: &#39;user:pas&#39;, // host: &#39;www.pandashen.com:8080&#39;, // port: &#39;8080&#39;, // hostname: &#39;www.pandashen.com&#39;, // hash: &#39;#hash&#39;, // search: &#39;?a=1&amp;b=2&#39;, // query: &#39;{ a: &#39;1&#39;, b: &#39;2&#39; }&#39;, // pathname: &#39;/src/index.html&#39; // path: &#39;/src/index.html?a=1&amp;b=2&#39;, // href: &#39;http://user:pass@www.pandashen.com:8080/src/index.html?a=1&amp;b=2#hash&#39; // } 在被解析路径返回的对象中有几个属性被经常使用：host：主机（域名 + 端口号）；hostname：主机名；query：请求参数（查询字符串或参数对象）；pathname：资源路径（根据不同的路径返回不同的资源）。我们使用 url 的 parse 方法来帮我们解析请求路径，在真实的服务器中传入的第一个参数为 req.url，第二个参数不传时，query 会被解析成 a=1&amp;b=2 的形式，第二个参数传入 true，query 属性的查询字符串会被解析成对象的形式。url 模块中，将查询字符串 a=1&amp;b=2 转换为对象 { a: &#39;1&#39;, b: &#39;2&#39; } 的实现方式其实是使用正则替换实现的。模拟查询字符串转换对象的核心逻辑：const query = &#39;a=1&amp;b=2&amp;c=3&#39;; const info = {}; query.replace(/([^=&amp;]+)=([^=&amp;]+)/g, function () { info[arguments[1]] = arguments[2]; }); console.log(info); // { a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; } 在上面代码的 replace 方法的回调函数中参数集合的第一项为匹配到的字符串，第二项为第一个分组的值，第三项为第二个分组的值，依次类推，倒数第二项为分组匹配的索引，最后一项为原字符串。设置响应信息我们可以通过 req 来获取请求信息，自然也可以通过 res 来设置响应信息返回给客户端。const http = require(&#39;http&#39;); const server = http.createServer(); server.on(&#39;request&#39;, function (req, res) { // 设置响应头（过去的用法），不能多次调用，见到要认识 res.writeHead(200, { &#39;Content-Type&#39;: &#39;text&#39;, data: &#39;hello world&#39; }); // 设置响应头（现在的用法，常用），可以多次调用，每次设置一个响应头 res.setHeader(&#39;Content-Type&#39;, &#39;text&#39;); // 设置状态码，不设置默认为 200 res.statusCode = 200; // 不发送 Date（日期）响应头 res.sendDate = false; // 返回内容 res.write(&#39;hello world&#39;); // 不会关闭连接 res.end(&#39;hello world&#39;); // 将内容返回后关闭连接 }); server.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 返回给客户端的信息主要分为两部分，分别为响应头和返回给浏览器的内容，在不设置响应头的情况下，默认会设置响应头 Content-Length 和 Date ，代表当前返回给客户端的内容长度和日期。返回给浏览器的内容可以通过 res 的 write 方法和 end 方法进行发送，write 方法不会断开连接（通常在响应后需要断开与客户端的连接），end 方法会断开连接，在 end 方法存在参数时，会在内部调用 write 将参数内容（只支持 string 和 buffer）返回给客户端，并断开连接。HTTP 客户端在 net 模块中可以通过 net.createConnection 来创建客户端，并发送请求到服务端，在 http 模块同样可以创建客户端，并向 http 服务器发送请求。/* 客户端：client.js */ const http = require(&#39;http&#39;); // 发送请求的配置 const config = { host: &#39;localhost&#39;, port: 3000, method: &#39;get&#39;, headers: { data: 1 } }; // 创建客户端 const client = http.request(config, function (res) { // 接收服务端返回的数据 const buffers = []; res.on(&#39;data&#39;, function (data) { buffers.push(data); }); res.on(&#39;end&#39;, function () { console.log(Buffer.concat(buffers).toString()); }); }); // 发送请求 client.end(); 在 http 模块中通过 request 方法创建客户端，该方法第一个参数为发送请求的配置，包含请求地址、端口号、请求方法以及请求头等，第二个参数为回调函数，在请求被响应后执行，回调函数的参数为服务器的响应对象 res，创建的客户端通过 end 方法将请求发出与服务端进行通信。使用 Node.js 实现的 “爬虫” 其实就可以通过 http 模块创建的客户端来实现，客户端帮我们向我们要抓取数据的地址发送请求，并拿到响应的数据进行解析。同时使用 HTTP 客户端和服务器我们使用自己创建的客户端访问自己的服务端，并体会请求响应的过程，就是用上面 client.js 作为客户端，启动 server.js 后再启动 client.js 查看效果。/* 服务器：server.js */ const http = require(&#39;http&#39;); http.createServer(function (req, res) { console.log(&#39;The request came&#39;); // 获取客户端请求信息 console.log(req.method); console.log(req.headers); // 返回数据 res.write(&#39;hello world&#39;); }).listen(3000, function () { console.log(&#39;server start 3000&#39;); }); 简易爬虫我们结合 http 模块创建的服务端和客户端实现一个简易版的 “爬虫” 去抓取百度新闻页所有 li 标签内的文章标题。/* 简易爬虫：crawl.js */ const http = require(&#39;http&#39;); // 创建服务器 const server = http.createServer(); // 发送请求的配置 const config = { host: &#39;news.baidu.com&#39;, method: &#39;get&#39;, port: 80 } // 监听请求 server.on(&#39;request&#39;, function (req, res) { const client = http.request(config, function (r) { // 接收百度新闻返回的数据 const buffers = []; r.on(&#39;data&#39;, function (data) { buffers.push(data); }); r.on(&#39;end&#39;, function () { // 处理数据 const result = Buffer.concat(buffers).toString(); const matches = result.match(/&lt;li class=&#39;bold-item&#39;&gt;([\\s\\S*?])&lt;\\/li&gt;/gm); // 设置返回给浏览器的文档类型和编码格式 res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf8&#39;); // 响应浏览器 res.end(matches.join(&#39;&#39;)); }); }); client.end(); }); server.listen(3000); 上面的正则匹配中 ([\\s\\S*?]) 代表匹配 &lt;li class=&#39;bold-item&#39;&gt; 到 &lt;\\/li&gt; 之间所有内容（多个字符、非贪婪模式），gm 代表全局并多行匹配。上面爬取百度新闻数据的过程中，我们自己的 Node 服务器扮演了一个 “中间层” 的角色，我们通过浏览器访问自己的服务器 localhost:3000 触发 request 事件，执行了回调，在回调中创建客户端向 news.baidu.com 发送了请求，并在客户端的回调中处理了响应（百度新闻页返回的数据），将处理后的内容通过我们自己 Node 服务器的 res 对象返回给了浏览器。总结相信在读过本篇文章之后对搭建一个 Node 服务应该已经有了思路，为未来通过 Node 服务实现复杂的业务场景及数据的处理打下了一个基础，希望初学 Node 的小伙伴在看了这篇文章后能有所收获。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"}]},{"title":"HTTP 基础","date":"2018-07-09T10:51:49.000Z","path":"20180709185149/","text":"HTTP 和 TCP 的关系HTTP 是在 TCP 传输协议上层的应用层协议，主要解决 Web 端的数据传输并对 TCP 传输的数据进行包装和拆解，关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP 协议，但是如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议，Web 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上”。HTTP 协议和 TCP 协议HTTP 访问到服务器的过程从在浏览器中输入一个网址直到请求到达服务器的过程中如下图：HTTP 协议访问服务器流程长连接在 HTTP1.0 版本中，每一个请求都需要在 TCP 协议中经历 “三次握手四次挥手”，在 HTTP1.1 中有了长连接，这个问题得到了改善，可以通过创建的一次 TCP 连接，对短时间内连续请求响应进行传输通道的复用，结束后关闭 TCP 连接。HTTP1.0 版本：HTTP1.0 版本HTTP1.1 长连接版本：HTTP1.1 版本管线化在不同的浏览器中对于访问同一个域名，都有一个最大的请求数限制，数量大小因浏览器而异，如果请求数量大于最大请求数限制，则需要排队等待其他请求结束。管线化技术，在超出最大请求数限制，客户端继续发送请求到服务端，而不需要其他请求得到响应的时候才能进行，实现并行发送请求，CDN 是比较典型的解决方式，将静态资源分发到不同 ip 下的服务器，请求资源是通过不同的代理服务器去同时获取，可以提高页面初始化响应的速度。HTTP 管线化URI 和 URLURI：是统一资源标识符，在某个规则下能把这个资源独一无二标示出来，类似人的身份证号；URL：统一资源定位符，表示资源的地点，是 URI 的特例，也是使用浏览器访问 Web 页面时输入的地址。URL 的组成：http://username:password@www.pandashen.com:80/2018/07/09/index.html?uid=1&amp;name=panda#ch1http：协议类型；username:password：登录信息（如 Github，不安全）；www.pandashen.com：服务器地址（与前面用 @ 连接）；80：服务器端口号（与前面用 : 连接）；/2018/07/09/index.html：带层次的文件路径；uid=1&amp;name=panda：查询字符串（与前面用 ? 连接）；ch1：片段标识符（hash 值，与前面使用 # 连接）。HTTP 的组成请求的一方叫客户端，响应的一方叫服务器端，通过请求和响应达成通信，HTTP 是一种无状态的协议。请求报文请求报文包含请求行、请求首部和请求体三个部分。请求报文请求行由三个部分组成，并写在同一行，分别为请求方法、请求路径（域名和端口号后面的部分）和协议/版本号。请求方法：GET：获取资源POST：向服务器端发送数据，传输实体主体PUT：传输文件HEAD：获取报文首部DELETE：删除文件OPTIONS：询问支持的方法TRACE：追踪路径追踪路径方式如下图：TRACE 追踪路径请求体内的内容为向服务端发送的数据，首部分为通用首部、请求首部、响应首部和实体首部四种，在后面详细说明。响应报文响应报文同样包含三个部分，响应行、响应首部和响应体。响应报文响应行由三个部分组成，并写在同一行，分别为协议/版本号、状态码和状态码原因短语。注意：在请求首部与请求体之间、在响应首部与响应体之间都应该空一个空行。HTTP 响应状态码状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误。状态码类别类别原因短语1XXInformational（信息性状态码）2XXSuccess（成功状态码）3XXRedirection（重定向）4XXClient Error（客户端错误状态码）5XXServer Error（服务器错误状态吗）常见状态码成功状态码原因短语原因解释200OK客户端发过来的数据被正常处理204Not Content正常响应，没有实体206Partial Content范围请求，返回部分数据，响应报文中由 Content-Range 指定实体内容重定向状态码原因短语原因解释301Moved Permanently永久重定向302Found临时重定向，规范要求方法名不变，但是都会改变成 GET303See Other和 302 类似，但必须用 GET 方法304Not Modified状态未改变，配合（If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since）307Temporary Redirect临时重定向，不该改变请求方法客户端错误状态码原因短语原因解释400Bad Request请求报文语法错误401Unauthorized需要认证403Forbidden服务器拒绝访问对应的资源404Not Found服务器上无法找到资源服务器错误状态码原因短语原因解释500Internal Server Error服务器故障503Service Unavailable服务器处于超负载或正在停机维护HTTP 首部HTTP 首部字段是 HTTP 报文首部的重要部分，在客户端和服务器进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。HTTP 首部主要分为通用首部、请求首部、响应首部和实体首部四种：通用首部字段：请求和响应报文两方都会使用的首部字段；请求首部字段：从客户端向服务器发送请求报文时使用的首部字段，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息；响应首部字段：从服务器向客户端返回响应报文时使用的首部字段，补充了响应的附加内容，也会要求客户端附加额外的内容信息；实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容的更新时间等与实体有关的信息。通用首部字段首部字段名说明Cache-Control控制缓存行为Connection链接的管理Date报文日期Pragma报文指令Trailer报文尾部的首部Trasfer-Encoding指定报文主体的传输编码方式Upgrade升级为其他协议Via代理服务器信息Warning错误通知请求首部字段首部字段名说明Accept用户代理可处理的媒体类型Accept-Charset优先的字符集Accept-Encoding优先的编码Accept-Langulage优先的语言AuthorizationWeb 认证信息Expect期待服务器的特定行为From用户的电子邮箱地址Host请求资源所在的服务器If-Match比较实体标记If-Modified-Since比较资源的更新时间If-None-Match比较实体标记If-Range资源未更新时发送实体 Byte 的范围请求If-Unmodified-Since比较资源的更新时间（ 与 If-Modified-Since相反 ）Max-Forwards最大传输跳数Proxy-Authorization代理服务器需要客户端认证Range实体字节范围请求Referer请求中的URI的原始获取方TE传输编码的优先级User-AgentHTTP 客户端程序的信息响应首部字段首部字段名说明Accept-Ranges是否接受字节范围Age资源的创建时间ETag资源的匹配信息Location客户端重定向至指定的 URIProxy-Authenticate代理服务器对客户端的认证信息Retry-After再次发送请求的时机Server服务器的信息Vary代理服务器缓存的管理信息www-Authenticate服务器对客户端的认证实体首部字段首部字段名说明Allow资源可支持的 HTTP 方法Content-Encoding实体的编码方式Content-Language实体的自然语言Content-Length实体的内容大小（字节为单位）Content-Location替代对应资源的 URIContent-MD5实体的报文摘要Content-Range实体的位置范围Content-Type实体主体的媒体类型Expires实体过期时间Last-Modified资源的最后修改时间总结本篇重点介绍关于 HTTP 协议的一点基础知识，关于请求、响应以及报文对应的信息及内容，也可以用作查询使用。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.overtaking.top/tags/TCP/"}]},{"title":"基于 TCP 实现简易聊天室","date":"2018-07-08T04:03:57.000Z","path":"20180708120357/","text":"前言TCP 为传输层协议，在 Node.js 中，基于 TCP 的核心模块为 net，http 和 https 模块都是基于 net 实现的，我们先简单介绍 net 的用法，再根据 net 实现一个简易的聊天室。net 模块的基本用法使用 net 创建一个网络服务方式 1：const net = require(&#39;net&#39;); // 创建 TCP 服务 const server = net.createServer(function (socket) { // ...... }); server.listen(3000); 方式 2：const net = require(&#39;net&#39;); // 创建 TCP 服务 const server = net.createServer(); // 监听连接 server.on(&#39;connection&#39;, function (socket) { // ...... }); server.listen(3000); 上面两种创建网络服务的方式第二种更常用，回调函数的参数都为 socket（套接字），在产生连接时执行，每产生一个连接就会产生一个 socket，我们也可以将 socket 理解为客户端。如果现在使用浏览器连接这个服务可以成功接收到请求，但浏览器是 http 协议，不识别，所以不会有任何响应。使用 TCP 模拟 httpconst net = require(&#39;net&#39;); // 创建 TCP 服务 const server = net.createServer(); // 监听连接 server.on(&#39;connection&#39;, function (socket) { // 设置编码 socket.setEncoding(&#39;utf8&#39;); // 读取请求报文 socket.on(&#39;data&#39;, function (data) { console.log(data); }); // 给浏览器返回响应报文 socket.write(` HTTP/1.1 200 ok Content-Length: 5 hello `); }); server.listen(3000); // GET /favicon.ico HTTP/1.1 // Host: localhost:3000 // Connection: keep-alive // Pragma: no-cache // Cache-Control: no-cache // ...... 后面省略 soket 是一个可读可写流 Duplex（双工流），所以既可以读取来自浏览器的请求信息，又可以写入响应信息，在模拟 http 时需遵循 http 协议规则，每行前面不允许有空格或制表符，响应头与响应正文之间需空一行。此时启动服务，使用浏览器访问 localhost:3000 可以在控制台打印请求报文，并在浏览器中显示 hello。http 的头部信息可以通过命令窗口中使用 curl 发送请求进行查看：输入命令：curl -v http://.....Windows 系统中默认命令行窗口不支持 curl 命令，请在 curl 官网 下载系统对应的版本，下载后的压缩包解压后将 curl.exe 和 ca-bundle.crt 拷贝至 C:\\Windows\\System32 或将所在文件夹添加至系统环境变量。server、socket 的属性和方法在 TCP 创建的服务 server 和连接中的 socket 本身具有一些属性、方法和事件，我们通过下面这个例子来介绍。const net = require(&#39;net&#39;); // 创建 TCP 服务器 const server = net.createServer(); server.on(&#39;connection&#39;, function (socket) { // 客户端的 ip + 端口号 const key = socket.remoteAddress + socket.remotePort; server.getConnetions(function (err, count) { socket.write(&#39;当前有&#39; + count + &#39;人，总人数为&#39; + server.maxConnections + &#39;人。&#39;); }); socket.on(&#39;data&#39;, function (data) { // 设置编码 socket.setEncoding(&#39;utf8&#39;); // 关闭客户端 // socket.end(); // 关闭服务器 // server.close(); server.unref(); }); }); // 最大连接数 server.maxConnections = 3; server.on(&#39;close&#39;, function () { console.log(&#39;服务端关闭&#39;); }); server.on(&#39;error&#39;, function (err) { if (err.code === &#39;EADDRINUSE&#39;) { server.listen(err.port + 1); } }); server.listen(3000, function () { console.log(&#39;server start 3000&#39;); }); socket.remoteAddress 属性，获取客户端的 IP 地址。socket.remotePort 属性，获取客户端的端口号。socket.setEncoding 方法，设置编码格式。socket.write 方法，向客户端写入内容，写入内容的值只能为字符串或 Buffer。socket.end 方法，断开对应客户端的连接，并返回信息，返回内容的值只能为字符串或 Buffer，soket 可以监听 end 事件，当关闭客户端时触发并执行回调。socket.destroy 方法，用于销毁当前客户端对应的 socket 对象。server.maxConnections 属性，是当前服务器允许的最大连接数，数值类型，当连接数超过设定值时，新的客户端将无法连接服务器。server.getConnetions 方法，获取当前的连接数，参数为回调函数，回调函数有两个参数 err（错误）和 count（当前连接数），异步执行。server.close 方法，关闭服务器，并没有真的关闭服务器，而是不允许新的连接，直到所有连接都断开后自动关闭服务器。server.unref 方法，关闭服务器的另一种形式，不阻止新的连接，当所有连接都断开时自动关闭服务器。server.listen 方法，监听端口号，支持传入回调，在启动服务后执行。server 的 close 事件，参数为回调函数，异步执行，当服务器关闭时触发。server 的 error 事件，参数为回调函数，回调函数的参数为 err（错误对象），异步执行，当启动服务器或服务器运行时出现错误触发。在 Webpack 中如果启动 webpack-dev-server 在端口号被占用时，端口号会自动 +1，我们可以利用 err 错误对象来模拟，在 err 事件对象上有很多属性，其中的 code 属性值为 EADDRINUSE 时代表端口号被占用，所以在判断 code 值后，重新调用了 server.listen 并传入重新计算后的端口号。想看一看上面代码的效果需要客户端的支持，本文中模拟客户端访问服务器有三种方式，使用一种即可。创建客户端验证我们自己实现的 TCP 服务器需要客户端访问，在本文的主题简易聊天室当中也需要用户和客户端，所以介绍一下创建客户端的方式。可以使用 net 模块创建客户端，并启访问服务器；Mac 中可以直接在命令窗口执行 brew install telnet 安装 telnet，安装后输入 telnet localhost 3000 即可以访问上面的服务器；Windows 中 telnet 接收到的服务器响应会变成乱码，所以可以使用 Xshell 和 PuTTY 等客户端工具。使用 net 创建客户端代码如下：/* 客户端：client.js */ const net = require(&#39;net&#39;); // 创建客户端 const client = net.createConnection({ port: 3000 }); // 给服务器发送消息 client.write(&#39;s:username:message&#39;); 由于本人目前使用 Windows 电脑，文中使用 PuTTY 工具，在使用之前需打开 Telnet 服务端和客户端，步骤如下：打开控制面板；打开或关闭 Windows 功能；勾选 Telnet 服务端和客户端。PuTTY 界面如下，在 Connection type（连接类型）中默认为 SSH，我们之所以使用 Raw 而不使用其他类型是因为其他的方式在连接服务器时会发送窗口信息，我们不需要这些数据。PuTTY 界面点击界面下面的 Open 按钮就可以创建一个客户端连接，客户端窗口如下，可以通过输入并回车确定的方式向服务端发送消息。PuTTY 客户端窗口目前所有的准备工作已经就绪，下面就是我们的正题，用 net 模块实现一个 TCP 服务，并使用 PuTTY 作为客户端，实现一个简易的聊天室。实现简易聊天室定义聊天室规则聊天室主要有四个功能，都需要输入对应的命令：显示在线用户：命令为 l；改名：聊天室默认用户名为匿名，重命名的命令为 r:newname；私聊：私聊的参数为聊天对象的名字和消息内容，命令为 s:username:message；广播：发送的消息除自己以外的所有人都能接收到，命令为 b:message。在存储所有的客户端时，都使用客户端的 ip + port 作为用户的唯一标识。服务搭建/* 服务器：server.js */ const net = require(&#39;net&#39;); // 处理输入命令模块 const processInstructs = require(&#39;./process-instructs&#39;); const server = net.createServer(); // 创建服务 const client = {}; // 客户端 const port = 3000; // 端口号 // 监听连接 server.on(&#39;connection&#39;, socket =&gt; { // 客户端的 ip + 端口号 作为存储客户端的唯一标识 const key = socket.remoteAddress + socket.remotePort; // 将客户端添加到 client 存储中 client[key] = { username: &#39;匿名&#39;, socket }; // 欢迎功能 server.getConnections((err, count) =&gt; { socket.write(&#39;欢迎加入！目前有 &#39; + count &#39;人。\\r\\n&#39;); }); // 设置编码 socket.setEncoding(&#39;utf8&#39;); // 监听用户输入 socket.on(&#39;data&#39;, data =&gt; { // 由于输入消息按回车键确认，所以需处理消息中的回车 data = data.replace(/\\r\\n/, &#39;&#39;); // 处理输入并做出响应 processInstructs(client, key, data); }); // 客户端主动关闭后在服务器客户端存储中清除客户端，并销毁对应的 socket socket.on(&#39;end&#39;, () =&gt; { socket.destroy(); delete client[key]; }); }); // 监听端口号 server.listen(port, () =&gt; { console.log(&#39;server start &#39; + port); }); 在上面的服务搭建当中，创建了 client 对象，专门存储聊天室内的客户端及信息，客户端使用 ip + port 作为存储的唯一标识，用户名默认为 “匿名”，设置了欢迎功能，并显示当前在线人数，监听用户的输入，并处理了消息中的回车，引入 process-instructs 对指令进行处理，最后处理了离开的用户，目的是防止有离开后，其他的人使用了私聊或广播功能通知这个人，因为找不到对应的 socket 而出现错误。处理指令模块 process-instructs/* 文件：process-instructs.js */ // 引入处理不同指令的功能函数 const { list, rename, privateChat, broadcast } = require(&#39;./instructs&#39;); module.exports = function (client, key, data) { const dataArr = data.split(&#39;:&#39;); // 针对不同的指令调用不同的处理方法 switch (dataArr[0]) { case &#39;l&#39;: list(client, key); break; case &#39;r&#39;: rename(client, key, dataArr); break; case &#39;s&#39;: privateChat(client, key, dataArr); break; case &#39;b&#39;: broadcast(client, key, dataArr); break; default: socket.write(&#39;命令有误\\r\\n&#39;); } }; 在上面对指令的处理中针对不同的指令引入了 instructs 模块对应的处理方法。指令处理方法模块 instructs/* 文件：instructs.js */ // 处理 l 指令，显示在线用户 exports.list = function (client, key) { // 获取当前 socket const socket = client[key].socket; // 写入信息 soket.write(&#39;当前用户列表:\\r\\n&#39;); Object.values(client).forEach(path =&gt; { socket.write(path.username + &#39;\\r\\n&#39;); }); }; // 处理 r 指令，用户重命名 exports.rename = function (client, key, dataArr) { const newName = dataArr[1]; // 更新对应 socket 的新用户名并通知 client[key].username = newName; client[key].socket.write(&#39;新用户名是: &#39; + newName + &#39;\\r\\n&#39;); }; // 处理 s 指令，私聊 exports.privateChat = function (client, key, dataArr) { Object.keys(client).forEach(path =&gt; { if (client[path].username === dataArr[1]) { client[path].socket.write(client[key].username + &#39;: &#39; + dataArr[2] + &#39;\\r\\n&#39;); } }); }; // 处理 b 指令，广播 exports.broadcast = function (client, key, dataArr) { Object.keys(client).forEach(path =&gt; { if (path !== key) { client[path].socket.write(client[key].username + &#39;: &#39; + dataArr[1] + &#39;\\r\\n&#39;); } }); }; 显示在线用户功能的思路是将 client 内部所有在线用户的用户名循环写入到当前 socket 中。重命名功能的思路是获取输入的新用户名替换掉 client 中对应的 username 并将当前新用户名设置成功的消息返回当前 socket。私聊功能的思路是循环 client 内的所有客户端，当 username 和发送的用户名相同时，将消息写入这个用户名对应的 socket。广播功能思路是循环 client，将消息写入给出自己以外的所有客户端。总结本文重点在于理解多人聊天功能的基本开发思路，及 Node.js 中 TCP 传输对应的 net 模块的应用，实际上本文中聊天室的代码在用户重名的情况下并没有做任何处理，正常情况应该使用 id 作为唯一标识，而不是指定用户名，在 Node.js 开发中其实很少直接使用 net 大多情况下使用 http 和 https 来替代，但是我们应该知道他们都是基于 net 封装的，了解 net 会在使用 http 和 https 时更得心应手。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.overtaking.top/tags/TCP/"}]},{"title":"使用 Node.js 可读流实现 “行读取器”","date":"2018-07-06T04:04:28.000Z","path":"20180706120428/","text":"前言本文是对于 Node.js 核心模块 fs 可读流 createReadeStream 的应用，实现 “行读取器”，功能为读取一个文档的内容，每读完一行触发一次监听的事件，并对这一行数据进行处理。推荐阅读文章：Node.js —— Stream 的基本使用Node.js —— Buffer 解读EventEmitter 源码分析与简易实现LineReader 类的创建实现 “行读取器” 的整体思路是创建一个类的实例，然后在这个实例上监听一个事件，并开始读取文件，每次读完一行触发，我们这里将这个类命名为 LineReader，因为类需要监听事件，所以需要继承 EventEmitter。/* 行读取器 LineReader 类 */ // 引入依赖 const EventEmitter = require(&#39;events&#39;); const fs = require(&#39;fs&#39;); // 行读取器的类，参数为读取文件的路径 class LineReader extends EventEmitter { contructor(path) { super(); this.path = path; // 文件路径 this._rs = fs.createReadStream(this.path); // 创建可读流 this.current = null; // 存储每次读到的单个字节 this.buffers = []; // 存放文件每一行单个字节 Buffer 的数组 this.system = null; // 默认的系统（windows 或 mac） this.RETURN = 13; // \\r 的十六进制数 this.LINE = 10; // \\n 的十六进制数 // 监听 newListener this.on(&#39;newListener&#39;, readLineCallback.bind(this)); } } 在 LineReader 实例上定义了 system（当前系统）、current（每次读取的单个字节）、RETURN（\\r 十六进制编码）和 LINE（\\n 十六进制编码）等属性方便后面使用。我们希望在监听的事件触发之前，就执行读取文件一行内容的逻辑，就说明我们需要一个在监听事件时就能执行的函数，那就需要在创建实例之前先监听 newListener 事件，把 newListener 的回调来作为这个函数执行，并能顺带在参数中获取事件类型。我们把读取文件的核心逻辑放在了 newListener 事件的回调函数中，将这个回调函数命名为 readLineCallback，为了保证执行时 readLineCallback 内部使用的 this 是 LineReader 的实例，使用 bind 进行修正。行读取器核心逻辑 readLineCall 函数如果需要默认就开始读取，并且每次读取一个字节后还可以进行下一次循环读取，这种场景最符合可读流的暂停模式 readable 事件默认触发一次，“容器” 内读走了一个字节，就会自动 “续杯” 的特点。/* 行读取器的核心逻辑 */ function readLineCallback(type) { // 使用暂停模式进行读取 this.on(&#39;readable&#39;, () =&gt; { if (type === &#39;newLine&#39;) { // 为了与 \\r 和 \\n 对比，每次只读一个字节 while ((this.current = this._rs.read(1))) { // 结果为 Buffer，所以使用索引取出对比 switch (this.current[0]) { case RETURN: // 针对 Windows this.system = &#39;windows&#39;; this.disposeLine(); // 处理换行逻辑 break; case LINE: // 针对 Mac this.system = &#39;mac&#39;; this.disposeLine(); // 处理换行逻辑 break; default: // 每读到换行的字符存入数组中 this.buffers.push(current); } } } }); // 防止最后一行丢失 this.on(&#39;end&#39;, this.disposeLine.bind(this)); } 在上面代码中监听了 readable 事件并验证了事件类型是否为 newLine，然后循环读取文件内容，为了与换行的十六进制码进行对比，每次只读取一个字节，当遇到换行符时，明确当前系统并调用换行符处理函数 disposeLine 进行处理。注意：在最后一次的时候文件最后一行可能没有换行，所以不满足 switch 内语句的条件，即没使用 disposeLine 进行处理，所以监听可读流的 end 事件，并在 end 触发时让 disposeLine 作为回调函数执行，注意使用 bind 修正 this 为当前实例。兼容操作系统的换行符处理函数在换行符处理函数中，Windows 与其他系统（Mac、Linux）系统唯一的区别就是 Window 系统的换行符为 \\r\\n，比 Mac 和 Linux 的 \\n 多了一个字节，而在读取下一行时，这个字节是无用的，需要忽略。/* 换行符处理函数 */ LineReader.prototype.disposeLine = function () { // 将这一行的内容发射出来并清空数组 this.emit(&#39;newLine&#39;, Buffer.concat(this.buffers).toString()); this.buffers = []; // 如果是 window 系统，下一个是 \\n，就往下多读一个字节不存入组即可 if (this.system === &#39;windows&#39;) { this._rs.read(1); } }; 验证 LineReader 行读取器创建一个 “行读取器” 需要创建 LineReader 类的实例，并传入被读取文件的路径，由于在源码中执行的是 newListener 的回调函数，所以只需添加 newLine 事件监听就可以了，然后会在 readable 默认触发时在内部循环读取，并把每行读到的内容重新整合后发送，实现 newLine 事件的连续触发，直到文件读完。/* 使用行读取器 */ // 创建文件 1.txt 每次内容为 1~9 9个数字，每 3 个字符为一行 const lineReader = new LineReader(&#39;1.txt&#39;); lineReader.on(&#39;newLine&#39;, data =&gt; { console.log(&#39;------ &#39; + data + &#39;------&#39;); }); // ------ 123 ------ // ------ 456 ------ // ------ 789 ------ “行读取器” lineReader 对读取到每一行的数据进行处理的逻辑主要在 newLine 事件的回调函数中，比如上面例子，在每一行的前、后添加了 ------ 并打印。总结在 Node.js 中，流的应用非常广泛，“行读取器” 只是其中的一种应用，可以根据流的不同模式的不同特性实现更复杂的功能，所以流在 Node.js 中还是非常重要的。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Stream","slug":"Stream","permalink":"https://www.overtaking.top/tags/Stream/"},{"name":"LineReader","slug":"LineReader","permalink":"https://www.overtaking.top/tags/LineReader/"}]},{"title":"Node.js —— 自定义流的实现","date":"2018-07-05T04:55:01.000Z","path":"20180705125501/","text":"概述常见的自定义流有四种，Readable（可读流）、Writable（可写流）、Duplex（双工流）和 Transform（转换流），常见的自定义流应用有 HTTP 请求、响应，crypto 加密，进程 stdin 通信等等。流相关文章推荐：Node.js —— Stream 的基本使用Node.js —— 流的原理分析与简易实现stream 模块介绍在 Node.js 中要想实现自定义流，需要依赖模块 stream，直接引入，不需下载，所有种类的流都是继承这个模块内部提供的对应不同种类的类来实现的。实现一个自定义可读流 Readable创建自定义可读流的类 MyRead我们创建一个名为 MyRead 的自定义可读流，并继承 stream 中的 Readable 类，重写 _read 方法，重写核心方法是实现自定义流的套路。/* 创建自定义可读流 */ const { Readable } = require(&#39;stream&#39;); // 创建自定义可读流的类 class MyRead extends Readable { constructor() { super(); this.index = 0; } // 重写自定义的可读流的 _read 方法 _read() { this.index++; this.push(this.index + &#39;&#39;); if (this.index === 3) { this.push(null); } } } 我们自己写的 _read 方法会继承很多流原有的特性，比如在读取时使用 push 方法将数据读取出来，直到 push 的值为 null 才会停止，否则会认为没有读取完成，会继续调用 _read。验证自定义可读流/* 验证自定义可读流 */ const myRead = new MyRead(); myRead.on(&#39;data&#39;, data =&gt; { console.log(data); }); myRead.on(&#39;end&#39;, function () { console.log(&#39;读取完成&#39;); }); // &lt;Buffer 31&gt; // &lt;Buffer 32&gt; // &lt;Buffer 33&gt; // 读取完成 实现一个自定义可写流 Writable创建自定义可写流的类 MyWrite创建一个名为 MyWrite 的自定义可写流，并继承 stream 中的 Writable 类，重写 _write 方法。/* 创建自定义可写流 */ const { Writable } = require(&#39;stream&#39;); // 创建自定义可写流的类 class MyWrite extends Writable { // 重写自定义的可写流的 _write 方法 _write(chunk, encoding, callback)) { callback(); // 将缓存区写入文件 } } 写入内容时默认第一次写入直接写入文件，后面的写入都写入缓存区，如果不调用 callback 只能默认第一次写入文件，调用 callback 会将缓存区清空并写入文件。验证自定义可写流/* 验证自定义可写流 */ const myWrite = new MyWrite(); myWrite.write(&#39;hello&#39;, &#39;utf8&#39;, () =&gt; { console.log(&#39;hello ok&#39;); }); myWrite.write(&#39;world&#39;, &#39;utf8&#39;, () =&gt; { console.log(&#39;world ok&#39;); }); // hello ok // world ok 实现一个自定义双工流 Duplex创建自定义可双工流的类 MyDuplex双工流的可以理解为即可读又可写的流，创建一个类名为 MyDuplex，并继承 stream 中的 Duplex 类，由于双工流即可读又可写，需重写 _read 和 _write 方法。/* 创建自定双工流 */ const { Duplex } = require(&#39;stream&#39;); // 创建自定义双工流的类 class MyDuplex extends Duplex { // 重写自定义的双工流的 _read 方法 _read() { this.push(&#39;123&#39;); this.push(null); } // 重写自定义的双工流的 _write 方法 _write(chunk, encoding, callback)) { callback(); } } 双工流分别具备 Readable 和 Writable 的功能，但是读和写互不影响，互不关联。验证自定义双工流/* 验证自定义双工流 */ const myDuplex = new MyDuplex(); myDuplex.on(&#39;readable&#39;, () =&gt; { console.log(myDuplex.read(1), &#39;----&#39;); }); setTimeout(() =&gt; { myDuplex.on(&#39;data&#39;, data =&gt; { console.log(data, &#39;xxxx&#39;); }); }, 3000); // &lt;Buffer 31&gt; ---- // &lt;Buffer 32&gt; xxxx // &lt;Buffer 32&gt; ---- // &lt;Buffer 33&gt; xxxx 如果 readable 和 data 两种读取方式都使用默认先通过 data 事件读取，所以一般只选择一个，不要同时使用，可读流的特点是读取数据被消耗掉后就丢失了（缓存区被清空），如果非要两个都用可以加一个定时器（绝对不要这样写）。实现一个自定义转化流 Transform创建自定义可转化流的类 MyTransform转化流的意思是即可以当作可读流，又可以当作可写流，与双工流的区别是读和写可以相关联，创建一个类名为 MyTransform，并继承 stream 中的 Transform 类，重写 _transform 方法，该方法的参数和 _write 相同。/* 创建自定义转化流 */ const { Transform } = require(&#39;stream&#39;); // 创建自定义转化流的类 class MyTransform extends Transform { // 重写自定义的转化流的 _transform 方法 _transform(chunk, encoding, callback)) { console.log(chunck.toString.toUpperCase()); callback(); this.push(&#39;123&#39;); } } 在自定义转化流的 _transform 方法中，读取数据的 push 方法和 写入数据的 callback 都可以使用。由此可以看出，Transform 类型可以将可读流转化为可写流，也可以将可写流转化成可读流，他的主要目的不是像其他类型的流一样负责数据的读写，而是既作为可读流又作为可写流，实现流的转化，即实现对数据的特殊处理，如 zib 模块实现的压缩流，cropo 模块实现的加密流，本质都是转化流，将转化流作为可写流，将存储文件内容的可写流通过 pipe 方法写入转化流，再将转化流作为可读流通过 pipe 方法将处理后的数据响应给浏览器。验证自定义转化流/* 验证自定义转化流 */ const myTransForm = new MyTransform(); // 使用标准输入 process.stdin.pipe(myTransForm).pipe(process.stdin); 打开命令行窗口执行 node demo.js，然后输入 abc，会在命令窗口输出 ABC 和 123，其实转换流先作为一个可写流被写入到标准输入中，而此时 stdin 的作用是读流，即读取用户的输入，读取后转换流作为一个可读流调用 pipe，将用户输入的信息通过标准输出写到命令行窗口，此时 stdout 的作用是写流。总结自定义流最常见的种类在上面都已经涵盖了，真正的在开发中用到的不多，如果需要写一个自定义流应该比上面的复杂很多，本文主要目的是认识什么是自定义流，并了通过 Node.js 解实现一个自定义流的基本流程。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Stream","slug":"Stream","permalink":"https://www.overtaking.top/tags/Stream/"}]},{"title":"Node.js —— 流的原理分析与简易实现","date":"2018-07-04T09:52:17.000Z","path":"20180704175217/","text":"前言在之前的文章中有一篇讲解了流的基本用法，本篇的重点在于根据可读流的用法对可读流的原理进行分析，实现简易版的 Stream，而并非流的使用，下面代码中依赖了 fs 的很多基本操作和流的基本使用知识，可以看下面两篇：Node.js 文件操作 —— fs 基本使用。Node.js —— Stream 的基本使用。可读流的实现（流动模式）ReadStream 类创建在使用 fs 的 createReadStream 创建可读流时，返回了 ReadStream 对象，上面存在着一些事件和方法，其实我们在创建这个可读流的时候创建了某一个类的实例，这个实例可以调用类原型上的方法，我们这里将这个类命名为 ReadStream。类的原型方法内部可能会创建一些事件，在 Node.js 中，事件是依赖 events 模块的，即 EventEmitter 类，同时类的方法可能会操作文件，会用到 fs 模块，所以也提前引入 fs。/* 创建 ReadStream 类 */ // 引入依赖模块 const EventEmitter = require(&#39;events&#39;); const fs = require(&#39;fs&#39;); // 创建 ReadStream 类 class ReadStream extends EventEmitter { constructor(path, options = {}) { super(); // 创建可读流参数传入的属性 this.path = path; // 读取文件的路径 this.flags = options.flags || &#39;r&#39;; // 文件标识位 this.encoding = options.encoding || null; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 读取文件的起始位置 this.end = options.end || null; // 读取文件的结束位置（包含） // 每次读取文件的字节数 this.highWaterMark = options.highWaterMark || 64 * 1024; this.flowing = false; // 控制当前是否是流动状态，默认为暂停状态 // 存储读取内容的 Buffer this.buffer = Buffer.alloc(this.highWaterMark); this.pos = this.start; // 下次读取文件的位置（变化的） // 创建可读流要打开文件 this.open(); // 如果监听了 data 事件，切换为流动状态 this.on(&#39;newListener&#39;, type =&gt; { if (type === &#39;data&#39;) { this.flowing = true; // 开始读取文件 this.read(); } }); } } // 导出模块 module.exports = ReadStream; 使用 fs.createReadStream 时传入了两个参数，读取文件的路径和一个 options 选项，options 上有 8 个参数，我们在创建 ReadStream 类的时候将这些参数初始化到了 this 上。创建可读流的时候有两种状态，流动状态和暂停状态，默认创建可读流是暂停状态，只有在触发 data 事件时才会变为流动状态，所以在 this 上挂载了 flowing 存储当前的状态是否为流动状态，值默认为 false。注意：这里说的暂停状态不是暂停模式，暂停模式是 readable，是可读流的另一种模式，我们这小节讨论的可读流为流动模式。在读取文件时其实是操作 Buffer 进行读取的，需要有一个 Buffer 实例用来存储每次读取的数据，所以在 this 上挂载了一个新创建的 Buffer，长度等于 highWaterMark。当从 start 值的位置开始读取文件，下一次读取文件的位置会发生变化，所以在 this 上挂载了 pos 属性，用于存储下次读取文件的位置。在创建 ReadStream 的实例（可读流）时，应该打开文件并进行其他操作，所以在 this 上挂载了 open 方法并执行。创建实例的同时监听了 newListener 事件，回调在每次使用 on 监听事件时触发，回调内部逻辑是为了将默认的暂停状态切换为流动状态，因为在使用时，流动状态是通过监听 data 事件触发的，在 newListener 的回调中判断事件类型为 data 的时候将 flowing 标识的值更改为 true，并调用读取文件的 read 方法。在使用 ES6 的类编程时，原型上的方法都是写在 class 内部，我们下面为了把原型上的方法拆分出来成为单独的代码块，都使用 ReadStream.prototype.open = function... 直接给原型添加属性的方式，但这样的方式和直接写在 class 内有一点区别，就是 class 内部的书写的原型方法都是不可遍历的，添加属性的方式创建的方法都是可遍历的，但是这点区别对我们代码的执行没有任何影响。打开文件方法 open 的实现在使用可读流时，打开时默认是暂停状态，会触发 open 事件，如果打开文件出错会触发 error 事件。/* open 方法 */ // 打开文件 ReadStream.prototype.open = function () { fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; { if (err) { this.emit(&#39;error&#39;, err); // 如果文件打开了出错，并配置自动关闭，则关掉文件 if (this.autoClose) { // 关闭文件（触发 close 事件） this.destroy(); // 不再继续执行 return; } } // 存储文件描述符 this.fd = fd; // 成功打开文件后触发 open 事件 this.emit(&#39;open&#39;); }); } open 方法的逻辑就是在打开文件的时候，将文件描述符存储在实例上方便后面使用，并使用 EventEmitter 的原型方法 emit 触发 open 事件，如果出错就使用 emit 触发 error 事件，如果配置 autoClose 参数为 true，就关闭文件并触发 close。我们将关闭文件的逻辑抽取出来封装在了 ReadStream 类的 destroy 方法中，下面来实现 destroy。关闭文件方法 destroy 的实现文件出错分为两种，第一种文件打开出错，第二种是文件不存在出错（没打开文件，系统不会分配文件描述符 fd）。/* detroy 方法 */ // 关闭文件 ReadStream.prototype.detroy = function () { // 判断是否存在文件描述符 if (typeof this.fd === &#39;number&#39;) { // 存在则关闭文件并触发 close 事件 fs.close(fd, () =&gt; { this.emit(&#39;close&#39;); }); return; } // 不存在文件描述符直接触发 close 事件 this.emit(&#39;close&#39;); } 如果是打开文件后出错需要关闭文件，并触发 close 事件，如果是没打开文件，则直接触发 close 事件，所以上面通过文件描述符来判断该如何处理。读取文件方法 read 的实现还记得在 ReadStream 类中，监听的 newListener 事件的回调中如果监听了 data 事件则会执行 read 读取文件，接下来就实现读取文件的核心逻辑。/* read 方法 */ // 读取文件 ReadStream.prototype.read = function () { // 由于 open 异步执行，read 是在创建实例时同步执行，read 执行可能早于 open，此时不存在文件描述符 if (typeof this.fd !== &#39;number&#39;) { // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 read return this.once(&#39;open&#39;, () =&gt; this.read()); } // 如过设置了结束位置，读到结束为止就不能再读了，最后一次读取真实读取数应该小于 highWaterMark // 所以每次读取的字节数应该和 highWaterMark 取最小值 const howMuchToRead = this.end ? Math.min(this.highWaterMark, this.end - this.pos + 1) : this.highWaterMark; // 读取文件 fs.read(this.fd, this.buffer, 0, howMuchToRead, this.pos, (err, bytesRead) =&gt; { // 如果读到内容执行下面代码，读不到则触发 end 事件并关闭文件 if (bytesRead &gt; 0) { // 维护下次读取文件位置 this.pos += bytesRead; // 保留有效的 Buffer let realBuf = this.buffer.slice(0, bytesRead); // 根据编码处理 data 回调返回的数据 realBuf = this.encoding ? realBuf.toString(this.encoding) : realBuf; // 触发 data 事件并传递数据 this.emit(&#39;data&#39;, realBuf); // 递归读取 if (this.flowing) { this.read(); } } else { this.isEnd = true; this.emit(&#39;end&#39;); // 触发 end 事件 this.detroy(); // 关闭文件 } }); } 创建 ReadStream 的实例时，执行的 open 方法内部是使用 fs.open 打开文件的，是异步操作，而读取文件方法 read 是在 newListener 回调中同步执行的，这样很可能触发 read 的时候文件还没有被打开（不存在文件描述符），所以在 read 方法中判断了文件描述符是否存在，并在不存在时候使用 once 添加了 open 事件，回调中重新执行了 read。由于在 open 方法中使用 emit 触发了 open 事件，所以 read 内用 once 添加的 open 事件的回调也会跟着执行一次，并在回调中重新调用了 read 方法，保证了 read 读取文件的逻辑在文件真正打开后才执行，为了文件打开前执行 read 而不执行读取文件的逻辑，用 once 添加 open 事件时别忘记 return。在使用 fs.read 读取文件的时候有一个参数为本次读取几个字符到 Buffer 中，如果在创建可读流的时候设置了读取文件的结束位置 end 参数，则读到 end 位置就不应该再继续读取了，所以在存在 end 参数的时候每次都计算一下读取个数和 highWaterMark 取最小值，保证读取内容小于 highWaterMark 的时候不会多读，因为读取时是包括 end 值作为 Buffer 的索引这一项的，所以计算时多减去的要 +1 加回来，再一次读取这个读取个数计算结果变成了 0，也就结束了读取。因为 end 参数的情况，所以在内部读取逻辑前判断了 bytesRead （实际读取字节数）是否大于 0，如果不满足条件则在实例添加是否读取结束标识 isEnd（后面使用），触发 end 事件并关闭文件，如果满足条件，也是通过 bytesRead 对 Buffer 进行截取，保留了有用的 Buffer，并且通过 encoding 编码对 Buffer 进行处理后，触发 data 事件，并将处理后的数据传递给 data 事件的回调。暂停、恢复读取 pause 和 resumepause 的目的就是暂停读取，其实就是阻止 read 方法在读取时进行递归，所以只需要更改 flowing 的值即可。/* pause 方法 */ // 暂停读取 ReadStream.prototype.pause = function () { this.flowing = false; }; resume 的目的是恢复读取，在更改 flowing 值得基础上重新执行 read 方法，由于在 pause 调用时 read 内部还是执行得读取文件得分支，文件并没有关闭，读取文件位置的参数也是通过实例上的当前的属性值进行计算的，所以重新执行 read 会继续上一次的位置读取。/* resume 方法 */ // 恢复读取 ReadStream.prototype.resume = function () { this.flowing = true; if (!this.isEnd) this.read(); }; 上面在重新执行 read 之前使用 isEnd 标识做了判断，防止在 setInterval 中调用 resume 在读取完成后不断的触发 end 和 close 事件。验证可读流（流动模式）ReadStream接下来我们使用自己实现的 ReadStream 类来创建可读流，并按照 fs.createReadStream 的用法进行使用并验证。/* 验证 ReadStream */ // 文件 1.txt 内容为 0123456789 const fs = require(&#39;fs&#39;); const ReadStream = require(&#39;./ReadStream&#39;); // 创建可读流 const rs = new ReadStream(&#39;1.txt&#39;, { encoding: &#39;utf8&#39;, start: 0, end: 5, highWaterMark: 2 }); rs.on(&#39;open&#39;, () =&gt; console.log(&#39;open&#39;)); rs.on(&#39;data&#39;, data =&gt; { console.log(data, new Date()); rs.pause(); }); rs.on(&#39;end&#39;, () =&gt; console.log(&#39;end&#39;)); rs.on(&#39;close&#39;, () =&gt; console.log(&#39;close&#39;)); rs.on(&#39;error&#39;, err =&gt; console.log(err)); setInterval(() =&gt; rs.resume(), 1000); // open // 01 2018-07-04T10:44:20.384Z // 23 2018-07-04T10:44:21.384Z // 45 2018-07-04T10:44:22.384Z // end // close 执行上面的代码正常的执行逻辑是先触发 open 事件，然后触发 data 事件，读取一次后暂停，每隔一秒恢复读取一次，再读取完成后触发 end 和 close 事件，通过运行代码结果和我们希望的一样。可读流的实现（暂停模式）在 fs 中的暂停模式的真正用法在 fs 模块中用 createReadStream 创建的可读流中通过监听 readable 事件触发暂停模式（监听 data 事件触发流动模式），通过下面例子感受暂停模式与流动模式的不同，现在读取文件 1.txt，内容为 0~9 十个数字。/* 暂停模式的用法 */ // 文件 1.txt 内容为 0123456789 const fs = require(&#39;fs&#39;); // 创建可读流 const rs = fs.createReadStream(&#39;1.txt&#39;, { encoding: &#39;utf8&#39;, start: 0, highWaterMark: 3 }); rs.on(&#39;readable&#39;, () =&gt; { // read 参数为本次读取的个数 const r = rs.read(3); // 打印读取的数据 console.log(&#39;data:&#39;, r); // 打印容器剩余空间 console.log(rs._readableState.length); }); // data:012 // 0 // data:345 // 0 // data:678 // 0 // data:null // 1 // data:9 // 0 通俗的解释，暂停模式的 readable 事件默认会触发一次，监听 readable 事件后就像创建了一个 “容器”，容量为 highWaterMark，文件中的数据会自动把容器注满，调用可读流的 read 方法读取时，会从容器中取出数据，如果 read 方法读取的数据小于 highWaterMark，则直接暂停，不再继续读取，如果大于等于 highWaterMark ，说明 “容器” 空了，则会触发 readable 事件，无论读取字节数与 highWaterMark 关系如何，只要 “容器” 内容量剩余小于 highWaterMark 就会进行 “续杯”，再次向 “容器” 中填入 highWaterMark 个，所以有些时候真实的容量会大于 highWaterMark。read 方法读取的内容会返回 null 是因为容器内真实的数据数小于了读取数，如果不是最后一次读取，会在多次读取后将值一并返回，如果是最后一次读取，会把剩余不足的数据返回。可读流暂停模式的特点：readable 事件的触发条件：“容器” 空了；“续杯” 条件：读取后 “容器” 内剩余量小于 highWaterMark；read 返回 null：“容器” 容器内可悲读取数据无法满足一次读取字节数。ReadableStream 类的实现同为可读流，暂停模式与流动模式相同，都依赖 fs 模块和 events 模块的 EventEmitter 类，参数依然为读取文件的路径和 options。/* 创建 ReadableStream 类 */ // 引入依赖 const EventEmitter = require(&#39;events&#39;); const fs = require(&#39;fs&#39;); class ReadableStream extends EventEmitter { constructor(path, options = {}) { super(); this.path = path; // 读取文件的路径 this.flags = options.flags || &#39;r&#39;; // 文件标识位 this.encoding = options.encoding || null; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 读取文件的起始位置 // 每次读取文件的字节数 this.highWaterMark = options.highWaterMark || 64 * 1024; this.reading = false; // 如果正在读取，则不再读取 // 当缓存区的长度等于 0 的时候， 触发 readable this.emitReadable = false; this.cache = []; // 缓存区 this.len = 0; // 缓存区的长度 this.pos = this.start; // 下次读取文件的位置（变化的） // 创建可读流要打开文件 this.open(); this.on(&#39;newListener&#39;, type =&gt; { if (type === &#39;readable&#39;) { this.read(); // 监听readable就开始读取 } }); } } // 导出模块 module.exports = ReadableStream; 在类的添加了 newListener 事件，在回调中判断是否监听了 readable 事件，如果监听了开始从 “容器” 中读取。打开、关闭文件 open 和 detroy打开和关闭文件的方法和流动模式的套路基本相似。/* open 方法 */ // 打开文件 ReadableStream.prototype.open = function () { fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; { if (err) { this.emit(&#39;error&#39;, err); // 如果文件打开了出错，并配置自动关闭，则关掉文件 if (this.autoClose) { // 关闭文件（触发 close 事件） this.destroy(); // 不再继续执行 return; } } // 存储文件描述符 this.fd = fd; // 成功打开文件后触发 open 事件 this.emit(&#39;open&#39;); }); } /* detroy 方法 */ // 关闭文件 ReadableStream.prototype.detroy = function () { // 判断是否存在文件描述符 if (typeof this.fd === &#39;number&#39;) { // 存在则关闭文件并触发 close 事件 fs.close(fd, () =&gt; { this.emit(&#39;close&#39;); }); return; } // 不存在文件描述符直接触发 close 事件 this.emit(&#39;close&#39;); } 从 “容器” 中读取 read 方法的实现read 方法的参数不传时就相当于从 “容器” 读取 highWaterMart 个字节，如果传参表示读取参数数量的字节数。/* read 方法 */ ReadableStream.prototype.read = function (n) { // 如果读取大于了 highWaterMark，重新计算 highWaterMark，并重新读取 if (n &gt; this.len) { // 计算新的 highWaterMark，方法摘自 Node.js 源码 this.highWaterMark = computeNewHighWaterMark(n); this.reading = true; this._read(); } // 将要返回的数据 let buffer; // 如果读取的字节数大于 0 小于等于当前缓存 Buffer 的总长度 if (n &gt; 0 &amp;&amp; n &lt;= this.len) { // 则从缓存中取出 buffer = Buffer.alloc(n); let current; // 存储每次从缓存区读出的第一个 Buffer let index = 0; // 每次读取缓存 Buffer 的索引 let flag = true; // 是否结束整个 while 循环的标识 // 开始读取 while ((current = this.cache.shift()) &amp;&amp; flag) { for (let i = 0; i &lt; current.length; i++) { // 将缓存中取到的 Buffer 的内容读到自己定义的 Buffer 中 buffer[index++] = current[i]; // 如果当前索引值已经等于了读取个数，结束 for 循环 if (index === n) { flag = false; // 取出当前 Buffer 没有消耗的 const residue = current.slice(i + 1); // 在读取后维护缓存的长度 this.len -= n; // 如果 BUffer 真的有剩下的就给塞回到缓存中 if (residue.length) { this.cache.unshift(residue); } break; } } } } // 如果当前 读取的 Buffer 为 0，将触发 readable 事件 if (this.len === 0) { this.emitReadable = true; } // 如果当前的缓存区大小小于 highWaterMark，就要读取 if (this.len &lt; this.highWaterMark) { // 如果不是正在读取才开始读取 if (!this.read) { this.reading = true; this._read(); // 正真读取的方法 } } // 将 buffer 转回创建可读流设置成的编码格式 if (buffer) { buffer = this.encoding ? buffer.toString(this.encoding) : buffer; } return buffer; } 上面的 read 方法的参数大小对比缓存区中取出的 Buffer 长度有两种情况，一种是小于当前缓存区内取出 Buffer 的长度，一种是大于了整个缓存区的 len 的长度。小于当前缓存区总长度通过循环取出需要的 Buffer 存储了我们要返回创建的 Buffer 中，剩余的 Buffer 会丢失，所以我们做了一个小小的处理，将剩下的 Buffer 作为第一个 Buffer 塞回到了缓存区中，在处理这个问题时与流动模式不相同，流动模式处理后直接跳出了，而暂停模式相当于从 “容器” 中读取，如果第一次读取后还有剩余还要接着从容器中继续读取。大于 len 属性时，规定需要重新计算 highWaterMark，遵循的原则是将当前 highWaterMark 设定为当前读取字节个数距离最接近的 2 的 n 次方的数值，Node.js 源码中方法名称为 computeNewHighWaterMark，为了提高性能是使用位运算的方式进行计算的，源码如下。/* 重新计算 highWaterMark */ function computeNewHighWaterMark(n) { n--; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n++; return n; } 在调用该方法重新计算 highWaterMark 后更改正在读取状态，重新读取，由于读取逻辑的重复，所以真正读取文件的逻辑抽取成一个 _read 方法来实现，下面呢就来看看 _read 内部都做了什么。真正读取文件的 _read对比可读流（流动模式）的 read 方法，在调用 _read 方法读取时，是在 newListener 中同步执行 _read，所以为了保证 _read 的逻辑是在 open 方法打开文件以后执行，使用了与 read 相同的处理方式。/* _read 方法 */ ReadableStream.prototype._read = function () { if (typeof this.fd !== &#39;number&#39;) { return this.once(&#39;open&#39;, () =&gt; _read()); } // 创建本次读取的 Buffer let buffer = Buffer.alloc(this.highWaterMark); // 读取文件 fs.read(this.fd, buffer, 0, this.highWaterMark, this.pos, (err, bytesRead) =&gt; { if (bytesRead &gt; 0) { this.cache.push(buffer); // 缓存 this.len += bytesRead; // 维护缓存区长度 this.pos += bytesRead; // 维护下一次读取位置 this.reading = false; // 读取完毕 // 触发 readable 事件 if (this.emitReadable) { // 触发后更改触发状态为 false this.emitReadable = false; this.emit(&#39;readable&#39;); } } else { // 如果读完触发结束事件 this.emit(&#39;end&#39;); } }); } 由于缓存区是一个数组，存储的每一个 Buffer 是独立存在的，所以不能挂载在实例上共用，如果挂在实例上则引用相同，一动全动，这不是我们想要的，所以每一次执行 _read 方法时都创建新的 Buffer 实例存入读取的数据后存储在缓存区中，如果读取完成 bytesRead 为 0，则触发 end 事件。注意：在 Node.js 源码中，可读流两种模式代码都是通过一个类 ReadStream 实现的，使用 fs.createReadStream 创建一个可读流就具备两种模式，通过监听 data 和 readable 两种不同的事件来触发两种不同的模式，而我们为了更清晰的模拟两种模式的实现，把两种模式拆开成了两个类来实现的，在测试时需要创建不同类的实例。验证可读流（暂停模式）ReadableStream为了统一我们依然读取真正用法中 1.txt 文件，内容为 0~9 十个数字。/* 验证 ReadableStream */ // 引入依赖 const fs = require(&#39;fs&#39;); const ReadableStream = require(&#39;./ReadableStream&#39;); const rs = new ReadableStream(&#39;1.txt&#39;, { encoding: &#39;utf8&#39;, start: 0, highWaterMark: 3 }); rs.on(&#39;readable&#39;, () =&gt; { let r = rs.read(3); console.log(r); console.log(rs.len); }); 在打印 “容器” 剩余容量时，我们使用在 ReadableStream 上构造的 len 属性，源码中的属性是 _readableState.length。流动模式和暂停模式分别有不同的应用场景：如果只是希望读取一个文件，并最快的获得结果使用流动模式是很好的选择；如果希望了解读取文件的具体内容，并进行精细的处理，使用暂停模式更好一些。可写流的实现WriteStream 类创建在使用 fs 的 createWriteStream 创建可写流时，返回了 WriteStream 对象，上面也存在事件和方法，创建可写流的时也是创建类的实例，我们将这个类命名为 WriteStream，事件同样依赖 events 模块的 EventEmitter 类，文件操作同样依赖 fs 模块，所以需提前引入。/* 创建 WriteStream 类 */ // 引入依赖模块 const EventEmitter = require(&#39;events&#39;); const fs = require(&#39;fs&#39;); // 创建 WriteStream 类 class WriteStream extends EventEmitter { constructor(path, options = {}) { super(); // 创建可写流参数传入的属性 this.path = path; // 写入文件的路径 this.flags = options.flags || &#39;w&#39;; // 文件标识位 this.encoding = options.encoding || &#39;utf8&#39;; // 字符编码 this.fd = options.fd || null; // 文件描述符 this.mode = options.mode || 0o666; // 权限位 this.autoClose = options.autoClose || true; // 是否自动关闭 this.start = options.start || 0; // 写入文件的起始位置 // 对比写入字节数的标识 this.highWaterMark = options.highWaterMark || 16 * 1024; this.writing = false; // 是否正在写入 this.needDrain = false; // 是否需要触发 drain 事件 this.buffer = []; // 缓存，正在写入就存入缓存中 this.len = 0; // 当前缓存的个数 this.pos = this.start; // 下次写入文件的位置（变化的） // 创建可写流要打开文件 this.open(); } } // 导出模块 module.exports = WriteStream; 使用 fs.createWriteStream 创建可写流时传入了两个参数，写入的文件路径和一个 options 选项，options 上有 7 个参数，我们在创建 WriteStream 类的时候将这些参数初始化到了 this 上。创建可写流后需要使用 write 方法进行写入，写入时第一次会真的通过内存写入到文件中，而再次写入则会将内容写到缓存中，注意这里的 “内存” 和 “缓存”，内存是写入文件是的系统内存，缓存是我们自己创建的数组，第一次写入以后要写入文件的 Buffer 都会先存入这个数组中，这个数组名为 buffer，挂载在实例上，实例上同时挂载了 len 属性用来存储当前缓存中 Buffer 总共的字节数（长度）。我们在可读流上挂载了是否正在写入的状态 writing 属性，只要缓存区中存在未写入的 Buffer，writing 的状态就是正在写入，当写入的字节数大于了 highWaterMark 需要触发 drain 事件，所以又挂载了是否需要触发 drain 事件的标识 needDrain 属性。当从文件的 start 值对应的位置开始写入，下一次写入文件的位置会发生变化，所以在 this 上挂载了 pos 属性，用于存储下次写入文件的位置。在 Node.js 流的源码中缓存是用链表实现的，通过指针来操作缓存中的 Buffer，而我们为了简化逻辑就使用数组来作为缓存，虽然性能相对链表要差，但更容易理解整个可读流的写入机制。打开、关闭文件 open 和 detroy在 WriteStream 中，写入文件之前也应该打开文件，在打开文件过程中出错时也应该触发 error 事件并关闭文件，打开和关闭文件的方法 open 和 detroy 与 ReadStream 的 open 和 detroy 方法的逻辑如出一辙，所以这里为了方便查看直接贴在下面。/* open 方法 */ // 打开文件 WriteStream.prototype.open = function () { fs.open(this.path, this.flags, this.mode, (err, fd) =&gt; { if (err) { this.emit(&#39;error&#39;, err); // 如果文件打开了出错，并配置自动关闭，则关掉文件 if (this.autoClose) { // 关闭文件（触发 close 事件） this.destroy(); // 不再继续执行 return; } } // 存储文件描述符 this.fd = fd; // 成功打开文件后触发 open 事件 this.emit(&#39;open&#39;); }); } /* detroy 方法 */ // 关闭文件 WriteStream.prototype.detroy = function () { // 判断是否存在文件描述符 if (typeof this.fd === &#39;number&#39;) { // 存在则关闭文件并触发 close 事件 fs.close(fd, () =&gt; { this.emit(&#39;close&#39;); }); return; } // 不存在文件描述符直接触发 close 事件 this.emit(&#39;close&#39;); } 写入文件方法 write 的实现write 方法默认支持传入三个参数：chunk：写入文件的内容；encoding：写入文件的编码格式；callback：写入成功后执行的回调。/* write 方法 */ // 写入文件的方法，只要逻辑为写入前的处理 WriteStream.prototype.write = function (chunk, encoding = this.encoding, callback) { // 为了方便操作将要写入的数据转换成 Buffer chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk); // 维护缓存的长度 this.len += chunk.lenth; // 维护是否触发 drain 事件的标识 this.needDrain = this.highWaterMark &lt;= this.len; // 如果正在写入 if (this.writing) { this.buffer.push({ chunk, encoding, callback }); } else { // 更改标识为正在写入，再次写入的时候走缓存 this.writing = true; // 如果已经写入清空缓存区的内容 this._write(chunk, encoding, () =&gt; this.clearBuffer()); } return !this.needDrain; } 与可写流的 read 一样，我们在使用 write 方法将数据写入文件时，也是操作 Buffer，在 write 方法中，首先将接收到的要写入的数据转换成了 Buffer，因为是多次写入，要知道缓存中 Buffer 字节数的总长度，所以维护了 len 变量。我们的 WriteStream 构造函数中，this 挂载了 needDrain 属性，在使用 fs.createWriteStream 创建的可读流时，是写入的字节长度超过 highWaterMark 才会触发 drain 事件，而 needDrain 与 write 的返回值正好相反，所以我们用 needDrain 取反来作为 write 方法的返回值。在写入的逻辑中第一次是直接通过内存写入到文件，但是再次写入就需要将数据存入缓存，将数据写入到文件中写入状态 writing 默认为 false，通过缓存再写入证明应该正在写入中，所以在第一次写入后应更改 writing 的状态为 true，写入缓存其实就是把转换的 Buffer、编码以及写入成功后要执行的回调挂在一个对象上存入缓存的数组 buffer 中。我们把真正写入文件的逻辑抽取成一个单独的方法 _write，并传入 chunk（要写入的内容，已经处理成 Buffer）、encoding（字符编码）、回调函数，在回调函数中执行了原型方法 clearBuffer，接下来就来实现 _write 和 clearBuffer。注意：方法使用 _ 开头代表私有方法，轻易不要在外部调用或修改，这是一个开发者之间约定俗成的不成文规定。真正的文件操作 _write对比可读流（流动模式）的 read 方法，在调用 _write 方法写入时，是在创建可写流之后的同步代码中执行的，与可读流在 newListener 中同步执行 read 的情况类似，所以为了保证 _write 的逻辑是在 open 方法打开文件以后执行，使用了与 read 相同的处理方式。/* _write 方法 */ // 真正的写入文件操作的方法 WriteStream.prototype._write = function (chunk, encoding, callback) { // 由于 open 异步执行，write 是在创建实例时同步执行，write 执行可能早于 open，此时不存在文件描述符 if (typeof this.fd !== &#39;number&#39;) { // 因为 open 用 emit 触发了 open 事件，所以在这是重新执行 write return this.once(&#39;open&#39;, () =&gt; this._write(chunk, encoding, callback)); } // 读取文件 fs.write(this.fd, chunk, 0, chunk.length, this.pos, (err, bytesWritten) =&gt; { // 维护下次写入的位置和缓存区 Buffer 的总字节数 this.pos += bytesWritten; this.len -= bytesWritten; callback(); }); } 在打开文件并写入的时候需要维护两个变量，下次写入的位置 pos 和当前缓存区内 Buffer 所占总字节数 len，本次写入了多少个字节，下次写入需要在写入位置的基础上加多少个字节，而 len 恰恰相反，本次写入了多少个字节，缓存区中的总长度应该对应的减少多少个字节。在维护两个变量的值以后调用 callback，其实 callback 内执行的是 clearBuffer 方法，就如方法名，译为 “清空缓存”，其实就是一次一次的将数据写入文件并从缓存中移除，很明显需要递归调用 _write 方法，我们将这个递归的逻辑统一放在 clearBuffer 方法中实现。清空缓存操作 clearBuffer/* clearBuffer 方法 */ // 清空缓存方法 WriteStream.prototype.clearBuffer = function () { // 先写入的在数组前面，从前面取出缓存中的 Buffer const buf = this.buffer.shift(); // 如果存在 buf，证明缓存还有 Buffer 需要写入 if (buf) { // 递归 _write 按照编码将数据写入文件 this._write(buf.chunk, buf.encoding, () =&gt; this.clearBuffer); } else { // 如果没有 buf，说明缓存内的内容已经完全写入文件并清空，需要触发 drain 事件 this.emit(&#39;drain&#39;); // 更改正在写入状态 this.writing = false; // 更改是否需要触发 drain 事件状态 this.needDrain = false; } } clearBuffer 方法中获取了缓存区数组的最前面的 Buffer（最前面的是先写入缓存的，也应该先取出来写入文件），存在这个 Buffer 时，递归 _write 方法按照编码将数据写入文件，如果不存在说明缓存区已经清空了，代表内容完全写入文件中，所以触发 drain 事件，最后更改了 writing 和 needDrain 的状态。更正 writing 是为了 WriteStream 创建的可读流在下次调用 write 方法时默认第一次真正写入文件，而更正 needDrain 的状态是在缓存区要清空的最后一个 Buffer 的长度小于了 highWaterMark 时，保证 write 方法的返回值是正确的。第一次通过内存真正写入文件，其他的都写入缓存，再一个一个的将缓存中存储的 Buffer 写入并从缓存清空，之所以这样设计是为了把写入的内容排成一个队列，假如有 3 个人同时操作一个文件写入内容，只有第一个人是真的写入，其他的人都写在缓存中，再按照写入缓存的顺序依次写入文件，避免冲突和写入顺序出错。验证可写流 WriteStream接下来我们使用自己实现的 WriteStream 类来创建可写流，并按照 fs.createWriteStream 的用法进行使用并验证。/* 验证 WriteStream */ // 向 2.txt 文件中写入 012345 const fs = require(&#39;fs&#39;); const WriteStream = require(&#39;./WriteStream&#39;); // 创建可写流 const ws = new WriteStream(&#39;2.txt&#39;, { highWaterMark: 3 }); let i = 0; function write() { let flag = true; while (i &lt;= 6 &amp;&amp; flag) { i++; flag = ws.write(i + &#39;&#39;, &#39;utf8&#39;); } } ws.on(&#39;drain&#39;, function () { console.log(&#39;写入成功&#39;); write(); }); write(); // true // true // false // 写入成功 // true // true // false // 写入成功 可以使用 fs.createWriteStream 和 WriteStream 类分别执行上面的代码，对比结果，看看是否相同。可读流和可写流的桥梁 pipe可写流和可读流一般是通过 pipe 配合来使用的，pipe 方法是可读流 ReadStream 的原型方法，参数为一个可写流。/* pipe 方法 */ // 连接可读流和可写流的方法 pipe ReadStream.prototype.pipe = function (dest) { // 开始读取 this.on(&#39;data&#39;, data =&gt; { // 如果超出可写流的 highWaterMark，暂停读取 const flag = dest.write(data); if (!flag) this.pause(); }); dest.on(&#39;drain&#39;, () =&gt; { // 当可写流清空内存时恢复读取 this.resume(); }); this.on(&#39;end&#39;, () =&gt; { // 在读取完毕后关闭文件 this.destroy(); }); } pipe 方法其实就是通过可读流的 data 事件触发流动状态，并用可写流接收读出的数据进行写入，当写入数据超出 highWaterMark，则暂停可读流的读取，直到可写流的缓存被清空并把内容写进文件后，恢复可读流的读取，当读取结束后关闭文件。下面我们实现一个将 1.txt 的内容拷贝 2.txt 中的例子。/* 验证 pipe */ // pipe 的使用 const fs = require(&#39;fs&#39;); // 引入自己的 ReadStream 类和 WriteStream 类 const ReadStream = rquire(&#39;./ReadStream&#39;); const WriteStream = rquire(&#39;./WriteStream&#39;); // 创建可读流和可写流 const rs = new ReadStream(&#39;1.txt&#39;, { highWaterMark: 3 }); const ws = new WriteStream(&#39;2.txt&#39;, { highWaterMark: 2 }); // 使用 pipe 实现文件内容复制 rs.pipe(ws); 总结在 Node.js 源码中，可读流和可写流的内容要比本篇内容多很多，本篇是将源码精简，抽出核心逻辑并针对流的使用方式进行实现，主要目的是帮助理解流的原理和使用，争取做到 “知其然知其所以然”，了解了一些流的底层机制再使用也能游刃有余。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Stream","slug":"Stream","permalink":"https://www.overtaking.top/tags/Stream/"}]},{"title":"Node.js —— Stream 的基本使用","date":"2018-07-03T15:10:32.000Z","path":"20180703231032/","text":"流的介绍在 Node.js 中，我们对文件的操作需要依赖核心模块 fs，fs 中有很基本 API 可以帮助我们读写占用内存较小的文件，如果是大文件或内存不确定也可以通过 open、read、write、close 等方法对文件进行操作，但是这样操作文件每一个步骤都要关心，非常繁琐，fs 中提供了可读流和可写流，让我们通过流来操作文件，方便我们对文件的读取和写入。可读流createReadStream 创建可读流createReadStream 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 options 选项，其中有 8 个参数：flags：标识位，默认为 r；encoding：字符编码，默认为 null；fd：文件描述符，默认为 null；mode：权限位，默认为 0o666；autoClose：是否自动关闭文件，默认为 true；start：读取文件的起始位置；end：读取文件的（包含）结束位置；highWaterMark：最大读取文件的字节数，默认 64 * 1024。createReadStream 的返回值为 fs.ReadStream 对象，读取文件的数据在不指定 encoding 时，默认为 Buffer。// 创建可读流 const fs = require(&#39;fs&#39;); // 创建可读流，读取 1.txt 文件 const rs = fs.creatReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); 在创建可读流后默认是不会读取文件内容的，读取文件时，可读流有两种状态，暂停状态和流动状态。注意：本篇的可写流为流动模式，流动模式中有暂停状态和流动状态，而不是暂停模式，暂停模式是另一种可读流 readable。流动状态流动状态的意思是，一旦开始读取文件，会按照 highWaterMark 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 data 事件触发。假如现在 1.txt 文件中的内容为 0~9 十个数字，我们现在创建可读流并用流动状态读取。// 流动状态 const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); // 读取文件 rs.on(&#39;data&#39;, data =&gt; { console.log(data); }); // 监听读取结束 rs.on(&#39;end&#39;, () =&gt; { console.log(&#39;读完了&#39;); }); // &lt;Buffer 30 31&gt; // &lt;Buffer 32 33&gt; // 读完了 在上面代码中，返回的 rs 对象监听了两个事件：data：每次读取 highWaterMark 个字节，触发一次 data 事件，直到读取完成，回调的参数为每次读取的 Buffer；end：当读取完成时触发并执行回调函数。我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 data 事件触发时进行拼接，以前我们可能使用下面这种方式。/* 错误拼接数据的方式 */ const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); let str = &#39;&#39;; rs.on(&#39;data&#39;, data =&gt; { str += data; }); rs.on(&#39;end&#39;, () =&gt; { console.log(str); }); // 0123 在上面代码中如果读取的文件内容是中文，每次读取的 highWaterMark 为两个字节，不能组成一个完整的汉字，在每次读取时进行 += 操作会默认调用 toString 方法，这样会导致最后读取的结果是乱码。在以后通过流操作文件时，大部分情况下都是在操作 Buffer，所以应该用下面这种方式来获取最后读取到的结果。/* 正确拼接数据的方式 */ const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); // 存储每次读取回来的 Buffer const bufArr = []; rs.on(&#39;data&#39;, data =&gt; { bufArr.push(data); }); rs.on(&#39;end&#39;, () =&gt; { console.log(Buffer.concat(bufArr).toString()); }); // 0123 暂停状态在流动状态中，一旦开始读取文件，会不断的触发 data 事件，直到读完，暂停状态是我们每读取一次就直接暂停，不再继续读取，即不再触发 data 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。类似于开关水龙头的动作，也就是暂停和恢复读取的动作，在可读流返回的 rs 对象上有两个对应的方法，pause 和 resume。在下面的场景中我们把创建可读流的结尾位置更改成 9，在每次读两个字节并暂停一秒后恢复读取，直到读完 0~9 十个数字。/* 暂停状态 */ const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 9, highWaterMark: 2 }); const bufArr = []; rs.on(&#39;data&#39;, data =&gt; { bufArr.push(data); rs.pause(); // 暂停读取 console.log(&#39;暂停&#39;, new Date()); setTimeout(() =&gt; { rs.resume(); // 恢复读取 }, 1000) }); rs.on(&#39;end&#39;, () =&gt; { console.log(Buffer.concat(bufArr).toString()); }); // 暂停 2018-07-03T23:52:52.436Z // 暂停 2018-07-03T23:52:53.439Z // 暂停 2018-07-03T23:52:54.440Z // 暂停 2018-07-03T23:52:55.442Z // 暂停 2018-07-03T23:52:56.443Z // 0123456789 错误监听通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 rs 对象可以通过 error 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 err，即错误对象。/* 错误监听 */ const fs = require(&#39;fs&#39;); // 读取一个不存在的文件 const rs = fs.createReadStream(&#39;xxx.js&#39;, { highWarterMark: 2 }); const bufArr = []; rs.on(&#39;data&#39;, data =&gt; { bufArr.push(data); }); rs.on(&#39;err&#39;, err =&gt; { console.log(err); }); rs.on(&#39;end&#39;, () =&gt; { console.log(Buffer.concat(bufArr).toString()); }); // { Error: ENOENT: no such file or directory, open &#39;......xxx.js&#39; ......} 打开和关闭文件的监听流的适用性非常广，不只是文件读写，也可以用在 http 中数据的请求和响应上，但是在针对文件读取返回的 rs 上有两个专有的事件用来监听文件的打开与关闭。open 事件用来监听文件的打开，回调函数在打开文件后执行，close 事件用来监听文件的关闭，如果创建的可读流的 autoClose 为 true，在自动关闭文件时触发，回调函数在关闭文件后执行。/* 打开和关闭可读流的监听 */ const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); rs.on(&#39;open&#39;, () =&gt; { console.log(&#39;open&#39;); }); rs.on(&#39;close&#39;, () =&gt; { console.log(&#39;close&#39;); }); // open 在上面代码我们看出只要创建了可读流就会打开文件触发 open 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 close 事件。/* 暂停状态 */ const fs = require(&#39;fs&#39;); const rs = fs.createReadStream(&#39;1.txt&#39;, { start: 0, end: 3, highWaterMark: 2 }); rs.on(&#39;open&#39;, () =&gt; { console.log(&#39;open&#39;); }); rs.on(&#39;data&#39;, data =&gt; { console.log(data); }); rs.on(&#39;end&#39;, () =&gt; { console.log(&#39;end&#39;); }); rs.on(&#39;close&#39;, () =&gt; { console.log(&#39;close&#39;); }); // open // &lt;Buffer 30 31&gt; // &lt;Buffer 32 33&gt; // end // close 从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 close 事件，end 事件的触发要早于 close。可写流createWriteStream 创建可写流createWriteStream 方法有两个参数，第一个参数是读取文件的路径，第二个参数为 options 选项，其中有 7 个参数：flags：标识位，默认为 w；encoding：字符编码，默认为 utf8；fd：文件描述符，默认为 null；mode：权限位，默认为 0o666；autoClose：是否自动关闭文件，默认为 true；start：写入文件的起始位置；highWaterMark：一个对比写入字节数的标识，默认 16 * 1024。createWriteStream 返回值为 fs.WriteStream 对象，第一次写入时会真的写入文件中，继续写入，会写入到缓存中。/* 创建可写流 */ const fs = require(&#39;fs&#39;); // 创建可写流，写入 2.txt 文件 const ws = fs.createWriteStream(&#39;2.txt&#39;, { start: 0, highWaterMark: 3 }); 可写流的 write 方法在可写流中将内容写入文件需要使用 ws 的 write 方法，参数为写入的内容，返回值是一个布尔值，代表 highWaterMark 的值是否足够当前的写入，如果足够，返回 true，否则返回 false，换种说法就是写入内容的长度是否超出了 highWaterMark，超出返回 false。/* write 方法写入 */ const fs = require(&#39;fs&#39;); const ws = fs.createWriteSteam(&#39;2.txt&#39;, { start: 0, highWaterMark: 3 }); const flag1 = ws.write(&#39;1&#39;); console.log(flag1); const flag2 = ws.write(&#39;2&#39;); console.log(flag2); const flag3 = ws.write(&#39;3&#39;); console.log(flag3); // true // true // false 写入不存在的文件时会自动创建文件，如果 start 的值不是 0，在写入不存在的文件时默认找不到写入的位置。可写流的 drain 事件drain 意为 “吸干”，当前写入的内容已经大于等于了 highWaterMark，会触发 drain 事件，当内容全部从缓存写入文件后，会执行回调函数。/* drain 事件 */ const fs = require(&#39;fs&#39;); const ws = fs.createWriteStream(&#39;2.txt&#39;, { start: 0, highWaterMark: 3 }); const flag1 = ws.write(&#39;1&#39;); console.log(flag1); const flag2 = ws.write(&#39;2&#39;); console.log(flag2); const flag3 = ws.write(&#39;3&#39;); console.log(flag3); ws.on(&#39;drain&#39;, () =&gt; { console.log(&#39;吸干&#39;); }); // true // true // false // 吸干 可写流的 end 方法end 方法传入的参数为最后写入的内容，end 会将缓存未写入的内容清空写入文件，并关闭文件。/* end 方法 */ const fs = require(&#39;fs&#39;); const ws = fs.createWriteStream(&#39;2.txt&#39;, { start: 0, highWaterMark: 3 }); const flag1 = ws.write(&#39;1&#39;); console.log(flag1); const flag2 = ws.write(&#39;2&#39;); console.log(flag2); const flag3 = ws.write(&#39;3&#39;); console.log(flag3); ws.on(&#39;drain&#39;, () =&gt; { console.log(&#39;吸干&#39;); }); ws.end(&#39;写完了&#39;); // true // true // false 在调用 end 方法后，即使再次写入的值超出了 highWaterMark 也不会再触发 drain 事件了，此时打开 2.txt 后发现文件中的内容为 ‘123写完了’。/* 常见报错 */ const fs = require(&#39;fs&#39;); const ws = fs.createWriteStream(&#39;2.txt&#39;, { start: 0, highWaterMark: 3 }); ws.write(&#39;1&#39;); ws.end(&#39;写完了&#39;); ws.write(&#39;2&#39;); // Error [ERR_STREAM_WRITE_AFTER_END]: write after end... 在调用 end 方法后，不可以再调用 write 方法写入，否则会报一个很常见的错误 write after end，文件原有内容会被清空，而且不会被写入新内容。可写流与可读流混合使用可写流和可读流一般配合来使用，读来的内容如果超出了可写流的 highWaterMark，则调用可读流的 pause 暂停读取，等待内存中的内容写入文件，未写入的内容小于 highWaterMark 时，调用可写流的 resume 恢复读取，创建可写流返回值 rs 上的 pipe 方法是专门用来连接可读流和可写流的，可以将一个文件读来的内容通过流写到另一个文件中。/* pipe 方法使用 */ const fs = require(&#39;fs&#39;); // 创建可读流和可写流 const rs = fs.createReadStream(&#39;1.txt&#39;, { highWaterMark: 3 }); const ws = fs.createWriteStream(&#39;2.txt&#39;, { highWaterMark: 2 }); // 将 1.txt 的内容通过流写入 2.txt 中 rs.pipe(ws); 通过上面的这种类似于管道的方式，将一个流从一个文件输送到了另一个文件中，而且会根据读流和写流的 highWaterMark 自由的控制写入的 “节奏”，不用担心内存的消耗。总结这篇是关于读流和写流的基本用法，在平时的开发当中，大多数 API 都用的不多，pipe 用的较多，无论是在文件的读写还是请求的响应，其他的 API 虽然用的少，但是确实很多底层的实现，作为一个合格的程序员一定要有所了解。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Stream","slug":"Stream","permalink":"https://www.overtaking.top/tags/Stream/"}]},{"title":"Node.js 树结构遍历 —— 深度优先和广度优先","date":"2018-07-02T04:29:23.000Z","path":"20180702122923/","text":"树的基本概念树（Tree）是 n 个结点的有限集，n 为 0 时，称为空树，在任意一棵非空树中有且仅有一个特定的被称为根（Root）的结点，当 n 大于 1 时，其余结点可分为 m 个互不相交的有限集 T1、T2、......、Tm，其中每一个集合本身又是一棵树，并且称为 SubTree，即根的子树。需要强调的是，n&gt;0 时根结点是唯一的，不可能存在多个根结点，m&gt;0 时，子树的个数没有限制，但它们一定是互不相交的。从根开始定义起，根为第一层，根的第一级子节点为第二层，若某结点在第 l 层，则其子树就在第 l+1 层，其双亲在同一层的结点互为 “堂兄弟”，树中结点的最大层级数称为树的深度（Depth）或高度。树结构的组成在对树结构进行遍历时，按顺序可分为先序、中序和后续，按遍历的方式可分为深度优先和广度优先，我们这篇文章就通过使用先序深度优先和先序广度优先来实现递归删除目录结构，体会对树结构遍历的应用，文章中会大量用到 Node.js 核心模块 fs，可以通过 Node.js 文件操作 —— fs 基本使用 来了解文中用到的 fs 模块的方法及用法。先序深度优先实现递归删除文件目录深度优先的意思就是在遍历当前文件目录的时候，如果子文件夹内还有内容，就继续遍历子文件夹，直到遍历到最深层不再有文件夹，则删除其中的文件，再删除这个文件夹，然后继续遍历它的 “兄弟”，直到内层文件目录都被删除，再删除上一级，最后根文件夹为空，删除根文件夹。先序深度优先同步的实现我们要实现的函数参数为要删除的根文件夹的路径，执行函数后会删除这个根文件夹。/* 深度优先 —— 同步 */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 先序深度优先同步删除文件夹 function rmDirDepSync(p) { // 获取根文件夹的 Stats 对象 const statObj = fs.statSync(p); // 检查该文件夹的是否是文件夹 if (statObj.isDirectory()) { // 查看文件夹内部 let dirs = fs.readdirSync(p); // 将内部的文件和文件夹拼接成正确的路径 dirs = dirs.map(dir =&gt; path.join(p, dir)); // 循环递归处理 dirs 内的每一个文件或文件夹 for (let i = 0; i &lt; dirs.length; i++) { rmDirDepSync(dirs[i]); } // 等待都处理完后删除该文件夹 fs.rmdirSync(p); } else { // 若是文件则直接删除 fs.unlinkSync(p); } } // 调用 rmDirDepSync(&#39;a&#39;); 上面代码在调用 rmDirDepSync 时传入 a，先判断 a 是否是文件夹，不是则直接删除文件，是则查看文件目录，使用 map 将根文件路径拼接到每一个成员的名称前，并返回合法的路径集合，循环这个集合并对每一项进行递归，重复执行操作，最终实现删除根文件夹内所有的文件和文件夹，并删除根文件夹。异步回调的实现同步的实现会阻塞代码的执行，每次执行一个文件操作，必须在执行完毕之后才能执行下一行代码，相对于同步，异步的方式性能会更好一些，我们下面使用异步回调的方式来实现递归删除文件目录的函数。函数有两个参数，第一个参数同样为根文件夹的路径，第二个参数为一个回调函数，在文件目录被全部删除后执行。/* 深度优先 —— 异步回调 */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 先序深度优先异步（回调函数）删除文件夹 function rmDirDepCb(p, callback) { // 获取传入路径的 Stats 对象 fs.stat(p, (err, statObj) =&gt; { // 判断路径下是否为文件夹 if (statObj.isDirectory()) { // 是文件夹则查看内部成员 fs.readdir(p, (err, dirs) =&gt; { // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // next 方法用来检查集合内每一个路径 function next(index) { // 如果所有成员检查并删除完成则删除上一级目录 if (index === dirs.length) return fs.rmdir(p, callback); // 对路径下每一个文件或文件夹执行递归，回调为递归 next 检查路径集合中的下一项 rmDirDepCb(dirs[index], () =&gt; next(index + 1)); } next(0); }); } else { // 是文件则直接删除 fs.unlink(p, callback); } }); } // 调用 rmDirDepCb(&#39;a&#39;, () =&gt; { console.log(&#39;删除完成&#39;); }); // 删除完成 上面方法也遵循深度优先，与同步相比较主要思路是相同的，异步回调的实现更为抽象，并不是通过循环去处理的文件夹下的每个成员的路径，而是通过调用 next 函数和在成功删除文件时递归执行 next 函数并维护 index 变量实现的。异步 Promise 的实现在异步回调函数的实现方式中，回调嵌套层级非常多，这在对代码的可读性和维护性上都造成困扰，在 ES6 规范中，Promise 的出现就是用来解决 “回调地狱” 的问题，所以我们也使用 Promise 来实现。函数的参数为要删除的根文件夹的路径，这次之所以不需要传 callback 参数是因为 callback 中的逻辑可以在调用函数之后链式调用 then 方法来执行。/* 深度优先 —— 异步 Promise */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 先序深度优先异步（Promise）删除文件夹 function rmDirDepPromise(p) { return new Promise((resolve, reject) =&gt; { // 获取传入路径的 Stats 对象 fs.stat(p, (err, statObj) =&gt; { // 判断路径下是否为文件夹 if (statObj.isDirectory()) { // 是文件夹则查看内部成员 fs.readdir(p, (err, dirs) =&gt; { // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // 将所有的路径都转换成 Promise dirs = dirs.map(dir =&gt; rmDirDepPromise(dir)); // 数组中路径下所有的 Promise 都执行了 resolve 时，删除上级目录 Promise.all(dirs).then(() =&gt; fs.rmdir(p, resolve)); }); } else { // 是文件则直接删除 fs.unlink(p, resolve); } }); }); } // 调用 rmDirDepPromise(&#39;a&#39;).then(() =&gt; { console.log(&#39;删除完成&#39;); }); // 删除完成 与异步回调函数的方式不同的是在调用 rmDirDepPromise 时直接返回了一个 Promise 实例，而在删除文件成功或在删除文件夹成功时直接调用了 resolve，在一个子文件夹下直接将这些成员通过递归 rmDirDepPromise 都转换为 Promise 实例，则可以用 Promise.all 来监听这些成员删除的状态，如果都成功再调用 Promise.all 的 then 直接删除上一级目录。异步 async/await 的实现Promise 版本相对于异步回调版本从代码的可读性上有所提升，但是实现逻辑还是比较抽象，没有同步代码的可读性好，如果想要 “鱼” 和 “熊掌” 兼得，既要性能又要可读性，可以使用 ES7 标准中的 async/await 来实现，由于 async 函数的返回值为一个 Promise 实例，所以参数只需要传被删除的根文件夹的路径即可。/* 深度优先 —— 异步 async/await */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const { promisify } = require(&#39;util&#39;); // 将用到 fs 模块的异步方法转换成 Promise const stat = promisify(fs.stat); const readdir = promisify(fs.readdir); const rmdir = promisify(fs.rmdir); const unlink = promisify(fs.unlink); // 先序深度优先异步（async/await）删除文件夹 async function rmDirDepAsync(p) { // 获取传入路径的 Stats 对象 const statObj = await stat(p); // 判断路径下是否为文件夹 if (statObj.isDirectory()) { // 是文件夹则查看内部成员 let dirs = await readdir(p); // 将文件夹成员拼接成合法路径的集合 dirs = dirs.map(dir =&gt; path.join(p, dir)); // 循环集合递归 rmDirDepAsync 处理所有的成员 dirs = dirs.map(dir =&gt; rmDirDepAsync(dir)); // 当所有的成员都成功 await Promise.all(dirs); // 删除该文件夹 await rmdir(p); } else { // 是文件则直接删除 await unlink(p); } } // 调用 rmDirDepAsync(&#39;a&#39;).then(() =&gt; { console.log(&#39;删除完成&#39;); }); // 删除完成 在递归 rmDirDepAsync 时，所有子文件夹内部的成员必须都删除成功，才删除这个子文件夹，在使用 unlink 删除文件时，必须等待文件删除结束才能让 Promise 执行完成，所以也需要 await，所有递归之前的异步 Promise 都需要在递归内部的异步 Promise 执行完成后才能执行完成，所以涉及到异步的操作都使用了 await 进行等待。先序广度优先实现递归删除文件目录广度优先的意思是遍历文件夹目录的时候，先遍历根文件夹，将内部的成员路径一个一个的存入数组中，再继续遍历下一层，再将下一层的路径都存入数组中，直到遍历到最后一层，此时数组中的路径顺序为第一层的路径，第二层的路径，直到最后一层的路径，由于要删除的文件夹必须为空，所以删除时，倒序遍历这个数组取出路径进行文件目录的删除。先序广度优先在广度优先的实现方式中同样按照同步、异步回调、和 async/await 这几种方式分别来实现，因为在拼接存储路径数组的时候没有异步操作，所以单纯使用 Promise 没有太大的意义。同步的实现参数为根文件夹的路径，内部的 fs 方法同样都使用同步方法。/* 广度优先 —— 同步 */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 先序广度优先同步删除文件夹 function rmDirBreSync(p) { let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 let index = 0; // 用于存储取出数组成员的索引 let current; // 用于存储取出的成员，即路径 // 如果数组中能找到当前指定索引的项，则执行循环体，并将该项存入 current while ((current = arr[index++])) { // 获取当前从数组中取出的路径的 Stats 对象 const statObj = fs.statSync(current); // 如果是文件夹，则读取内容 if (statObj.isDirectory()) { let dirs = fs.readdirSync(current); // 将获取到的成员路径处理为合法路径 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中 pathArr = [...pathArr, ...dirs]; } } // 逆序循环 pathArr for (let i = pathArr.length - 1; i &gt;= 0; i--) { const pathItem = pathArr[i]; // 当前循环项 const statObj = fs.statSync(pathItem); // 获取 Stats 对象 // 如果是文件夹则删除文件夹，是文件则删除文件 if (statObj.isDirectory()) { fs.rmdirSync(pathItem); } else { fs.unlinkSync(pathItem); } } } // 调用 rmDirBreSync(&#39;a&#39;); 通过 while 循环广度遍历，将所有的路径按层级顺序存入 pathArr 数组中，在通过 for 反向遍历数组，对遍历到的路径进行判断并调用对应的删除方法，pathArr 后面的项存储的都是最后一层的路径，从后向前路径的层级逐渐减小，所以反向遍历不会导致删除非空文件夹的操作。异步回调的实现函数有两个参数，第一个参数为根文件夹的路径，第二个为 callback，在删除结束后执行。/* 广度优先 —— 异步回调 */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 先序广度优先异步（回调函数）删除文件夹 function rmDirBreCb(p, callback) { let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 function next(index) { // 如果已经都处理完，则调用删除的函数 if (index === pathArr.length) return remove(); // 取出数组中的文件路径 const current = arr[index]; // 获取取出路径的 Stats 对象 fs.stat(currrent, (err, statObj) =&gt; { // 判断是否是文件夹 if (statObj.isDirectory()) { // 是文件夹读取内部成员 fs.readdir(current, (err, dirs) =&gt; { // 将数组中成员名称修改为合法路径 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 将原数组的成员路径和处理后的成员路径重新解构在 pathArr 中 pathArr = [...pathArr, ...dirs]; // 递归取出数组的下一项进行检测 next(index + 1); }); } else { // 如果是文件则直接递归获取数组的下一项进行检测 next(index + 1); } }); } next(0); // 删除的函数 function remove() { function next(index) { // 如果全部删除完成，执行回调函数 if (index &lt; 0) return callback(); // 获取数组的最后一项 const current = pathArr[index]; // 获取该路径的 Stats 对象 fs.stat(current, (err, statObj) =&gt; { // 不管是文件还是文件夹都直接删除 if (statObj.isDirectory()) { fs.rmdir(current, () =&gt; next(index - 1)); } else { fs.unlink(current, () =&gt; next(index - 1)); } }); } next(arr.length - 1); } } // 调用 rmDirBreCb(&#39;a&#39;, () =&gt; { console.log(&#39;删除完成&#39;); }); // 删除完成 在调用 rmDirBreCb 时主要执行两个步骤，第一个步骤是构造存储路径的数组，第二个步骤是逆序删除数组中对应的文件或文件夹，为了保证性能，两个过程都是通过递归 next 函数并维护存储索引的变量来实现的，而非循环。在构造数组的过程中如果构造数组完成后，调用的删除函数 remove，在 remove 中在删除完成后，调用的 callback，实现思路是相同的，都是在递归时设置判断条件，如果构造数组或删除结束以后不继续递归，而是直接执行对应的函数并跳出。异步 async/await 的实现参数为删除根文件夹的路径，因为 async 最后返回的是 Promise 实例，所以不需要 callback，删除后的逻辑可以通过调用返回 Promise 实例的 then 来实现。/* 广度优先 —— 异步 async/await */ // 引入依赖模块 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const { promisify } = require(&#39;util&#39;); // 将用到 fs 模块的异步方法转换成 Promise const stat = promisify(fs.stat); const readdir = promisify(fs.readdir); const rmdir = promisify(fs.rmdir); const unlink = promisify(fs.unlink); // 先序广度优先异步（async/await）删除文件夹 async function rmDirBreAsync(p) { let pathArr = [p]; // 创建存储路径的数组，默认存入根路径 let index = 0; // 去数组中取出路径的索引 let delCurrent; // 删除的路径 // 如果存在该项则继续循环 while (index !== pathArr.length) { // 取出当前的路径 const current = pathArr[index]; // 获取 Stats 对象 const statObj = await stat(current); // 判断是否是文件夹 if (statObj.isDirectory()) { // 查看文件夹成员 let dirs = await readdir(current); // 将路径集合更改为合法路径集合 dirs = dirs.map(dir =&gt; path.join(current, dir)); // 合并存储路径的数组 pathArr = [...pathArr, ...dirs]; } index++; } // 循环取出路径 while ((delCurrent = pathArr.pop())) { // 获取 Stats 对象 const statObj = await stat(delCurrent); // 不管是文件还是文件夹都直接删除 if (statObj.isDirectory()) { await rmdir(delCurrent); } else { await unlink(delCurrent); } } } // 调用 rmDirBreAsync(&#39;a&#39;).then(() =&gt; { console.log(&#39;删除完成&#39;); }); // 删除完成 上面的写法都是使用同步的写法，但对文件的操作都是异步的，并使用 await 进行等待，在创建路径集合的数组和倒序删除的过程都是通过 while 循环实现的。总结深度优先和广度优先的两种遍历方式应该是考虑具体场景选择最适合的方式使用，上面这么多实现递归删除文件目录的方法中，重点在于体会深度遍历和广度遍历的不同，其实在类似于递归删除文件目录的这种功能使用深度优先更适合一些。","tags":[{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"https://www.overtaking.top/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://www.overtaking.top/tags/ES7/"},{"name":"async/await","slug":"async-await","permalink":"https://www.overtaking.top/tags/async-await/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.overtaking.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"fs","slug":"fs","permalink":"https://www.overtaking.top/tags/fs/"}]},{"title":"Node.js 文件操作 —— fs 基本使用","date":"2018-06-30T09:26:01.000Z","path":"20180630172601/","text":"fs 概述在 Node.js 中，所有与文件操作都是通过 fs 核心模块来实现的，包括文件目录的创建、删除、查询以及文件的读取和写入，在 fs 模块中，所有的方法都分为同步和异步两种实现，具有 sync 后缀的方法为同步方法，不具有 sync 后缀的方法为异步方法，在了解文件操作的方法之前有一些关于系统和文件的前置知识需要先明确，如文件的权限位 mode、标识位 flag、文件描述符 fd 等。权限位 mode因为 fs 模块需要对文件进行操作，会涉及到操作权限的问题，所以需要先清楚文件权限是什么，都有哪些权限。文件权限表：权限分配文件所有者文件所属组其他用户权限项读写执行读写执行读写执行字符表示rwxrwxrwx数字表示421421421在上面表格中，我们可以看出系统中针对三种类型进行权限分配，即文件所有者（自己）、文件所属组（家人）和其他用户（陌生人），文件操作权限又分为三种，读、写和执行，数字表示为八进制数，具备权限的八进制数分别为 4 、2、1，不具备权限为 0。为了更容易理解，我们可以随便在一个目录中打开命令行，使用 Linux 命令 ls -al 来查目录中文件和文件夹的权限位，如果对 Linux 基本命令不熟悉，可以看 Git 命令总结，从零到熟悉 的前一小节。drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core -rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md 在上面的目录信息当中，很容易看出用户名、创建时间和文件名等信息（十位的字符），但最重要的是开头第一项。第一位代表是文件还是文件夹，d 开头代表文件夹，- 开头的代表文件，而后面九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。权限参数 mode 主要针对 Linux 和 Unix 操作系统，Window 的权限默认是可读、可写、不可执行，所以权限位数字表示为 0o666，转换十进制表示为 438。rw—r——r——420400400644标识位 flagNode.js 中，标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，下面用一张表来表示文件操作的标识位和其对应的含义。符号含义r读取文件，如果文件不存在则抛出异常。r+读取并写入文件，如果文件不存在则抛出异常。rs读取并写入文件，指示操作系统绕开本地文件系统缓存。w写入文件，文件不存在会被创建，存在则清空后写入。wx写入文件，排它方式打开。w+读取并写入文件，文件不存在则创建文件，存在则清空后写入。wx+和 w+ 类似，排他方式打开。a追加写入，文件不存在则创建文件。ax与 a 类似，排他方式打开。a+读取并追加写入，不存在则创建。ax+与 a+ 类似，排他方式打开。上面表格就是这些标识位的具体字符和含义，但是 flag 是不经常使用的，不容易被记住，所以总结了一个加速记忆的方：r：读取w：写入s：同步+：增加相反操作x：排他方式r+ 和 w+ 的区别，当文件不存在时，r+ 不会创建文件，而会抛出异常，但 w+ 会创建文件；如果文件存在，r+ 不会自动清空文件，但 w+ 会自动把已有文件的内容清空。文件描述符 fd操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件，Windows 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，Node.js 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。在 Node.js 中，每操作一个文件，文件描述符递增，文件描述符一般从 3 开始，因为前面有 0、1、2 三个比较特殊的描述符被占用了，分别为 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。文件操作的基本方法文件操作中的基本方法都是对文件进行整体操作，即整个文件数据直接放在内存中操作，如读取、写入、拷贝和追加，由于计算机的内存容量有限，对文件操作需要考虑性能，所以这些方法只针对操作占用内存较小的文件。文件读取同步读取方法 readFileSyncreadFileSync 有两个参数：第一个参数为读取文件的路径或文件描述符；第二个参数为 options 对象，默认值为 null，对象属性有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），该参数也可直接传入 encoding；返回值为文件的内容，如果没有 encoding，返回的文件内容为 Buffer，如果有按照传入的编码解析。若现在有一个文件名为 1.txt，内容为 “Hello”，现在使用 readFileSync 读取。/* 同步读取 readFileSync */ const fs = require(&#39;fs&#39;); const buf = fs.readFileSync(&#39;1.txt&#39;); const data = fs.readFileSync(&#39;1.txt&#39;, &#39;utf8&#39;); console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt; console.log(data); // Hello 异步读取方法 readFile异步读取方法 readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。依然读取 1.txt 文件：/* 异步读取 readFile */ const fs = require(&#39;fs&#39;); fs.readFile(&#39;1.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(err); // null console.log(data); // Hello }); 文件写入同步写入方法 writeFileSyncwriteFileSync 有三个参数：第一个参数为写入文件的路径或文件描述符；第二个参数为写入的数据，类型为 String 或 Buffer；第三个参数为 options 对象，默认值为 null，对象属性有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），该参数也可直接传入 encoding。若现在有一个文件名为 2.txt，内容为 “12345”，现在使用 writeFileSync 写入。/* 同步写入 writeFileSync */ const fs = require(&#39;fs&#39;); fs.writeFileSync(&#39;2.txt&#39;, &#39;Hello world&#39;); const data = fs.readFileSync(&#39;2.txt&#39;, &#39;utf8&#39;); console.log(data); // Hello world 异步写入方法 writeFile异步写入方法 writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。/* 异步写入 writeFile */ const fs = require(&#39;fs&#39;); fs.writeFile(&#39;2.txt&#39;, &#39;Hello world&#39;, err =&gt; { if (!err) { fs.readFile(&#39;2.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(data); // Hello world }); } }); 文件追加写入同步追加写入方法 appendFileSyncappendFileSync 有三个参数：第一个参数为写入文件的路径或文件描述符；第二个参数为写入的数据，类型为 String 或 Buffer；第三个参数为 options 对象，默认值为 null，对象属性有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），该参数也可直接传入 encoding。若现在有一个文件名为 3.txt，内容为 “Hello”，现在使用 appendFileSync 追加写入 “ world”。/* 同步追加 appendFileSync */ const fs = require(&#39;fs&#39;); fs.appendFileSync(&#39;3.txt&#39;, &#39; world&#39;); const data = fs.readFileSync(&#39;3.txt&#39;, &#39;utf8&#39;); console.log(data); // Hello world 异步追加写入方法 appendFile异步追加写入方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行。/* 异步追加 appendFile */ const fs = require(&#39;fs&#39;); fs.appendFile(&#39;3.txt&#39;, &#39; world&#39;, err =&gt; { if (!err) { fs.readFile(&#39;3.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(data); // Hello world }); } }); 文件拷贝写入同步拷贝写入方法 copyFileSync同步拷贝写入方法 copyFileSync 有两个参数，第一个参数为被拷贝的源文件路径，第二个参数为拷贝到的目标文件路径，如果目标文件不存在，则会创建并拷贝。现在将上面 3.txt 的内容拷贝到 4.txt 中：/* 同步拷贝 copyFileSync */ const fs = require(&#39;fs&#39;); fs.copyFileSync(&#39;3.txt&#39;, &#39;4.txt&#39;); const data = fs.readFileSync(&#39;4.txt&#39;, &#39;utf8&#39;); console.log(data); // Hello world 异步拷贝写入方法 copyFile异步拷贝写入方法 copyFile 和 copyFileSync 前两个参数相同，最后一个参数为回调函数，在拷贝完成后执行。/* 异步拷贝 copyFile */ const fs = require(&#39;fs&#39;); fs.copyFile(&#39;3.txt&#39;, &#39;4.txt&#39;, () =&gt; { fs.readFile(&#39;4.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(data); // Hello world }); }); 模拟同步、异步拷贝写入文件使用 readFileSync 和 writeFileSync 可以模拟同步拷贝写入文件，使用 readFile 和 writeFile 可以模拟异步写入拷贝文件，代码如下：/* 模拟同步拷贝 */ const fs = require(&#39;fs&#39;); function copy(src, dest) { const data = fs.readFileSync(src); fs.writeFileSync(dest, data); } // 拷贝 copy(&#39;3.txt&#39;, &#39;4.txt&#39;); const data = fs.readFileSync(&#39;4.txt&#39;, &#39;utf8&#39;); console.log(data); // Hello world /* 模拟异步拷贝 */ const fs = require(&#39;fs&#39;); function copy(src, dest, cb) { fs.readFile(src, (err, data) =&gt; { // 没错误就正常写入 if (!err) fs.writeFile(dest, data, cb); }); } // 拷贝 copy(&#39;3.txt&#39;, &#39;4.txt&#39;, () =&gt; { fs.readFile(&#39;4.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(data); // Hello world }); }); 文件操作的高级方法打开文件 openopen 方法有四个参数：path：文件的路径；flag：标识位；mode：权限位，默认 0o666；callback：回调函数，有两个参数 err（错误）和 fd（文件描述符），打开文件后执行。/* 异步打开文件 */ const fs = require(&#39;fs&#39;); fs.open(&#39;4.txt&#39;, &#39;r&#39;, (err, fd) =&gt; { console.log(fd); fs.open(&#39;5.txt&#39;, &#39;r&#39;, (err, fd) =&gt; { console.log(fd); }); }); // 3 // 4 关闭文件 closeclose 方法有两个参数，第一个参数为关闭文件的文件描述符 fd，第二参数为回调函数，回调函数有一个参数 err（错误），关闭文件后执行。/* 异步关闭文件 */ const fs = require(&#39;fs&#39;); fs.open(&#39;4.txt&#39;, &#39;r&#39;, (err, fd) =&gt; { fs.close(fd, err =&gt; { console.log(&#39;关闭成功&#39;); }); }); // 关闭成功 读取文件 readread 方法与 readFile 不同，一般针对于文件太大，无法一次性读取全部内容到缓存中或文件大小未知的情况，都是多次读取到 Buffer 中，想了解 Buffer 可以看 Node.js —— Buffer 解读。read 方法中有六个参数：fd：文件描述符，需要先使用 open 打开文件获取；buffer：要将内容读取到的 Buffer；offset：整数，向 Buffer 写入的初始位置；length：整数，读取文件多少个字节长度；position：整数，读取文件初始位置；callback：回调函数，有三个参数 err（错误），bytesRead（实际读取的字节数），buffer（被写入的缓存区对象），读取执行完成后执行。下面读取一个 6.txt 文件，内容为 “你好”。/* 异步读取文件 */ const fs = require(&#39;fs&#39;); const buf = Buffer.alloc(6); // 打开文件 fs.open(&#39;6.txt&#39;, &#39;r&#39;, (err, fd) =&gt; { // 读取文件 fs.read(fd, buf, 0, 3, 0, (err, bytesRead, buffer) =&gt; { console.log(bytesRead); console.log(buffer); // 继续读取 fs.read(fd, buf, 3, 3, 3, (err, bytesRead, buffer) =&gt; { console.log(bytesRead); console.log(buffer); console.log(buffer.toString()); }); }); }); // 3 // &lt;Buffer e4 bd a0 00 00 00&gt; // 3 // &lt;Buffer e4 bd a0 e5 a5 bd&gt; // 你好 同步磁盘缓存 fsyncfsync 方法有两个参数，第一个参数为文件描述符 fd，第二个参数为回调函数，回调函数中有一个参数 err（错误），在同步磁盘缓存后执行。在使用 write 方法向文件写入数据时，由于不是一次性写入，所以最后一次写入在关闭文件之前应先同步磁盘缓存，fsync 方法将在后面配合 write 一起使用。写入文件 writewrite 方法与 writeFile 不同，是将 Buffer 中的数据写入文件，Buffer 的作用是一个数据中转站，可能数据的源占用内存太大或内存不确定，无法一次性放入内存中写入，所以分段写入，多与 read 方法配合。write 方法中有六个参数：fd：文件描述符，需要先使用 open 打开文件获取；buffer：存储将要写入文件数据的 Buffer；offset：整数，从 Buffer 读取数据的初始位置；length：整数，读取 Buffer 数据的字节数；position：整数，写入文件初始位置；callback：回调函数，有三个参数 err（错误），bytesWritten（实际写入的字节数），buffer（被读取的缓存区对象），写入完成后执行。下面将一个 Buffer 中间的两个字写入文件 6.txt，原内容为 “你好”。/* 选择范围写入 */ const fs = require(&#39;fs&#39;); const buf = Buffer.from(&#39;你还好吗&#39;); // 打开文件 fs.open(&#39;6.txt&#39;, &#39;r+&#39;, (err, fd) =&gt; { // 读取 buf 向文件写入数据 fs.write(fd, buf, 3, 6, 3, (err, bytesWritten, buffer) =&gt; { // 同步磁盘缓存 fs.fsync(fd, err =&gt; { // 关闭文件 fs.close(fd, err =&gt; { console.log(&#39;关闭文件&#39;); }); }); }); }); // 这里为了看是否写入成功简单粗暴的使用 readFile 方法 fs.readFile(&#39;6.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { console.log(data); }); // 你还好 上面代码将 “你还好吗” 中间的 “还好” 从 Buffer 中读取出来写入到 6.txt 的 “你” 字之后，但是最后的 “好” 并没有被保留，说明先清空了文件中 “你” 字之后的内容再写入。针对大文件实现 copy之前我们使用 readFile 和 writeFile 实现了一个 copy 函数，那个 copy 函数是将被拷贝文件的数据一次性读取到内存，一次性从内存写入到目标文件中，主要针对小文件。如果是一个大文件一次性读取到内存再写入非常占用计算机的内存，所以需要多次读取多次写入，也就是一边读一边写，接下来使用上面的这些高级方法针对大文件和文件大小未知的情况实现一个 copy 函数。/* 大文件拷贝 */ // copy 方法 function copy(src, dest, size = 16 * 1024, callback) { // 打开源文件 fs.open(src, &#39;r&#39;, (err, readFd) =&gt; { // 打开目标文件 fs.open(dest, &#39;w&#39;, (err, writeFd) =&gt; { const buf = Buffer.alloc(size); let readed = 0; // 下次读取文件的位置 let writed = 0; // 下次写入文件的位置 function next() { // 读取 fs.read(readFd, buf, 0, size, readed, (err, bytesRead) =&gt; { readed += bytesRead; // 如果读不到内容关闭文件 if (!bytesRead) fs.close(readFd, err =&gt; console.log(&#39;关闭源文件&#39;)); // 写入 fs.write(writeFd, buf, 0, bytesRead, writed, (err, bytesWritten) =&gt; { // 如果没有内容了同步缓存，并关闭文件后执行回调 if (!bytesWritten) { fs.fsync(writeFd, err =&gt; { fs.close(writeFd, err =&gt; return !err &amp;&amp; callback()); }); } writed += bytesWritten; // 继续读取、写入 next(); }); }); }; // 第一次执行读取写入 next() }); }); } 在上面的 copy 方法中，我们手动维护的下次读取位置和下次写入位置，其实参数 readed 和 writed 的位置传入 null，Node.js 会自动帮我们维护这两个值。现在有一个文件 6.txt 内容为 “你好”，一个空文件 7.txt，我们将 6.txt 的内容写入 7.txt 中。/* 验证大文件拷贝 */ const fs = require(&#39;fs&#39;); // buffer 的长度 const BUFFER_SIZE = 3; // 拷贝文件内容并写入 copy(&#39;6.txt&#39;, &#39;7.txt&#39;, BUFFER_SIZE, () =&gt; { fs.readFile(&#39;7.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { // 拷贝完读取 7.txt 的内容 console.log(data); // 你好 }); }); 在 Node.js 中进行文件操作，多次读取和写入时，一般一次读取数据大小为 64k，写入数据大小为 16k。文件目录操作方法下面的这些操作文件目录的方法有一个共同点，就是传入的第一个参数都为文件的路径，如：a/b/c/d，也分为同步和异步两种实现。查看文件目录操作权限同步查看操作权限方法 accessSyncaccessSync 方法传入文件路径，检查传入路径下的目录是否可读可写，当有操作权限的时候没有返回值，没有权限或路径非法时抛出一个 Error 对象，所以使用时多用 try...catch... 进行异常捕获。/* 同步查看操作权限 */ const fs = require(&#39;fs&#39;); try { fs.accessSync(&#39;a/b/c&#39;); console.log(&#39;可读可写&#39;); } catch (err) { console.error(&#39;不可访问&#39;); } 异步查看操作权限方法 accessaccess 方法与第一个参数为文件路径，最后一个参数为一个回调函数，回调函数有一个参数为 err（错误），在权限检测后触发，如果有权限 err 为 null，没有权限或路径非法 err 是一个 Error 对象。/* 异步查看操作权限 */ const fs = require(&#39;fs&#39;); fs.access(&#39;a/b/c&#39;, err =&gt; { if (err) { console.error(&#39;不可访问&#39;); } else { console.log(&#39;可读可写&#39;); } }); 获取文件目录的 Stats 对象文件目录的 Stats 对象存储着关于这个文件或文件夹的一些元信息，如创建时间、最后一次访问的时间、最后一次修改的时间、文章所占字节和判断文件类型的多个方法等等。同步获取 Stats 对象方法 statSyncstatSync 方法参数为文件路径，返回值为当前目录路径的 Stats 对象，现在通过 Stats 对象获取 a 目录下的 b 目录下的 c.txt 文件的字节大小，文件内容为 “你好”。/* 同步获取 Stats 对象 */ const fs = require(&#39;fs&#39;); const statObj = fs.statSync(&#39;a/b/c.txt&#39;); console.log(statObj.size); // 6 异步获取 Stats 对象方法 statstat 方法的第一个参数为文件路径，最后一个参数为回调函数，回调函数有两个参数 err（错误）和 Stats 对象，在读取 Stats 后执行，同样实现上面的读取文件字节数的例子。/* 异步获取 Stats 对象 */ const fs = require(&#39;fs&#39;); fs.stat(&#39;a/b/c.txt&#39;, (err, statObj) =&gt; { console.log(statObj.size); // 6 }); 创建文件目录同步创建目录方法 mkdirSyncmkdirSync 方法参数为文件路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。/* 同步创建文件目录 */ const fs = require(&#39;fs&#39;); // 假设已经有了 a 文件夹和 a 下的 b 文件夹 fs.mkdirSync(&#39;a/b/c&#39;); 异步创建目录方法 mkdirmkdir 方法的第一个参数为文件路径，最后一个参数为回调函数，回调函数有一个参数 err（错误），在执行创建操作后执行，同样需要路径前部分的文件夹都存在。/* 异步创建文件目录 */ const fs = require(&#39;fs&#39;); // 假设已经有了 a 文件夹和 a 下的 b 文件夹 fs.mkdir(&#39;a/b/c&#39;, err =&gt; { if (!err) console.log(&#39;创建成功&#39;); }); // 创建成功 读取文件目录同步读取目录方法 readdirSyncreaddirSync 方法有两个参数：第一个参数为文件路径，传入的路径前部分的目录必须存在，否则会报错；第二个参数为 options，其中有 encoding（编码，默认值为 utf8），该参数也可直接传入 encoding；返回值为一个存储文件目录中成员名称的数组。假设现在已经存在了 a 目录和 a 下的 b 目录，b 目录中有 c 目录和 index.js 文件，下面读取文件目录结构。/* 同步读取目录 */ const fs = require(&#39;fs&#39;); const data = fs.readdirSync(&#39;a/b&#39;); console.log(data); // [ &#39;c&#39;, &#39;index.js&#39; ] 异步读取目录方法 readdirreaddir 方法的前两个参数与 readdirSync 相同，第三个参数为一个回调函数，回调函数有两个参数 err（错误）和 data（存储文件目录中成员名称的数组），在读取文件目录后执行。上面案例异步的写法：/* 异步读取目录 */ const fs = require(&#39;fs&#39;); fs.readdir(&#39;a/b&#39;, (err, data) =&gt; { if (!err) console.log(data); }); // [ &#39;c&#39;, &#39;index.js&#39; ] 删除文件目录无论同步还是异步，删除文件目录时必须同时满足两个条件：保证文件目录的路径存在；且被删除的文件目录为空，即不存在任何文件夹和文件。同步删除目录方法 rmdirSyncrmdirSync 的参数为要删除目录的路径，现在存在 a 目录和 a 目录下的 b 目录，删除 b 目录。/* 同步删除目录 */ const fs = require(&#39;fs&#39;); fs.rmdirSync(&#39;a/b&#39;); 异步删除目录方法 rmdirrmdir 方法的第一个参数与 rmdirSync 相同，最后一个参数为回调函数，函数中存在一个参数 err（错误），在删除目录操作后执行。/* 异步删除目录 */ const fs = require(&#39;fs&#39;); fs.rmdir(&#39;a/b&#39;, err =&gt; { if (!err) console.log(&#39;删除成功&#39;); }); // 删除成功 删除文件操作同步删除文件方法 unlinkSyncunlinkSync 的参数为要删除文件的路径，现在存在 a 目录和 a 目录下的 index.js 文件，删除 index.js 文件。/* 同步删除文件 */ const fs = require(&#39;fs&#39;); fs.unlinkSync(&#39;a/inde.js&#39;); 异步删除文件方法 unlinkunlink 方法的第一个参数与 unlinkSync 相同，最后一个参数为回调函数，函数中存在一个参数 err（错误），在删除文件操作后执行。/* 异步删除文件 */ const fs = require(&#39;fs&#39;); fs.unlink(&#39;a/index.js&#39;, err =&gt; { if (!err) console.log(&#39;删除成功&#39;); }); // 删除成功 实现递归创建目录我们创建一个函数，参数为一个路径，按照路径逐级的创建文件夹目录。同步的实现/* 递归删除文件目录 —— 同步 */ const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 同步创建文件目录 function mkPathSync(dirPath) { // path.sep 文件路径分隔符（mac 与 windows 系统不同），转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const parts = dirPath.split(path.sep); for (let i = 1; i &lt;= parts.length; i++) { // 重新拼接成 a a/b a/b/c const current = parts.slice(0, i).join(path.sep); // accessSync 路径不存在则抛出错误在 catch 中创建文件夹，否则直接创建下一级 try { fs.accessSync(current); } catch(e) { fs.mkdirSync(current); } } } // 创建文件目录 mkPathSync(path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)); 同步代码就是利用 accessSync 方法检查文件路径是否存在，利用 try...catch... 进行错误捕获，如果路径不存在，则会报错，会进入 catch 完成文件夹的创建。异步回调的实现/* 递归删除文件目录 —— 异步回调 */ const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); function mkPathAsync(dirPath, callback) { // 转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const parts = dirPath.split(path.sep); // 创建文件夹方法 function next(index) { // 重新拼接成 a a/b a/b/c const current = parts.slice(0, index).join(path.sep); // 如果路径检查成功说明已经有该文件目录，则继续创建下一级, 失败则创建目录，成功后递归 next 创建下一级 fs.access(current, err =&gt; { if (err) { fs.mkdir(current, () =&gt; next(++index)); } else { next(++index); } }); } // 第一次调用 index 值为 1，因为 slice 截取包前不包后 next(1); } // 创建文件目录 mkPathAsync(path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), () =&gt; { console.log(&#39;创建文件目录完成&#39;) }); // 创建文件目录完成 上面方法中没有通过循环实现每次目录的拼接，而是通过递归内部函数 next 的方式并维护 index 变量来实现的，在使用 access 的时候成功说明文件目录已经存在，就继续递归创建下一级，如果存在 err 说明不存在，则创建文件夹。异步 async/await 的实现上面两种方式，同步会阻塞代码，性能不好，异步回调函数性能好，但嵌套多维护性差，我们想要具备性能好，代码可读性又好可以使用现在 Node.js 中正流行的 async/await 的方式进行异步编程，想了解 async/await 可以看 异步发展流程 —— 异步编程的终极大招 async/await 这篇文章。使用 async 函数中 await 等待的异步操作必须转换成 Promise 实例，util 模块下的 promisify 方法可以进行转换，其实 promisify 方法的原理也很简单，我们在实现递归创建文件目录之前先实现 promisify 方法。/* promisify 原理 */ // 将一个异步方法转换成 Promise function promisify(fn) { return function (...args) { return new Promise((resolve, reject) =&gt; { fn.call(null, ...args, (err, data) =&gt; { err ? reject(err) : resolve(data); }); }); } } 其实 promisify 方法就是利用闭包来实现的，调用时传入一个需要转换成 Promise 的函数 fn，返回一个闭包函数，在闭包函数中返回一个 Promise 实例，并同步执行了 fn，通过 call 将闭包函数中的参数和回调函数作为参数传入了 fn 中，该回调存在错误的时候调用了 Promise 实例的 reject，否则调用 resolve；/* 递归删除文件目录 —— 异步 async/await */ const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 将 fs 中用到的方法转换成 Promise const access = promisify(fs.access); const mkdir = promisify(fs.mkdir); // async/await 实现递归创建文件目录 async function mkPath(dirPath) { // 转变成数组，如 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const parts = dirPath.split(path.sep); for (let i = 1; i &lt;= parts.length; i++) { // 重新拼接成 a a/b a/b/c const current = parts.slice(0, i).join(path.sep); // accessSync 路径不存在则抛出错误在 catch 中创建文件夹 try { await access(current); } catch(e) { await mkdir(current); } } } // 创建文件目录 mkPath(path.(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)).then(() =&gt; { console.log(&#39;创建文件目录完成&#39;); }); // 创建文件目录完成 使用 async/await 的写法，代码更像同步的实现方式，却是异步执行，所以同时兼顾了性能和代码的可读性，优势显而易见，在使用 Node.js 框架 Koa 2.x 版本时大量使用这种方式进行异步编程。总结在 fs 所有模块都有同步异步两种实现，同步方法的特点就是阻塞代码，性能差，异步代码的特点就是回调函数嵌套多，在使用 fs 应尽量使用异步方式编程来保证性能，如果觉得回调函数嵌套不好维护，可以使用 Promise 或 async/await 的方式解决。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"fs","slug":"fs","permalink":"https://www.overtaking.top/tags/fs/"}]},{"title":"Node.js —— Buffer 解读","date":"2018-06-29T03:53:13.000Z","path":"20180629115313/","text":"Buffer 概述在 ES6 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制，Node.js 实现了 Buffer 相关的 API，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流，Buffer 属于 Global 对象，使用时不需引入，且 Buffer 的大小在创建时确定，无法调整。创建 Buffer在 Node.js v6.0.0 版本之前，Buffer 实例是通过 Buffer 构造函数创建的，即使用 new 关键字创建，它根据提供的参数返回不同的 Buffer，但在之后的版本中这种声明方式就被废弃了，替代 new 的创建方式主要有以下几种。Buffer.alloc 和 Buffer.allocUnsafe用 Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer 的传参方式相同，参数为创建 Buffer 的长度，数值类型。/* Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer */ // Buffer.alloc 创建 Buffer const buf1 = Buffer.alloc(6); // Buffer.allocUnsafe 创建 Buffer const buf2 = Buffer.allocUnsafe(6); console.log(buf1); // &lt;Buffer 00 00 00 00 00 00&gt; console.log(buf2); // &lt;Buffer 00 e7 8f a0 00 00&gt; 通过打印结果可以看出，用 Buffer.alloc 和 Buffer.allocUnsafe 创建 Buffer 是有区别的，Buffer.alloc 创建的 Buffer 是被初始化过的，Buffer 的每一项都用 00 填充，而 Buffer.allocUnsafe 创建的 Buffer 并没有经过初始化，在内存中只要有闲置的 Buffer 就直接 “抓过来” 使用。Buffer.allocUnsafe 创建 Buffer 使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感数据，有明显性能优势的同时又是不安全的，所以需谨慎使用。Buffer.fromBuffer.from 支持三种传参方式：第一个参数为字符串，第二个参数为字符编码，如 ASCII、UTF-8、Base64 等等;传入一个数组，数组的每一项会以十六进制存储为 Buffer 的每一项;传入一个 Buffer，会将 Buffer 的每一项作为新返回 Buffer 的每一项。传入字符串和字符编码：/* 传入字符串和字符编码 */ const buf = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;); console.log(buf); // &lt;Buffer 68 65 6c 6c 6f&gt; 传入数组：/* 数组成员为十进制数 */ const buf = Buffer.from([1, 2, 3]); console.log(buf); // &lt;Buffer 01 02 03&gt; /* 数组成员为十六进制数 */ let buf = Buffer.from([0xe4, 0xbd, 0xa0, 0xe5, 0xa5, 0xbd]); console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt; console.log(buf.toString(&#39;utf8&#39;)); // 你好 在 Node.js 中不支持 GB2312 编码，默认支持 UTF-8，在 GB2312 中，一个汉字占两个字节，而在 UTF-8 中，一个汉字占三个字节，所以上面 “你好” 的 Buffer 为 6 个十六进制数组成。/* 数组成员为字符串类型的数字 */ const buf = Buffer.from([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]); console.log(buf); // &lt;Buffer 01 02 03&gt; 传入的数组成员可以是任何进制的数值，当成员为字符串的时候，如果值是数字会被自动识别成数值类型，如果值不是数字或成员为是其他非数值类型的数据，该成员会被初始化为 00。创建的 Buffer 可以通过 toString 方法直接指定编码进行转换，默认编码为 UTF-8。传入 Buffer：/* 传入一个 Buffer */ const buf1 = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;); const buf2 = Buffer.from(buf1); console.log(buf1); // &lt;Buffer 68 65 6c 6c 6f&gt; console.log(buf2); // &lt;Buffer 68 65 6c 6c 6f&gt; console.log(buf1 === buf2); // true console.log(buf1[0] === buf2[0]); // false 当传入的参数为一个 Buffer 的时候，会创建一个新的 Buffer 并复制上面的每一个成员。Buffer 为引用类型，一个 Buffer 复制了另一个 Buffer 的成员，当其中一个 Buffer 复制的成员有更改，另一个 Buffer 对应的成员会跟着改变，因为指向同一个引用，类似于 “二维数组”。/* Buffer 类比二维数组 */ const arr1 = [1, 2, [3]]; const arr2 = arr1.slice(); arr2[2][0] = 5; console.log(arr1); // [1, 2, [5]] Buffer 的常用方法fillBuffer 的 fill 方法可以向一个 Buffer 中填充数据，支持传入三个参数：value：将要填充的数据；start：填充数据的开始位置，不指定默认为 0；end：填充数据的结束位置，不指定默认为 Buffer 的长度。const buf = Buffer.alloc(3); buf.fill(1); console.log(buf); // &lt;Buffer 01 01 01&gt; const buf = Buffer.alloc(6); buf.fill(1, 2, 4); console.log(buf); // &lt;Buffer 00 00 01 01 00 00&gt; 上面代码可以看出填充数据是 “包前不包后的”，fill 的第一个参数也支持是多个字节，从被填充 Buffer 的起始位置开始，一直到结束，会循环填充这些字节，剩余的位置不够填充这几个字节，会填到哪算哪，有可能不完整，如果 fill 指定的结束位置大于了 Buffer 的长度，会抛出 RangeError 的异常。const buf = Buffer.alloc(6); buf.fill(&#39;abc&#39;, 1, 5); console.log(buf); // &lt;Buffer 00 61 62 63 61 00&gt; const buf = Buffer.alloc(3); buf.fill(&#39;abc&#39;, 4, 8); console.log(buf); // throw new errors.RangeError(&#39;ERR_INDEX_OUT_OF_RANGE&#39;); sliceBuffer 的 slice 方法与数组的 slice 方法用法完全相同，相信数组的 slice 已经足够熟悉了，这里就不多赘述了，Buffer 中截取出来的都是 Buffer。const buf = Buffer.from(&#39;hello&#39;, &#39;utf8&#39;); const a = buf.slice(0, 2); const b = buf.slice(2); const c = buf.slice(-2); console.log(a.toString()); // he console.log(b.toString()); // llo console.log(c.toString()); // lo indexOfBuffer 的 indexOf 用法与数组和字符串的 indexOf 类似，第一个参数为查找的项，第二个参数为查找的起始位置，不同的是，对于 Buffer 而言，查找的可能是一个字符串，代表多个字节，查找的字节在 Buffer 中必须有连续相同的字节，返回连续的字节中第一个字节的索引，没查找到返回 -1。const buf = Buffer.from(&#39;你*好*吗&#39;, &#39;utf8&#39;); console.log(buf); // &lt;Buffer e4 bd a0 2a e5 a5 bd 2a e5 90 97&gt; console.log(buf.indexOf(&#39;*&#39;)); // 3 console.log(buf.indexOf(&#39;好&#39;)); // 4 console.log(buf.indexOf(&#39;*&#39;, 4)); // 7 copyBuffer 的 copy 方法用于将一个 Buffer 的字节复制到另一个 Buffer 中去，有四个参数：target：目标 Buffer；targetStart：目标 Buffer 的起始位置；sourceStart：源 Buffer 的起始位置；sourceEnd：源 Buffer 的结束位置。/* 容器 Buffer 长度充足 */ const targetBuf = Buffer.alloc(6); const sourceBuf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); // 将 “你好” 复制到 targetBuf 中 sourceBuf.copy(targetBuf, 0, 0, 6); console.log(targetBuf.toString()); // 你好 /* 容器 Buffer 长度不足 */ const targetBuf = Buffer.alloc(3); const sourceBuf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); sourceBuf.copy(targetBuf, 0, 0, 6); console.log(targetBuf.toString()); // 你 上面第二个案例中虽然要把整个源 Buffer 都复制进目标 Buffer 中，但是由于目标 Buffer 的长度只有 3，所以最终只能复制进去一个 “你” 字。Buffer 与数组不同，不能通过操作 length 和索引改变 Buffer 的长度，Buffer 一旦被创建，长度将保持不变。/* 数组对比 Buffer —— 操作 length */ // 数组 const arr = [1, 2, 3]; arr[3] = 4; console.log(arr); // [1, 2, 3, 4] arr.length = 5; console.log(arr); // [1, 2, 3, 4, empty] // Buffer const buf = Buffer.alloc(3); buf[3] = 0x00; console.log(buf); // &lt;Buffer 00 00 00&gt; buf.length = 5; console.log(buf); // &lt;Buffer 00 00 00&gt; console.log(buf.length); // 3 通过上面代码可以看出数组可以通过 length 和索引对数组的长度进行改变，但是 Buffer 中类似的操作都是不生效的。copy 方法的 Polyfill：/* 模拟 copy 方法 */ Buffer.prototype.myCopy = function (target, targetStart, sourceStart, sourceEnd) { for (let i = 0; i &lt; sourceEnd - sourceStart; i++) { target[targetStart + i] = this[sourceStart + i]; } } Buffer.concat与数组类似，Buffer 也存在用于拼接多个 Buffer 的方法 concat，不同的是 Buffer 中的 concat 不是实例方法，而是静态方法，通过 Buffer.concat 调用，且传入的参数不同。Buffer.concat 有两个参数，返回值是一个新的 Buffer：第一个参数为一个数组，数组中的每一个成员都是一个 Buffer；第二个参数代表新 Buffer 的长度，默认值为数组中每个 Buffer 长度的总和。Buffer.concat 会将数组中的 Buffer 进行拼接，存入新 Buffer 并返回，如果传入第二个参数规定了返回 Buffer 的长度，那么返回值存储拼接到规定长度个字节。const buf1 = Buffer.from(&#39;你&#39;, &#39;utf8&#39;); const buf2 = Buffer.from(&#39;好&#39;, &#39;utf8&#39;); const result1 = Buffer.concat([buf1, buf2]); const result2 = Buffer.concat([buf1, buf2], 3); console.log(result1); // &lt;Buffer e4 bd a0 e5 a5 bd&gt; console.log(result1.toString()); // 你好 console.log(result2); // &lt;Buffer e4 bd a0&gt; console.log(result2.toString()); // 你 Buffer.concat 方法的 Polyfill：/* 模拟 Buffer.concat */ Buffer.myConcat = function (bufferList, len) { // 新 Buffer 的长度 len = len || bufferList.reduce((prev, next) =&gt; prev + next.length, 0); let index = 0; // 下次开始的索引 const newBuf = Buffer.alloc(len); // 创建新 Buffer // 循环存储 Buffer 的数组进行复制 bufferList.forEach(buf =&gt; { buf.myCopy(newBuf, index, 0, buf.length); index += buf.length; }); return newBuf; } Buffer.isBufferBuffer.isBuffer 是用来判断一个对象是否是一个 Buffer，返回布尔值。const obj = {}; const buf = Buffer.alloc(6); console.log(Buffer.isBuffer(obj)); // false console.log(Buffer.isBuffer(buf)); // true 封装一个 split字符串的 split 是经常使用的方法，可以用分隔符将字符串切成几部分存储在数组中，Buffer 本身没有 split 方法，但是也会有类似的使用场景，所以我们在 Buffer 上自己实现一个 split。功能：Buffer 的 split 方法参数为一个分隔符，这个分隔符可能是一个或多个字节的内容，返回值为一个数组，分隔开的部分作为独立的 Buffer 存储在返回的数组中。/* 封装 Buffer 的 split 方法 */ Buffer.prototype.split = function (sep) { const len = Buffer.from(sep).length; // 分隔符所占的字节数 const result = []; // 返回的数组 let start = 0; // 查找 Buffer 的起始位置 let offset = 0; // 偏移量 // 循环查找分隔符 while ((offset = this.indexOf(sep, start)) !== -1) { // 将分隔符之前的部分截取出来存入 result.push(this.slice(start, offset)); start = offset + len; } // 处理剩下的部分 result.push(this.slice(start)); // 返回结果 return result; } 验证 split 方法：/* 验证 split */ const buf = Buffer.from(&#39;哈登爱篮球爱夜店&#39;, &#39;utf8&#39;); const bufs = buf.split(&#39;爱&#39;); console.log(bufs); // [ &lt;Buffer e5 93 88 e7 99 bb&gt;, // &lt;Buffer e7 af ae e7 90 83&gt;, // &lt;Buffer e5 a4 9c e5 ba 97&gt; ] const newBufs = bufs.map(buf =&gt; buf.toString()); console.log(newBufs); // [ &#39;哈登&#39;, &#39;篮球&#39;, &#39;夜店&#39; ] Buffer 的编码转换我们知道 Node.js 中的默认编码为 UTF-8，且不支持 GB2312 编码，假如现在有一个编码格式为 GB2312 的 txt 文件，内容为 “你好”，现在我们使用 Node.js 去读取它，由于在 UTF-8 与 GB2312 编码中汉字所占字节数不同，所以读出的内容无法解析，即为乱码。// 引入依赖 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;)); console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt; console.log(buf.toString()); // 你好 console.log(result); // &lt;Buffer c4 e3 ba c3&gt; console.log(result.toString()); // ��� 如果一定要在 Node.js 中来正确解析这样的内容，这样的问题还是有办法解决的，我们需要借助 iconv-lite 模块，这个模块可以将一个 Buffer 按照指定的编码格式进行编码或解码。由于 iconv-lite 是第三方提供的模块，在使用前需要安装，安装命令如下：$ npm install iconv-lite 如果想正确的读出其他编码格式文件的内容，上面代码应该更改为：// 引入依赖 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const iconvLite = require(&#39;iconv-lite&#39;); const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;)); console.log(iconvLite.decode(result, &#39;gb2312&#39;)); // 你好 去掉 BOM 头上面读取 GB2312 编码的 txt 文件也可以通过打开文件重新保存为 UTF-8 或用编辑器直接将编码手动修改为 UTF-8，此时读取的文件不需要进行编码转换，但是会产生新的问题。/* 产生 BOM 头 */ // 引入依赖 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); const result = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;)); console.log(buf); // &lt;Buffer e4 bd a0 e5 a5 bd&gt; console.log(result); // &lt;Buffer ef bb bf e4 bd a0 e5 a5 bd&gt; 在手动修改 txt 文件编码后执行上面代码，发现读取的 Buffer 与正常情况相比前面多出了三个字节，只要存在文件编码的修改就会在这个文件的前面产生多余的字节，叫做 BOM 头。BOM 头是用来判断文本文件是哪一种 Unicode 编码的标记，其本身是一个 Unicode 字符，位于文本文件头部。虽然 BOM 头起到了标记文件编码的作用，但是它并不属于文件的内容部分，因此会产生一些问题，如文件编码发生变化后无法正确读取文件的内容，或者多个文件在合并的过程中，中间会夹杂着这些多余内容，所以在 Node.js 文件操作的源码中，Buffer 编码转换的模块 iconv-lite 中，以及 Webpack 对项目文件进行打包编译时都进行了去掉 BOM 头的操作。为了让上面的代码可以正确的读取并解析编码被手动修改过的文件内容，我们这里也需要进行去掉 BOM 头的操作。/* 去掉 BOM 头的方法 */ function BOMStrip(result) { if (Buffer.isBuffer(result)) { // 如果读取的内容为 Buffer if (result[0] === 0xef &amp;&amp; result[1] === 0xbb &amp;&amp; result[2] === 0xbf) { // 若前三个字节是否和 BOM 头的前三字节相同，去掉 BOM 头 return Buffer.slice(3); } } else { // 如果不是 Buffer if (result.charCodeAt(0) === 0xfeff) { // 判断第一项是否和 BOM 头的十六进制相同，去掉 BOM 头 return result.slice(1); } } } 使用去掉 BOM 头的方法并验证上面读文件的案例：/* 验证去 BOM 头的方法 */ // 引入依赖 const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); // 两种方式读文件 const result1 = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;)); const result2 = fs.readFileSync(path.resolve(__dirname, &#39;a.txt&#39;), &#39;utf8&#39;); console.log(BOMStrip(result1).toString()); // 你好 console.log(BOMStrip(result2)); // 你好 缓存 Buffer/* 产生乱码问题 */ const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); const a = buf.slice(0, 2); const b = buf.slice(2, 6); console.log(a.toString()); // � console.log(b.toString()); // �好 UTF-8 编码，一个汉字三个字节，使用 slice 方法对一个表达汉字的 Buffer 进行截取，如果截取长度不是 3 的整数倍，此时无法正确解析，会显示乱码，这种情况可以使用模块 string_decoder 对不能组成汉字的 Buffer 进行缓存，string_decoder 是核心模块，不需要安装。/* 缓存 Buffer */ // 引入依赖 const { StringDecoder } = require(&#39;string_decoder&#39;); const buf = Buffer.from(&#39;你好&#39;, &#39;utf8&#39;); const a = buf.slice(0, 2); const b = buf.slice(2, 6); // 创建 StringDecoder 实例 const sd = new StringDecoder(); console.log(sd.write(a)); console.log(sd.write(b)); // 你好 上面代码中使用了 string_decoder 后，截取的 Buffer 不能组成一个汉字的时候不打印，进行缓存，等到可以正确解析时取出缓存，重新拼接后打印。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"Buffer","slug":"Buffer","permalink":"https://www.overtaking.top/tags/Buffer/"}]},{"title":"EventEmitter 源码分析与简易实现","date":"2018-06-28T12:47:55.000Z","path":"20180628204755/","text":"EventEmitter 简介EventEmitter 是 Node.js 的核心模块 events 中的类，用于对 Node.js 中的事件进行统一管理，用 events 特定的 API 对事件进行添加、触发和移除等等，核心方法的模式类似于发布订阅。实现 EventEmitterEventEmitter 构造函数的实现/* 文件：events.js */ function EventEmitter () { this._events = Object.create(null); } /* * 其他方法 */ // 导出自定义模块 module.export = EventEmitter; 在构造函数 EventEmitter 上有一个属性 _events，类型为对象，用于存储和统一管理所有类型的事件，在创建构造函数的时候导出了 EventEmitter，后面实现其他方法的代码将放在构造函数与导出中间。事件最大监听个数在 EventEmitter 中监听的每一类事件都有最大监听个数，超过了这个数值，事件虽然可以正常执行，但是会发出警告信息，其目的是为了防止内存泄露。/* 默认事件最大监听个数 */ EventEmitter.defaultMaxListeners = 10; 这个同类型事件最大个数默认是 10，EventEmitter 当然也有方法设置和获取这个值，下面是设置和获取同类型事件最大监听个数的方法实现。/* 操作最大事件监听个数 */ // 设置同类型事件监听最大个数 EventEmitter.prototype.setMaxListeners = function (count) { this._count = count; } // 获取同类型事件监听最大个数 EventEmitter.prototype.getMaxListeners = function () { return this._count || EventEmitter.defaultMaxListeners; } 在设置这个值的时候其实就是给 EventEmitter 实例添加了一个 _count 的属性用来存储设置的新值来作为这个类型事件的最大监听个数，在获取的时候就是获取 _count，如果没有设置过就获取默认值。添加事件监听在给 EventEmitter 的实例添加事件监听时，在 _event 对象中会以事件的类型作为属性名，值为一个数组，每次添加这个类型事件的时候，会将要执行的函数存入这个数组中进行统一管理。添加事件监听的方法有 on、once、addListener、prependListener 和 prependOnceListener：on 等同于 addListener 将函数正常添加到 _event 对应事件类型的数组中；once 将函数添加到 _event 对应事件类型的数组中，但是只能执行一次；prependListener 将函数添加到 _event 对应事件类型的数组中的前面；prependOnceListener 将函数添加到 _event 对应事件类型的数组中的前面，但只能执行一次。在 EventEmitter 中正常添加事件有四点需要注意：如果其他的类使用 util 模块的 inherits 方法继承 EventEmitter 时是无法继承实例属性的，在调用操作 _events 的方法中因为无法获取到 _events 导致报错，为了兼容这种继承的情况，在获取不到 _events 时应添加一个 _events 到继承 EventEmitter 的类的实例上；如果添加事件的类型为 newListener，传入要执行的函数会有一个参数 type ，是事件的类型，之后再添加事件的时候，就会执行 newListener 的函数，对添加的事件的事件类型进行处理；on 方法表面上有两个参数，实际上有第三个参数，为布尔值，代表是否从 _events 对应事件类型的数组前面追加函数成员；在添加事件的时候需要判断是否超出这个类型事件的最大监听个数，如果超出要打印警告信息。on 方法和 addListener 方法的实现：/* on 和 addListener 方法 */ // 添加事件监听 EventEmitter.prototype.on = EventEmitter.prototype.addListener = function (type, callback, flag) { // 兼容继承不存在 _events 的情况 if (!this._events) this._events = Object.create(null); // 如果 type 不是 newListener 就去执行 newListener 的回调 if (type !== &#39;newListener&#39;) { // 如果没添加过 newListener 事件就忽略此处的逻辑 if (this._events[&#39;newListener&#39;] &amp;&amp; this._events[&#39;newListener&#39;].length) { this._events[&#39;newListener&#39;].forEach(fn =&gt; fn(type)); } } // 如果不是第一次添加 callback 存入数组中 if (this._events[type]) { // 是否从数组前面添加 callback if (flag) { this._events[type].unshift(callback); } else { this._events[type].push(callback); } } else { // 第一次添加，在 _events 中创建数组并添加 callback 到数组中 this._events[type] = [callback]; } // 获取事件最大监听个数 const maxListeners = this.getMaxListeners(); // 判断 type 类型的事件是否超出最大监听个数，超出打印警告信息 if (this._events[type].length - 1 === maxListeners) { console.error(&#39;MaxListenersExceededWarning: &#39; + (maxListeners + 1) + &#39; &#39; + type + &#39; listeners added&#39;); } } 通过上面代码可以看出 on 方法的第三个参数其实是服务于 prependListener 方法的，其他添加事件的方法都是基于 on 来实现的，只是在调用 on 的外层做了不同的处理，而我们平时调这些添加事件监听的方法时都只传入 type 和 callback。prependListener 方法的实现：/* prependListener 方法 */ // 添加事件监听，从数组的前面追加 EventEmitter.prototype.prependListener = function (type, callback) { // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback this.on(type, callback, true); } once 方法的实现：/* once 方法 */ // 添加事件监听，只能执行一次 EventEmitter.prototype.once = function (type, callback, flag) { const wrap =&gt; (...args) { callback(...args); // 执行 callback 后立即从数组中移除 callback this.removeListener(type, wrap); } // 存储 callback，确保单独使用 removeListener 删除传入的 callback 时可以被删除掉 wrap.realCallback = callback; // 调用 on 添加事件监听 this.on(type, wrap, flag); } 想让事件只执行一次，需要在执行 callback 之后就立即在数组中移除这个函数，由于是同步执行，直接操作 callback 是很难实现的，添加事件其实就是添加 callback 到 _events 对应类型的数组中，我们在使用 once 的时候将 callback 包一层函数名为 wrap，将这个外层函数存入数组，wrap 的内部逻辑就是真正 callback 的调用和移除 wrap，这里涉及到事件监听的移除方法 removeListener 在后面来详细说明。once 的第三个参数是为了 prependOnceListener 服务的，prependOnceListener 与 prependListener 实现方式类似，不同的是 prependOnceListener 是基于 once 实现的。prependOnceListener 方法的实现：/* prependOnceListener 方法 */ // 添加事件监听，从数组的前面追加，只执行一次 EventEmitter.prototype.prependOnceListener = function (type, callback) { // 第三个参数为 true 表示从 _events 对应事件类型的数组前面添加 callback this.once(type, callback, true); } 移除事件监听移除事件监听有两个方法，分别是 removeListener 和 removeAllListeners，前者的作用是移除某个类型数组中的某个回调函数，后者的作用是移除某个类型数组的所有成员，如果类型参数为空，则清空整个 _events。removeListener 方法的实现：/* removeListener 方法 */ // 移除事件执行程序 EventEmitter.prototype.removeListener = function (type, callback) { if (this._events[type]) { // 过滤掉当前传入的要移除的 callback this._events[type] = this._events[type].filter(fn =&gt; { return fn !== callback &amp;&amp; fn !== callback.realCallback; }); } } 由于 once 中在真正的 callback 包了一层 wrap，只有在触发事件时才能执行 wrap 并执行 removeListener 删掉函数，如果在事件触发之前使用 removeListener 删除，传入的是真正的回调 callback 将不存在，无法执行，所以在 once 方法中对真正的 callback 进行了存储，在 removeListener 中调用 filter 时的返回条件的逻辑中做了处理。removeAllListeners 方法的实现：/* removeAllListeners 方法 */ // 移除全部事件执行程序 EventEmitter.prototype.removeAllListeners = function (type) { // 存在 type 清空 _events 对应的数组，否则直接清空 _events if (type) { this._events[type] = []; } else { this._events = Object.create(null); } } 触发事件监听执行事件就比较简单了，取出 _events 中对应类型的数组进行循环，执行内部的每一个函数，第一个参数为 type，后面参数会作为数组中函数执行传入的参数。/* emit 方法 */ // 触发事件w EventEmitter.prototype.emit = function (type, ...args) { if (this._events[type]) { // 循环执行函数，并将 this 指回 EventEmitter 实例 this._events[type].forEach(fn =&gt; fn.call(this, ...args)); } } 获取事件类型名称集合/* eventNames 方法 */ // 获取监听的所有事件类型 EventEmitter.prototype.eventNames = function () { return Object.keys(this._events); } 按事件类型获取执行程序的集合/* listeners 方法 */ // 获取事件类型对应的数组 EventEmitter.prototype.listeners = function (type) { return this._events[type]; } EventEmitter 的基本使用EventEmitter 的核心逻辑已经实现，由于上面大多数方法需要组合使用，所以在没有一一验证，下面让我们通过一些案例来了解 EventEmitter 的用法。我们在这里引入自己自定义的 events 模块，并使用 util 模块的 inherits 继承 EventEmitter，下面是前置代码，后面将不在重复。/* 文件：events-demo.js */ // 引入依赖 const EventEmitter = require(&#39;./events&#39;); const util = require(&#39;util&#39;); function Girl() {} // 使 Girl 继承 EventEmitter util.inherits(Girl, EventEmitter); // 创建 Girl 的实例 const girl = new Girl(); 案例 1：设置和获取同类型事件的最大监听个数/* 文件：events-demo.js */ // 获取事件最大监听个数 console.log(girl.getMaxListeners()); // 10 // 设置事件最大监听个数 girl.setMaxListeners(2); console.log(girl.getMaxListeners()); // 2 案例 2：使用 on 添加事件并执行/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.emit(&#39;失恋&#39;); // 哭了 // 喝酒 案例 3：使用 prependListener 添加事件并执行/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.prependListener(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.emit(&#39;失恋&#39;); // 喝酒 // 哭了 案例 4：添加 newListener 类型的事件/* 文件：events-demo.js */ girl.on(&#39;newListener&#39;, (type) =&gt; console.log(type)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;)); // 失恋 // 和好 案例 5：添加同类型事件超出最大个数并执行事件/* 文件：events-demo.js */ // 设置事件最大监听个数 girl.setMaxListeners(2); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;)); girl.emit(&#39;失恋&#39;); // MaxListenersExceededWarning: 3 失恋 listeners added // 哭了 // 喝酒 // 吸烟 案例 6：对比 on 和 once/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.once(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.emit(&#39;失恋&#39;); girl.emit(&#39;失恋&#39;); // 哭了 // 喝酒 // 哭了 案例 7：移除 on 和 once 添加的事件监听/* 文件：events-demo.js */ const cry = () =&gt; console.log(&#39;哭了&#39;); const drink = () =&gt; console.log(&#39;喝酒&#39;); girl.on(&#39;失恋&#39;, cry); girl.once(&#39;失恋&#39;, drink); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;)); girl.removeListener(&#39;失恋&#39;, cry); girl.removeListener(&#39;失恋&#39;, drink); girl.emit(&#39;失恋&#39;); // 吸烟 案例 8：使用 prependOnceListener 添加事件监听/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.prependOnceListener(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.emit(&#39;失恋&#39;); girl.emit(&#39;失恋&#39;); // 喝酒 // 哭了 // 哭了 案例 9：获取某个事件类型执行程序的集合/* 文件：events-demo.js */ const cry = () =&gt; console.log(&#39;哭了&#39;); const drink = () =&gt; console.log(&#39;喝酒&#39;); girl.on(&#39;失恋&#39;, cry); girl.once(&#39;失恋&#39;, drink); girl.once(&#39;失恋&#39;, () =&gt; console.log(&#39;吸烟&#39;)); console.log(girl.listeners(&#39;失恋&#39;)); // [ [Function: cry], [Function: drink], [Function] ] 案例 10：获取所有事件类型名称/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;)); console.log(girl.eventNames()); // [ &#39;失恋&#39;, &#39;和好&#39; ] 案例 11：使用 removeAllListeners 按类型移除事件监听/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;)); // 移除 “失恋” 类型事件监听 girl.removeAllListeners(&#39;失恋&#39;); console.log(girl.listeners(&#39;失恋&#39;)); // [] 案例 12：使用 removeAllListeners 移除全部事件监听/* 文件：events-demo.js */ girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;哭了&#39;)); girl.on(&#39;失恋&#39;, () =&gt; console.log(&#39;喝酒&#39;)); girl.on(&#39;和好&#39;, () =&gt; console.log(&#39;开心&#39;)); // 移除全部事件监听 girl.removeAllListeners(); console.log(girl._events); // {} EventEmitter 总结events 模块在 Node.js 中的使用率非常高，很多其他模块的事件执行机制都是通过继承该模块的 EventEmitter 类来实现的，比如 ReadStream（可读流）、WriteStream（可写流）、net（tcp）和 http 等等，包括 Vue 事件机制的 on 和 emit 的实现与 EventEmitter 也非常相似，我们也可以通过上面案例的方式创建自己的类去继承 EventEmitter 来实现事件的管理。","tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"EventEmitter","slug":"EventEmitter","permalink":"https://www.overtaking.top/tags/EventEmitter/"}]},{"title":"CommonJS 模块化简易实现","date":"2018-06-26T06:28:25.000Z","path":"20180626142825/","text":"CommonJS 概述CommonJS 是一种模块化的标准，而 Node.js 是这种标准的实现，每个文件就是一个模块，有自己的作用域，在一个模块里面定义的变量、函数、类，都是私有的，不会和其他模块相互污染。Node.js 模块化的简易实现在实现模块加载之前，我们需要清除模块的加载过程：假设 A 文件夹下有一个 a.js，我们要解析出一个绝对路径来；我们写的路径可能没有后缀名 .js、.json；得到一个真实的加载路径（模块会被缓存）先去缓存中看一下这个文件是否存在，如果存在返回缓存 没有则创建一个模块；得到对应文件的内容，加一个闭包，把内容塞进去，之后执行即可。提前加载需要用到的模块因为我们只是实现 CommonJS 的模块加载方法，并不会去实现整个 Node.js，但在这里我们需要依赖一些 Node.js 的模块，所以我们就暂且使用 Node 自带的 require 方法把模块加载进来（忽略引入核心模块的 require）。/* 依赖模块 */ // 操作文件的模块 const fs = require(&#39;fs&#39;); // 处理路径的模块 const path = require(&#39;path&#39;); // 虚拟机，帮我们创建一个黑箱执行代码，防止变量污染 const vm = require(&#39;vm&#39;); 创建 Module 构造函数其实 CommonJS 中引入的每一个模块我们都需要通过 Module 构造函数创建一个实例。/* 创建 Module 构造函数 */ /* * @param {String} p */ function Module(p) { this.id = p; // 当前文件的表示（绝对路径） this.exports = {}; // 每个模块都有一个 exports 属性，用来存储模块的内容 this.loaded = false; // 标记是否被加载过 } 定义静态属性存储我们需要使用的一些值/* Module 静态变量 */ // 函数后面需要使用的闭包的字符串 Module.wrapper = [ &#39;(function (exports, require, module, __dirname, __filename) {&#39;, &#39;\\n})&#39; ]; // 根据绝对路径进行缓存的模块的对象 Module._cacheModule = {}; // 处理不同文件后缀名的方法 Module._extensions = { &#39;.js&#39;: function () {}, &#39;.json&#39;: function () {} }; 创建引入模块的 req 方法为了防止和 Node.js 自带的 require 方法重名，我们将模拟的方法重命名为 req。/* 引入模块方法 req */ /* * @param {String} moduleId */ function req(moduleId) { // 将 req 传入的参数处理成绝对路径 const p = Module._resolveFileName(moduleId); // 生成一个新的模块 const module = new Module(p); } 在上面代码中，我们先把传入的参数通过 Module._resolveFileName 处理成了一个绝对路径，并创建模块实例把绝对路径作为参数传入，我们现在实现一下 Module._resolveFileName 方法。返回文件绝对路径 Module._resolveFileName 方法的实现这个方法的功能就是将 req 方法的参数根据是否有后缀名两种方式处理成带后缀名的文件绝对路径，如果 req 的参数没有后缀名，会去按照 Module._extensions 的键的后缀名顺序进行查找文件，直到找到后缀名对应文件的绝对路径，优先 .js，然后是 .json，这里我们只实现这两种文件类型的处理。/* 处理绝对路径 _resolveFileName 方法 */ /* * @param {String} moduleId */ Module._resolveFileName = function (moduleId) { // 将参数拼接成绝对路径 const p = path.resolve(moduleId); // 判断是否含有后缀名 if (!/\\.\\w+$/.test(p)) { // 创建规范规定查找文件后缀名顺序的数组 .js .json const arr = Object.keys(Module._extensions); // 循环查找 for (let i = 0; i &lt; arr.length; i++) { // 将绝对路径与后缀名进行拼接 const file = p + arr[i]; // 查找不到文件时捕获异常 try { // 并通过 fs 模块同步查找文件的方法对改路径进行查找 // 文件未找到会直接进入 catch 语句 fs.accessSync(file); // 如果找到文件将该文件绝对路径返回 return file; } catch (e) { // 当后缀名循环完毕都没有找到对应文件时，抛出异常 if (i &gt;= arr.length) throw new Error(&#39;not found module&#39;); } } } else { // 有后缀名直接返回该绝对路径 return p; } }; 加载模块的 load 方法/* 完善 req 方法 */ /* * @param {String} moduleId */ function req(moduleId) { // 将 req 传入的参数处理成绝对路径 const p = Module._resolveFileName(moduleId); // 生成一个新的模块 const module = new Module(p); // ********** 下面为新增代码 ********** // 加载模块 const content = module.load(p); // 将加载后返回的内容赋值给模块实例的 exports 属性上 module.exports = content; // 最后返回 模块实例的 exports 属性，即加载模块的内容 return module.exports; // ********** 上面为新增代码 ********** } 上面代码实现了一个实例方法 load，传入文件的绝对路径，为模块加载文件的内容，在加载后将值存入模块实例的 exports 属性上最后返回，其实 req 函数返回的就是模块加载回来的内容。/* load 方法 */ // 模块加载的方法 Module.prototype.load = function (filepath) { // 判断加载的文件是什么后缀名 const ext = path.extname(filepath); // 根据不同的后缀名处理文件内容，参数是当前实例 const content = Moudule._extensions[ext](this); // 将处理后的结果返回 return content; }; 实现加载 .js 文件和 .json 文件的方法还记得前面准备的静态属性中有 Module._extensions 就是用来存储这两个方法的，下面我们来完善这两个方法。/* 处理后缀名方法的 _extensions 对象 */ Module._extensions = { &#39;.js&#39;: function (module) { // 读取 js 文件，返回文件的内容 const script = fs.readFileSync(module.id, &#39;utf8&#39;); // 给 js 文件的内容增加一个闭包环境 const fn = Module.wrap(script); // 创建虚拟机，将我们创建的 js 函数执行，将 this 指向模块实例的 exports 属性 vm.runInThisContext(fn).call( module.exports, module.exports, req, module ); // 返回模块实例上的 exports 属性（即模块的内容） return module.exports; }, &#39;.json&#39;: function (module) { // .json 文件的处理相对简单，将读出的字符串转换成对象即可 return JSON.parse(fs.readFileSync(module.id, &#39;utf8&#39;)); } }; 我们这里使用了 Module.wrap 方法，代码如下，其实帮助我们加了一个闭包环境（即套了一层函数并传入了我们需要的参数），里面所有的变量都是私有的。/* 创建闭包 wrap 方法 */ Module.wrap = function (content) { return Module.wrapper[0] + content + Module.wrapper[1]; }; Module.wrapper 的两个值其实就是我们需要在外层包了一个函数的前半段和后半段。这里我们要划重点了，非常重要：我们在虚拟机中执行构建的闭包函数时利用执行上/下文 call 将 this 指向了模块实例的 exports 属性上，所以这也是为什么我们用 node 启动一个 js 文件，打印 this 时，不是全局对象 global，而是一个空对象，这个空对象就是我们的 module.exports，即当前模块实例的 exports 属性。还是第一条的函数执行，我们传入的第一个参数是改变 this 指向，那第二个参数是 module.exports，所以在每个模块导出的时候，使用 module.exports = xxx，其实直接替换了模块实例的值，即直接把模块的内容存放在了模块实例的 exports 属性上，而 req 最后返回的就是我们模块导出的内容。第三个参数之所以传入 req 是因为我们还可能在一个模块中导入其他模块，而 req 会返回其他模块的导出在当前模块使用，这样整个 CommonJS 的规则就这样建立起来了。对加载过的模块进行缓存我们现在的程序是有问题的，当重复加载了一个已经加载过得模块，当执行 req 方法的时候会发现，又创建了一个新的模块实例，这是不合理的，所以我们下面来实现一下缓存机制。还记得之前的一个静态属性 Module._cacheModule，它的值是一个空对象，我们会把所有加载过的模块的实例存储到这个对象上。/* 完善 req 方法（处理缓存） */ /* * @param {String} moduleId */ function req(moduleId) { // 将 req 传入的参数处理成绝对路径 const p = Module._resolveFileName(moduleId); // ********** 下面为新增代码 ********** // 判断是否已经加载过 if (Module._cacheModule[p]) { // 模块存在，如果有直接把 exports 对象返回即可 return Module._cacheModule[p].exprots; } // ********** 上面为新增代码 ********** // 生成一个新的模块 const module = new Module(p); // 加载模块 const content = module.load(p); // ********** 下面为新增代码 ********** // 存储时是拿模块的绝对路径作为键与模块内容相对应的 Module._cacheModule[p] = module; // 是否缓存表示改为 true module.loaded = true; // ********** 上面为新增代码 ********** // 将加载后返回的内容赋值给模块实例的 exports 属性上 module.exports = content; // 最后返回 模块实例的 exports 属性，即加载模块的内容 return module.exports; } 试用 req 加载模块在同级目录下新建一个文件 a.js，使用 module.exports 随便导出一些内容，在我们实现模块加载的最下方尝试引入并打印内容。/* 导出自定义模块 */ // a.js module.exports = &#39;Hello world&#39;; /* 检测 req 方法 */ const a = req(&#39;./a&#39;); console.log(a); // Hello world CommonJS 模块查找规范其实我们只实现了 CommonJS 规范的一部分，即自定义模块的加载，其实在 CommonJS 的规范当中关于模块查找的规则还有很多，具体的我们就用下面的流程图来表示。CommonJS 模块加载流程图这篇文章让我们了解了 CommonJS 是什么，主要目的在于理解 Node.js 模块化的实现思路，想要更深入的了解 CommonJS 的实现细节，建议看一看 Node.js 源码对应的部分，如果觉得源码比较多，不容易找到模块化实现的代码，也可以在 VSCode 中通过调用 require 方法引入模块时，打断点调试，一步一步的跟进到 Node.js 源码中查看。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://www.overtaking.top/tags/CommonJS/"}]},{"title":"高阶函数应用 —— 柯里化与反柯里化","date":"2018-06-23T00:40:25.000Z","path":"20180623084025/","text":"前言在 JavaScript 中，柯里化和反柯里化是高阶函数的一种应用，在这之前我们应该清楚什么是高阶函数，通俗的说，函数可以作为参数传递到函数中，这个作为参数的函数叫回调函数，而拥有这个参数的函数就是高阶函数，回调函数在高阶函数中调用并传递相应的参数，在高阶函数执行时，由于回调函数的内部逻辑不同，高阶函数的执行结果也不同，非常灵活，也被叫做函数式编程。柯里化在 JavaScript 中，函数柯里化是函数式编程的重要思想，也是高阶函数中一个重要的应用，其含义是给函数分步传递参数，每次传递部分参数，并返回一个更具体的函数接收剩下的参数，这中间可嵌套多层这样的接收部分参数的函数，直至返回最后结果。最基本的柯里化拆分/* 柯里化拆分 */ // 原函数 function add(a, b, c) { return a + b + c; } // 柯里化函数 function addCurrying(a) { return function (b) { return function (c) { return a + b + c; } } } // 调用原函数 add(1, 2, 3); // 6 // 调用柯里化函数 addCurrying(1)(2)(3) // 6 被柯里化的函数 addCurrying 每次的返回值都为一个函数，并使用下一个参数作为形参，直到三个参数都被传入后，返回的最后一个函数内部执行求和操作，其实是充分的利用了闭包的特性来实现的。柯里化通用式上面的柯里化函数没涉及到高阶函数，也不具备通用性，无法转换形参个数任意或未知的函数，我们接下来封装一个通用的柯里化转换函数，可以将任意函数转换成柯里化。/* 柯里化通用式 ES5 */ function currying(func, args) { // 形参个数 var arity = func.length; // 上一次传入的参数 var args = args || []; return function () { // 将参数转化为数组 var _args = [].slice.call(arguments); // 将上次的参数与当前参数进行组合并修正传参顺序 Array.prototype.unshift.apply(_args, args); // 如果参数不够，返回闭包函数继续收集参数 if (_args.length &lt; arity) { return currying.call(null, func, _args); } // 参数够了则直接执行被转化的函数 return func.apply(null, _args); } } 上面主要使用的是 ES5 的语法来实现，大量的使用了 call 和 apply，下面我们通过 ES6 的方式实现功能完全相同的柯里化转换通用式。/* 柯里化通用式 ES6 */ function currying(func, args = []) { const arity = func.length; return function (..._args) { _args.unshift(...args); if (_args.length &lt; arity) { return currying(func, _args); } return func(..._args); } } 函数 currying 算是比较高级的转换柯里化的通用式，可以随意拆分参数，假设一个被转换的函数有多个形参，我们可以在任意环节传入任意个数的参数进行拆分，举一个例子，假如 5 个参数，第一次可以传入 2 个，第二次可以传入 1 个, 第三次可以传入剩下的，也有其他的多种传参和拆分方案，因为在 currying 内部收集参数的同时按照被转换函数的形参顺序进行了更正。柯里化的一个很大的好处是可以帮助我们基于一个被转换函数，通过对参数的拆分实现不同功能的函数，如下面的例子。/* 柯里化通用式应用 —— 普通函数 */ // 被转换函数，用于检测传入的字符串是否符合正则表达式 function checkFun(reg, str) { return reg.test(str); } // 转换柯里化 const check = currying(checkFun); // 产生新的功能函数 const checkPhone = check(/^1[34578]\\d{9}$/); const checkEmail = check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 上面的例子根据一个被转换的函数通过转换变成柯里化函数，并用 check 变量接收，以后每次调用 check 传递不同的正则就会产生一个检测不同类型字符串的功能函数。这种使用方式同样适用于被转换函数是高阶函数的情况，比如下面的例子。/* 柯里化通用式应用 —— 高阶函数 */ // 被转换函数，按照传入的回调函数对传入的数组进行映射 function mapFun(func, array) { return array.map(func); } // 转换柯里化 const getNewArray = currying(mapFun); // 产生新的功能函数 const createPercentArr = getNewArray(item =&gt; item * 100 + &#39;%&#39;); const createDoubleArr = getNewArray(item =&gt; item * 2); // 使用新的功能函数 let arr = [1, 2, 3, 4, 5]; let percentArr = createPercentArr(arr); // [&#39;100%&#39;, &#39;200%&#39;, &#39;300%&#39;, &#39;400%&#39;, &#39;500%&#39;,] let doubleArr = createDoubleArr(arr); // [2, 4, 6, 8, 10] 柯里化与 bindbind 方法是经常使用的一个方法，它的作用是帮我们将调用 bind 函数内部的上下文对象 this 替换成我们传递的第一个参数，并将后面其他的参数作为调用 bind 函数的参数。/* bind 方法原理模拟 */ Function.prototype.bind = function (context) { var self = this; var args = [].slice.call(arguments, 1); return function () { return self.apply(context, args); } } 通过上面代码可以看出，其实 bind 方法就是一个柯里化转换函数，将调用 bind 方法的函数进行转换，即通过闭包返回一个柯里化函数，执行该柯里化函数的时候，借用 apply 将调用 bind 的函数的执行上下文转换成了 context 并执行，只是这个转换函数没有那么复杂，没有进行参数拆分，而是函数在调用的时候传入了所有的参数。反柯里化反柯里化的思想与柯里化正好相反，如果说柯里化的过程是将函数拆分成功能更具体化的函数，那反柯里化的作用则在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。反柯里化通用式反柯里化通用式的参数为一个希望可以被其他对象调用的方法或函数，通过调用通用式返回一个函数，这个函数的第一个参数为要执行方法的对象，后面的参数为执行这个方法时需要传递的参数。/* 反柯里化通用式 ES5 */ function uncurring(fn) { return function () { // 取出要执行 fn 方法的对象，同时从 arguments 中删除 var obj = [].shift.call(arguments); return fn.apply(obj, arguments); } } /* 反柯里化通用式 ES6 */ function uncurring(fn) { return function (...args) { return fn.call(...args); } } 下面我们通过一个例子来感受一下反柯里化的应用。/* 反柯里化通用式应用 */ // 构造函数 F function F() {} // 拼接属性值的方法 F.prototype.concatProps = function () { let args = Array.from(arguments); return args.reduce((prev, next) =&gt; this[prev] + &#39;&amp;&#39; + this[next]); } // 使用 concatProps 的对象 const obj = { name: &#39;Panda&#39;, age: 16 }; // 使用反柯里化进行转化 const concatProps = uncurring(F.prototype.concatProps); concatProps(obj, &#39;name&#39;, &#39;age&#39;); // Panda&amp;16 反柯里化还有另外一个应用，用来代替直接使用 call 和 apply，比如检测数据类型的 Object.prototype.toString 等方法，以往我们使用时是在这个方法后面直接调用 call 更改上下文并传参，如果项目中多处需要对不同的数据类型进行验证是很麻的，常规的解决方案是封装成一个检测数据类型的模块。/* 检测数据类型常规方案 */ function checkType(val) { return Object.prototype.toString.call(val); } 如果需要这样封装的功能很多就麻烦了，代码量也会随之增大，其实我们也可以使用另一种解决方案，就是利用反柯里化通用式将这个函数转换并将返回的函数用变量接收，这样我们只需要封装一个 uncurring 通用式就可以了。/* 反柯里化创建检测类型函数 */ const checkType = uncurring(Object.prototype.toString); checkType(1); // [object Number] checkType(&#39;hello&#39;); // [object String] checkType(true); // [object Boolean] 通过函数调用生成反柯里化函数在 JavaScript 我们经常使用面向对象的编程方式，在两个类或构造函数之间建立联系实现继承，如果我们对继承的需求仅仅是希望一个构造函数的实例能够使用另一个构造函数原型上的方法，那进行繁琐的继承很浪费，简单的继承父子类的关系又不那么的优雅，还不如之间不存在联系。/* 将反柯里化方法扩展到函数原型 */ Function.prototype.uncurring = function () { var self = this; return function () { return Function.prototype.call.apply(self, arguments); } } 之前的问题通过上面给函数扩展的 uncurring 方法完全得到了解决，比如下面的例子。/* 函数应用反柯里化原型方法 */ // 构造函数 function F() {} F.prototype.sayHi = function () { return &quot;I&#39;m &quot; + this.name + &quot;, &quot; + this.age + &quot; years old.&quot;; } // 希望 sayHi 方法被任何对象使用 sayHi = F.prototype.sayHi.uncurring(); sayHi({ name: &#39;Panda&#39;, age: 20}); // I&#39;m Panda, 20 years old. 在 Function 的原型对象上扩展的 uncurring 中，难点是理解 Function.prototype.call.apply，我们知道在 call 的源码逻辑中 this 指的是调用它的函数，在 call 内部用第一个参数替换了这个函数中的 this，其余作为形参执行了函数。而在 Function.prototype.call.apply 中 apply 的第一个参数更换了 call 中的 this，这个用于更换 this 的就是例子中调用 uncurring 的方法 F.prototype.sayHi，所以等同于 F.prototype.sayHi.call，arguments 内的参数会传入 call 中，而 arguments 的第一项正是用于修改 F.prototype.sayHi 中 this 的对象。总结看到这里你应该对柯里化和反柯里化有了一个初步的认识了，但要熟练的运用在开发中，还需要我们更深入的去了解它们内在的含义。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"高阶函数","slug":"高阶函数","permalink":"https://www.overtaking.top/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"柯里化","slug":"柯里化","permalink":"https://www.overtaking.top/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.overtaking.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Canvas + WebSocket + Redis 实现一个视频弹幕","date":"2018-06-21T03:30:25.000Z","path":"20180621113025/","text":"页面布局首先，我们需要实现页面布局，在根目录创建 index.html 布局中需要有一个 video 多媒体标签引入本地视频，添加输入弹幕的输入框、确认发送的按钮、颜色选择器、字体大小滑动条，创建一个 style.css 来调整页面布局的样式，顺便创建一个 index.js 文件用于后续实现核心逻辑，先引入到页面当中。HTML 布局代码如下：&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;title&gt;视频弹幕&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;cantainer&quot;&gt; &lt;h2&gt;Canvas + WebSocket + Redis 实现视频弹幕&lt;/h2&gt; &lt;div id=&quot;content&quot;&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;video id=&quot;video&quot; src=&quot;./barrage.mp4&quot; controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;!-- 输入弹幕内容 --&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt; &lt;!-- 添加弹幕按钮 --&gt; &lt;button id=&quot;add&quot;&gt;发送&lt;/button&gt; &lt;!-- 选择文字颜色 --&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;!-- 调整字体大小 --&gt; &lt;input type=&quot;range&quot; max=&quot;40&quot; min=&quot;20&quot; id=&quot;range&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS 样式代码如下：/* 文件：style.css */ #cantainer { text-align: center; } #content { width: 640px; margin: 0 auto; position: relative; } #canvas { position: absolute; } video { width: 640px; height: 360px; } input { vertical-align: middle; } 布局效果如下图：弹幕布局定义接口，构造假数据弹幕中的弹幕数据正常情况下应该是通过与后台数据交互请求回来，所以我们需要先定义数据接口，并构造假数据来实现前端逻辑。数据字段定义：value：表示弹幕的内容（必填）time：表示弹幕出现的时间（必填）speed：表示弹幕移动的速度（选填）color：表示弹幕文字的颜色（选填）fontSize：表示弹幕的字体大小（选填）opacity：表示弹幕文字的透明度（选填）上面的 value 和 time 是必填参数，其他的选填参数可以在前端设置默认值。前端定义的假数据如下：/* 文件：index.js */ const data = [ { value: &#39;这是第一条弹幕&#39;, speed: 2, time: 0, color: &#39;red&#39;, fontSize: 20 }, { value: &#39;这是第二条弹幕&#39;, time: 1 } ]; 实现前端弹幕的逻辑我们希望是把弹幕封装成一个功能，只要有需要的地方就可以使用，从而实现复用，那么不同的地方使用这个功能通常的方式是 new 一个实例，传入当前使用该功能对应的参数，我们也使用这种方式来实现，所以我们需要封装一个统一的构造函数或者类，参数为当前的 canvas 元素、video 元素和一个 options 对象，options 里面的 data 属性为我们的弹幕数据，之所以不直接传入 data 是为了后续参数的扩展，严格遵循开放封闭原则，这里我们就统一使用 ES6 的 class 类来实现。创建弹幕功能的类及基本参数处理布局时需要注意 Canvas 的默认宽为 300px，高为 150px，我们要保证 Canvas 完全覆盖整个视频，需要让 Canvas 与 video 宽高相等。因为我们不确定每一个使用该功能的视频的宽高都是一样的，所以 Canvas 画布的宽高并没有通过 CSS 来设置，而是通过 JS 在类创建实例初始化属性的时候动态设置。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); } } 应该挂在实例上的属性除了有当前的 canvas 元素、video 元素、弹幕数据的默认选项以及弹幕数据之外，还应该有一个代表当前是否渲染弹幕的参数，因为视频暂停的时候，弹幕也是暂停的，所以没有重新渲染，因为是否暂停与弹幕是否渲染的状态是一致的，所以我们这里就用 isPaused 参数来代表当前是否暂停或重新渲染弹幕，值类型为布尔值。创建构造每一条弹幕的类我们知道，后台返回给我们的弹幕数据是一个数组，这个数组里的每一个弹幕都是一个对象，而对象上有着这条弹幕的信息，如果我们需要在每一个弹幕对象上再加一些新的信息或者在每一个弹幕对象的处理时用到了当前弹幕功能类 CanvasBarrage 实例的一些属性值，取值显然是不太方便的，这样为了后续方便扩展，遵循开放封闭原则，我们把每一个弹幕的对象转变成同一个类的实例，所以我们创建一个名为 Barrage 的类，让我们每一条弹幕的对象进入这个类里面走一遭，挂上一些扩展的属性。/* 文件：index.js */ class Barrage { constructor(item, ctx) { this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 } } 在我们的 CanvasBarrage 类上有一个存储弹幕数据的数组 data，此时我们需要给 CanvasBarrage 增加一个属性用来存放 “加工” 后的每条弹幕对应的实例。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // ********** 以下为新增代码 ********** // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // ********** 以上为新增代码 ********** } } 其实通过上面操作以后，我们相当于把 data 里面的每一条弹幕对象转换成了一个 Barrage 类的一个实例，把当前的上下文 this 传入后可以随时在每一个弹幕实例上获取 CanvasBarrage 类实例的属性，也方便我们后续扩展方法，遵循这种开放封闭原则的方式开发，意义是不言而喻的。在 CanvasBarrage 类实现渲染所有弹幕的 render 方法CanvasBarrage 的 render 方法是在创建弹幕功能实例的时候应该渲染 Canvas 所以应该在 CanvasBarrage 中调用，在 render 内部，每一次渲染之前都应该先将 Canvas 画布清空，所以需要给当前的 CanvasBarrage 类新增一个属性用于存储 Canvas 画布的内容。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // ********** 以下为新增代码 ********** // Canvas 画布的内容 this.context = canvas.getContext(&quot;2d&quot;); // 渲染所有的弹幕 this.render(); // ********** 以上为新增代码 ********** } // ********** 以下为新增代码 ********** render() { // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) { // 递归渲染 requestAnimationFrame(this.render.bind(this)); } } // ********** 以上为新增代码 ********** } 在上面的 CanvasBarrage 的 render 函数中，清空时由于 Canvas 性能比较好，所以将整个画布清空，所以从坐标 (0, 0) 点，清空的宽高为整个 Canvas 画布的宽高。只要视频是在播放状态应该不断的调用 render 方法实现清空画布、渲染弹幕、判断是否暂停，如果非暂停状态继续渲染，所以我们用到了递归调用 render 去不断的实现渲染，但是递归时如果直接调用 render，性能特别差，程序甚至会挂掉，以往这种情况我们会在递归外层加一个 setTimeout 来定义一个短暂的递归时间，但是这个过程类似于动画效果，如果使用 setTimeout 其实是将同步代码转成了异步执行，会增加不确定性导致画面出现卡顿的现象。这里我们使用 H5 的新 API requestAnimationFrame，可以在平均 1/60 S 内帮我执行一次该方法传入的回调，我们直接把 render 函数作为回调函数传入 requestAnimationFrame，该方法是按照帧的方式执行，动画流畅，需要注意的是，render 函数内使用了 this，所以应该处理一下 this 指向问题。由于我们使用面向对象的方式，所以渲染弹幕的具体细节，我们抽离出一个单独的方法 renderBarrage，接下来看一下 renderBarrage 的实现。CanvasBarrage 类 render 内部 renderBarrage 的实现/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext(&#39;2d&#39;); // 渲染所有的弹幕 this.render(); } render() { // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) { // 递归渲染 requestAnimationFrame(this.render.bind(this)); } } // ********** 以下为新增代码 ********** renderBarrage() { // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; { // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (time &gt;= barrage.time) { // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) { // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; } } }); } // ********** 以上为新增代码 ********** } 此处的 renderBarrage 方法内部主要对每一条弹幕实例所设置的出现时间和视频的播放时间做对比，如果视频的播放时间大于等于了弹幕出现的时间，说明弹幕需要绘制在 Canvas 画布内。之前我们的每一条弹幕实例的属性可能不全，弹幕的其他未传参数并没有初始化，所以为了最大限度的节省性能，我们在弹幕该第一次绘制的时候去初始化参数，等到视频播放的时间变化再去重新绘制时，不再初始化参数，所以初始化参数的方法放在了判断弹幕出现时间的条件里面执行，又设置了代表弹幕实例是不是初始化了的参数 isInited，初始化函数 init 执行过一次后，马上修改 isInited 的值，保证只初始化参数一次。在 renderBarrage 方法中我们可以看出来，其实我们是循环了专门存放每一条弹幕实例（Barrage 类的实例）的数组，我们在内部用实例去调用的方法 init 应该是在 Barrage 类的原型上，下面我们去 Barrage 类上实现 init 的逻辑。Barrage 类 init 的实现/* 文件：index.js */ class Barrage { constructor(item, ctx) { this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 } // ********** 以下为新增代码 ********** init() { this.opacity = this.item.opacity || this.ctx.opacity; this.color = this.item.color || this.ctx.color; this.fontSize = this.item.fontSize || this.ctx.fontSize; this.speed = this.item.speed || this.ctx.speed; // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断） let span = document.createElement(&#39;span&#39;); // 能决定宽度的只有弹幕的内容和文字的大小，和字体 // 字体默认为微软雅黑，我们就不做设置了 span.innerText = this.value; span.style.font = this.fontSize + &#39;px &quot;Microsoft YaHei&quot;&#39;; // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素 span.style.position = &#39;absolute&#39;; document.body.appendChild(span); // 放入页面 this.width = span.clientWidth; // 记录弹幕的宽度 document.body.removeChild(span); // 从页面移除 // 存储弹幕出现的横纵坐标 this.x = this.ctx.canvas.width; this.y = this.ctx.canvas.height; // 处理弹幕纵向溢出的边界处理 if (this.y &lt; this.fontSize) { this.y = this.fontSize; } if (this.y &gt; this.ctx.canvas.height - this.fontSize) { this.y = this.ctx.canvas.height - this.fontSize; } } // ********** 以上为新增代码 ********** } 在上面代码的 init 方法中我们其实可以看出，每条弹幕实例初始化的时候初始的信息除了之前说的弹幕的基本参数外，还获取了每条弹幕的宽度（用于后续做弹幕是否已经完全移出屏幕的边界判断）和每一条弹幕的 x 和 y 轴方向的坐标并为了防止弹幕在 y 轴显示不全做了边界处理。实现每条弹幕的渲染和弹幕移除屏幕的处理我们当时在 CanvasBarrage 类的 render 方法中的渲染每个弹幕的方法 renderBarrage中（原谅这么啰嗦，因为到现在内容已经比较多，说的具体一点方便知道是哪个步骤，哈哈）只做了对每一条弹幕实例的初始化操作，并没有渲染在 Canvas 画布中，这时我们主要做两部操作，实现每条弹幕渲染在画布中和左侧移出屏幕不再渲染的边界处理。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext(&#39;2d&#39;); // 渲染所有的弹幕 this.render(); } render() { // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) { // 递归渲染 requestAnimationFrame(this.render.bind(this)); } } renderBarrage() { // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; { // ********** 以下为改动的代码 ********** // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) { // ********** 以上为改动的代码 ********** // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) { // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; } // ********** 以下为新增代码 ********** barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) { barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 } // ********** 以上为新增代码 ********** } }); } } 每个弹幕实例都有一个 speed 属性，该属性代表着弹幕移动的速度，换个说法其实就是每次减少的 x 轴的差值，所以我们其实是通过改变 x 轴的值再重新渲染而实现弹幕的左移，我们创建了一个标识 flag 挂在每个弹幕实例下，代表是否已经离开屏幕，如果离开则更改 flag 的值，使外层的 CanvasBarrage 类的 render 函数再次递归时不进入渲染程序。每一条弹幕具体是怎么渲染的，通过代码可以看出每个弹幕实例在 x 坐标改变后都调用了实例方法 render 函数，注意此 render 非彼 render，该 render 函数属于 Barrage 类，目的是为了渲染每一条弹幕，而 CanvasBarrage 类下的 render，是为了在视频时间变化时清空并重新渲染整个 Canvas 画布。Barrage 类下的 render 方法的实现/* 文件：index.js */ class Barrage { constructor(item, ctx) { this.value = item.value; // 弹幕的内容 this.time = item.time; // 弹幕出现的时间 this.item = item; // 每一个弹幕的数据对象 this.ctx = ctx; // 弹幕功能类的执行上下文 } init() { this.opacity = this.item.opacity || this.ctx.opacity; this.color = this.item.color || this.ctx.color; this.fontSize = this.item.fontSize || this.ctx.fontSize; this.speed = this.item.speed || this.ctx.speed; // 求自己的宽度，目的是用来校验当前是否还要继续绘制（边界判断） let span = document.createElement(&#39;span&#39;); // 能决定宽度的只有弹幕的内容和文字的大小，和字体 // 字体默认为微软雅黑，我们就不做设置了 span.innerText = this.value; span.style.font = this.fontSize + &#39;px &quot;Microsoft YaHei&#39;; // span 为行内元素，取不到宽度，所以我们通过定位给转换成块级元素 span.style.position = &#39;absolute&#39;; document.body.appendChild(span); // 放入页面 this.width = span.clientWidth; // 记录弹幕的宽度 document.body.removeChild(span); // 从页面移除 // 存储弹幕出现的横纵坐标 this.x = this.ctx.canvas.width; this.y = this.ctx.canvas.height; // 处理弹幕纵向溢出的边界处理 if (this.y &lt; this.fontSize) { this.y = this.fontSize; } if (this.y &gt; this.ctx.canvas.height - this.fontSize) { this.y = this.ctx.canvas.height - this.fontSize; } } // ********** 以下为新增代码 ********** render() { this.ctx.context.font = this.fontSize + &#39;px &quot;Microsoft YaHei&quot;&#39;; this.ctx.context.fillStyle = this.color; this.ctx.context.fillText(this.value, this.x, this.y); } // ********** 以上为新增代码 ********** } 从上面新增代码我们可以看出，其实 Barrage 类的 render 方法只是将每一条弹幕的字号、颜色、内容、坐标等属性通过 Canvas 的 API 添加到了画布上。实现播放、暂停事件还记得我们的 CanvasBarrage 类里面有一个属性 isPaused，属性值控制了我们是否递归渲染，这个属性与视频暂停的状态是一致的，我们在播放的时候，弹幕不断的清空并重新绘制，当暂停的时候弹幕也应该跟着暂停，说白了就是不在调用 CanvasBarrage 类的 render 方法，其实就是在暂停、播放的过程中不断的改变 isPaused 的值即可。还记得我们之前构造的两条假数据 data 吧，接下来我们添加播放、暂停事件，来尝试使用一下我们的弹幕功能。/* 文件：index.js */ // 实现一个简易选择器，方便获取元素，后面获取元素直接调用 $ const $ = document.querySelector.bind(document); // 获取 Canvas 元素和 Video 元素 const canvas = $(&#39;#canvas&#39;); const video = $(&#39;#video&#39;); const canvasBarrage = new CanvasBarrage(canvas, video, { data }); // 添加播放事件 video.addEventListener(&#39;play&#39;, function () { canvasBarrage.isPaused = false; canvasBarrage.render(); }); // 添加暂停事件 video.addEventListener(&#39;pause&#39;, function () { canvasBarrage.isPaused = true; }); 实现发送弹幕事件/* 文件：index.js */ $(&#39;#add&#39;).addEventListener(&#39;click&#39;, function () { let time = video.currentTime; // 发送弹幕的时间 let value = $(&#39;#text&#39;).value; // 发送弹幕的文字 let color = $(&#39;#color&#39;).value; // 发送弹幕文字的颜色 let fontSize = $(&#39;#range&#39;).value; // 发送弹幕的字体大小 let sendObj = { time, value, color, fontSize }; //发送弹幕的参数集合 canvasBarrage.add(sendObj); // 发送弹幕的方法 }); 其实我们发送弹幕时，就是向 CanvasBarrage 类的 barrages 数组里添加了一条弹幕的实例，我们单独封装了一个 add 的实例方法。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext(&#39;2d&#39;); // 渲染所有的弹幕 this.render(); } render() { // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) { // 递归渲染 requestAnimationFrame(this.render.bind(this)); } } renderBarrage() { // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; { // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) { // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) { // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; } barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) { barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 } } }); } // ********** 以下为新增代码 ********** add(item) { this.barrages.push(new Barrage(item, this)); } // ********** 以上为新增代码 ********** } 拖动进度条实现弹幕的前进和后退其实我们发现，弹幕虽然实现了正常的播放、暂停以及发送，但是当我们拖动进度条的时候弹幕应该是跟着视频时间同步播放的，现在的弹幕一旦播放过无论怎样拉动进度条弹幕都不会再出现，我们现在就来解决这个问题。/* 文件：index.js */ // 拖动进度条事件 video.addEventListener(&#39;seeked&#39;, function () { canvasBarrage.reset(); }); 我们在事件内部其实只是调用了一下 CanvasBarrage 类的 reset 方法，这个方法就是在拖动进度条的时候来帮我们初始化弹幕的状态。/* 文件：index.js */ class CanvasBarrage { constructor(canvas, video, options = {}) { // 如果没有传入 canvas 或者 video 直接跳出 if (!canvas || !video) return; this.canvas = canvas; // 当前的 canvas 元素 this.video = video; // 当前的 video 元素 // 设置 canvas 与 video 等高 this.canvas.width = video.clientWidth; this.canvas.height = video.clientHeight; // 默认暂停播放，表示不渲染弹幕 this.isPaused = true; // 没传参数的默认值 const defaultOptions = { fontSize: 20, color: &#39;gold&#39;, speed: 2, opacity: 0.3, data: [] }; // 对象的合并，将默认参数对象的属性和传入对象的属性统一放到当前实例上 Object.assign(this, defaultOptions, options); // 存放所有弹幕实例，Barrage 是创造每一条弹幕的实例的类 this.barrages = this.data.map(item =&gt; new Barrage(item, this)); // Canvas 画布的内容 this.context = canvas.getContext(&#39;2d&#39;); // 渲染所有的弹幕 this.render(); } render() { // 渲染整个弹幕 // 第一次先进行清空操作，执行渲染弹幕，如果没有暂停，继续渲染 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // 渲染弹幕 this.renderBarrage(); if (this.isPaused == false) { // 递归渲染 requestAnimationFrame(this.render.bind(this)); } } renderBarrage() { // 将数组的弹幕一个一个取出，判断时间和视频的时间是否符合，符合就执行渲染此弹幕 let time = this.video.currentTime; this.barrages.forEach(barrage =&gt; { // 当视频时间大于等于了弹幕设置的时间，那么开始渲染（时间都是以秒为单位） if (!barrage.flag &amp;&amp; time &gt;= barrage.time) { // 初始化弹幕的各个参数，只有在弹幕将要出现的时候再去初始化 // 节省性能，初始化后再进行绘制 // 如果没有初始化，先去初始化一下 if (!barrage.isInited) { // 初始化后下次再渲染就不需要再初始化了，所以创建一个标识 isInited barrage.init(); barrage.isInited = true; } barrage.x -= barrage.speed; barrage.render(); // 渲染该条弹幕 if (barrage.x &lt; barrage.width * -1) { barrage.flag = true; // 是否出去了，出去了，做停止渲染的操作 } } }); } add(item) { this.barrages.push(new Barrage(item, this)); } // ********** 以下为新增代码 ********** reset() { // 先清空 Canvas 画布 this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); let time = this.video.currentTime; // 循环每一条弹幕实例 this.barrages.forEach(barrage =&gt; { // 更改已经移出屏幕的弹幕状态 barrage.flag = false; // 当拖动到的时间小于等于当前弹幕时间是，重新初始化弹幕的数据，实现渲染 if (time &lt;= barrage.time) { barrage.isInited = false; } else { barrage.flag = true; // 否则将弹幕的状态设置为以移出屏幕 } }); } // ********** 以上为新增代码 ********** } 其实 reset 方法中值做了几件事，从而实现了拖动进度条弹幕的 “前进” 和 “后退” 功能。清空 Canvas 画布；获取当前进度条拖动位置的时间；循环存储弹幕实例的数组；将所有弹幕更改为未移出屏幕；判断拖动时间和每条弹幕的时间；在当前时间以后的弹幕重新初始化数据；以前的弹幕更改为已移出屏幕。使用 WebSocket 和 Redis 实现前后端通信及数据存储服务器代码的实现要使用 WebSocket 和 Redis 首先需要去安装 ws、redis 依赖，在项目根目录执行下面命令：$ npm install ws redis 我们创建一个 server.js 文件，用来写服务端的代码：/* 文件：index.js */ const WebSocket = require(&#39;ws&#39;); // 引入 WebSocket const redis = require(&#39;redis&#39;); // 引入 redis // 初始化 WebSocket 服务器，端口号为 3000 const wss = new WebSocket.Server({ port: 3000 }); // 创建 redis 客户端 const client = redis.createClient(); // key value // 原生的 websocket 就两个常用的方法 on(&#39;message&#39;)、on(&#39;send&#39;) wss.on(&#39;connection&#39;, function (ws) { // 监听连接 // 连接上需要立即把 redis 数据库的数据取出返回给前端 client.lrange(&#39;barrages&#39;, 0, -1, function (err, applies) { // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象 applies = applies.map(item =&gt; JSON.parse(item)); // 使用 websocket 服务器将 redis 数据库的数据发送给前端 // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串 ws.send(JSON.stringify({ type: &#39;INIT&#39;, data: applies })); }); // 当服务器收到消息时，将数据存入 redis 数据库 ws.on(&#39;message&#39;, function (data) { // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库 client.rpush(&#39;barrages&#39;, data, redis.print); // 再将当前这条数据返回给前端 // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串 ws.send(JSON.stringify({ type: &#39;ADD&#39;, data: JSON.parse(data) })); }); }); 服务器的逻辑很清晰，在 WebSocket 连接上时，立即获取 Redis 数据库的所有弹幕数据返回给前端，当前端点击发送弹幕按钮发送数据时，接收数据存入 Redis 数据库中并打印验证数据是否成功存入，再通过 WebSocket 服务把当前这一条数返回给前端，需要注意一下几点：从 Redis 数据库中取出全部弹幕数据的数组内部都存储的是字符串，需要使用 JSON.parse 方法进行解析；将数据发送前端时，最外层要使用 JSON.stringify 重新转换成字符串发送；在初始化阶段 WebSocket 发送所有数据和前端添加新弹幕 WebSocket 将弹幕的单条数据重新返回时，需要添加对应的 type 值告诉前端，当前的操作行为。前端代码的修改在没有实现后端代码之前，前端使用的是 data 的假数据，是在添加弹幕事件中，将获取的新增弹幕信息通过 CanvasBarrage 类的 add 方法直接创建 Barrage 类的实例，并加入到存放弹幕实例的 barrages 数组中。现在我们需要更正一下交互逻辑，在发送弹幕事件触发时，我们应该先将获取的单条弹幕数据通过 WebSocket 发送给后端服务器，在服务器重新将消息返还给我们的时候，去将这条数据通过 CanvasBarrage 类的 add 方法加入到存放弹幕实例的 barrages 数组中。还有在页面初始化时，我们之前在创建 CanvasBarrage 类实例的时候直接传入了 data 假数据，现在需要通过 WebSocket 的连接事件，在监听到连接 WebSocket 服务时，去创建 CanvasBarrage 类的实例，并直接把服务端返回 Redis 数据库真实的数据作为参数传入，前端代码修改如下：/* 文件：index.js */ // ********** 下面代码被删掉了 ********** // let canvasBarrage = new CanvasBarrage(canvas, video, { // data // }); // ********** 上面代码被删掉了 ********** // ********** 以下为新增代码 ********** let canvasBarrage; // 创建 WebSocket 连接 const socket = new WebSocket(&#39;ws://localhost:3000&#39;); // 监听连接事件 socket.onopen = function () { // 监听消息 socket.onmessage = function (e) { // 将收到的消息从字符串转换成对象 let message = JSON.parse(e.data); // 根据不同情况判断是初始化还是发送弹幕 if (message.type === &#39;INIT&#39;) { // 创建 CanvasBarrage 的实例添加弹幕功能，传入真实的数据 canvasBarrage = new CanvasBarrage(canvas, video, { data: message.data }); } else if (message.type === &#39;ADD&#39;) { // 如果是添加弹幕直接将 WebSocket 返回的单条弹幕存入 barrages 中 canvasBarrage.add(message.data); } } } // ********** 以上为新增代码 ********** $(&#39;#add&#39;).addEventListener(&#39;click&#39;, function () { let time = video.currentTime; // 发送弹幕的时间 let value = $(&#39;#text&#39;).value; // 发送弹幕的文字 let color = $(&#39;#color&#39;).value; // 发送弹幕文字的颜色 let fontSize = $(&#39;#range&#39;).value; // 发送弹幕的字体大小 let sendObj = { time, value, color, fontSize }; //发送弹幕的参数集合 // ********** 以下为新增代码 ********** socket.send(JSON.stringify(sendObj)); // ********** 以上为新增代码 ********** // ********** 下面代码被删掉了 ********** // canvasBarrage.add(sendObj); // 发送弹幕的方法 // ********** 上面代码被删掉了 ********** }); 现在我们可以打开 index.html 文件并启动 server.js 服务器，就可以实现真实的视频弹幕操作了，但是我们还是差了最后一步，当前的服务只能同时服务一个人，但真实的场景是同时看视频的有很多人，而且发送的弹幕是共享的。实现多端通信、弹幕共享我们需要处理两件事情：第一件事情是实现多端通信共享数据库信息；第二件事情是当有人离开的时候清除关闭的 WebSocket 对象。/* 文件：server.js */ const WebSocket = require(&#39;ws&#39;); // 引入 WebSocket const redis = require(&#39;redis&#39;); // 引入 redis // 初始化 WebSocket 服务器，端口号为 3000 const wss = new WebSocket.Server({ port: 3000 }); // 创建 redis 客户端 const client = redis.createClient(); // key value // ********** 以下为新增代码 ********** // 存储所有 WebSocket 用户 const clientsArr = []; // ********** 以上为新增代码 ********** // 原生的 websocket 就两个常用的方法 on(&#39;message&#39;)、on(&#39;send&#39;) wss.on(&#39;connection&#39;, function (ws) { // ********** 以下为新增代码 ********** // 将所有通过 WebSocket 连接的用户存入数组中 clientsArr.push(ws); // ********** 以上为新增代码 ********** // 监听连接 // 连接上需要立即把 redis 数据库的数据取出返回给前端 client.lrange(&#39;barrages&#39;, 0, -1, function (err, applies) { // 由于 redis 的数据都是字符串，所以需要把数组中每一项转成对象 applies = applies.map(item =&gt; JSON.parse(item)); // 使用 websocket 服务器将 redis 数据库的数据发送给前端 // 构建一个对象，加入 type 属性告诉前端当前返回数据的行为，并将数据转换成字符串 ws.send(JSON.stringify({ type: &#39;INIT&#39;, data: applies })); }); // 当服务器收到消息时，将数据存入 redis 数据库 ws.on(&#39;message&#39;, function (data) { // 向数据库存储时存的是字符串，存入并打印数据，用来判断是否成功存入数据库 client.rpush(&#39;barrages&#39;, data, redis.print); // ********** 以下为修改后的代码 ********** // 循环数组，将某一个人新发送的弹幕在存储到 Redis 之后返回给所有用户 clientsArr.forEach(w =&gt; { // 再将当前这条数据返回给前端 // 同样添加 type 字段告诉前端当前行为，并将数据转换成字符串 w.send(JSON.stringify({ type: &#39;ADD&#39;, data: JSON.parse(data) })); }); // ********** 以上为修改后的代码 ********** }); // ********** 以下为新增代码 ********** // 监听关闭连接事件 ws.on(&#39;close&#39;, function () { // 当某一个人关闭连接离开时，将这个人从当前存储用户的数组中移除 clientsArr = clientsArr.filter(client =&gt; client != ws); }); // ********** 以上为新增代码 ********** }); 上面就是 Canvas + WebSocket + Redis 视频弹幕的实现，实现过程可能有些复杂，但整个过程写的还是比较详细，可能需要一定的耐心慢慢的读完，并最好一步一步跟着写一写，希望这篇文章可以让读到的人解决视频弹幕类似的需求，真正理解整个过程和开放封闭原则，认识到前端面向对象编程思想的美。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://www.overtaking.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://www.overtaking.top/tags/CSS/"},{"name":"Canvas","slug":"Canvas","permalink":"https://www.overtaking.top/tags/Canvas/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://www.overtaking.top/tags/WebSocket/"},{"name":"Redis","slug":"Redis","permalink":"https://www.overtaking.top/tags/Redis/"}]},{"title":"异步发展流程 —— 异步编程 async/await","date":"2018-06-15T13:20:40.000Z","path":"20180615212040/","text":"前言这篇文章是异步发展流程系列的最后一篇，可能会涉及 Promise、Generators、co 等前置知识，如果对这些不是很了解可以看这个系列的前三篇：异步发展流程 —— Promise 的基本使用异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise异步发展流程 —— Generators + co 让异步更优雅如果已经具备这些前置知识，那我们继续看看今天的主角，JavaScript 异步编程的终极大招 async/await。async/await 简介async/await 指的是两个关键字，是 ES7 引入的新标准，async 关键字用于声明 async 函数，await 关键字用来等待异步（必须是 Promise 实例）操作，说白了 async/await 就是 Generators + co 的语法糖。async/await 和 Generators + co 的写法非常的相似，只是把用于声明 Generator 函数的 * 关键字替换成了 async 并写在了 function 关键字的前面，把 yield 关键字替换成了 await；另外，async 函数是基于 Promise 的，await 关键字后面等待的异步操作必须是一个 Promise 实例或基本类型的值，基本类型值的执行效果等同于同步，与 Generator 不同的是，await 关键字前可以使用变量去接收这个正在等待的 Promise 实例执行后的结果。async 函数的基本用法async 函数返回一个 Promise 实例，可以使用 then 方法添加回调函数。当函数执行的时候，只要遇到 await 就会等待，直到 await 后面的同步或异步操作完成，再接着执行函数体内后面的语句。async 函数声明async 的声明方式大概有以下几种：/* async 函数声明 */ // 函数声明 async function fn() {} // 函数表达式 const fn = async function () {}; // 箭头函数 const fn = async () =&gt; {}; // 作为对象的方法 const obj = { async fn() {} }; // 作为 class 的方法 class Person(name) { constructor () { this.name = name; } async getName() { const name = await this.name; return name; } } 在上一篇介绍 Generators + co 的文章中我们举了一个例子，使用 Node.js 的 fs 模块连续异步读文件，第一个文件名为 a.txt，读到的内容为 b.txt，作为要读的第二个文件的文件名，继续读 b.txt 后将读到的内容 “Hello world” 打印出来。我们来使用 async/await 的方式来实现一下：/* async 函数实现文件读取 */ // 引入依赖 const fs = require(&#39;fs&#39;); const util = require(&#39;util&#39;); // 将 fs.readFile 转换成 Promise const readFile = util.promisify(fs.readFile); // 声明 async 函数 async function read(file) { const aData = await readFile(file, &#39;utf8&#39;); const bData = await readFile(aData, &#39;utf8&#39;); return bData; } // 调用 async 函数 read(&#39;a.txt&#39;).then(data =&gt; { console.log(data); // Hello world }); 其实对比上一篇文章 Generator 的案例，与 Generator 函数一样，写法像同步，执行是异步，不同的是我们即没有手动调用 next 方法，也没有借助 co 库，其实是 async 函数内部集成了类似于 co 的执行器，帮我们在异步完成后自动向下执行代码，所以说 async/await 是 Generators + co 的语法糖。async 函数错误处理async 函数内部如果执行错误可以有三种方式进行错误处理：在 await 后面的 Promise 实例使用 then 方法错误回调或 catch 方法进行错误处理；如果有多个 await，可以在 async 函数执行完后使用 catch 方法统一处理；由于 async 内部代码是同步的写法，多个 await 的情况也可以使用 try...catch... 进行处理。需要注意的是，如果在 async 函数内部使用了 try...catch... 又在函数执行完后使用了 catch，错误会优先被同步的 try...catch... 捕获到，后面的 catch 就不会再捕获了。/* async 函数异常捕获 */ // 第一种 async function fn() { const result = await Promise.reject(&#39;error&#39;).catch(err =&gt; { console.log(err); }); } fn(); // error // 第二种 async function fn() { try { const val1 = await Promise.reject(&#39;error&#39;); const val2 = await Promise.resolve(&#39;success&#39;); } catch (e) { console.log(e); } } fn(); // error // 第三种 async function fn() { const val1 = await Promise.resolve(&#39;success&#39;); const val2 = await Promise.reject(&#39;error&#39;); } fn().catch((err =&gt; console.log(err))); // error await 异步并发在 async 函数中，如果有多个 await 互不依赖，这种情况下如果执行一个，等待一个完成，再执行一个，再等待完成，这样是很浪费性能的，所以我们要把这些异步操作同时触发。假设我们异步读取两个文件，且这两个文件不相关，我可以使用下面的方式来实现：/* await 异步并发 */ // 前置 const fs = require(&#39;fs&#39;); const util = require(&#39;util&#39;); const readFile = util.promisify(fs.readFile); // 需要改进的 async 函数 async function fn() { const aData = await readFile(&#39;a.txt&#39;, &#39;utf8&#39;); const bData = await readFile(&#39;b.txt&#39;, &#39;utf8&#39;); return [aData, bData]; } fn(); // 在 async 函数外部触发异步 const aDataPromise = readFile(&#39;a.txt&#39;, &#39;utf8&#39;); const bDataPromise = readFile(&#39;b.txt&#39;, &#39;utf8&#39;); async function fn() { const aData = await aDataPromise; const bData = await bDataPromise; return [aData, bData]; } fn(); // 使用 Promise.all async function fn() { const dataArr = await Promise.all( readFile(&#39;a.txt&#39;, &#39;utf8&#39;), readFile(&#39;a.txt&#39;, &#39;utf8&#39;) ); return dataArr; } fn(); 使用 async/await 的注意点使用 async/await 应注意以下几点：对 await 习惯性错误处理；await 命令后互不依赖的异步应同时触发；async 函数中，函数的执行上/下文发生变化时，不能使用 await（如使用 forEach 循环的回调中）。针对第一点，在 async 函数中 await 命令后面大多情况下是 Promise 异步操作，运行结果可能出现错误并调用 reject 函数，最好对这个 await 语句进行错误处理，具体方式参照 async 函数基本用法中关于错误处理的内容。针对第二点，如果两个或多个 await 命令后的异步操作没有依赖关系，执行时，需先触发第一个，等待异步完成，再触发第二个，再等异步完成，依次类推，这样比较耗时，性能不好，所以应该将这些异步操作同时触发，触发方式参照 async 函数基本用法中的 await 异步并发的内容。针对第三点，如果声明一个 async 函数并传入一个数组，数组里面存储的都是 Promise 实例，若使用 forEach 循环数组，由于函数的执行上/下文发生了变化，此时使用 await 命令会报错。/* 循环内使用 await */ // 创建 Promise 实例 const p1 = Promise.resolve(&#39;p1 success&#39;); const p2 = Promise.resolve(&#39;p2 success&#39;); const p3 = Promise.resolve(&#39;p3 success&#39;); // async 函数 async function fn(promises) { promise.forEach(function (promise) { await promise; }); } fn([p1, p2, p3]); // 执行时报错 // 修改方式 async function fn(promises) { for (let i = 0; i &lt; promises.length; i++) { await pormises[i]; } } fn([p1, p2, p3]); // 正常执行 总结async/await 的实现原理，其实就是在 async 函数内部逻辑映射成了 Generator 函数并集成了一个类似于 co 的执行器，所以我们使用 async/await 的时候，代码更简洁，没有了自己触发遍历器的 next 或调用 co 充当执行器的过程，只需要关心 async 函数的内部逻辑就可以了，因为写法与同步相同，更提高了代码的可读性，所以说 async/await 是异步编程的终极大招。由于 async/await 是 ES7 规范，在浏览器端的支持并不是那么的友好，所以现在这种写法多用在 Node.js 的异步操作当中，在 Node.js 框架 Koa 2.x 版本得到广泛应用。最后希望大家在读过异步发展流程这个系列之后，对 JavaScript 异步已经有了较深的认识，并可以在不同情况下游刃有余的使用这些处理异步的编程手段。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"ES7","slug":"ES7","permalink":"https://www.overtaking.top/tags/ES7/"},{"name":"async/await","slug":"async-await","permalink":"https://www.overtaking.top/tags/async-await/"}]},{"title":"异步发展流程 —— Generators + co 让异步更优雅","date":"2018-06-14T08:14:13.000Z","path":"20180614161413/","text":"Generators 简介Generator 函数是 ES6 提供的一种异步编程解决方案，是一个生成器，用于生成一个遍历器的函数，语法行为与传统函数完全不同。Iterator 遍历器JavaScript 原有的表示 “集合” 的数据结构，主要有 Array 和 Object，在 ES6 中又加入了 Set 和 Map，这样就有了四种数据集合，还可以组合使用它们，如数组的成员是 Map 或 Object，这样就需要一种统一的接口机制，用来处理所有不同的数据结构。遍历器 Iterator 就是这样一种机制，它是一种接口，为不同的数据结构提供统一的、简便的访问机制，任何数据结构只要部署了 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员。Iterator 遍历器其实就是一个指针对象，上面有 next 方法，第一次调用 next 指针指向数据结构的第一个成员，第二次 next 调用指针指向第二个成员，直到指针指向最后一个成员。我们可以使用 ES6 的展开运算符 ... 和 for...of... 去遍历带有 Iterator 接口的数据结构，需要注意的是，Object 本身不具备 Iterator 接口，所以我们无法通过 ... 把一个对象扩展到一个数组中，并且会报错，我们可以通过代码手动将 Object 类型实现 Iterator 接口。/* 给对象扩展 Iterator 接口 */ // 通过 Generator 函数给 Object 扩展 Iterator 接口 Object.prototype[Symbol.iterator] = function* () { for (var key in this) { yield this[key]; } } // 测试 Iterator 接口 const obj = { a: 1, b: 2, c: 3 }; const arr = [...obj]; console.log(arr); // [1, 2, 3] 上面我们其实是通过 ES6 的 Generator 函数简单粗暴的给 Object 类型实现了 Iterator 接口，后面我们会简单模拟 Generator 生成器。模拟 GeneratorGenerator 函数是一个生成器，调用后会返回给我们一个 Iterator 遍历器对象，在对象中有一个 next 方法，调用一次 next，帮我遍历一次，返回值为一个对象，内部有 value 和 done 两个属性，value 属性代表当前遍历的值，done 属性代表是否遍历完成，如果遍历完成后继续调用 next，返回的对象中 value 属性值为 undefined，done 属性值为 true，这个遍历器在进行数据遍历时更像给我们提供了一个暂停功能，每次都需要手动调用 next 去进行下一次遍历。我们根据 Generator 的特性用 ES5 简单模拟一个遍历器生成函数：/* 模拟遍历器生成函数 */ function iterator(arr) { var i = 0; return { next: function () { var done = i &gt;= arr.length; var value = !done ? arr[i++] : undefined; return { value: value, done: done }; } }; } 测试一下模拟的遍历器生成函数：/* 测试 iterator 函数 */ var arr = [1, 3, 5]; // 遍历器 var result = iterator(arr); result.next(); // {value: 1, done: false} result.next(); // {value: 3, done: false} result.next(); // {value: 5, done: false} result.next(); // {value: undefined, done: true} Generator 的基本使用在普通的函数 function 关键字后加一个 * 就代表声明了一个生成器函数，执行后返回一个遍历器对象，每次调用遍历器的 next 方法时，遇到 yield 关键字暂停执行，并将 yield 关键字后面的值会作为返回对象中 value 的值，如果函数有返回值，会把返回值作为调用 next 方法进行遍历完成后返回的对象中 value 的值，果已经遍历完成，再次 next 调用这个 value 的值会变成 undefined。// 生成器函数 function* gen() { yield 1; yield 2; return 3; } // 遍历器 const it = gen(); it.next(); // {value: 1, done: false} it.next(); // {value: 2, done: false} it.next(); // {value: 3, done: true} it.next(); // {value: undefined, done: true} 在 Generator 函数中可以使用变量接收 yield 关键字执行后的返回值，只是接收的值并不是 yield 关键字后面表达式执行的结果，而是遍历器在下一次调用 next 方法时传入的参数。也就是说我们第一次调用 next 方法进行遍历时是不需要传递参数的，因为上面并没有变量来接收它，即使传参也会被忽略掉，我们用一个例子感受一下这种比较特殊的执行机制：// 生成器函数 function* gen() { const a = yield 1; const b = yield a; const c = yield b; return c; } // 遍历器 const it = gen(); it.next(); // {value: 1, done: false} it.next(2); // {value: 2, done: false} it.next(3); // {value: 3, done: false} it.next(4); // {value: 4, done: true} it.next(5); // {value: undefined, done: true} 如果已经遍历完成，并把上次遍历接收到的值作为返回值传递给返回对象 value 属性的值，后面再次调用 next 传入的参数也会被忽略，返回对象的 value 值为 undefined。在 Generator 函数中，如果在其他函数或方法调用的回调内部（函数的执行上/下文发生变化）不能直接使用 yield 关键字。/* 循环中使用 yield */ // 错误的写法 function* gen(arr) { arr.forEach(*item =&gt; { yield* item; }); } // 正确的写法 function* gen(arr) { for (let i = 0; i &lt; arr.length; i++) { yield arr[i]; } } 如果在一个 Generator 函数中调用了另一个 Generator 函数，在调用外层函数返回遍历器的 next 方法时是不会遍历内部函数返回的遍历器的。/* 合并生成器 —— 错误 */ // 外层的生成器函数 function* genOut() { yield &#39;a&#39;; yield genIn(); yield &#39;c&#39;; } // 内层的生成器函数 function* genIn() { yield &#39;b&#39;; } // 遍历器 const it = genOut(); it.next(); // {value: &#39;a&#39;, done: false} it.next(); // 返回 genIn 的遍历器对象 it.next(); // {value: &#39;c&#39;, done: false} it.next(); // {value: undefined, done: true} 上面代码如果想在调用 genOut 返遍历器的 next 方法时，同时遍历 genIn 调用后返回的遍历器，需要使用 yield* 表达式。/* 合并生成器 —— yield* */ // 外层的生成器函数 function* genOut() { yield &#39;a&#39;; yield* genIn(); yield &#39;c&#39;; } // 内层的生成器函数 function* genIn() { yield &#39;b&#39;; } // 遍历器 const it = genOut(); it.next(); // {value: &#39;a&#39;, done: false} it.next(); // {value: &#39;b&#39;, done: false} it.next(); // {value: &#39;c&#39;, done: false} it.next(); // {value: undefined, done: true} 在 genOut 返回的遍历器调用 next 遇到 yield* 表达式时帮我们去遍历了 genIn 返回的遍历器，其实 yield* 内部做了处理，等同于下面代码：/* 合并生成器 —— for of */ // 外层的生成器 function* genOut() { yield &#39;a&#39;; for (let v of genIn()) { yield v; } yield &#39;c&#39;; } // 内层的生成器 function* genIn() { yield &#39;b&#39;; } // 遍历器 const it = genOut(); it.next(); // {value: &#39;a&#39;, done: false} it.next(); // {value: &#39;b&#39;, done: false} it.next(); // {value: &#39;c&#39;, done: false} it.next(); // {value: undefined, done: true} Generators 与 Promise 结合Promise 也是 ES6 的规范，同样是解决异步的一种手段，如果对 Promise 还不了解，可以阅读下面两篇文章：异步发展流程 —— Promise 的基本使用异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise因为 Generator 函数在执行时遇到 yield 关键字会暂停执行，那么 yield 后面可以是异步操作的代码，比如 Promise，需要继续执行，就手动调用返回遍历器的 next 方法，因为中间有一个等待的过程，所以在执行异步代码的时候避免了回调函数的嵌套，在写法上更像同步，更容易理解。我们来设计一个 Generator 函数与 Promise 异步操作结合的使用场景，假设我们需要使用 Node.js 的 fs 模块读取一个文件 a.txt 的内容，而 a.txt 的内容是另一个需要读取文件 b.txt 的文件名，读取 b.txt 最后打印读取到的内容 “Hello world”。回调函数的实现：/* 连续读取文件 —— 异步回调 */ // 引入依赖 const fs = require(&#39;fs&#39;); fs.readFile(&#39;a.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; { if (!err) { fs.readFile(data, &#39;utf8&#39;, (err, data) =&gt; { if (!err) { console.log(data); // Hello world } }); } }); 上面代码因为只有两层回调函数嵌套，所以感觉没那么复杂，但是嵌套的回调函数多了，代码就不那么的优雅了，我们接下来使用 Generator 结合 Promise 来实现，为了方便将 fs 异步的方法转换成 Promise，我们引入 util 模块，并转换 readFile 方法。/* 连续读取文件 —— Generator + Promise */ // 引入依赖 const fs = require(&#39;fs&#39;); const util = require(&#39;util&#39;); // 将 readFile 方法转换成 Promise const read = util.promisify(fs.readFile); // 生成器函数 function* gen() { const aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;); const bData = yield read(aData, &#39;utf8&#39;); return bData; } // 遍历器 const it = gen(); it.next().value.then(data =&gt; { it.next(data).then(data =&gt; { console.log(data); // Hello world }); }); 我们只看 Generator 函数 gen 内部的执行，虽然是异步操作，但是在写法上几乎和同步没有区别，理解起来更容易，唯一美中不足的是，我们需要自己手动的调用遍历器的 next 和 Promise 实例的 then，这个问题 co 库可以帮我们解决。co 库的使用co 库的作者是著名的 Node.js 大神 tj，是基于 Generator 和 Promise 的，这个库能帮我们实现自动调用 Generator 函数返回遍历器的 next 方法，并执行 yield 后面 Promise 实例的 then 方法，所以每次 yield 后面的异步操作返回的必须是一个 Promise 实例，代码看起来像同步，执行其实是异步，不用自己手动进行下一次遍历，这更是我们想要的。由于 co 是一个第三方的模块，所以在使用时需要我们提前下载：$ npm install co 我们使用 co 来实现之前异步连续读文件的案例：/* 连续读取文件 —— Generator + co */ // 引入依赖 const fs = require(&#39;fs&#39;); const util = require(&#39;util&#39;); const co = require(&#39;co&#39;); // 将 readFile 方法转换成 Promise const read = util.promisify(fs.readFile); // 生成器函数 function* gen() { const aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;); const bData = yield read(aData, &#39;utf8&#39;); return bData; } // 使用 co 库代替手动调用 next co(gen()).then(data =&gt; { console.log(data); // Hello world }); 从上面代码可以看出，co 库的 co 函数参数是一个遍历器，即 Generator 函数执行后的返回结果，在 co 内部操作遍历器并遍历完成后返回了一个 Promise 实例，遍历器最终的返回结果的 value 值作为 then 方法回调的参数，所以我们可以使用 then 对结果进行后续的处理。co 库的实现原理我们其实在上面使用 co 的过程中对于 co 函数的内部做了什么已经有所了解，主要就是帮助我们调用遍历器的 next 和调用 yield 后面代码执行后返回 Promise 实例的 then，并在整个遍历结束后，返回一个新的 Promise 实例。下面我们根据上面分析的 co 函数的原理来模拟一个简易版的 co 库：/* 文件：myCo.js —— co 原理 */ // co 函数，it 为遍历器对象 function co(it) { // 返回 Promise 实例 return new Promise((resolve, reject) =&gt; { // 异步递归 function next(data) { // 第一次调用 next 不需要传参 let { value, done } = it.next(data); if (!done) { // 如果没完成遍历，调用返回 Promise 的 then 方法 value.then(data =&gt; { // 如果 Promise 成功，继续递归，如果失败直接执行 reject next(data); }, reject); } else { // 如果遍历完成直接执行 resolve 并传入 value resolve(value); } } next(); }); } // 导出模块 module.exports = co; 验证 myCo.js 实现的 co 函数：/* 验证 myCo */ // 引入依赖 const fs = require(&#39;fs&#39;); const util = require(&#39;util&#39;); const myCo = require(&#39;./myCo&#39;); // 将 readFile 方法转换成 Promise const read = util.promisify(fs.readFile); // 生成器函数 function* gen() { let aData = yield read(&#39;1.txt&#39;, &#39;utf8&#39;); let bData = yield read(aData, &#39;utf8&#39;); return bData; } // 使用 co 库代替手动调用 next myCo(gen()).then(data =&gt; { console.log(data); // Hello world }); 我们将引入的 co 库替换成了自己实现的简易版 myCo 模块，上面读取文件的案例依然生效，这说明我们模拟的 co 库核心逻辑是没问题的，跟原版不同的是并没有处理很多细节，并定义指针，如果对 co 库感兴趣建议看看 tj 大神的源码，整个库写的非常精简，值得学习。总结Generators 相当于把一个函数拆分成若干个部分执行，执行一次时将指针指向下一段要执行的代码，直到结束位置，Generators 配合 co 库的使用场景多在 Node.js 当中，并在 Koa 1.x 版本中居多，现在已经升级到 Koa 2.x 版本，使用更多的是基于 Generators 和 co 库衍生出来的 ES7 新标准 async/await，我们在下一篇异步发展流程系列的文章中来详细介绍。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"https://www.overtaking.top/tags/ES6/"},{"name":"Generators","slug":"Generators","permalink":"https://www.overtaking.top/tags/Generators/"}]},{"title":"异步发展流程 —— 手写一个符合 Promise/A+ 规范的 Promise","date":"2018-06-13T11:36:26.000Z","path":"20180613193626/","text":"概述Promise 是 js 异步编程的一种解决方案，避免了 “回调地狱” 给编程带来的麻烦，在 ES6 中成为了标准，这篇文章重点不是叙述 Promise 的基本用法，而是从零开始，手写一版符合 Promise/A+ 规范的 Promise，如果想了解更多 Promise 的基本用法，可以看 异步发展流程 —— Promise 的基本使用 这篇文章。Promise 构造函数的实现我们在使用 Promise 的时候其实是使用 new 关键字创建了一个 Promise 的实例，其实 Promise 是一个类，即构造函数，下面来实现 Promise 构造函数。Promise/A+ 规范的内容比较多，详情查看 https://promisesaplus.com/，我们在实现 Promise 逻辑时会根据实现的部分介绍相关的 Promise/A+ 规范内容。在 Promise/A+ 规范中规定:构造函数的参数为一个名为 executor 的执行器，即函数，在创建实例时该函数内部逻辑为同步，即立即执行；executor 执行时的参数分别为 resolve 和 reject，一个为成功时执行的函数，一个为失败时执行的函数；在 executor 执行时，一旦出现错误立即调用 reject 函数，并设置错误信息给 reason 属性；每个 Promise 实例有三个状态 pending、fulfilled 和 rejected，默认状态为 pending；状态只能从 pending 到 fulfilled 或从 pending 到 rejected，不可逆；执行 resolve 函数会使状态从 pending 变化到 fulfilled 并将参数存入实例的 value 属性中；执行 reject 函数会使状态从 pending 变化到 rejected 并将错误信息存入实例的 reason 属性中。针对上面的 Promise/A+ 规范，Promise 构造函数代码实现如下：/* promise.js -- Promise 构造函数 */ function Promise(executor) { var self = this; self.status = &#39;pending&#39;; // 当前 Promise 实例的状态 self.value = undefined; // 当前 Promise 实例成功状态下的值 self.reason = undefined; // 当前 Promise 实例失败状态的错误信息 self.onFulfilledCallbacks = []; // 存储成功的回调函数的数组 self.onRejectedCallbacks = []; // 存储失败的回调函数的数组 // 成功的执行的函数 function resolve(value) { // 处理 executor 执行时，调用 resolve 将一个新的 Promise 实例作为结果返回 if (value instanceof Promise) { return value.then(function (data) { resolve(data); }, function (err) { reject(err); }); } if (self.status === &#39;pending&#39;) { self.status = &#39;fulfilled&#39;; self.value = value; // 每次调用 resolve 时 // 执行 onFulfilledCallbacks 内部存储的所有的函数 // 在实现 then 方法中详细说明 self.onFulfilledCallbacks.forEach(function (fn) { fn(); }); } } // 失败执行的函数 function reject(reason) { if (self.status === &#39;pending&#39;) { self.status = &#39;rejected&#39;; self.reason = reason; // 每次调用 reject 时 // 执行 onRejectedCallbacks 内部存储的所有的函数 // 在实现 then 方法中详细说明 self.onRejectedCallbacks.forEach(function (fn) { fn(); }); } } // 调用执行器函数 try { executor(resolve, reject); } catch (e) { // 如果执行器执行时出现错误，直接调用失败的函数 reject(e); } } // 将自己的 Promise 导出 module.exports = Promise; 上面构造函数中的 resolve 和 reject 方法在执行的时候都进行了当前状态的判断，只有状态为 pending 时，才能执行判断内部逻辑，当两个函数有一个执行后，此时状态发生变化，再执行另一个函数时就不会通过判断条件，即不会执行判断内部的逻辑，从而实现了两个函数只有一个执行判断内部逻辑的效果，使用如下：/* verify-promise.js -- 验证 promise.js 的代码 */ // 引入自己的 Promise 模块 // 因为都验证代码都写在 verify-promise.js 文件中，后面就不再引入了 const Promise = require(&#39;./promise.js&#39;); const p = new Promise((resolve, reject) =&gt; { // ...同步代码 resolve(); reject(); // 上面两个函数只有先执行的 resolve 生效 }); 实例方法的实现then 方法的实现没有 Promise 之前在一个异步操作的回调函数中返回一个结果在输入给下一个异步操作，下一个异步操作结束后需要继续执行回调，就形成回调函数的嵌套，在 Promise 中，原来回调函数中的逻辑只需要调用当前 Promise 实例的 then 方法，并在 then 方法的回调中执行，改变了原本异步的书写方式。在 then 方法中涉及到的 Promise/A+ 规范：Promise 实例的 then 方法中有两个参数，都为函数，第一个参数为成功的回调 onFulfilled，第二个参数为失败的回调 onRejected；当 Promise 内部执行 resolve 时，调用实例的 then 方法执行成功的回调 onFulfilled，当 Promise 内部执行 reject 或执行出错时，调用实例的 then 方法执行错误的回调 onRejected；then 方法需要支持异步，即如果 resovle 或 reject 执行为异步时，then 方法的回调 onFulfilled 或 onRejected 需要在后面执行；Promise 需要支持链式调用，Promise 实例调用 then 方法后需要返回一个新的 Promise 实例。如果 then 的回调中有返回值且是一个 Promise 实例，则该 Promise 实例执行后成功或失败的结果传递给下一个 Promise 实例的 then 方法 onFulfilled （成功的回调）或 onRejected（失败的回调）的参数，如果返回值不是 Promise 实例，直接将这个值传递给下一个 Promise 实例 then 方法回调的参数，then 的回调如果没有返回值相当于返回 undefined；Promise 实例链式调用 then 时，当任何一个 then 执行出错，链式调用下一个 then 时会执行错误的回调，错误的回调没有返回值相当于返回了 undefined，再次链式调用 then 时会执行成功的回调；Promise 实例的链式调用支持值的穿透，即当上一个 then 没有传递回调函数，或参数不是一个函数时（null），参数要被忽略，需要后面调用的 then 的回调函数来接收之前执行成功或失败的结果；executor 在 Promise 构造函数中执行时使用 try...catch... 捕获异常，但是内部执行的代码有可能是异步的，所以需要在 then 方法中使用 try...catch... 再次捕获；Promise 实例的 then 方法中的回调为 micro-tasks（微任务），回调内的代码应晚于同步代码执行，在浏览器内部调用微任务接口，我们这里模拟使用宏任务代替。针对上面的 Promise/A+ 规范，then 方法代码实现如下：/* promise.js -- then 方法 */ Promise.prototype.then = function (onFulfilled, onRejected) { // 实现值的穿透 if (typeof onFulfilled !== &#39;function&#39;) { onFulfilled = function (data) { return data; } } if (typeof onRejected !== &#39;function&#39;) { onRejected = function (err) { throw err; } } var self = this; // 返回新的 Promise，规范中规定这个 Promise 实例叫 promise2 var promise2 = new Promise(function (resolve, reject) { if (self.status === &#39;fulfilled&#39;) { // 用宏任务替代模拟微任务，目的是使 `then` 的回调晚于同步代码执行 // 并保证执行 resolvePromise 时可以获取到 promise2 作为参数 setTimeout(function () { try { // 捕获异步的异常 // onFulfilled 执行完返回值的处理，x 为成功回调的返回值 var x = onFulfilled(self.value); // 处理返回值单独封装一个方法 resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (self.status === &#39;rejected&#39;) { setTimeout(function () { try { // onRejected 执行完返回值的处理，x 为失败回调的返回值 var x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } // 如果在 Promise 执行 resolve 或 renject 为异步 // 将 then 的执行程序存储在实例对应的 // onFulfilledCallbacks 或 onRejectedCallbacks 中 if (self.status === &#39;pending&#39;) { self.onFulfilledCallbacks.push(function () { setTimeout(function () { try { var x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); self.onRejectedCallbacks.push(function () { setTimeout(function () { try { var x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); } }); return promise2; }; 在处理 then 回调的返回值时，其实就是在处理该返回值与 then 方法在执行后返回的新 Promise 实例（即 promise2）之间的关系，因为无论 Promise 的执行器在执行 resolve 还是 reject 是同步或是异步，都需要进行处理，所以我们单独封装一个函数 resolvePromise 来处理。resolvePromise 函数有四个参数：promise2：then 执行后返回的 Promise 实例；x：then 的回调返回的结果；resolve：promise2 的 resolve 函数；reject：promise2 的 reject 函数。在 resolvePromise 函数中涉及到的 Promise/A+ 规范：将每个 Promise 实例调用 then 后返回的新 Promise 实例称为 promise2，将 then 回调返回的值称为 x；如果 promise2 和 x 为同一个对象，由于 x 要将执行成功或失败的结果传递 promise2 的 then 方法回调的参数，因为是同一个 Promise 实例，此时既不能成功也不能失败（自己不能等待自己完成），造成循环引用，这种情况下规定应该抛出一个类型错误来回绝；如果 x 是一个对象或者函数且不是 null，就去取 x 的 then 方法，如果 x 是对象，防止 x 是通过 Object.defineProperty 添加 then 属性，并添加 get 和 set 监听，如果在监听中抛出异常，需要被捕获到，x.then 是一个函数，就当作 x 是一个 Promise 实例，直接执行x 的 then 方法，执行成功就让 promise2 成功，执行失败就让 promise2 失败，如果 x.then 不是函数，则说明 x 为普通值，直接调用 promise2 的 resolve 方法将 x 传入，不满足条件说明该返回值就是一个普通值，直接执行 promise2 的 resolve 并将 x 作为参数传入；如果每次执行 x 的 then 方法，回调中传入的参数还是一个 Promise 实例，循环往复，需要递归 resolvePromise 进行解析；在递归的过程中如果返回的 Promise 是其他人通过 Promise/A+ 规范实现的，并且实现 Promise 的 then 方法中同时调用了 resolve 和 reject 的情况（未严格按照规范，有坑的 Promise），应该声明一个标识变量 called 做判断来避免这种情况，第一次调用 resolve 或 reject 生效，然后更改标识来忽略其他的调用。针对上面的 Promise/A+ 规范，resolvePromise 函数代码实现如下：/* promise.js -- resolvePromise 方法 */ function resolvePromise(promise2, x, resolve, reject) { // 判断 x 和 promise2 是不是同一个函数 if (promise2 === x) { reject(new TypeError(&#39;循环引用&#39;)); } // x 是对象或者函数并且不是 null，如果不满足该条件说明 x 只是一个普通的值 if (x !== null &amp;&amp; (typeof x === &#39;object&#39; || typeof x === &#39;function&#39;)) { // 标识变量，防止递归内外层 resolve 和 reject 同时调用 // 针对 Promise，x 为普通值的时候可以放行 var called; // 为了捕获 Object.defineProperty 创建的 then 属性时添加监听所抛出的异常 try { // then 只取一次，防止 Object.defineProperty getter 内，用次数控制报错 var then = x.then; // then 为一个方法，就当作 x 为一个 promise if (typeof then === &#39;function&#39;) { // 执行 then，第一个参数为 this（即 x） // 第二个参数为成功的回调，第三个参数为失败的回调 then.call(x, function (y) { if (called) return; called = true; // 如果 y 是 Promise 就继续递归解析 resolvePromise(promise2, y, resolve, reject); }, function (err) { if (called) return; called = true; reject(err); }); } else { // x 是一个普通对象，直接成功即可 resolve(x); } } catch(e) { if (called) return; called = true; reject(e); } } else { resolve(x); } } 注意：Promise 是一套规范，是通用的，每个人都可以实现一个符合 Promise/A+ 规范的 Promise，其他人实现的 Promise 可能会在我们的 Promise 的 then 方法中被返回，所以当我们取出这个对象查看是否含有 then 方法，如果有则认为这个对象是一个 Promise 的实例。上面我们按照 Promise/A+ 规范实现了 Promise 的 then 方法，接下来针对上面的规范，用一些有针对行的案例来对 then 方法一一进行验证。验证异步调用 resolve 或 reject：/* 文件：verify-promise.js */ // 验证 promise.js 异步调用 resolve 或 reject const p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(), 1000); }); p.then(() =&gt; console.log(&#39;执行了&#39;)); // 执行了 验证链式调用 then 返回 Promise 实例：/* 文件：verify-promise.js */ // 验证 promise.js then 回调返回 Promise 实例 const p1 = new Promise((resolve, reject) =&gt; resolve()); const p2 = new Promise((resolve, reject) =&gt; resolve(&#39;hello&#39;)); p1.then(() =&gt; p2).then(data =&gt; console.log(data)); // hello 验证链式调用 then 返回普通值：/* 文件：verify-promise.js */ // 验证 promise.js then 回调返回普通值 const p = new Promise((resolve, reject) =&gt; resolve()); p.then(() =&gt; &#39;hello&#39;).then(data =&gt; console.log(data)); // hello 验证链式调用 then 中执行出错链式调用 then 执行错误的回调后，再次链式调用 then：/* 文件：verify-promise.js */ // 验证 promise.js 链式调用 then 中执行出错 // 链式调用 then 执行错误的回调后，再次链式调用 then const p = new Promise((resolve, reject) =&gt; resolve()); p.then(() =&gt; { throw new Error(&#39;error&#39;); }).then(() =&gt; { console.log(&#39;success&#39;); }, err =&gt; { console.log(err); }).then(() =&gt; { console.log(&#39;成功&#39;); }, () =&gt; { console.log(&#39;失败&#39;); }); // Error: error at p.then... // 成功 验证 then 的参数穿透：/* 文件：verify-promise.js */ // 验证 then 的参数穿透 const p1 = new Promise((resolve, reject) =&gt; resolve(&#39;ok&#39;)); const p2 = p1.then().then(data =&gt; { console.log(data); throw new Error(&#39;出错了&#39;); }); p2.then().then(null, err =&gt; console.log(err)); // ok // 出错了 验证 then 方法是否晚于同步代码执行：/* 文件：verify-promise.js */ // 验证 then 方法是否晚于同步代码执行 const p = new Promise((resolve, reject) =&gt; { resolve(1); }); p.then(data =&gt; console.log(data)); console.log(2); // 2 // 1 验证循环引用：/* 文件：verify-promise.js */ // 验证 promise.js 循环引用 const p1 = new Promise((resolve, reject) =&gt; resolve()); // 让 p1 then 方法的回调返回自己 var p2 = p1.then(() =&gt; { return p2; }); p2.then(() =&gt; { console.log(&#39;成功&#39;); }, err =&gt; { console.log(err); }); // TypeError: 循环引用 at resolvePromise... 验证 then 回调返回对象通过 Object.definePropertype 添加 then 属性并添加 get 监听，在触发监听时抛出异常：/* 文件：verify-promise.js */ // 验证 promise.js then 回调 // 返回对象通过 Object.definePropertype 添加 then 和 get 监听，捕获异常 let obj = {}; let index = 0; Object.defineProperty(obj, &#39;then&#39;, { get () { index++; if (index === 2) { throw new Error(); } } }); let p = new Promise((resolve, reject) =&gt; resolve()); p.then(() =&gt; { return obj; }).then(() =&gt; { console.log(&#39;成功&#39;); }, () =&gt; { console.log(&#39;出错了&#39;); }); // 出错了 验证每次执行 resolve 都传入 Promise 实例，需要将最终的执行结果传递给下一个 Promise 实例 then 的回调中：/* 文件：verify-promise.js */ // 验证 promise.js 每次执行 resolve 都传入 Promise 实例 const p = new Promise((resolve, reject) =&gt; resolve()); p.then(() =&gt; { return new Promise((resolve, reject) =&gt; { resolve(new Promise(resolve, reject) =&gt; { resolve(new Promise(resolve, reject) =&gt; { resolve(200); }); }); }); }).then(data =&gt; { console.log(data); }); // 200 catch 方法的实现/* promise.js -- catch 方法 */ Promise.prototype.catch = function (onRejected) { return this.then(null, onRejected); } catch 方法可以理解为是 then 方法的一个简写，只是参数中少了成功的回调，所以利用 Promise/A+ 规范中参数穿透的特性，很容易就实现了 catch 方法，catch 方法的真相就是这么的简单。验证 catch 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 catch 方法 const p = new Promise((resolve, reject) =&gt; reject(&#39;err&#39;)); p.then().catch(err =&gt; { console.log(err); }).then(() =&gt; { console.log(&#39;成功了&#39;); }); // err // 成功了 finally 方法的实现/* promise.js -- finally 方法 */ Promise.prototype.finally = function (callback) { return this.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; { throw reason }) ); } finally 方法是在 ES9 的规范中实现的，特点是无论成功或者失败都会执行传入的回调函数，并且回调函数没有任何参数，而在 finally 后可以再链式调用 then 或 catch 去处理后续逻辑或捕获异常，因为参数不是在 finally 方法传入的回调中返回的，所以借助了静态方法 Promise.resolve（该方法实现方式在静态方法中会说明），在 finally 内部调用 then 返回 Promise 实例，并传入成功和失败的回调用来返回最初成功或失败的结果，finally 的回调中执行的返回结果不生效。验证 finally 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 finally 方法 const p = new Promise((resolve, reject) =&gt; resolve(&#39;nihao&#39;)); p.finally(() =&gt; { // node版本的问题 8以上 console.log(&#39;hello&#39;); throw &#39;error&#39; }).catch(err =&gt; { console.log(&#39;err&#39;, err); }); p.finally(() =&gt; { console.log(&#39;hello&#39;); return 100; }).then(data =&gt; { console.log(&#39;data&#39;, data); }); // hello // hello // err error // data nihao 静态方法的实现Promise.resolve 方法的实现Promise.resolve 方法传入一个参数，并返回一个新的 Promise 实例，这个参数作为新 Promise 实例 then 方法成功回调的参数，在调用时感觉直接成功了，其实是直接执行了返回 Promise 实例的 resolve。/* promise.js -- Promise.resolve 方法 */ Promise.resolve = function (val) { return new Promise(function (resolve, reject) { resolve(val); }); } 验证 Promise.resolve 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 Promise.resolve 方法 Promise.resolve(&#39;成功了&#39;).then(data =&gt; console.log(data)); // 成功了 Promise.reject 方法的实现Promise.reject 方法与 Promise.resolve 的实现思路相同，不同的是，直接调用了返回新 Promise 实例的 reject。/* promise.js -- Promise.reject 方法 */ Promise.reject = function (reason) { return new Promise(function (resolve, reject) { reject(reason); }); } 验证 Promise.reject 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 Promise.reject 方法 Promise.reject(&#39;失败了&#39;).then(err =&gt; console.log(err)); // 失败了 Promise.all 方法的实现Promise.all 方法可以实现多个 Promise 实例的并行，返回值为一个新的 Promise 实例，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，这些 Promise 实例的返回顺序先后不确定，但是返回值的数组内存储的返回结果是按照数组中 Promise 实例最初顺序进行排列的，返回的数组作为返回 Promise 实例成功回调的参数，当其中一个失败，直接返回失败实例的错误信息，并作为返回 Promise 实例失败回调的参数。/* promise.js -- Promise.all 方法 */ Promise.all = function (promises) { return new Promise(function (resolve, reject) { // 存储返回值 var result = []; // 代表存入的个数，因为 Promise 为异步 // 不知道哪个 Promise 先成功，不能用数组的长度来判断 var idx = 0; // 用来构建全部成功的返回值 function processData(index, data) { result[index] = data; // 将返回值存入数组 idx++; if (idx === promises.length) { resolve(result); } } for (var i = 0; i &lt; promises.length; i++) { var current = promises[i]; // 因为 Promise 为异步，保证 i 值是顺序传入 (function (i) { if (current &amp;&amp; current.then &amp;&amp; typeof current.then === &#39;function&#39;) { current.then(function (data) { processData(i, data); }, reject); } else { processData(i, current); } })(i); } }); } 验证 Promise.all 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 Promise.all 方法 const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(1), 2000); }); const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(2), 1000); }); Promise.all([p1, p2, 3]).then(data =&gt; console.log(data)); // [1, 2, 3] const p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(1), 2000); }); const p4 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(2), 1000) }); Promise.all([p3, p4]).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(err); }); // 2 Promise.race 方法的实现Promise.race 方法与 Promise.all 类似，同样可以实现多个 Promise 实例的并行，同样返回值为一个新的 Promise 实例，参数同样为一个存储多个 Promise 实例的数组，区别是只要有一个 Promise 实例返回结果，无论成功或失败，则直接返回这个结果，并作为新 Promise 实例 then 方法中成功或失败的回调函数的参数。/* promise.js -- Promise.race 方法 */ Promise.race = function (promises) { return new Promise(function (resolve, reject) { for (var i = 0; i &lt; promises.length; i++) { var current = promises[i]; if (current &amp;&amp; current.then &amp;&amp; typeof current.then === &#39;function&#39;) { current.then(resolve, reject); } else { resolve(current); } } }); } 验证 Promise.race 方法：/* 文件：verify-promise.js */ // 验证 promise.js 的 Promise.race 方法 const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(1), 2000); }); const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(2), 1000); }); Promise.race([p1, p2]).then(data =&gt; console.log(data)); // 2 const p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(1), 2000); }); const p4 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(2), 1000); }); Promise.all([p3, p4]).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(err); }); // 2 测试 Promise 是否符合 Promise/A+ 规范promises-aplus-test 是专门用来验证 Promise 代码（构造函数和 then 方法）是否符合 Promise/A+ 规范的模块，需要通过 npm 下载。$ npm install promises-aplus-test -g 测试方法：在 promise.js 中写入测试代码；在命令行中输入命令 promises-aplus-test + fileName。测试代码：/* promise.js -- 测试方法 Promise.derfer */ // Promise 语法糖 // 好处：解决 Promise 嵌套问题 // 坏处：错误处理不方便 Promise.derfer = Promise.deferred = function () { const dfd = {}; dfd.promise = new Promise((resolve, reject) =&gt; { dfd.resolve = resolve; dfd.reject = reject; }); return dfd; } 输入命令：$ promises-aplus-test promise.js 执行上面命令后，会根据 Promise/A+ 规范一条一条进行极端的验证，当验证通过后会在窗口中这一条对应的执行项前打勾，验证不通过打叉，直到所有的规范都验证完毕。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"ES6","slug":"ES6","permalink":"https://www.overtaking.top/tags/ES6/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"异步发展流程 —— Promise 的基本使用","date":"2018-06-11T20:50:05.000Z","path":"20180612045005/","text":"Promise 简介Promise 是 ES6 的新特性，提供了对 js 异步编程控制的新的解决方案，在过去书写异步代码时要靠回调函数，当异步操作依赖于其他异步操作的返回值时，会出现一种现象，被程序员们称为 “回调地狱”，即多层回调函数嵌套，这种代码的可读性、维护性都很差，因此诞生了 Promise，当然 Promise 并不是完全摆脱回调，而只是改变了传递回调的位置，大大减少了回调函数嵌套。Promise 的使用实例方法 thenPromise 中的代码默认是同步执行的，then 方法中的回调在微任务队列中执行，在 Promise 的 then 方法中支持传入两个参数，一个是成功的回调，一个是失败的回调，在 Promise 中调用了 resolve 方法，就会在 then 中执行成功的回调，调用了 reject 方法，就会在 then 中执行失败的回调，成功的回调和失败的回调只能执行一个，resolve 和 reject 方法调用时传入的参数会传递给 then 方法中对应的回调函数。/* 执行 resolve */ const p = new Promise((resolve, reject) =&gt; { console.log(1); resolve(3); }); console.log(2); p.then(data =&gt; { console.log(data); }, err =&gt; { console.log(err); }); // 1 // 2 // 3 /* 执行 reject */ const p = new Promise((resolve, reject) =&gt; { reject(); }); p.then(() =&gt; { console.log(1); }, () =&gt; { console.log(2); }); // 2 如果 Promise 中发生错误，就会在 then 中执行失败的回调。/* 失败的回调 */ const p = new Promise((resolve, reject) =&gt; { throw new Error(); }); p.then(() =&gt; { console.log(1); }, () =&gt; { console.log(&#39;报错啦&#39;); }); // 报错啦 当同一个 Promise 实例的 then 方法多次调用时，就会多次执行。/* 多次调用 then */ const p = new Promise((resolve, reject) =&gt; { resolve(&#39;成功&#39;); }); p.then(data =&gt; { console.log(data); }); p.then(data =&gt; { console.log(data); }); // 成功 // 成功 Promise 支持链式调用，每次调用一次 then 方法都会返回一个新的 Promise 实例，如果该 then 方法中执行的回调函数有返回值，并且这个返回值会作为返回的下一个 Promise 实例的 then 方法回调的参数，如果 then 方法的返回值是一个 Promise 实例，那就返回一个新的 Promise 实例，将 then 返回的 Promise 实例执行后的结果作为返回 Promise 实例回调的参数。/* 链式调用 then */ function read(url) { return new Promise((resolve, reject) =&gt; { fs.readFile(url, &#39;utf8&#39;, (err, data) =&gt; { if (err) reject(err); resolve(data); }); }); } read(&#39;1.txt&#39;).then(data =&gt; { // 假设此时读到的内容为 Hello world return data; }, err =&gt; { console.log(err); }).then(data =&gt; { console.log(data); // Hello world }, err =&gt; { console.log(err); }); read(&#39;1.txt&#39;).then(data =&gt; { // 假如此时读到的 1.txt 的内容为 2.txt 的字符串，2.txt 的内容为 Hello world return read(data); }, err =&gt; { console.log(err); }).then(data =&gt; { console.log(data); // Hello world }, err =&gt; { console.log(err); }); 在 Promise 实例的 then 中如果有错误产生，在返回的新的 Promise 实例中的 then 方法中会执行错误的回调。/* 链式调用 then 出错 */ const p = new Promise((resolve, reject) =&gt; { resolve(); }); p.then(() =&gt; { console.log(&#39;success&#39;, 1); throw new Error(); }, () =&gt; { console.log(&#39;error&#39;, 1); }).then(() =&gt; { console.log(&#39;success&#39;, 2); }, () =&gt; { console.log(&#39;error&#39;, 2) }); // success 1 // error 2 在 Promise 中有三个状态：pending：等待态fulfilled：成功态rejected：失败态Promise 实例的状态只能从 pending 到 fulfilled 或从 pending 到 rejected，状态一旦发生变化就不可逆，所以 Promise 实现链式调用与 jQuery 不同，返回的不是 this，只能是一个新的 Promise。实例方法 catch在 Promise 中实例的 catch 方法可以捕获创建 Promise 过程中和链式调用中的异常，不需要每次调用 then 方法中都传入错误的回调，在链式调用的过程中只要有任何一个 then 中出现错误，都会被 catch 方法捕获到。/* 创建 Promise 实例时出错 */ const p = new Promise((resolve, reject) =&gt; { throw new Error(); }); p.then(() =&gt; { console.log(&#39;success&#39;); }).catch(() =&gt; { console.log(&#39;error&#39;); }); // error /* 调用 then 方法时出错 */ const p = new Promise((resolve, reject) =&gt; { resolve(); }); p.then(() =&gt; { throw new Error(); console.log(&#39;success&#39;, 1); }).then(() =&gt; { console.log(&#39;success&#39;, 2); }).catch(() =&gt; { console.log(&#39;出错了&#39;); }); // 出错了 p.then(() =&gt; { console.log(&#39;success&#39;, 1); }).then(() =&gt; { throw new Error(); console.log(&#39;success&#39;, 2); }).catch(() =&gt; { console.log(&#39;出错了&#39;); }); // success 1 // 出错了 实例方法 finallyPromise 的实例方法 finally 是 ES7 标准引入的，不管最后 Promise 实例的状态是成功还是失败出传入的回调都会执行，回调函数没有参数，这说明 finally 方法里的操作与 Promise 实例状态无关，不依赖于 Promise 的执行结果。const p = new Promise((resolve, reject) =&gt; { resolve(); }); p.finally(() =&gt; { console.log(&#39;执行了&#39;); }); // 执行了 const p = new Promise((resolve, reject) =&gt; { reject(); }); p.finally(() =&gt; { console.log(&#39;执行了&#39;); }); // 未使用 catch 捕获错误，finally 不执行 finally 方法执行后返回一个新的 Promise，继续调用 then 方法，返回值为执行 finally 之前的结果。const p = new Promise((resolve, reject) =&gt; { resolve(1); }); p.finally(() =&gt; { console.log(&#39;fanilly&#39;); }).then(data =&gt; { console.log(data); }); // fanilly // 1 const p = new Promise((resolve, reject) =&gt; { resolve(1); }); p.then(data =&gt; { return data; }).finally(() =&gt; { console.log(&#39;执行了&#39;); return 2; }).then(data =&gt; { console.log(&#39;data: &#39;, data); }); // 执行了 // 1 // data: Promise {&lt;resolved&gt;: undefined} 静态方法 Promise.allPromise 中的静态方法 all 可以实现多个 Promise 实例的并行，当所有结果都为成功时，返回一个数组，该数组存储的为每一个 Promise 实例的返回结果，每一个 Promise 实例的返回顺序先后不固定，但是返回值的数组内存储每一个 Promise 的返回值的结果按照最初传入的顺序排列，all 方法的返回值为一个新的 Promise 实例，返回的数组作为返回新 Promise 的 then 方法成功回调的参数。当 all 传入的参数数组中的 Promise 实例执行时，只要有一个失败，则直接返回该 Promise 实例失败的结果或错误信息。/* Promise.all 方法 */ const p1 = new Promise((resolve, reject) =&gt; { resolve(1); }); const p2 = new Promise((resolve, reject) =&gt; { resolve(2); }); Promise.all([p1, p2]).then(data =&gt; { console.log(data); }); // [1, 2] /* Promise.all 错误捕获 */ const p1 = new Promise((resolve, reject) =&gt; { resolve(1); }); const p2 = new Promise((resolve, reject) =&gt; { reject(2); }); Promise.all([p1, p2]).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(err); }); // 2 静态方法 Promise.racePromise 的静态方法 race 的用法和 all 类似，参数同为一个存储 Promise 实例的数组，返回值同样是一个新的 Promise 的实例，不同的是，数组中的 Promise 实例只有一个结果为成功，那就直接返回这个结果（只取出最快返回的结果），在没有成功的结果之前有一个出错，就直接返回这个错误。/* Promise.race 方法 */ const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(1), 2000); }); const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(2), 1000); }); Promise.race([p1, p2]).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(err); }); // 2 /* Promise.race 错误捕获 */ const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(1), 1000); }); const p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(2), 2000); }); Promise.race([p1, p2]).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(err); }); // 1 静态方法 Promise.resolvePromise 的静态方法 resolve 可以直接将 Promise 的状态变为成功并返回一个新的 Promise 实例，resolve 的参数会传递给返回的新 Promise 实例 then 中成功回调。/* Promise.resolve 方法 */ Promise.resolve(&#39;hello&#39;).then(data =&gt; { console.log(data); }); // hello 静态方法 Promise.rejectPromise 的静态方法 reject 与 resolve 使用完全相同，都返回一个新的 Promise 实例，不同的是 reject 的参数会传递给新 Promise 实例的 then 方法失败回调。/* Promise.reject 方法 */ Promise.reject(&#39;出错了&#39;).then(null, err =&gt; { console.log(err); }); // 出错了 当成功的回调不传递时，可以使用 null 代替，因为 null 作为参数会被忽略掉，将参数穿透到下一个 then 的回调中。总结Promise 是异步编程的一大趋势，也是当前更先进的异步解决方案的基础，下一篇我们着重讨论一下 Promise 的实现原理以及 A+ 规范。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"ES6","slug":"ES6","permalink":"https://www.overtaking.top/tags/ES6/"}]},{"title":"九种 “姿势” 让你彻底解决跨域问题","date":"2018-06-10T17:06:38.000Z","path":"20180611010638/","text":"同源策略同源策略 SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指 “协议 + 域名 + 端口” 三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。什么是跨域？当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 cookie、localStorage、dom、ajax、IndexDB 都是不支持跨域的。假设 cookie 支持了跨域，http 协议无状态，当用户访问了一个银行网站登录后，银行网站的服务器给返回了一个 sessionId，当通过当前浏览器再访问一个恶意网站，如果 cookie 支持跨域，恶意网站将获取 sessionId 并访问银行网站，出现安全性问题；IndexDB、localStorage 等数据存储在不同域的页面切换时是获取不到的；假设 Dom 元素可以跨域，在自己的页面写入一个 iframe 内部嵌入的地址是 www.baidu.com，当在百度页面登录账号密码时就可以在自己的页面获取百度的数据信息，这显然是不合理的。这就是为什么 cookie、localStorage、dom、ajax、IndexDB 会受到同源策略会限制，下面还有一点对跨域理解的误区：误区：同源策略限制下，访问不到后台服务器的数据，或访问到后台服务器的数据后没有返回；正确：同源策略限制下，可以访问到后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。实现跨域的方式使用 jsonp 跨域使用场景：当自己的项目前端资源和后端部署在不同的服务器地址上，或者其他的公司需要访问自己对外公开的接口，需要实现跨域获取数据，如百度搜索。/* 封装 jsonp */ // 封装 jsonp 跨域请求的方法 function jsonp({ url, params, cb }) { return new Promise((resolve, reject) =&gt; { // 创建一个 script 标签帮助我们发送请求 let script = document.createElement(&#39;script&#39;); const arr = []; params = { ...params, cb }; // 循环构建键值对形式的参数 for (let key in params) { arr.push(key + &#39;=&#39; + params[key]); } // 创建全局函数 window[cb] = function (data) { resolve(data); // 在跨域拿到数据以后将 script 标签销毁 document.body.removeChild(script); }; // 拼接发送请求的参数并赋值到 src 属性 script.src = url + &#39;?&#39; arr.join(&#39;&amp;&#39;); document.body.appendChild(script); }); } // 调用方法跨域请求百度搜索的接口 json({ url: &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#39;, params: { wd: &#39;jsonp&#39; }, cb: &#39;show&#39; }).then(data =&gt; { // 打印请求回的数据 console.log(data); }); 缺点：只能发送 get 请求，不支持 post、put、delete 等；不安全，容易引发 xss 攻击，会把别人的脚本引入到自己的页面中执行，如：弹窗、广告等，甚至更危险的脚本程序，如在返回的结果中返回了下面代码。`let script = document.createElement(&#39;script&#39;); script.src = &#39;http://192.168.0.57:8080/xss.js&#39;; document.body.appendChild(script);`; 使用 CORS 跨域跨源资源共享 CORS（Cross-Origin Resource Sharing）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。使用场景：多用于开发时，前端与后台在不同的 ip 地址下进行数据访问。现在启动两个端口号不同的服务器，创建跨域条件，服务器（Node.js）代码如下：/* 服务端代码 */ // 服务器1 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(3000); // 服务器2 const express = require(&#39;express&#39;); const app = express(); app.get(&#39;/getDate&#39;, function (req, res) { res.end(&#39;I love you&#39;); }); app.use(express.static(__dirname)); app.listen(4000); 由于我们的 Node.js 服务器使用 express 框架，在我们的项目根目录下的命令行中输入下面代码进行安装：$ npm install express --save 通过访问 http://localhost:3000/index.html 获取 index.html 文件并执行其中的 Ajax 请求 http://localhost:4000/getDate 接口去获取数据，index.html 文件内容如下：&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CORS 跨域&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); // 正常 cookie 是不允许跨域的 document.cookie = &#39;name=hello&#39;; // cookie 想要实现跨域必须携带凭证 xhr.withCredentials = true; // xhr.open(&#39;GET&#39;, &#39;http://localhost:4000/getDate&#39;, true); xhr.open(&#39;PUT&#39;, &#39;http://localhost:4000/getDate&#39;, true); // 设置名为 name 的自定义请求头 xhr.setRequestHeader(&#39;name&#39;, &#39;hello&#39;); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) { // 打印返回的数据 console.log(xhr.response); // 打印后台设置的自定义头信息 console.log(xhr.getResponseHeader(&#39;name&#39;)); } } } xhr.send(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上面 index.html 代码中发送请求访问不在同源的服务器 2，此时会在控制台给出错误信息，告诉我们缺少了哪些响应头，我们对应报错信息去修改访问的服务器 2 的代码，添加对应的响应头，实现 CORS 跨域。/* 服务端代码 */ // 服务器2 const express = require(&#39;express&#39;); const app = express(); // 允许访问域的白名单 const whiteList = [&#39;http://localhost:3000&#39;]; app.use(function (req, res, next) { let origin = req.header.origin; if (whiteList.includes(origin)) { // 设置那个源可以访问我，参数为 * 时 // 允许任何人访问，但是不可以和 cookie 凭证的响应头共同使用 res.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin); // 想要获取 ajax 的头信息，需设置响应头 res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;name&#39;); // 处理复杂请求的头 res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT&#39;); // 允许发送 cookie 凭证的响应头 res.setHeader(&#39;Access-Control-Allow-Credentials&#39;, true); // 允许前端获取哪个头信息 res.setHeader(&#39;Access-Control-Expose-Headers&#39;, &#39;name&#39;); // 处理 OPTIONS 预检的存活时间，单位 s res.setHeader(&#39;Access-Control-Max-Age&#39;, 5); // 发送 PUT 请求会做一个试探性的请求 OPTIONS // 其实是请求了两次，当接收的请求为 OPTIONS 时不做任何处理 if (req.method === &#39;OPTIONS&#39;) { res.end(); } } next(); }); app.put(&#39;/getDate&#39;, function (req, res) { // res.setHeader(&#39;name&#39;, &#39;nihao&#39;); // 设置自定义响应头信息 res.end(&#39;I love you&#39;); }); app.get(&#39;/getDate&#39;, function (req, res) { res.end(&#39;I love you&#39;); }); app.use(express.static(__dirname)); app.listen(4000); 使用 postMessage 实现跨域postMessage 是 H5 的新 API，跨文档消息传送（cross-document messaging），有时候简称为 XMD，指的是在来自不同域的页面间传递消息。调用方式：window.postMessage(message, targetOrigin)message：发送的数据targetOrigin：发送的窗口的域在对应的页面中用 message 事件接收，事件对象中有 data、origin、source 三个重要信息：data：接收到的数据origin：接收到数据源的域（数据来自哪个域）source：接收到数据源的窗口对象（数据来自哪个窗口对象）使用场景：不是使用 Ajax 的数据通信，更多是在两个页面之间的通信，在 A 页面中引入 B 页面，在 A、B 两个页面之间通信。与上面 CORS 类似，我们要创建跨域场景，搭建两个端口号不同的 Node.js 服务器，后面相同方式就不多赘述了。/* 服务端代码 */ // 服务器1 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(3000); // 服务器2 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(4000); 通过访问 http://localhost:3000/a.html，在 a.html 中使用 iframe 标签引入 http://localhost:4000/b.html，在两个窗口间传递数据。&lt;!-- 文件：a.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/b.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt; &lt;/iframe&gt; &lt;script&gt; function load() { let frame = document.getElementById(&#39;frame&#39;); frame.contentWindow.postMessage(&#39;I love you&#39;, &#39;http://localhost:4000&#39;); window.onmessage = function (e) { console.log(e.data); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 文件：b.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; window.onmessage = function (e) { // 打印来自页面 A 的消息 console.log(e.data); // 给页面 A 发送回执 e.source.postMessage(&#39;I love you, too&#39;, e.origin); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 window.name 实现跨域同样是页面之间的通信，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面在独立的域 http://localhost:4000。/* 服务端代码 */ // 服务器1 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(3000); // 服务器2 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(4000); 实现思路：在 A 页面中将 iframe 的 src 指向 C 页面，在 C 页面中将属性值存入 window.name 中，再把 iframe 的 src 换成同域的 B 页面，在当前的 iframe 的 window 对象中取出 name 的值，访问 http://localhost:3000/a.html。&lt;!-- 文件：a.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/c.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt; &lt;/iframe&gt; &lt;script&gt; // 增加一个标识，第一次触发 load 时更改地址，更改后再次触发直接取值 let isFirst = true; function load() { let frame = document.getElementById(&#39;frame&#39;); if (isFirst) { frame.src = &#39;http://localhost:3000/b.html&#39;; isFirst = false; } else { console.log(frame.contentWindow.name); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 文件：c.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 C&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; window.name = &#39;I love you&#39;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 location.hash 实现跨域与 window.name 跨域的情况相同，是不同域的页面间的参数传递，需要借助 iframe 标签，A 页面和 B 页面是同域的 http://localhost:3000，C 页面是独立的域 http://localhost:4000。/* 服务端代码 */ // 服务器1 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(3000); // 服务器2 const express = require(express); const app = express(); app.use(express.static(__dirname)); app.listen(4000); 实现思路：A 页面通过 iframe 引入 C 页面，并给 C 页面传一个 hash 值，C 页面收到 hash 值后创建 iframe 引入 B 页面，把 hash 值传给 B 页面，B 页面将自己的 hash 值放在 A 页面的 hash 值中，访问 http://localhost:3000/a.html。&lt;!-- 文件：a.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://localhost:4000/c.html#Iloveyou&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt; &lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function () { console.log(location.hash); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 文件：c.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 C&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 打印 A 页面引入 C 页面设置的 hash 值 console.log(location.hash); let iframe = document.createElement(&#39;iframe&#39;); iframe.src = &#39;http://localhost:3000/b.html#Iloveyoutoo&#39;; document.body.appendChild(iframe); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 文件：b.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 将 C 页面引入 B 页面设置的 hash 值设置给 A页面 window.parent.parent.location.hash = location.hash; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 document.domain 实现跨域使用场景：不是万能的跨域方式，大多使用于同一公司不同产品间获取数据，必须是一级域名和二级域名的关系，如 www.baidu.com 与 video.baidu.com 之间。/* 服务端代码 */ const express = require(&#39;express&#39;); const app = express(); app.use(express.static(__dirname)); app.listen(3000); 想要模拟使用 document.domain 跨域的场景需要做些小小的准备，到 C:\\Windows\\System32\\drivers\\etc 该路径下找到 hosts 文件，在最下面创建一个一级域名和一个二级域名。127.0.0.1 www.domainacross.com 127.0.0.1 sub.domainacross.com 命名是随意的，只要是符合一级域名与 二级域名的关系即可，然后访问 http://www.domainacross.com:3000/a.html。&lt;!-- 文件：a.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面 A&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是页面 A 的内容&lt;/p&gt; &lt;iframe src=&quot;http://sucess.domainacross.com:3000/b.html&quot; onload=&quot;load()&quot; id=&quot;frame&quot; &gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &#39;domainacross.com&#39;; function load() { console.log(frame.contentWindow.message); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- 文件：b.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;页面 B&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是 B 页面的内容&lt;/p&gt; &lt;script&gt; document.domain = &#39;domainacross.com&#39;; var message = &#39;Hello A&#39;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 WebSocket 实现跨域WebSocket 没有跨域限制，高级 API（不兼容），想要兼容低版本浏览器，可以使用 socket.io 的库，WebSocket 与 HTTP 内部都是基于 TCP 协议，区别在于 HTTP 是单向的（单双工），WebSocket 是双向的（全双工），协议是 ws:// 和 wss:// 对应 http:// 和 https://，因为没有跨域限制，所以使用 file:// 协议也可以进行通信。由于我们在 Node.js 服务中使用了 WebSocket，所以需要安装对应的依赖：$ npm install ws --save &lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 创建 webSocket const socket = new WebSocket(&#39;ws://localhost:3000&#39;); // 连接上触发 socket.onopen = function () { socket.send(&#39;I love you&#39;); } // 收到消息触发 socket.onmessage = function (e) { // 打印收到的数据 console.log(e.data); // I love you, too } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; /* 服务端代码 */ const express = require(&#39;express&#39;); const app = express(); // 引入 webSocket const WebSocket = require(&#39;ws&#39;); // 创建连接，端口号与前端相对应 const wss = new WebSocket.Server({ port: 3000 }); // 监听连接 wss.on(&#39;connection&#39;, function (ws) { // 监听消息 ws.on(&#39;message&#39;, function (data) { // 打印消息 console.log(data); // I love you // 发送消息 ws.send(&#39;I love you, too&#39;); }); }); 使用 nginx 实现跨域nginx 本身就是一个服务器，因此我们需要去 nginx 官网下载服务环境 http://nginx.org/en/download.html。下载后解压到一个文件夹中；双击 nginx.exe 启动（此时可以通过 http://localhost 访问 nginx 服务）；在目录新建 json 文件夹；进入 json 文件夹新建 data.json 文件并写入内容；回到 nginx 根目录进入 conf 文件夹；使用编辑器打开 nginx.conf 进行配置。data.json 文件：{ &quot;name&quot;: &quot;nginx&quot; } nginx.conf 文件：# nginx 配置 server { # ... location ~.*\\.json { root json; add_header &quot;Access-Control-Allow-Origin&quot; &quot;*&quot;; } # ... } 含义：~.*\\.json：代表忽略大小写，后缀名为 json 的文件；root json：代表 json 文件夹；add_header：代表加入跨域的响应头及允许访问的域，* 为允许任何访问。在 nginx 根目录启动 cmd 命令行（Windows 系统必须使用 cmd 命令行）执行下面代码重启 nginx。$ nginx -s reload 不跨域访问：http://localhost/data.json，跨域访问时需要创建跨域条件代码如下：/* 服务端代码 */ const express = require(&#39;express&#39;); const app = express(); app.use(express.static(__dirname)); app.listen(3000); 跨域访问：http://localhost:3000/index.html&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;nginx跨域&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;http://localhost/data.json&#39;, true); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) { console.log(xhr.response); } } } xhr.send(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 http-proxy-middleware 实现跨域Node.js 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证。非 vue 框架的跨域（2 次跨域）&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;proxy 跨域&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写 cookie xhr.withCredentials = true; // 访问 http-proxy-middleware 代理服务器 xhr.open(&#39;get&#39;, &#39;http://www.proxy1.com:3000/login?user=admin&#39;, true); xhr.send(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 中间代理服务中使用了 http-proxy-middleware 中间件，因此需要提前下载：$ npm install http-proxy-middleware --save-dev /* 中间代理服务器 */ const express = require(&#39;express&#39;); const proxy = require(&#39;http-proxy-middleware&#39;); const app = express(); app.use( &#39;/&#39;, proxy({ // 代理跨域目标接口 target: &#39;http://www.proxy2.com:8080&#39;, changeOrigin: true, // 修改响应头信息，实现跨域并允许带 cookie onProxyRes: function (proxyRes, req, res) { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.proxy1.com&#39;); res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;); }, // 修改响应信息中的 cookie 域名 cookieDomainRewrite: &#39;www.proxy1.com&#39; // 可以为 false，表示不修改 }); ); app.listen(3000); /* 服务器 */ const http = require(&#39;http&#39;); const qs = require(&#39;querystring&#39;); const server = http.createServer(); server.on(&#39;request&#39;, function (req, res) { let params = qs.parse(req.url.substring(2)); // 向前台写 cookie res.writeHead(200, { // HttpOnly：脚本无法读取 &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly&#39; }); res.write(JSON.stringify(params)); res.end(); }); server.listen(&#39;8080&#39;); vue 框架的跨域（1 次跨域）利用 node + webpack + webpack-dev-server 代理接口跨域。在开发环境下，由于 Vue 渲染服务和接口代理服务都是 webpack-dev-server，所以页面与代理接口之间不再跨域，无须设置 Headers 跨域信息了。/* 导出服务器配置 */ module.exports = { entry: {}, module: {}, // ... devServer: { historyApiFallback: true, proxy: [{ context: &#39;/login&#39;, target: &#39;http://www.proxy2.com:8080&#39;, // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: &#39;www.domain1.com&#39; // 可以为 false，表示不修改 }], noInfo: true } } 本篇文章在于帮助我们理解跨域，以及不同跨域方式的基本原理，在公司的项目比较多，多个域使用同一个服务器或者数据，以及在开发环境时，跨域的情况基本无法避免，一般会有各种各样形式的跨域解决方案，但其根本原理基本都在上面的跨域方式当中方式，我们可以根据开发场景不同，选择最合适的跨域解决方案。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"跨域","slug":"跨域","permalink":"https://www.overtaking.top/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"JSONP","slug":"JSONP","permalink":"https://www.overtaking.top/tags/JSONP/"}]},{"title":"模拟 Vue 手写一个 MVVM","date":"2018-03-28T06:00:39.000Z","path":"20180328140039/","text":"MVVM 的前世今生MVVM 设计模式，是由 MVC（最早来源于后端）、MVP 等设计模式进化而来，M - 数据模型（Model），VM - 视图模型（ViewModel），V - 视图层（View）。在 MVC 模式中，除了 Model 和 View 层以外，其他所有的逻辑都在 Controller 中，Controller 负责显示页面、响应用户操作、网络请求及与 Model 的交互，随着业务的增加和产品的迭代，Controller 中的处理逻辑越来越多、越来越复杂，难以维护。为了更好的管理代码，为了更方便的扩展业务，必须要为 Controller “瘦身”，需要更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离，MVVM 为此而生。很多 MVVM 的实现都是通过数据绑定来将 View 的逻辑从其他层分离，可以用下图来简略的表示。MVVM 模型图使用 MVVM 设计模式的前端框架很多，其中渐进式框架 Vue 是典型的代表，并在开发使用中深得广大前端开发者的青睐，我们这篇就根据 Vue 对于 MVVM 的实现方式来简单模拟一版 MVVM 库。MVVM 的流程分析在 Vue 的 MVVM 设计中，我们主要针对 Compile（模板编译）、Observer（数据劫持）、Watcher（数据监听）和 Dep（发布订阅）几个部分来实现，核心逻辑流程可参照下图：MVVM 流程图类似这种 “造轮子” 的代码毋庸置疑一定是通过面向对象编程来实现的，并严格遵循开放封闭原则，由于 ES5 的面向对象编程比较繁琐，所以，在接下来的代码中统一使用 ES6 的 class 来实现。MVVM 类的实现在 Vue 中，对外只暴露了一个名为 Vue 的构造函数，在使用的时候 new 一个 Vue 实例，然后传入了一个 options 参数，类型为一个对象，包括当前 Vue 实例的作用域 el、模板绑定的数据 data 等等。我们模拟这种 MVVM 模式的时候也构建一个类，名字就叫 MVVM，在使用时同 Vue 框架类似，需要通过 new 指令创建 MVVM 的实例并传入 options。/* 文件：MVVM.js */ class MVVM { constructor(options) { // 先把 el 和 data 挂在 MVVM 实例上 this.$el = options.el; this.$data = options.data; // 如果有要编译的模板就开始编译 if (this.$el) { // 数据劫持，就是把对象所有的属性添加 get 和 set new Observer(this.$data); // 将数据代理到实例上 this.proxyData(this.$data); // 用数据和元素进行编译 new Compile(this.el, this); } } proxyData(data) { // 代理数据的方法 Object.keys(data).forEach(key =&gt; { Object.defineProperty(this, key, { get() { return data[key]; } set(newVal) { data[key] = newVal; } }); }); } } 通过上面代码，我们可以看出，在我们 new 一个 MVVM 的时候，在参数 options 中传入了一个 Dom 的根元素节点和数据 data 并挂在了当前的 MVVM 实例上。当存在根节点的时候，通过 Observer 类对 data 数据进行了劫持，并通过 MVVM 实例的方法 proxyData 把 data 中的数据挂在当前 MVVM 实例上，同样对数据进行了劫持，是因为我们在获取和修改数据的时候可以直接通过 this 或 this.$data，在 Vue 中实现数据劫持的核心方法是 Object.defineProperty，我们也使用这个方式通过添加 getter 和 setter 来实现数据劫持。最后使用 Compile 类对模板和绑定的数据进行了解析和编译，并渲染在根节点上，之所以数据劫持和模板解析都使用类的方式实现，是因为代码方便维护和扩展，其实不难看出，MVVM 类其实作为了 Compile 类和 Observer 类的一个桥梁。模板编译 Compile 类的实现Compile 类在创建实例的时候需要传入两个参数，第一个参数是当前 MVVM 实例作用的根节点，第二个参数就是 MVVM 实例，之所以传入 MVVM 的实例是为了更方便的获取 MVVM 实例上的属性。在 Compile 类中，我们会尽量的把一些公共的逻辑抽取出来进行最大限度的复用，避免冗余代码，提高维护性和扩展性，我们把 Compile 类抽取出的实例方法主要分为两大类，辅助方法和核心方法，在代码中用注释标明。解析根节点内的 Dom 结构/* 文件：Compile.js */ class Compile { constructor(el, vm) { this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 如过传入的根元素存在，才开始编译 if (this.el) { // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片） let fragment = this.node2fragment(this.el); } } /* 辅助方法 */ // 判断是否是元素节点 isElementNode(node) { return node.nodeType === 1; } /* 核心方法 */ // 将根节点转移至文档碎片 node2fragment(el) { // 创建文档碎片 let fragment = document.createDocumentFragment(); // 第一个子节点 let firstChild; // 循环取出根节点中的节点并放入文档碎片中 while (firstChild = el.firstChild) { fragment.appendChild(firstChild); } return fragment; } } 上面编译模板的过程中，前提条件是必须存在根元素节点，传入的根元素节点允许是一个真实的 Dom 元素，也可以是一个选择器，所以我们创建了辅助方法 isElementNode 来帮我们判断传入的元素是否是 Dom，如果是就直接使用，是选择器就获取这个 Dom，最终将这个根节点存入 this.el 属性中。解析模板的过程中为了性能，我们应取出根节点内的子节点存放在文档碎片中（内存），需要注意的是将一个 Dom 节点内的子节点存入文档碎片的过程中，会在原来的 Dom 容器中删除这个节点，所以在遍历根节点的子节点时，永远是将第一个节点取出存入文档碎片，直到节点不存在为止。编译文档碎片中的结构在 Vue 中的模板编译的主要就是两部分，也是浏览器无法解析的部分，元素节点中的指令和文本节点中的 Mustache 语法（双大括号）。/* 文件：Compile.js —— 完善 */ class Compile { constructor(el, vm) { this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 如过传入的根元素存在，才开始编译 if (this.el) { // 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片） let fragment = this.node2fragment(this.el); // ********** 以下为新增代码 ********** // 2、将模板中的指令中的变量和 {{}} 中的变量替换成真实的数据 this.compile(fragment); // 3、把编译好的 fragment 再塞回页面中 this.el.appendChild(fragment); // ********** 以上为新增代码 ********** } } /* 辅助方法 */ // 判断是否是元素节点 isElementNode(node) { return node.nodeType === 1; } // ********** 以下为新增代码 ********** // 判断属性是否为指令 isDirective(name) { return name.includes(&#39;v-&#39;); } // ********** 以上为新增代码 ********** /* 核心方法 */ // 将根节点转移至文档碎片 node2fragment(el) { // 创建文档碎片 let fragment = document.createDocumentFragment(); // 第一个子节点 let firstChild; // 循环取出根节点中的节点并放入文档碎片中 while (firstChild = el.firstChild) { fragment.appendChild(firstChild); } return fragment; } // ********** 以下为新增代码 ********** // 解析文档碎片 compile(fragment) { // 当前父节点节点的子节点，包含文本节点，类数组对象 let childNodes = fragment.childNodes; // 转换成数组并循环判断每一个节点的类型 Array.from(childNodes).forEach(node =&gt; { if (this.isElementNode(node)) { // 是元素节点 // 递归编译子节点 this.compile(node); // 编译元素节点的方法 this.compileElement(node); } else { // 是文本节点 // 编译文本节点的方法 this.compileText(node); } }); } // 编译元素 compileElement(node) { // 取出当前节点的属性，类数组 let attrs = node.attributes; Array.form(attrs).forEach(attr =&gt; { // 获取属性名，判断属性是否为指令，即含 v- let attrName = attr.name; if (this.isDirective(attrName)) { // 如果是指令，取到该属性值得变量在 data 中对应得值，替换到节点中 let exp = attr.value; // 取出方法名 let [, type] = attrName.split(&#39;-&#39;); // 调用指令对应得方法 CompileUtil[type](node, this.vm, exp); } }); } // 编译文本 compileText(node) { // 获取文本节点的内容 let exp = node.contentText; // 创建匹配 {{}} 的正则表达式 let reg = /\\{\\{([^}+])\\}\\}/g; // 如果存在 {{}} 则使用 text 指令的方法 if (reg.test(exp)) { CompileUtil[&#39;text&#39;](node, this.vm, exp); } } // ********** 以上为新增代码 ********** } 上面代码新增内容得主要逻辑就是做了两件事：调用 compile 方法对 fragment 文档碎片进行编译，即替换内部指令和 Mustache 语法中变量对应的值；将编译好的 fragment 文档碎片塞回根节点。在第一个步骤当中逻辑是比较繁琐的，首先在 compile 方法中获取所有的子节点，循环进行编译，如果是元素节点需要递归 compile，传入当前元素节点。在这个过程当中抽取出了两个方法，compileElement 和 compileText 用来对元素节点的属性和文本节点进行处理。compileElement 中的核心逻辑就是处理指令，取出元素节点所有的属性判断是否是指令，是指令则调用指令对应的方法。compileText 中的核心逻辑就是取出文本的内容通过正则表达式匹配出被 Mustache 语法的 “&#123;&#123; &#125;&#125;” 包裹的内容，并调用处理文本的 text 方法。文本节点的内容有可能存在 “&#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125; &#123;&#123; &#125;&#125;”，正则匹配默认是贪婪的，为了防止第一个 “&#123;” 和最后一个 “&#125;” 进行匹配，所以在正则表达式中应使用非贪婪匹配。在调用指令的方法时都是调用的 CompileUtil 下对应的方法，我们之所以单独把这些指令对应的方法抽离出来存储在 CompileUtil 对象下的目的是为了解耦，因为后面其他的类还要使用。CompileUtil 对象中指令方法的实现CompileUtil 中存储着所有的指令方法及指令对应的更新方法，由于 Vue 的指令很多，我们这里只实现比较典型的 v-model 和 “&#123;&#123; &#125;&#125;” 对应的方法，考虑到后续更新的情况，我们统一把设置值到 Dom 中的逻辑抽取出对应上面两种情况的方法，存放到 CompileUtil 的 updater 对象中。/* 文件：CompileUtil.js */ const CompileUtil = {}; // 更新节点数据的方法 CompileUti.updater = { // 文本更新 textUpdater(node, value) { node.textContent = value; }, // 输入框更新 modelUpdater(node, value) { node.value = value; } }; 这部分的整个思路就是在 Compile 编译模板后处理 v-model 和 “&#123;&#123; &#125;&#125;” 时，其实都是用 data 中的数据替换掉 fragment 文档碎片中对应的节点中的变量。因此会经常性的获取 data 中的值，在更新节点时又会重新设置 data 中的值，所以我们抽离出了三个方法 getVal、getTextVal 和 setVal 挂在了 CompileUtil 对象下。/* 文件：CompileUtil.js —— 取值方法 */ // 获取 data 值的方法 CompileUtil.getVal = function (vm, exp) { // 将匹配的值用 . 分割开，如 vm.data.a.b exp = exp.split(&#39;.&#39;); // 归并取值 return exp.reduce((prev, next) =&gt; { return prev[next]; }, vm.$data); }; // 获取文本 {{}} 中变量在 data 对应的值 CompileUtil.getTextVal = function (vm, exp) { // 使用正则匹配出 {{ }} 间的变量名，再调用 getVal 获取值 return exp.replace(/\\{\\{([^}]+)\\}\\}/g, (...args) =&gt; { return this.getVal(vm, args[1]); }); }; // 设置 data 值的方法 CompileUtil.setVal = function (vm, exp, newVal) { exp = exp.split(&#39;.&#39;); return exp.reduce((prev, next, currentIndex) =&gt; { // 如果当前归并的为数组的最后一项，则将新值设置到该属性 if (currentIndex === exp.length - 1) { return prev[next] = newVal } // 继续归并 return prev[next]; }, vm.$data); } 获取和设置 data 的值两个方法 getVal 和 setVal 思路相似，由于获取的变量层级不定，可能是 data.a，也可能是 data.obj.a.b，所以都是使用归并的思路，借用 reduce 方法实现的，区别在于 setVal 方法在归并过程中需要判断是不是归并到最后一级，如果是则设置新值，而 getTextVal 就是在 getVal 外包了一层处理 “&#123;&#123; &#125;&#125;” 的逻辑。在这些准备工作就绪以后就可以实现我们的主逻辑，即对 Compile 类中解析的文本节点和元素节点指令中的变量用 data 值进行替换，还记得前面说针对 v-model 和 “&#123;&#123; &#125;&#125;” 进行处理，因此设计了 model 和 text 两个核心方法。CompileUtil.model 方法的实现：/* 文件：CompileUtil.js —— model 方法 */ // 处理 v-model 指令的方法 CompileUtil.model = function (node, vm, exp) { // 获取赋值的方法 const updateFn = this.updater[&#39;modelUpdater&#39;]; // 获取 data 中对应的变量的值 let value = this.getVal(vm, exp); // 添加观察者，作用与 text 方法相同 new Watcher(vm, exp, newValue =&gt; { updateFn &amp;&amp; updateFn(node, newValue); }); // v-model 双向数据绑定，对 input 添加事件监听 node.addEventListener(&#39;input&#39;, e =&gt; { // 获取输入的新值 let newValue = e.target.value; // 更新到节点 this.setVal(vm, exp, newValue); }); // 第一次设置值 updateFn &amp;&amp; updateFn(vm, value); }; CompileUtil.text 方法的实现：/* 文件：CompileUtil.js —— text 方法 */ // 处理文本节点 {{}} 的方法 CompileUtil.text = function (node, vm, exp) { // 获取赋值的方法 const updateFn = this.updater[&#39;textUpdater&#39;]; // 获取 data 中对应的变量的值 let value = this.getTextVal(vm, exp); // 通过正则替换，将取到数据中的值替换掉 {{ }} exp.replace(/\\{\\{([^}]+)\\}\\}/g, (...args) =&gt; { // 解析时遇到了模板中需要替换为数据值的变量时，应该添加一个观察者 // 当变量重新赋值时，调用更新值节点到 Dom 的方法 new Watcher(vm, arg[1], newValue =&gt; { // 如果数据发生变化，重新获取新值 updateFn &amp;&amp; updateFn(node, newValue); }); }); // 第一次设置值 updateFn &amp;&amp; updateFn(vm, value); }; 上面两个方法逻辑相似，都获取了各自的 updater 中的方法，对值进行设置，并且在设置的同时为了后续 data 中的数据修改，视图的更新，创建了 Watcher 的实例，并在内部用新值重新更新节点，不同的是 Vue 的 v-model 指令在表单中实现了双向数据绑定，只要表单元素的 value 值发生变化，就需要将新值更新到 data 中，并响应到页面上。所以我们的实现方式是给这个绑定了 v-model 的表单元素监听了 input 事件，并在事件中实时的将新的 value 值更新到 data 中，至于 data 中的改变后响应到页面中需要另外三个类 Watcher、Observer 和 Dep 共同实现，我们下面就来实现 Watcher 类。观察者 Watcher 类的实现在 CompileUtil 对象的方法中创建 Watcher 实例的时候传入了三个参数，即 MVVM 的实例、模板绑定数据的变量名 exp 和一个 callback，这个 callback 内部逻辑是为了更新数据到 Dom，所以我们的 Watcher 类内部要做的事情就清晰了，获取更改前的值存储起来，并创建一个 update 实例方法，在值被更改时去执行实例的 callback 以达到视图的更新。/* 文件：Watcher.js */ class Watcher { constructor(vm, exp, callback) { this.vm = vm; this.exp = exp; this.callback = callback; // 更改前的值 this.value = this.get(); } get() { // 将当前的 watcher 添加到 Dep 类的静态属性上 Dep.target = this; // 获取值触发数据劫持 let value = CompileUtil.getVal(this.vm, this.exp); // 清空 Dep 上的 Watcher，防止重复添加 Dep.target = null; return value; } update() { // 获取新值 let newValue = CompileUtil.getVal(this.vm, this.exp); // 获取旧值 let oldValue = this.value; // 如果新值和旧值不相等，就执行 callback 对 dom 进行更新 if (newValue !== oldValue) { this.callback(newValue); } } } 看到上面代码一定有两个疑问：使用 get 方法获取旧值得时候为什么要将当前的实例挂在 Dep 上，在获取值后为什么又清空了；update 方法内部执行了 callback 函数，但是 update 在什么时候执行。这就是后面两个类 Dep 和 observer 要做的事情，我们首先来介绍 Dep，再介绍 Observer 最后把他们之间的关系整个串联起来。发布订阅 Dep 类的实现其实发布订阅说白了就是把要执行的函数统一存储在一个数组中管理，当达到某个执行条件时，循环这个数组并执行每一个成员。/* 文件：Dep.js */ class Dep { constructor() { this.subs = []; } // 添加订阅 addSub(watcher) { this.subs.push(watcher); } // 通知 notify() { this.subs.forEach(watcher =&gt; watcher.update()); } } 在 Dep 类中只有一个属性，就是一个名为 subs 的数组，用来管理每一个 watcher，即 Watcher 类的实例，而 addSub 就是用来将 watcher 添加到 subs 数组中的，我们看到 notify 方法就解决了上面的一个疑问，Watcher 类的 update 方法是怎么执行的，就是这样循环执行的。接下来我们整合一下盲点：Dep 实例在哪里创建声明，又是在哪里将 watcher 添加进 subs 数组的；Dep 的 notify 方法应该在哪里调用；Watcher 内容中，使用 get 方法获取旧值得时候为什么要将当前的实例挂在 Dep 上，在获取值后为什么又清空了。这些问题在最后一个类 Observer 实现的时候都将清晰，下面我们重点来看最后一部分核心逻辑。数据劫持 Observer 类的实现还记得实现 MVVM 类的时候就创建了这个类的实例，当时传入的参数是 MVVM 实例的 data 属性，在 MVVM 中把数据通过 Object.defineProperty 挂到了实例上，并添加了 getter 和 setter，其实 Observer 类主要目的就是给 data 内的所有层级的数据都进行这样的操作。/* 文件：Observer.js */ class Observer { constructor (data) { this.observe(data); } // 添加数据监听 observe(data) { // 验证 data if (!data || typeof data !== &#39;object&#39;) return; // 要对这个 data 数据将原有的属性改成 set 和 get 的形式 // 要将数据一一劫持，先获取到 data 的 key 和 value Object.keys(data).forEach(key =&gt; { // 劫持（实现数据响应式） this.defineReactive(data, key, data[key]); this.observe(data[key]); // 深度劫持 }); } // 数据响应式 defineReactive (object, key, value) { let _this = this; // 每个变化的数据都会对应一个数组，这个数组是存放所有更新的操作 const dep = new Dep(); // 获取某个值被监听到 Object.defineProperty(object, key, { enumerable: true, configurable: true, get() { // 当取值时调用的方法 Dep.target &amp;&amp; dep.addSub(Dep.target); return value; }, set(newValue) { // 当给 data 属性中设置的值适合，更改获取的属性的值 if (newValue !== value) { _this.observe(newValue); // 重新赋值如果是对象进行深度劫持 value = newValue; dep.notify(); // 通知所有人数据更新了 } } }); } } 在的代码中 observe 的目的是遍历对象，在内部对数据进行劫持，即添加 getter 和 setter，我们把劫持的逻辑单独抽取成 defineReactive 方法，需要注意的是 observe 方法在执行最初就对当前的数据进行了数据类型验证，然后再循环对象每一个属性进行劫持，目的是给同为 Object 类型的子属性递归调用 observe 进行深度劫持。在 defineReactive 方法中，创建了 Dep 的实例，并对 data 的数据使用 get 和 set 进行劫持，还记得在模板编译的过程中，遇到模板中绑定的变量，就会解析，并创建 watcher，会在 Watcher 类的内部获取旧值，即当前的值，这样就触发了 get，在 get 中就可以将这个 watcher 添加到 Dep 的 subs 数组中进行统一管理，因为在代码中获取 data 中的值操作比较多，会经常触发 get，我们又要保证 watcher 不会被重复添加，所以在 Watcher 类中，获取旧值并保存后，立即将 Dep.target 赋值为 null，并且在触发 get 时对 Dep.target 进行了短路操作，存在才调用 Dep 的 addSub 进行添加。而 data 中的值被更改时，会触发 set，在 set 中做了性能优化，即判断重新赋的值与旧值是否相等，如果相等就不重新渲染页面，不等的情况有两种，如果原来这个被改变的值是基本数据类型没什么影响，如果是引用类型，我们需要对这个引用类型内部的数据进行劫持，因此递归调用了 observe，最后调用 Dep 的 notify 方法进行通知，执行 notify 就会执行 subs 中所有被管理的 watcher 的 update，就会执行创建 watcher 时的传入的 callback，就会更新页面。在 MVVM 类将 data 的属性挂在 MVVM 实例上并劫持与通过 Observer 类对 data 的劫持还有一层联系，因为整个发布订阅的逻辑都是在 data 的 get 和 set 上，只要触发了 MVVM 中的 get 和 set 内部会自动返回或设置 data 对应的值，就会触发 data 的 get 和 set，就会执行发布订阅的逻辑。通过上面长篇大论的叙述后，这个 MVVM 模式用到的几个类的关系应该完全叙述清晰了，虽然比较抽象，但是细心琢磨还是会明白之间的关系和逻辑，下面我们就来对我们自己实现的这个 MVVM 进行验证。验证 MVVM我们按照 Vue 的方式根据自己的 MVVM 实现的内容简单的写了一个模板如下：&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;MVVM&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 双向数据绑定 靠的是表单 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;ul&gt; &lt;li&gt;{{message}}&lt;/li&gt; &lt;/ul&gt; {{message}} &lt;/div&gt; &lt;!-- 引入依赖的 js 文件 --&gt; &lt;script src=&quot;./js/Watcher.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/Observer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/Compile.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/CompileUtil.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/Dep.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/MVVM.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new MVVM({ el: &#39;#app&#39;, data: { message: &#39;hello world!&#39; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 打开 Chrom 浏览器的控制台，在上面通过下面操作来验证：输入 vm.message = &#39;hello&#39; 看页面是否更新；输入 vm.$data.message = &#39;hello&#39; 看页面是否更新；改变文本输入框内的值，看页面的其他元素是否更新。总结通过上面的测试，相信应该理解了 MVVM 模式对于前端开发重大的意义，实现了双向数据绑定，实时保证 View 层与 Model 层的数据同步，并可以让我们在开发时基于数据编程，而最少的操作 Dom，这样大大提高了页面渲染的性能，也可以使我们把更多的精力用于业务逻辑的开发上。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.overtaking.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Vue","slug":"Vue","permalink":"https://www.overtaking.top/tags/Vue/"},{"name":"MVVM","slug":"MVVM","permalink":"https://www.overtaking.top/tags/MVVM/"}]},{"title":"浅析 event-loop 事件轮询","date":"2018-03-25T09:02:08.000Z","path":"20180325170208/","text":"浏览器中的事件轮询JavaScript 是一门单线程语言，之所以说是单线程，是因为在浏览器中，如果是多线程，并且两个线程同时操作了同一个 Dom 元素，那最后的结果会出现问题。所以，JavaScript 是单线程的，但是如果完全由上至下的一行一行执行代码，假如一个代码块执行了很长的时间，后面必须要等待当前执行完毕，这样的效率是非常低的，所以有了异步的概念，确切的说，JavaScript 的主线程是单线程的，但是也有其他的线程去帮我们实现异步操作，比如定时器线程、事件线程、Ajax 线程。在浏览器中执行 JavaScript 有两个区域，一个是我们平时所说的同步代码执行，是在栈中执行，原则是先进后出，而在执行异步代码的时候分为两个队列，macro-task（宏任务）和 micro-task（微任务），遵循先进先出的原则。/* 作用域链 */ function one() { console.log(1); function two() { console.log(2); function three() { console.log(3); } three(); } two(); } one(); // 1 // 2 // 3 上面的代码都是同步的代码，在执行的时候先将全局作用域放入栈中，执行全局作用域中的代码，解析了函数 one，当执行函数调用 one() 的时候将 one 的作用域放入栈中，执行 one 中的代码，打印了 1，解析了 two，执行 two()，将 two 放入栈中，执行 two，打印了 2，解析了 three，执行了 three()，将 three 放入栈中，执行 three，打印了 3。在函数执行完释放的过程中，因为全局作用域中有 one 正在执行，one 中有 two 正在执行，two 中有 three 正在执行，所以释放内存时必须由内层向外层释放，three 执行后释放，此时 three 不再占用 two 的执行环境，将 two 释放，two 不再占用 one 的执行环境，将 one 释放，one 不再占用全局作用域的执行环境，最后释放全局作用域，这就是在栈中执行同步代码时的先进后出原则，更像是一个杯子，先放进去的在最下面，需要最后取出。而异步队列更像时一个管道，有两个口，从入口进，从出口出，所以是先进先出，在宏任务队列中代表的有 setTimeout、setInterval、setImmediate、MessageChannel，微任务的代表为 Promise 的 then 方法、MutationObserve（已废弃）。案例 1const messageChannel = new MessageChannel(); const prot2 = messageChannel.port2; messageChannel.port1.postMessage(&#39;I love you&#39;); console.log(1); prot2.onmessage = function (e) { console.log(e.data); }; console.log(2); // 1 // 2 // I love you 从上面案例中可以看出，MessageChannel 是宏任务，晚于同步代码执行。案例 2setTimeout(() =&gt; console.log(1), 2000); setTimeout(() =&gt; console.log(2), 1000); console.log(3); // 3 // 2 // 1 上面代码可以看出其实 setTimeout 并不是在同步代码执行的时候就放入了异步队列，而是等待时间到达时才会放入异步队列，所以才会有了上面的结果。案例 3setImmediate(function () { console.log(&#39;setImmediate&#39;); }); setTimeout(function () { console.log(&#39;setTimeout&#39;); }, 0); console.log(1); // 1 // setTimeout // setImmediate 同为宏任务，setImmediate 在 setTimeout 延迟时间为 0 时是晚于 setTimeout 被放入异步队列的，这里需要注意的是 setImmediate 在浏览器端，到目前为止只有 IE 实现了。上面的案例都是关于宏任务，下面我们举一个有微任务的案例来看一看微任务和宏任务的执行机制，在浏览器端微任务的代表其实就是 Promise 的 then 方法。案例 4setTimeout(() =&gt; { console.log(&#39;setTimeout1&#39;); Promise.resolve().then(data =&gt; { console.log(&#39;Promise1&#39;); }); }, 0); Promise.resolve().then(data =&gt; { console.log(&#39;Promise2&#39;); setTimeout(() =&gt; { console.log(&#39;setTimeout2&#39;); }, 0); }); // Promise2 // setTimeout1 // Promise1 // setTimeout2 从上面的执行结果其实可以看出，同步代码在栈中执行完毕后会先去执行微任务队列，将微任务队列执行完毕后，会去执行宏任务队列，宏任务队列执行一个宏任务以后，会去看看有没有产生新的微任务，如果有则清空微任务队列后再执行下一个宏任务，依次轮询，直到清空整个异步队列。Node 中的事件轮询在 Node 中的事件轮询机制与浏览器相似又不同，相似的是，同样先在栈中执行同步代码，同样是先进后出，不同的是 Node 有自己的多个处理不同问题的阶段和对应的队列，也有自己内部实现的微任务 process.nextTick，Node 的整个事件轮询机制是 Libuv 库实现的。Node 中事件轮询的流程如下图：Node 事件环流程图从图中可以看出，在 Node 中有多个队列，分别执行不同的操作，而每次在队列切换的时候都去执行一次微任务队列，反复的轮询。案例 1setTimeout(function () { console.log(&#39;setTimeout&#39;); }, 0); setImmediate(function () { console.log(&#39;setInmediate&#39;); }); 默认情况下 setTimeout 和 setImmediate 是不知道哪一个先执行的，顺序不固定，Node 执行的时候有准备的时间，setTimeout 延迟时间设置为 0 其实是大概 4ms，假设 Node 准备时间在 4ms 之内，开始执行轮询，定时器没到时间，所以轮询到下一队列，此时要等再次循环到 timer 队列后执行定时器，所以会先执行 check 队列的 setImmediate。如果 Node 执行的准备时间大于了 4ms，因为执行同步代码后，定时器的回调已经被放入 timer 队列，所以会先执行 timer 队列。案例 2setTimeout(() =&gt; { console.log(&#39;setTimeout1&#39;); Promise.resolve().then(() =&gt; { console.log(&#39;Promise1&#39;); }); }, 0); setTimeout(() =&gt; { console.log(&#39;setTimeout2&#39;); }, 0); console.log(1); // 1 // setTimeout1 // setTimeout2 // Promise1 Node 事件轮询中，轮询到每一个队列时，都会将当前队列任务清空后，在切换下一队列之前清空一次微任务队列，这是与浏览器端不一样的。浏览器端会在宏任务队列当中执行一个任务后插入执行微任务队列，清空微任务队列后，再回到宏任务队列执行下一个宏任务。上面案例在 Node 事件轮询中，会将 timer 队列清空后，在轮询下一个队列之前执行微任务队列。案例 3setTimeout(() =&gt; { console.log(&#39;setTimeout1&#39;); }, 0); setTimeout(() =&gt; { console.log(&#39;setTimeout2&#39;); }, 0); Promise.resolve().then(() =&gt; { console.log(&#39;Promise1&#39;); }); console.log(1); // 1 // Promise1 // setTimeout1 // setTimeout2 上面代码的执行过程是，先执行栈，栈执行时打印 1，Promise.resolve() 产生微任务，栈执行完毕，从栈切换到 timer 队列之前，执行微任务队列，再去执行 timer 队列。案例 4setImmediate(() =&gt; { console.log(&#39;setImmediate1&#39;); setTimeout(() =&gt; { console.log(&#39;setTimeout1&#39;); }, 0); }); setTimeout(() =&gt; { console.log(&#39;setTimeout2&#39;); setImmediate(() =&gt; { console.log(&#39;setImmediate2&#39;); }); }, 0); //结果1 // setImmediate1 // setTimeout2 // setTimeout1 // setImmediate2 // 结果2 // setTimeout2 // setImmediate1 // setImmediate2 // setTimeout1 setImmediate 和 setTimeout 执行顺序不固定，假设 check 队列先执行，会执行 setImmediate 打印 setImmediate1，将遇到的定时器放入 timer 队列，轮询到 timer 队列，因为在栈中执行同步代码已经在 timer 队列放入了一个定时器，所以按先后顺序执行两个 setTimeout，执行第一个定时器打印 setTimeout2，将遇到的 setImmediate 放入 check 队列，执行第二个定时器打印 setTimeout1，再次轮询到 check 队列执行新加入的 setImmediate，打印 setImmediate2，产生结果 1。假设 timer 队列先执行，会执行 setTimeout 打印 setTimeout2，将遇到的 setImmediate 放入 check 队列，轮询到 check 队列，因为在栈中执行同步代码已经在 check 队列放入了一个 setImmediate，所以按先后顺序执行两个 setImmediate，执行第一个 setImmediate 打印 setImmediate1，将遇到的 setTimeout 放入 timer 队列，执行第二个 setImmediate 打印 setImmediate2，再次轮询到 timer 队列执行新加入的 setTimeout，打印 setTimeout1，产生结果 2。案例 5setImmediate(() =&gt; { console.log(&#39;setImmediate1&#39;); setTimeout(() =&gt; { console.log(&#39;setTimeout1&#39;); }, 0); }); setTimeout(() =&gt; { process.nextTick(() =&gt; console.log(&#39;nextTick&#39;)); console.log(&#39;setTimeout2&#39;); setImmediate(() =&gt; { console.log(&#39;setImmediate2&#39;); }); }, 0); //结果1 // setImmediate1 // setTimeout2 // setTimeout1 // nextTick // setImmediate2 // 结果2 // setTimeout2 // nextTick // setImmediate1 // setImmediate2 // setTimeout1 这与上面一个案例类似，不同的是在 setTimeout 执行的时候产生了一个微任务 nextTick，我们只要知道，在 Node 事件轮询中，在切换队列时要先去执行微任务队列，无论是 check 队列先执行，还是 timer 队列先执行，都会很容易分析出上面的两个结果。案例 6const fs = require(&#39;fs&#39;); fs.readFile(&#39;./.gitignore&#39;, &#39;utf8&#39;, function () { setTimeout(() =&gt; { console.log(&#39;timeout&#39;); }, 0); setImmediate(function () { console.log(&#39;setImmediate&#39;); }); }); // setImmediate // timeout 上面案例的 setTimeout 和 setImmediate 的执行顺序是固定的，前面都是不固定的，这是为什么？因为前面的不固定是在栈中执行同步代码时就遇到了 setTimeout 和 setImmediate，因为无法判断 Node 的准备时间，不确定准备结束定时器是否到时并加入 timer 队列。而上面代码明显可以看出 Node 准备结束后会直接执行 poll 队列进行文件的读取，在回调中将 setTimeout 和 setImmediate 分别加入 timer 队列和 check 队列，Node 队列的轮询是有顺序的，在 poll 队列后应该先切换到 check 队列，然后再重新轮询到 timer 队列，所以得到上面的结果。案例 7Promise.resolve().then(() =&gt; console.log(&#39;Promise&#39;)); process.nextTick(() =&gt; console.log(&#39;nextTick&#39;)); // nextTick // Promise 在 Node 中有两个微任务，Promise 的 then 方法和 process.nextTick，从上面案例的结果我们可以看出，在微任务队列中 process.nextTick 是优先执行的。上面内容就是浏览器与 Node 在事件轮询的规则，相信在读完以后应该已经彻底弄清了浏览器的事件轮询机制和 Node 的事件轮询机制，并深刻的体会到了他们之间的相同和不同。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"异步","slug":"异步","permalink":"https://www.overtaking.top/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Promise","slug":"Promise","permalink":"https://www.overtaking.top/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.overtaking.top/tags/Node-js/"}]},{"title":"Git 命令总结，从零到熟悉","date":"2017-12-13T18:41:01.000Z","path":"20171214024101/","text":"什么是 Git？Git 是一个免费的开源分布式版本控制系统，它的设计目的是为了速度和效率的处理从小型到大型的项目；Git 可以帮我们管理我们的代码，记录历史，只要代码提交到 Git 上就永久不会丢失，可以随时 “穿越”（回到之前的某一个版本）；可以多端共享，团队协作中，多个人操作了同一个文件时，可以实现自动合并（模块化，组件化）、标记冲突，拥有强大的分支管理系统。Git 与 SVN 的区别SVN：集中式，需要一台中央服务器，所有代码的拉取和提交都是在中央服务器，一旦中央服务器或者网络出现故障，则不能拉取和提交代码，需要不断去备份中央服务器，防止代码丢失。Git：分布式，有一个中央服务器的同时，每个开发者本地都有自己的本地仓库，拥有完整的版本库，不用担心代码丢失，Git 存储的是代码变化的快照，更新代码的速度要比 SVN 更快。Git 安装Windowshttps://git-scm.com/Mac如果安装过 Xcode 自带 Git，https://developer.apple.com/xcode/可以安装 Homebrew，是 wmac 的包管理器，https://brew.sh/，下面是两款界面美化插件：Oh My ZSH：http://ohmyz.sh/iTerm2：https://www.iterm2.com/常用 Linux 命令查看当前工作目录$ pwd 创建文件夹$ mkdir 文件夹名 改变路径# 进入盘符 $ cd d: # 进入文件夹 $ cd 文件夹名 # 回上一级目录 $ cd .. # 进入某一个路径 $ cd 路径 想要进入某一个不知道路径的文件夹中，可以直接拖拽该文件到命令窗口，会自动识别路径。查看文件列表$ ls $ ls -a $ ls -al 下面命令加了 -a 参数可以查看隐藏文件，加了 -al 参数可以查看所有文件及权限位。创建文件$ touch 文件名 移动文件$ mv 文件/文件夹 路径 移动文件时可以通过第二个参数对文件进行重命名操作。拷贝文件$ cp 文件/文件夹 路径 将文件或者文件夹移动或拷贝到所输入的路径下。查看文件内容$ cat 文件名 删除文件 / 文件夹$ rm -rf 文件夹名 $ rm 文件名 -rf 为递归删除，后面加上 * 为参数会递归删除整个文件夹的内容，rm -rf *（慎用）。清空命令窗口$ clear 查看命令历史# 直接在命令行中查看 $ history # 将当前 Git 的命令历史写入文件中 $ history &gt; 文件名 使用 vi 编辑器编辑文件$ vi 文件名 # 进入编辑模式（键盘） i # 进入命令模式（键盘） Esc # 保存并退出（键盘） :wq # 强制退出（键盘） :q! 使用命令编辑文件# 向文件输入内容 $ echo 内容 &gt; 文件名 # 向文件追加内容 $ echo 内容 &gt;&gt; 文件名 当使用 echo 编辑了一个不存在的文件时，会创建一个新文件并将内容编辑到文件中，而 touch 创建的是空文件。Git 的本地操作Git 在管理文件时，所有文件都具有三种状态，已修改、已暂存、已提交。Git 在本地仓库中由三部分组成，工作区、暂存区、版本库。Git 管理的文件夹下都有一个名为 .git 的隐藏文件夹。对应关系如下：已修改 → 工作区已暂存 → 暂存区（.git 文件夹下的 index 文件中）已提交 → 版本库配置用户不配置用户无法提交代码。# 查看配置信息 $ git config --list # 配置用户名 $ git config --global user.name &#39;你的名字&#39; # 配置邮箱 $ git config --global user.email &#39;你的邮箱&#39; # 查看某一项配置 $ git config --global user.name $ git config --global user.email 配置用户信息参数：--local：只对某一个仓库生效；--global：对计算机当前用户所有仓库生效；--system：对计算机整个操作系统生效。初始化 Git 仓库在要初始化的文件夹下执行下面命令，告诉 Git 哪个文件夹被 Git 所管理，一个项目初始化一次，不能嵌套。# 把已有项目纳入 Git 管理 $ cd 项目代码所在文件夹 $ git init # 新建项目直接用 Git 管理 $ cd 希望创建项目的文件夹 $ git init your_project #会在当前路径下创建和项目名称同名的文件夹 $ cd your_project 查看 Git 状态$ git status 文件为红色，代表有修改，文件名为绿色，代表已经加入暂存区。添加到暂存区# 将单个文件变化提交到暂存区，参数支持多个 $ git add 文件名/文件夹 # 将已经被 Git 管理的文件变化全部提交 $ git add -u # 将修改、添加文件的变化全部提交 $ git add . # 将修改、添加、删除文件的变化全部提交 $ git add -A 删除暂存区# 删除暂存区，工作区不保留，参数支持多个 $ git rm 文件名/文件夹 # 删除暂存区，工作区保留 $ git rm --cached 文件名 # 删除全部暂存区 $ git rm --cached . -r 当参数为 . 的时候删除全部暂存区，所以需要加上代表递归删除的参数 -r。重命名暂存区文件# 方式一（不常用） $ mv oldname newname $ git rm oldname $ git add newname # 方式二 $ git mv oldname newname 当对一个已被 Git 管理的文件使用 mv 重命名时，执行 git status 命令时，会提示删除该文件（旧名字），新增该文件（新名字），使用 git rm、git add 命令进行删除和添加，执行 git status 命令时会提示该文件从 renamed: oldname -&gt; newname，而 git mv 命令等于将上面三个步骤合并成一个。注意：OS 系统中大小写不敏感，重命名后的文件名只是大小写改变，git mv 命令执行会失效。提交到版本库# 从暂存区提交到版本库 $ git commit -m &#39;版本信息&#39; # 从工作区直接提交到版本库（需要之前添加过暂存区） $ git commit -am &#39;版本信息&#39; 查看提交日志（版本库）# 最详细的信息 $ git log # 查看某一个分支的提交历史 $ git log 分支名 # 单行查看，只有版本号和提交信息 $ git log --online # 查看最近 4 个提交，数字根据需要配置 $ git log -n4 # 查看所有分支的提交历史 $ git log --all # 查看所有分支图形化的提交历史 $ git log --all --graph # 查看全部版本记录，包含被删除的提交记录 $ git reflog # 以列表的方式查看单个文件的提交 $ git blame 文件名 --oneline、-n*（n 可省略）、--all 和 --graph 等参数可以组合使用；log 和 reflog 的区别在于 reflog 可以查看被删除的提交记录，当想回退被删除的提交时使用；查看图形化分支时，红色线代表主分支，绿色线代表新创建的分支，分支上的 * 代表提交到版本库的节点。查看 Git 命令 Web 文档$ git help --web 命令 暂存更改分支工作区有更改不能直接切换其他分支，可以提交更改或者暂存更改，若暂存更改（使用暂存区覆盖掉工作区），等待重新切回分支时，还原暂存。此处所说的暂存不是之前的将代码提交到暂存区，因为当前分支工作区的代码会变成要切换分支工作区的代码，而导致当前分支工作区的更改丢失，此处的暂存类似于将修改寄存，重新切回该分支时再还原。# 暂存更改 $ git stash # 查看暂存列表 $ git stash --list # 还原暂存的内容 $ git stash apply|pop stash@{n} apply 与 pop 都是用于还原暂存的内容到工作区，stash@{n} 代表还原指定的暂存，n 代表暂存的序号，若省略 stash@{n} 则代表默认取出最新的暂存，apply 与 pop 的区别是，apply 还原的暂存，在暂存栈中依然存在，可多次还原，pop 还原的暂存在覆盖到工作区同时，暂存栈中删除该暂存。分支操作查看分支# 查看本地分支及分支最后一次提交信息 $ git branch # 查看本地分支 $ git branch -v # 查看所有分支 $ git branch -a # 查看所有分支及最后一次提交信息 $ git branch -av 创建分支# 从当前所在分支的 commit 创建分支 $ git branch 新分支名 # 基于已有分支的 commit 创建分支 $ git branch 新分支名 分支名 注意：新创建的分支和主分支 master 还是同一个区域，新建的文件只有提交到新分支的版本库才真正脱离关系；Git 刚刚初始化管理的的文件夹必须有一次提交到版本库（root-commit：根提交）以后才会有主分支 master，否则即使创建了新分支也无法切换回 master。切换分支# 切换分支 $ git checkout 分支名 # 创建并切换分支 $ git checkout -b 分支名 删除分支# 删除已经合并的分支 $ git branch -d 分支名 # 删除未合并的分支 $ git branch -D 分支名 需切换出要删除的分支，才能进行删除操作，使用 -d 在删除前 Git 会判断在该分支上开发的功能是否被 merge 到其它分支，如果没有，不能删除，如果 merge 到其它分支，但之后又在其上做了开发，使用 -d 还是不能删除，-D 会强制删除。合并分支将指定分支合并到当前所在的分支，所以，在分支开发完毕后，合并分支需要先切换回目标分支。$ git merge 指定的分支名 比较变更# 两个不同分支的比较，文件名参数省略比较所有文件 $ git diff 分支1 分支2 文件名 # 两个不同的 commit 比较，文件名参数省略比较所有文件 $ git diff 61db01a 968adc7 文件名 commit 也可以用 HEAD 指代当前 HEAD 所在的提交，参数详情如下：HEAD^：父节点；HEAD^n：第 n 个父节点；HEAD^^：父节点的父节点；HEAD～：父节点；HEAD～2：父节点的父节点。HEAD^^ 等同于 HEAD～2，一个节点可以有多个子节点（在某个 commit 下创建多个分支），也可以有多个父节点（多个分支的 commit 合并）。# 工作区和暂存区比较 $ git diff # 工作区和版本库比较 $ git diff 分支名 # 暂存区和版本库比较 $ git diff --cached|--staged 撤销和回退操作$ git checkout 文件名 $ git checkout . # 撤销某一个版本的文件到工作区 $ git checkout 版本号 文件名 撤销操作是将暂存区覆盖到工作区，会放弃掉当前工作区修改的内容，. 参数是将整个暂存区覆盖当前工作区，一旦撤销就回不到之前的工作区了。当不小心将当前工作区错误的代码提交到暂存区，可以使用下面命令将暂存区回滚到上一个暂存区，只可回滚一次。# 文件名参数，省略后为撤销全部文件更改的暂存 $ git reset HEAD 文件名 # 按版本号回退版本 $ git reset --hard 版本号 # 回退到上一个版本 $ git reset --hard HEAD^ reset 指令的参数有三种，区别如下：--mixed：默认参数，可省略，暂存区、版本库修改为指定的 commit 状态；--soft：只将版本库修改为指定的 commit 状态；--hard：工作区、暂存区、版本库都修改为指定的 commit 状态。注意：当想要改变工作区内容时使用 checkout，当想要改变暂存区内容时使用 reset。解决冲突当创建分支后，分支和 master 主分支分别提交代码到版本库，此时切换回 master 主分支，合并分支会出现冲突，需手动处理后，重新提交到暂存区并提交到版本库。代码冲突：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD (当前更改) master 分支代码 ======= 开发分支的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 开发的分支 (传入的更改) Git 操作远程仓库远程仓库可以是 Github、Gitee（码云）、Coding 或者中央服务器等等。以下是常用免费仓库的地址，可以在首页注册账号：Github： https://github.comGitee： https://gitee.comCoding： https://coding.net克隆仓库克隆仓库带工作区$ git clone 项目地址 项目别名 上面命令项目别名是可选的，相当于给项目根文件夹重命名。克隆裸仓库# 使用哑协议 $ pwd # /Users/pandashen/Study/git_learning $ git clone --bare /Users/pandashen/Study/git_learning/.git ya.git # Cloning into bare repository &#39;ya.git&#39;... # done. # 使用智能协议 $ git clone --bare fill:///Users/pandashen/Study/git_learning/.git zhineng.git # Cloning into bare repository &#39;zhineng.git&#39;... # remote: Enumerating objects: 23, done. # remote: Counting objects: 100% (23/23), done. # remote: Compressing objects: 100% (18/18), done. # remote: Total 23 (delta 2), reused 0 (delta 0) # Receiving objects: 100% (23/23), done. # Resolving deltas: 100% (2/2), done. 裸仓库是一个文件夹，内部存储的与带有工作区仓库的 .git 相同，使用哑协议和智能协议的区别是哑协议没有进度信息，而且智能协议由于对传输的信息进行了打包、压缩，所以传输速度更快。关联远程仓库# 创建关联 $ git remote add origin 远程仓库地址 # 查看关联的远程仓库 $ git remote -v # 删除远程仓库的关联 $ git remote rm 地址别名 地址别名指的是上面的 origin，也可以是其他名称，必须对应要删除关联的地址别名。处理需要提交时过滤的文件/文件夹使用 WebStrom 编辑器编辑代码时，会自动在根目录生成 .idea 文件夹，使用 Mac 开发时根目录下的 .DS_Store 文件夹，以及在项目开发时会安装依赖存放在 node_modules 文件夹中，此类文件夹都是在把代码上传到远程仓库或中央服务器时不应该上传的，因此应该在上传之前过滤掉。在根目录创建 .gitignore 文件用于记录上传时被忽略的文件夹，内容（可根据需要自行配置）如下：# 文件：.gitignore .idea .DS_Store node_modules Git 上传时会自动忽略空文件夹，假设想要上传一个名为 public 的空文件夹，需要在文件夹内新建一个名为 .gitkeep 的文件（名字随意，最好有语义化），目的是使要提交的空文件夹不再为空。推送代码到远程仓库# 将本地所有分支推送到远端 $ git push 地址别名 --all # 将本地分支推送到远端 $ git push 地址别名 分支名 $ git push -u 地址别名 分支名 如果加上了 -u 参数，以后再次提交时可省略地址别名和分支名称，直接执行下面命令进行提交。$ git push $ git push -f 注意：-f 参数是在 Git 默认不允许的情况下也能将代码推送到远程服务器，是一个非常危险的命令，团队中一般禁止使用。拉取远程仓库的代码在提交代码时，如果直接提交到远程仓库，会将当前代码覆盖到远程仓库，如果别人之前也向远程仓库提交了代码，会在远程仓库中造成冲突，所以一般在提交代码之前先拉取远程仓库的代码与本地代码进行合并，并产生一个新的历史记录，若出现冲突，手动处理冲突后再统一提交到远程仓库。# 拉取但不合并代码（与 merge 配合，不常用） $ git fetch 地址别名 分支名 # 拉取并合并代码（常用） $ git pull origin master # 拉去代码执行变基操作 $ git pull --rebase 创建并拉取远程仓库的分支# 创建、切换并拉取远程分支 $ git checkout -b 分支名 地址别名/分支名 上面命令的意思是在本地创建并切换分支，同时将远端分支代码拉取到这个刚创建的分支。创建 gh-pages 分支来发布静态页涉及到远程仓库网站上的操作均以 Github 为例，其他仓库大同小异：在项目中创建一个静态页分支，我们使用 gh-pages 作为分支名；将 gh-pages 分支提交到线上仓库；找到提供仓库网站的 Settings 设置，切换到 github-pages 分支；点击该栏顶端的地址可以访问我们的静态页。# 创建静态页命令 $ git checkout -b gh-pages $ touch index.html $ git add . $ git commit -m &#39;提交信息&#39; $ git push origin gh-pages 向别人的项目提问在远程仓库网站进入别人的项目页面；点击 Issue 选项；输入问题标题和问题描述并点击提交；项目所有者可以回复或关闭问题。更改别人的项目代码在别人项目的主页上有一个叉子的图标，操作名为 Fork；Fork 是在当前项目下克隆了一份，如果代码更新，不会随之更新；使用 clone 命令克隆自己的地址将项目拉到本地，进行操作；默认就是 Git 仓库而且有 origin 地址，修改后可以将代码提交到自己的仓库上；只有 Fork 关系才能修改别人代码后点击 New pull request 发送提交请求；点击 Create pull request 按钮，填写提交标题，和提交详情，确认提交；项目所有者可以在自己的项目页面中 Pull request 菜单中查看提交并处理；点击 Close pull request 关闭，点击 Merge pull request 同意提交并合并。如果是一个团队的其他人需要操作同一个项目，上面的过程显得很繁琐，项目所有者可以在 Settings 的 Collaborators 选项中通过添加别人的账号或用户名向项目中添加贡献者，被添加的人拥有最大权限。GUI 界面化在当前的前端开发编辑器中，如 VSCode 和 WebStorm 等都集成了 Git，也有专门用于管理代码的软件 Sourcetree 等，可以直接点击按钮操作，不必使用命令行，这种操作 Git 的界面称作 GUI 界面，个人建议还是尽量少的使用 GUI 界面，命令行是根本，还是多敲命令，孰能生巧。","tags":[{"name":"Git","slug":"Git","permalink":"https://www.overtaking.top/tags/Git/"},{"name":"代码管理/版本控制","slug":"代码管理-版本控制","permalink":"https://www.overtaking.top/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"命令行","slug":"命令行","permalink":"https://www.overtaking.top/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"https://www.overtaking.top/tags/Linux/"}]},{"title":"JavaScript 的继承方式及优缺点","date":"2017-07-10T08:27:24.000Z","path":"20170710162724/","text":"前言JavaScript 原本不是纯粹的 OOP 语言，因为在 ES5 规范中没有类的概念，在 ES6 中才正式加入了 class 的编程方式，在 ES6 之前，也都是使用面向对象的编程方式，当然是 JavaScript 独有的面向对象编程，而且这种编程方式是建立在 JavaScript 独特的原型链的基础之上的，我们本篇就将对原型链以及面向对象编程最常用到的继承进行刨析。继承简介在 JavaScript 的中的面向对象编程，继承是给构造函数之间建立关系非常重要的方式，根据 JavaScript 原型链的特点，其实继承就是更改原本默认的原型链，形成新的原型链的过程。复制的方式进行继承复制的方式进行继承指定是对象与对象间的浅复制和深复制，这种方式到底算不算继承的一种备受争议，我们也把它放在我们的内容中，当作一个 “不正经” 的继承。浅复制创建一个浅复制的函数，第一个参数为复制的源对象，第二个参数为目标对象。// 浅复制方法 function extend(p, c = {}) { for (let k in p) { c[k] = p[k]; } return c; } // 源对象 const parent = { a: 1, b: function () { console.log(1); } }; // 目标对象 const child = { c: 2 }; // 执行 extend(parent, child); console.log(child); // { c: 2, a: 1, b: ƒ } 上面的 extend 方法在 ES6 标准中可以直接使用 Object.assign 方法所替代。深复制可以组合使用 JSON.stringify 和 JSON.parse 来实现，但是有局限性，不能处理函数和正则类型，所以我们自己实现一个方法，参数与浅复制相同。// 深复制方法 function extendDeeply(p, c = {}) { for (let k in p) { if (typeof p[k] === &#39;object&#39; &amp;&amp; typeof p[k] !== null) { c[k] = p[k] instanceof Array ? [] : {}; extendDeeply(p[k], c[k]); } else { c[k] = p[k]; } } return c; } // 源对象 const parent = { a: { b: 1 }, b: [1, 2, 3], c: 1, d: function () { console.log(1); } }; // 执行 const child = extendDeeply(parent); console.log(child); // { a: {b: 1}, b: [1, 2, 3], c: 1, d: ƒ } console.log(child.a === parent.a); // false console.log(child.b === parent.b); // false console.log(child.d === parent.d); // true 在上面可以看出复制后的新对象 child 的 a 属性和 b 的引用是独立的，与 parent 的 a 和 b 毫无关系，实现了深复制，但是 extendDeeply 函数并没有对函数类型做处理，因为函数内部执行相同的逻辑指向不同引用是浪费内存的。原型替换原型替换是继承当中最简单也是最直接的方式，即直接让父类和子类共用同一个原型对象，一般有两种实现方式。/* 原型替换 */ // 父类 function Parent() {} // 子类 function Child() {} // 简单粗暴的写法 Child.prototype = Parent.prototype; // 另一种种实现方式 Object.setPrototypeOf(Child.prototype, Parent.prototype); 上面这种方式 Child 的原型被替换掉，Child 的实例可以直接调用 Parent 原型上的方法，实现了对父类原型方法的继承。上面第二种方式使用了 Object.setPrototypeOf 方法，该方法是将传入第一个参数对象的原型设置为第二个参数传入的对象，所以我们第一个参数传入的是 Child 的原型，将 Child 原型的原型设置成了 Parent 的原型，使父、子类原型链产生关联，Child 的实例继承了 Parent 原型上的方法，在 Node.js 中的内置模块 util 中用来实现继承的方法 inherits，底层就是使用这种方式实现的。缺点：父类的实例也同样可以调用子类的原型方法，我们希望继承是单向的，否则无法区分父、子类关系，这种方式一般是不可取的。原型链继承原型链继承的思路是子类的原型的原型是父类的原型，形成了一条原型链，建立子类与父类原型的关系。/* 原型链继承 */ // 父类 function Parent(name) { this.name = name; this.hobby = [&#39;basketball&#39;, &#39;football&#39;]; } // 子类 function Child() {} // 继承 Child.prototype = new Parent(); 上面用 Parent 的实例替换了 Child 自己的原型，由于父类的实例原型直接指向 Parent.prototype，所以也使父、子类原型链产生关联，子类实例继承了父类原型的方法。缺点：只能继承父类原型上的方法，却无法继承父类上的属性；由于原型对象被替换，原本原型的 constructor 属性丢失；如果父类的构造函数中有属性，则创建的父类的实例也会有这个属性，用这个实例的作为子类的原型，这个属性就变成了所有子类实例所共有的，这个属性可能是多余的，并不是我们想要的，也可能我们希望它不是共有的，而是每个实例自己的。构造函数继承构造函数继承又被国内的开发者叫做 “经典继承”。/* 构造函数继承 */ // 父类 function Parent(name) { this.name = name; } // 子类 function Child() { Parent.apply(this, arguments); } let c = new Child(&#39;Panda&#39;); console.log(c); // { name: &#39;Panda&#39; } 构造函数继承的原理就是在创建 Child 实例的时候执行了 Child 构造函数，并借用 call 或 apply 在内部执行了父类 Parent，并把父类的属性创建给了 this，即子类的实例，解决了原型链继承不能继承父类属性的缺点。缺点：子类的实例只能继承父类的属性，却不能继承父类的原型的方法。构造函数原型链组合继承为了使子类既能继承父类原型的方法，又能继承父类的属性到自己的实例上，就有了这种组合使用的方式。/* 构造函数原型链组合继承 */ // 父类 function Parent(name) { this.name = name; } Parent.prototype.sayName = function () { console.log(this.name); }; // 子类 function Child() { Parent.apply(this, arguments); } // 继承 Child.prototype = new Parent(); const c = new Child(&#39;Panda&#39;); console.log(c); // { name: &#39;Panda&#39; } c.sayName(); // Panda 这种继承看似完美，但是之前 constructor 丢失和子类原型上多余共有属性的问题还是没有解决，在这基础上又产生了新的问题。缺点：父类被执行了两次，在使用 call 或 apply 继承属性时执行一次，在创建实例替换子类原型时又被执行了一次。原型式继承原型式继承主要用来解决用父类的实例替换子类的原型时共有属性的问题，以及父类构造函数执行两次的问题，也就是说通过原型式继承能保证子类的原型是 “干净的”，而保证只在继承父类的属性时执行一次父类。/* 原型式继承 */ // 父类 function Parent(name) { this.name = name; } // 子类 function Child() { Parent.apply(this, arguments); } // 继承函数 function create(obj) { function F() {} F.prototype = obj; return new F(); } // 继承 Child.prototype = create(Parent.prototype); const c = new Child(&#39;Panda&#39;); console.log(c); // { name: &#39;Panda&#39; } 原型式继承其实是借助了一个中间的构造函数，将中间构造函数 F 的 prototype 替换成了父类的原型，并创建了一个 F 的实例返回，这个实例是不具备任何属性的（干净的），用这个实例替换子类的原型，因为这个实例的原型指向 F 的原型，F 的原型同时又是父类的原型对象，所以子类实例继承了父类原型的方法，父类只在创建子类实例的时候执行了一次，省去了创建父类实例的过程。原型式继承在 ES5 标准中被封装成了一个专门的方法 Object.create，该方法的第一个参数与上面 create 函数的参数相同，即要作为原型的对象，第二个参数则可以传递一个对象，会把对象上的属性添加到这个原型上，一般第二个参数用来弥补 constructor 的丢失问题，这个方法不兼容 IE 低版本浏览器。寄生式继承寄生式继承就是用来解决子统一为原型式继承中返回的对象统一添加方法的问题，只是在原型式继承的基础上做了小小的修改。/* 寄生式继承 */ // 父类 function Parent(name) { this.name = name; } // 子类 function Child() { Parent.apply(this, arguments); } // 继承函数 function create(obj) { function F() {} F.prototype = obj; return new F(); } // 将子类方法私有化函数 function creatFunction(obj) { // 调用继承函数 let clone = create(obj); // 子类原型方法（多个） clone.sayName = function () {}; clone.sayHello = function () {}; return clone; } // 继承 Child.prototype = creatFunction(Parent.prototype); 缺点：因为寄生式继承最后返回的是一个对象，如果用一个变量直接来接收它，那相当于添加的所有方法都变成这个对象自身的了，如果创建了多个这样的对象，无法实现相同方法的复用。寄生组合式继承/* 寄生组合式继承 */ // 父类 function P(name, age) { this.name = name; this.age = age; } P.prototype.headCount = 1; P.prototype.eat = function () { console.log(&#39;eating...&#39;); }; // 子类 function C(name, age) { P.apply(this, arguments); } // 寄生组合式继承方法 function myCreate(Child, Parent) { function F() {} F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; // 让 Child 子类的静态属性 super 和 base 指向父类的原型 Child.super = Child.base = Parent.prototype; } // 调用方法实现继承 myCreate(C, P); // 向子类原型添加属性方法，因为子类构造函数的原型被替换，所以属性方法仍然在替换之后 C.prototype.language = &#39;javascript&#39;; C.prototype.work = function () { console.log(&#39;writing code use &#39; + this.language); }; C.work = function () { this.super.eat(); }; // 验证继承是否成功 const f = new C(&#39;nihao&#39;, 16); f.work(); C.work(); // writing code use javascript // eating... 寄生组合式继承基本规避了其他继承的大部分缺点，应该比较强大了，也是平时使用最多的一种继承，其中 Child.super 方法的作用是为了在调用子类静态属性的时候可以调用父类的原型方法。缺点：子类没有继承父类的静态方法。class…extends… 继承在 ES6 规范中有了类的概念，使继承变得容易，在规避上面缺点的完成继承的同时，又在继承时继承了父类的静态属性。/* class...extends... 继承 */ // 父类 class P { constructor(name, age) { this.name = name; this.age = age; } sayName() { console.log(this.name); } static sayHi() { console.log(&#39;Hello&#39;); } } // 子类继承父类 class C extends P { constructor(name, age) { supper(name, age); // 继承父类的属性 } sayHello() { P.sayHi(); } static sayHello() { super.sayHi(); } } let c = new C(&#39;jack&#39;, 18); c.sayName(); // jack c.sayHello(); // Hello C.sayHi(); // Hello C.sayHello(); // Hello 在子类的 constructor 中调用 supper 可以实现对父类属性的继承，父类的原型方法和静态方法直接会被子类继承，在子类的原型方法中使用父类的原型方法只需使用 this 或 supper 调用即可，此时 this 指向子类的实例，如果在子类的静态方法中使用 this 或 supper 调用父类的静态方法，此时 this 指向子类本身。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.overtaking.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"继承","slug":"继承","permalink":"https://www.overtaking.top/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"浅谈 JavaScript 原型链","date":"2017-07-09T05:18:56.000Z","path":"20170709131856/","text":"概述在 JavaScript 中有种说法叫 “万物皆对象”，就是说无论是构造函数创建的实例，构造函数本身、原型对象、数组、函数本质上都是对象，都拥有 __proto__ 属性，即隐式原型，所有函数都拥有 prototype 属性，即显式原型（仅限函数），原型对象（prototype 属性指向的对象），在定义函数时就被创建。原型链指向概述在 JavaScript 中整个原型链及查找机制用下图可以完整的表示出来。JS 原型链原型链指向：通过字面量和 new Object() 所创建的对象，他们是构造函数是 function Object() 的实例，Object 构造函数的 prototype 指向原型对象 Object.prototype，Object.prototype 的 constructor 指向构造函数 Object，而实例的 __proto__ 也指向 Object.prototype，Object.prototype 的 __proto__ 指向 null，所以 Object.prototype 也叫做顶级原型对象。上图中 new Foo() 创建的对象是构造函数 function Foo() 的实例，Foo 的 prototype 指向原型对象 Foo.prototype，Foo.prototype 的 constructor 指向构造函数 Foo，而实例的 __proto__ 也指向 Foo.prototype，并且 Foo.prototype 虽然是原型对象，但也是对象，所以是构造函数 Object 的实例，__proto__ 指向顶级原型对象 Object.prototype。数组的构造函数是 function Array() 原型链的指向与其他除 Object 以外的构造函数相同，Array.prototype 的 __proto__ 也指向顶级原型对象 Object.prototype，每一个数组都是 Array 的实例，__proto__ 都指向 Array.prototype。Object、Array、Foo 等构造函数的本质也是对象，他们的构造函数是 function Function()，Function 的 prototype 指向 Function.prototype，Function.prototype 的 constructor 指向 Function，所有的构造函数的 __proto__ 都指向 Function.prototype，包括 Function 本身，也就是说构造函数 Function 是由自己构造的，Function.prototype 的 __proto__ 同样指向顶级原型对象 Object.prototype。prototype 原型对象prototype 是函数的一个属性，属性的值指向了一个对象，所以，只有函数才有 prototype 原型对象。function Person(name, age) { this.name = name; this.age = age; } typeof Person.prototype; // object Person.prototype.constructor; // Person {} Person.prototype.job = &#39;qianduan&#39;; var p1 = new Person(&#39;panda&#39;, 18); var p2 = new Person(&#39;shen&#39;, 20); p1.constructor.prototype; // 实例对象查找构造函数原型对象的方法 一般会把对象共有的属性和方法都放在构造函数的原型对象上。实例、构造函数、原型对象的关系构造函数的原型 prototype 属性指向一个原型对象，实例也可以通过 __proto__ 指向原型对象，但本质上实例和构造函数之间是没有关系的。function Person(name, age) { this.name = name; this.age = age; } var p = new Person(&#39;nihao&#39;, 16); p.constructor = { name: &#39;haha&#39; }; p.name; // nihao 上面的代码中改变了构造函数的值为一个对象，对象中的属性 name 并没有影响实例的 name 属性值。实例属性 __proto__上面访问实例 p 的原型，实际使用 p.constructor.prototype 去找原型对象，当构造函数的值改变后是找不到原型对象的，所以实例并不是通过 constructor.prototype 去查找原型对象的，而是通过每一个实例都有的 __proto__ 属性，这个属性指向创建实例的构造函数原本的原型对象，这个属性不是标准，在 IE 下不存在。function Person(name, age) { this.name = name; this.age = age; } Person.prototype.job = &#39;qianduan&#39;; var p = new Person(&#39;nihao&#39;, 16); p.__proto__.job; // qianduan 当构造函数的 prototype 属性值被改变之后，在之前创建的实例的 __proto__ 属性值的仍然引用原型对象，所以对构造函数改变前创建的实例是没有影响的，会影响后面创建的实例。原型链查找机制实例对象在调用了一个属性或方法时，如果对象本身没有这个属性或方法，会去自己的原型对象查找，也就是 __proto__ 中查找，如果原型对象中没有，去原型对象的原型对象查找，一般（原型链没有被修改）情况下就是去 __proto__ 的 __proto__ 中查找，即顶级原型对象 Object.prototype，如果实例对象本身有这个属性，则直接输出，不再向上查找，如果对象本身和原型对象具有同名属性，则会屏蔽掉原型对象的属性。function Person(name, age) { this.name = name; this.age = age; } Person.prototype.job = &#39;qianduan&#39;; var p = new Person(&#39;nihao&#39;, 16); p.job; // qianduan p.job = &#39;houtai&#39;; p.job; // houtai p.__proto__.job; // qianduan 总结原型链的指向及原型链的查找机制是 JavaScript 中非常重要的基础知识，理解原型链是更深入了解继承和面向对象编程的必经之路。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.overtaking.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"原型链","slug":"原型链","permalink":"https://www.overtaking.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"正则表达式基础知识总结","date":"2017-07-04T07:46:32.000Z","path":"20170704154632/","text":"正则表达式的创建/* 字面量 */ const reg = /test/g; /* 构造函数 */ const reg = new RegExp(&#39;test&#39;, &#39;g&#39;); 创建正则表达式有两种方式，使用字面量创建和通过构造函数创建，构造函数创建是使用字符串创建，可以动态生成正则表达式，构造函数中的第二个参数是修饰符。正则表达式修饰符正则表达式中包含一些修饰符用来决定匹配的模式，如忽略大小写、全局匹配等。i：忽略大小写，如 /test/i，可以匹配 test、TEST、Test、tEsT 等；g：全局匹配，在查找到第一个匹配项时不会停止，会继续向后查找到所有的匹配项；m：允许多行匹配，对获取 textarea 和 html 标签中的内容很有用；y：开始贪婪匹配，开启贪婪匹配时会试图从最后一个匹配的位置开始；u：允许使用 Unicode 点转义符，如 \\u...。修饰符可以多个同时作用于同一个正则，如 /test/ig 或 new RegExp(&#39;test&#39;, &#39;ig&#39;)。术语和操作符精确匹配除了非特殊字符和操作符之外，字符必须准确出现在表达式中，称为精确匹配，如 /test/，代表 t 连接 e，e 连接 s，s 连接 t。匹配字符集[abc] 代表匹配 a、b、c 中任意一个字符；[^abc] 代表匹配除了 a、b、c 的任意一个字符；[a-z] 代表匹配小写字母 a 到 z 的任意一个字符，[A-Z]、[0-9] 同理；起止符号^ 直接链接匹配的字符时，代表匹配以该串字符开头；$ 直接链接匹配的字符时，代表匹配以该串字符结尾。转义如果想匹配在正则表达式中带有语义的字符需要对字符进行转义，如匹配 [、]、.、$、(、)、^ 等，需使用 \\ 或 \\\\ 进行转义，如 \\[ 或 \\\\[。在字面量中创建的正则使用 \\ 进行转义，使用构造函数创建的正则，由于传入的字符串，所以需要使用 \\\\ 进行转义。匹配重复出现?：表示匹配连续 0 个或 1 个；+：表示匹配连续 1 个或多个；*：表示匹配连续 0 个、1 个或多个；{n}: 表示匹配连续 n 个；{m, n} 表示匹配连续 m 到 n 个；{m,} 表示匹配连续 m 个以上。贪婪和非贪婪匹配正则匹配默认是贪婪模式，可以匹配所有可能的字符，会直接匹配到最后，使用 ? 可以转换为非贪婪匹配。例如 /a+/ 对于字符串 aaaaa, 会匹配 aaaaa，/a+?/ 则只会匹配到 a。预定义字符集希望匹配的内容有些无法用字符表示，如回车、空格，或者想快速匹配一些预定义的字符，下面是预定义字符集的表。预定义元字符匹配的字符集\\t水平制表符\\b空格\\v垂直制表符\\f换页符\\r回车符\\n换行符\\cA:\\cZ控制字符\\u0000:\\uFFFF十六进制 Unicode 码\\x00:\\xFF十六进制 ASCII 码\\.匹配除换行字符（\\r、\\n、\\u2028 和 \\u2029）以外的任意字符\\d匹配任意十进制数字，等价于 [0-9]\\D匹配除了十进制数字以外的任意字符，等价于 [^0-9]\\w匹配任何字母、数字和下划线，等价于 [A-Za-z0-9_]\\W匹配除了字母、数字和下划线之外的字符，等价于 [^A-Za-z0-9_]\\s匹配任意空白字符（包括空格、制表符、换页符等）\\S匹配除空白字符外的任意字符\\b匹配单词边界\\B匹配非单词边界（单词内部）或操作符或操作符使用 | 表示，如 /a|b/ 可以匹配字符 a 或者 b。分组想要匹配某一个单词或者满足某一匹配规则的一段字符，可以使用分组实现，使用 () 进行分组。如 /(ab)+/ 可以匹配一个或多个 ab 字符，/(ab)+|(cd)+/ 可以匹配一个或多个 ab 或 cd 字符。反向引用反向引用指可以快速引用某一个分组所匹配出的结果作为当前的匹配规则，通常用 \\1 或 \\2 等表示，数字位置对应当前正则中第几个分组。如 /&lt;(\\w+)&gt;(.+)&lt;\\/\\1&gt;/ 可以用来匹配类似 &lt;div&gt;hello&lt;/div&gt; 等 html 标签。捕获匹配的片段matchmatch 方法是字符串方法，参数为正则表达式，未匹配返回 null，匹配结果返回数组，数组元素如下：索引 0：为匹配到的源字符串；索引 1 ~ length - 3：匹配到的分组对应的值；索引 length - 2：匹配到分组起始单词所在源字符串中的索引位置；索引 length - 1：源字符串。execexec 是正则表达式对象的实例方法，参数为字符串，匹配结果与 match 相似。match 与 exec 的主要区别在于对正则表达式 g 修饰符的处理，全局模式下 match 可以匹配到全部内容，而 exec 分为多次调用才可以匹配出全部内容。被动子表达式在复杂并且存在分组嵌套的正则表达式中，我们希望有些分组不被捕获，可以通过在分组起始括号后加 ?: 实现。const pattern = /((hello-)+)world/; /* 修改为 */ const pattern = /((?:hello-)+)world/; 正则替换 replace如果想对一个字符串中匹配出的某些匹配项进行替换可以使用 replace，第一个参数为正则表达式，第二个参数可以传入要替换的内容，会完全按照正则匹配的规则进行替换，如果第二个参数传入的是函数，则会在匹配时调用这个函数，并将函数的返回值作为该次匹配的替换值。函数的参数与 match 方法类似，第一个参数为正则匹配的值，第二到倒数第三个参数为分组的匹配项等等，不同的是 match 成功匹配的结果为数组，而 replace 为传入参数的参数列表。/* 将短横线连接的单词转换成驼峰式 */ const word = &#39;border-bottom-width&#39;; word.replace(/-(\\w)/g, (match, group) =&gt; { return group.toUpperCase(); }); console.log(word); // borderBottomWidth /* 解析查询字符串 */ const parse = (query) =&gt; { const result = {}; query.replace(/([^&amp;=]+)=([^&amp;]*)/g, (full, key, value) =&gt; { result[key] = value; }); return result; } console.log(parse(&#39;a=1&amp;b=2&amp;c=3&#39;)); // {a: &quot;1&quot;, b: &quot;2&quot;, c: &quot;3&quot;} 使用正则表达式解决常见问题匹配带换行的内容我们经常希望匹配某一段字符串中包括换行的某段内容，比如要匹配爬虫爬到的 html 页面中某个标签中的全部内容。在正则的预定义字符集中的 . 可以匹配所有字符，但是不包括换行，可以用于匹配一行中满足条件的字符，如果匹配多行可以使用 [\\S\\s]* 或 (:?.|\\s)* 来实现。/* 匹配 id 为 container 内的所有标签 */ const html = ` &lt;div id=&quot;container&quot;&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;b&gt;world!&lt;/b&gt; &lt;/div&gt; `; const reg = /&lt;div id=&quot;container&quot;&gt;([\\S\\s]*?)&lt;\\/div&gt;/; const content = html.match(reg)[1]; console.log(content); // &lt;span&gt;Hello&lt;/span&gt; // &lt;b&gt;world!&lt;/b&gt; 匹配 Unicode 字符有时匹配的字符不知要包含常见字符，还要包含特殊的符号等等，可以通过匹配 Unicode 编码来实现，因为 Unicode 编码所包含的范围更全。/* 匹配 CSS 属性选择器 */ const text = &quot;data-v-6fb581d0&quot;; const reg = /[\\w\\u0080-\\uFFFF_-]+/; console.log(text.match(reg)[0]) // data-v-6fb581d0 匹配转义字符在有些时候需要匹配的字符串中可以匹配出反斜杠连接的单词，比如一个库的开发者实现 CSS 选择器引擎时，需要支持转译字符，这样用户可以在写 CSS 属性是使用 . 等转译字符。const tests = [ &#39;formUpdate&#39;, &#39;form\\\\.update&#39;, &#39;form\\\\:update&#39;, &#39;\\\\f\\\\o\\\\r\\\\m\\\\u\\\\p\\\\d\\\\a\\\\t\\\\e&#39; ]; const pattern = /^((\\w+)|(\\\\.))+$/; for (let i = 0; i &lt; tests.length; i++) { console.log(tests[i].match(pattern)[0]); } // formUpdate // \\form\\.update // form\\:update // \\f\\o\\r\\m\\u\\p\\d\\a\\t\\e","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"正则","slug":"正则","permalink":"https://www.overtaking.top/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"封装一个 cookie 功能","date":"2017-07-02T10:26:45.000Z","path":"20170702182645/","text":"cookie 概述由于浏览器无状态的特性，cookie 技术应运而生，cookie 是一个会话级的存储，用于某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密），通过访问某些服务器而特定携带的存储信息，不支持跨域，在浏览器清空缓存或超过有效期后失效。JavaScript 中的 cookie在 JavaScript 中操作 cookie 通过 document.cookie 来实现：// 操作 cookie document.cookie = &#39;key1=value1; key2=value2; path=/; domain=pandashen.com&#39;; 在传递 cookie 过程中，使用上面这样的方式对于参数的传递和拼接都是不太方便的，下面我们来封装一个自己的 cookie 功能。封装一个 cookie 模块整体思路设计(function () { var kvTool = { maxage: &#39;max-age&#39;, path: &#39;path&#39;, domain: &#39;domain&#39;, secure: &#39;secure&#39; }; function setCookie() {} function getCookie() {} var cookieUtil = function () {}; window.cookieUtil = cookieUtil; })(); 我们封装了一个自执行函数，在内部将 cookie 基本参数的键名存入 kvTool 对象当中设计的 options 参数的键名一一对应，并单独声明一个设置 cookie 的方法 setCookie 和获取 cookie 的方法 getCookie，最后用函数表达式的形式声明一个 cookieUtil 暴露给全局作用域。setCookie 方法的实现(function () { var kvTool = { maxage: &#39;max-age&#39;, path: &#39;path&#39;, domain: &#39;domain&#39;, secure: &#39;secure&#39; }; function setCookie(k, v, options) { if (!options) { document.cookie = k + &#39;=&#39; + v; } else { var tmp = []; for (var key in options) { // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; } tmp.push(kvTool[key] + &#39;=&#39; + options[key]); } document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;); } } function getCookie() {} var cookieUtil = function () {}; window.cookieUtil = cookieUtil; })(); setCookie 方法的有三个参数：k：cookie 发送信息的键v：cookie 发送信息的值options：cookie 的基本参数当没有传入基本参数 options 的时候直接将 cookie 发送信息的键值拼接赋值给 document.cookie。传入基本参数 options 的时候取出 kvTool 真正的键名，并和 cookie 发送的信息的键值拼接成 k=v; k=v 形式的字符串赋值给 document.cookie。getCookie 方法的实现(function () { var kvTool = { maxage: &#39;max-age&#39;, path: &#39;path&#39;, domain: &#39;domain&#39;, secure: &#39;secure&#39; }; function setCookie(k, v, options) { if (!options) { document.cookie = k + &#39;=&#39; + v; } else { var tmp = []; for (var key in options) { // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; } tmp.push(kvTool[key] + &#39;=&#39; + options[key]); } document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;); } } function getCookie(k) { var strCookie = document.cookie; // 形如: &#39;k=v; k=v; k=v; k=v&#39; var kvs = strCookie.split(&#39;;&#39;).map(v =&gt; v.trim()); var objCookie = {}; kvs.forEach(v =&gt; { var kv = v.split(&#39;=&#39;); objCookie[kv[0]] = kv[1]; }); return objCookie[k]; } var cookieUtil = function () {}; window.cookieUtil = cookieUtil; })(); getCookie 方法只有一个参数，即我们要获取的 cookie 的某一个属性的键，函数会将对应的值返回。其实对外暴露的方法只有 cookieUtil，所以 setCookie 和 getCookie 都是在 cookieUtil 内部调用的。cookieUtil 方法的实现(function () { var kvTool = { maxage: &#39;max-age&#39;, path: &#39;path&#39;, domain: &#39;domain&#39;, secure: &#39;secure&#39; }; function setCookie(k, v, options) { if (!options) { document.cookie = k + &#39;=&#39; + v; } else { var tmp = []; for (var key in options) { // { path=&#39;/&#39;, domain=&#39;pandashen.com&#39; } tmp.push(kvTool[key] + &#39;=&#39; + options[key]); } document.cookie = k + &#39;=&#39; + v + &#39;; &#39; + tmp.join(&#39;; &#39;); } } function getCookie(k) { var strCookie = document.cookie; // 形如: &#39;k=v; k=v; k=v; k=v&#39; var kvs = strCookie.split(&#39;;&#39;).map(v =&gt; v.trim()); var objCookie = {}; kvs.forEach(v =&gt; { var kv = v.split(&#39;=&#39;); objCookie[kv[0]] = kv[1]; }); return objCookie[k]; } var cookieUtil = function (key, value, options) { if (!value) { // 没有传参, 得到数据 return getCookie(key); } else { setCookie(key, value, options); } }; window.cookieUtil = cookieUtil; })(); cookieUtil 的逻辑为当 key 和 value 两个参数都传入时，调用 setCookie 来设置 cookie，只传入 key 时，调用 getCookie 获取 cookie 对应参数的值。上面就是我们封装的 cookie 功能模块来帮主我们设置和获取 cookie，之所以封装这个功能最终的目的就是让我们更方便的通过 JavaScript 来操作 cookie。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.overtaking.top/tags/HTTP/"},{"name":"cookie/session","slug":"cookie-session","permalink":"https://www.overtaking.top/tags/cookie-session/"}]},{"title":"简单封装一个靠谱的检测数据类型模块","date":"2017-06-30T08:22:09.000Z","path":"20170630162209/","text":"简介本篇主要对 JavaScript 数据类型检测做一些介绍，并封装一个相对靠谱的数据类型检测模块。常见检测数据类型的三种方式typeoftypeof 可以满足大部分基本数据类型的检测，如 number、string、boolean、undefined 和 symbol，对于 null 使用 typeof 则会直接返回 object，对于引用类型的检测，只有 function 是可以正确返回的，其他都返回 object，可以看出 typeof 只适用于部分场景，并不是那么的靠谱。instanceofinstanceof 本质是用来检测一个对象是不是一个构造函数的实例，因为基本数据类型是基本包装类，已经不是对象了，所以 instanceof 是用不适合检测基本数据类型，instanceof 也有一个缺点，用 instanceof 检测一个对象原型链上的其他原型对象对应的构造函数时，也返回 true，所以说 instanceof 也不能保证绝对的准确。Object.prototype.toString.callObject.prototype.toString.call 在我们传入数据的时候，可以 [object Object] 的形式精准的返回给我们当前的数据类型，如 [object Array] 等等，我们本次要封装的类型检测工具就是基于这个方法。封装检测类型模块最终在全局会产生一个 checkTypes 的对象，上面对应着检测不同类型的方法，每个方法的参数都为被检测数据，返回值都为布尔值。/* 检测类型模块 */ (function () { // 存储检测数据类型方法的对象 var checkTypesFun = {}; // 涉及到的数据类型 var types = [ &#39;String&#39;, &#39;Number&#39;, &#39;Boolean&#39;, &#39;Undefined&#39;, &#39;Null&#39;, &#39;Symbol&#39;, &#39;Function&#39;, &#39;Array&#39;, &#39;Object&#39;, &#39;RegExp&#39; ]; // 通过闭包返回检测单个类型的函数 function isType(type) { return function (content) { var result = Object.prototype.toString.call(content); return type === result.replace(/\\[object\\s|\\]/g, &#39;&#39;); }; } types.forEach(function (type) { // 构建检测不同类型的方法，返回布尔值 checkTypesFun[&#39;is&#39; + type] = isType(type); }); // 将检测类型模块暴露在全局 window.checkTypes = checkTypesFun; })(); 使用方法上面代码是自执行函数，执行后会将 checkTypes 对象暴露在全局，可以直接使用。/* 使用模块 */ checkTypes.isString(&#39;123&#39;); // true checkTypes.isNumber(&#39;123&#39;); // false checkTypes.isArray([1, 2, 3]); // true checkTypes.isRegExp(/^[0-9]$/); // true checkTypes.isObject({}); // true 可以使用 console.log(checkTypes) 查看所有的方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"数据类型检测","slug":"数据类型检测","permalink":"https://www.overtaking.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"}]},{"title":"前端优化 —— 函数的节流和防抖","date":"2017-06-12T05:09:42.000Z","path":"20170612130942/","text":"前言在前端开发当中我们经常会绑定一些事件触发的某些程序执行，有时这些事件会连续触发，如浏览器窗口的 scroll、resize，输入框的 keyup、input，以及 click 事件在连续点击时连续发送请求等等，这些情况有些会严重影响前端性能，有些会增加服务器压力，使用户体验大打折扣，而函数节流和防抖就是为了解决这样的问题。函数节流 throtter函数节流：当持续发生事件时，保证在一个固定的时间间隔只执行一次真正的事件处理程序，通俗的说就像 “节流” 的名字一样，打开水龙头时要秉承勤俭节约的原则，把阀门关小，最好是达到在固定间隔内水一滴一滴的往下流。节流函数的时序图函数节流时序图从图中可以看出，连续触发事件时，真正执行事件处理程序的间隔是固定的，多次触发，也只会在某一个时间间隔内触发一次，由于事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的节流函数。节流函数的封装/* 文件：throtter.js */ // 节流函数 const throtter = (func, delay = 60) =&gt; { // 锁的标识 let lock = false; // 返回一个事件处理函数 return (...args) =&gt; { // 如果 lock 为 true 则跳出 if (lock) return; // 执行函数并更改锁的状态 func(...args); lock = true; // 添加定时器，在到达时间间隔时重置锁的状态 setTimeout(() =&gt; lock = false, delay); } } throtter 函数有两个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为定义的间隔时间，在函数执行时定义了 lock 的初始值，通过闭包返回一个函数作为事件处理函数，在返回的函数内部判断 lock 状态并确定执行真正的函数 func 还是跳出，每次执行 func 后会更改 lock 状态，通过定时器在规定的时间间隔内重置 lock，这就是函数节流的原理。验证节流函数/* 文件：throtter-test.js */ // 使用节流函数 document.addEventListener(&#39;scroll&#39;, throtter(console.log)); 上面我们给 document 对象添加了滚动事件，并不断的打印事件对象，事件处理函数的默认参数为事件对象，从执行效果应该可以看出，平均每 60ms 才会触发一次事件，达到了优化性能的目的，如果想让真正执行的函数 func 传入更多的参数，只需如下处理。/* 文件：throtter-test.js */ // a b 为函数要传入的参数 const a = 1, b = 2; // 返回事件处理函数 const func = throtter(console.log); // 添加事件监听 document.addEventListener(&#39;scroll&#39;, e =&gt; func(e, a, b)); 节流函数一般用于 scroll、resize 事件的情况较多，因为这些事件的触发是连续性的，需要在一个时间间隔内只触发一次。函数防抖 debounce函数防抖：当持续发生事件时，事件只在上一次触发后的一段时间内没再触发事件，才会真正的执行事件处理逻辑，如果每两次触发的间隔小于这个时间，则不执行事件逻辑。防抖函数的时序图函数防抖时序图从图中可以看出，连续触发事件时并没有执行事件处理函数，只有在某一阶段连续触发后的最后一次才执行，也就是上一次触发的时间间隔要大于设定值才执行，同样的，事件处理函数内部执行逻辑各不相同，我们就封装一版可通用的防抖函数。防抖函数的封装/* 文件：debounce.js */ // 防抖函数 const dobounce = (func, delay = 300, timer = null) =&gt; { return (...args) =&gt; { // 清除定时器 clearInterval(timer); // 在定时器到时后执行事件处理函数 timer = setTimeout(() =&gt; func(...args), delay); } } dobounce 函数有三个参数，第一个参数为在事件触发时真正要执行的函数，第二个参数为执行事件的延迟时间，第三个参数为定时器 ID 的初始值，执行 dobounce 通过闭包返回了事件处理函数，在处理函数内部先清除定时器，然后定义定时器并将 ID 赋值给 timer，如果事件连续触发，则会不断的清除定时器，直到有一次触发间隔超过了设定延时时间 delay，才会真正执行 func。验证防抖函数&lt;!-- 文件：index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;函数防抖&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt; &lt;/body&gt; &lt;/html&gt; /* 文件：debounce-test.js */ // 使用防抖函数 const ipt = document.querySelector(&#39;#ipt&#39;); // 添加事件监听 ipt.addEventListener(&#39;keyup&#39;, debounce(console.log)); 上面的功能跟 throtter 类似，真正执行事件处理函数时打印事件对象，通过验证，连续输入触发 keyup 事件，上一次触发和下一次触发间隔时间必须大于 300ms 才会执行打印事件对象的逻辑，如果想传入多个参数套路相同。/* 文件：debounce-test.js */ // 获取 dom 元素 const ipt = document.querySelector(&#39;#ipt&#39;); // a b 为函数要传入的参数 const a = 1, b = 2; // 返回事件处理函数 const func = debounce(console.log); // 添加事件监听 ipt.addEventListener(&#39;keyup&#39;, e =&gt; func(e, a, b)); 防抖函数一般用于输入框事件，常用场景就是搜索或查询，如果不使用防抖会连续发送请求，增加服务器的压力，使用防抖后，会在用户输入要查询的关键词后才发送请求，这也更符合用户的习惯，例如百度搜索，就是这样实现的。总结“节流” 和 “防抖” 是前端在项目中经常使用的优化手段，代码虽然不多，但是确是前端面试 “出镜率” 非常高的知识点，从而能看出它们的重要性，所以建议前端同学们一定要知道，并能手写，这是 “一箭双雕” 的事，可以用来通过面试，也可以因为工作中遇到直接就写而提高工作效率。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://www.overtaking.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"JavaScript 基础 —— call、apply 和 bind 的原理","date":"2017-05-24T08:20:30.000Z","path":"20170524162030/","text":"call 和 applycall 和 apply 是 Function 构造函数原型对象上的方法，所有的函数都可以调用 call 和 apply，作用是可以改变调用 call 和 apply 函数内部的 this 指向，并执行函数。call 的使用方法/* 不指定 this */ function fn() { console.log(this, arguments); } fn.call(); // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …} // Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ] 不指定替换的 this，则调用 call 的函数在运行时决定 this 指向，当前案例中在浏览器中运行，则指向 window 对象。/* 一次调用 call */ function fn() { console.log(this, arguments); } fn.call(&#39;hello&#39;, &#39;1&#39;, &#39;2&#39;); // String { &quot;hello&quot; } // Arguments(2) [&quot;1&quot;, &quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ] 在上面案例中，call 将 fn 内部的 this 更改为 hello 的基本包装类（对象），而 1 和 2 作为 fn 的参数，以 arguments 的形式被打印出来。/* 多次调用 call */ function fn1() { console.log(this, arguments); } function fn2() { console.log(this, arguments); } fn1.call.call(fn2, &#39;1&#39;, &#39;2&#39;); // String { &quot;1&quot; } // Arguments [&quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ] 由于 call 是函数原型的方法，当然也可以被 call 自己调用，在上面的案例中，第一个 call 内部的 this 为调用者 fn1，通过第二个 call 将第一个 call 内部的 this 由 fn1 更改为 fn2，1 和 2 作为参数传递给第一个 call，而 1 又作为第一个 call 内部 this 指向的 fn2 内部的 this，2 作为 fn2 的参数，最后执行 fn2，固有上面执行结果。call 的实现原理根据 call 方法的特点，来模拟实现一个自己封装的 call 方法，代码如下。/* call 的实现原理 */ // context 参数为要替换的 this Function.prototype.call = function (context) { // 将传入的 this 转换成对象，若没传则使用 window 作为 this context = context ? Object(context) : window; // 将调用 call 的函数作为属性赋值给传入的 this context.fn = this; var args = []; // 将传递给调用 call 函数的参数转化成字符串取值的形式 for (var i = 1; i &lt; arguments.length; i++) { // args [&#39;arguments[1]&#39;, &#39;arguments[2]&#39;] args.push(&#39;arguments[&#39; + i + &#39;]&#39;); } // 利用 eval 执行 context.fn，并利用数组转换字符串的 toString 去掉 [ ] var result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;); // 删除 context 上多余的 fn 属性 delete context.fn; return result; } 上面的实现方式重点解决两个问题：如何让调用 call 函数内部的 this 指向传入的 this，我们通过将传入 this 上加一个属性 fn，值为调用 call 的函数，在执行函数时并不直接调用 this，而是执行 context.fn，这样内部的 this 指向了调用者 context，即指向了传入要替换的 this；如何将 call 调用时除第一个参数以外的参数列表作为调用 call 函数的参数依次传入，我们这里借用了 eval 提供执行环境，将要执行的代码拼接成字符串，这样就可以容易的将 argument 第二项后面的所有项通过循环的方式拼接。给 context 添加的多余属性 fn，要在函数 context.fn 执行后删除。apply 的使用方法apply 与 call 的作用相同，基本用法如下。/* apply 用法 */ function fn() { console.log(this, arguments); } fn.apply(&#39;hello&#39;, [&#39;1&#39;, &#39;2&#39;]); // String { &quot;hello&quot; } // Arguments(2) [&quot;1&quot;, &quot;2&quot;, callee: ƒ, Symbol(Symbol.iterator): ƒ] apply 的实现原理通过用法可以看出 apply 与 call 唯一不同的就是传参方式，call 传递给调用它的函数传参靠调用时使用参数列表的方式依次传入，而 apply 是通过数组的方式传入，只需要将 call 的代码稍加改造就可以实现 apply。/* apply 的实现原理 */ // context 参数为要替换的 this，args 为调用 apply 函数执行的参数 Function.prototype.apply = function (context, args) { context = context ? Object(context) : window; context.fn = this; var result; // 判断是否传入参数列表，如果没传则直接执行 if (!args) { result = context.fn(); } else { result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;); } delete context.fn; return result; } bindbind 的使用方法bind 函数是 Function 原型对象上的方法，bind 的作用是可以将调用它的函数内部的 this 绑定成所指定的 this，第一个参数为指定的 this，与 call 和 apply 不同的是，调用 bind 的函数并不会执行，而是返回一个新的函数，新的函数调用时传入的参数会和 bind 调用时传入的除第一个以外的参数进行合并，并作为调用 bind 的函数执行的参数，下面是 bind 的基本用法。/* 返回的函数当做普通函数调用 */ var obj = { name: &#39;Shen&#39; }; function sayName() { console.log(this.name); } var bindFn = sayName.bind(obj); bindFn(); // Shen /* 调用 bind 和执行返回函数分开传参 */ var obj = { name: &#39;Shen&#39; }; function animal(name, age) { console.log(this.name + &#39; have a &#39; + name + &#39; is &#39; + age + &#39; years old.&#39;); } var bindFn = animal.bind(null, &#39;cat&#39;); bindFn(2); // Shen have a cat is 2 years old. /* 返回的函数当做构造函数执行 */ var obj = { name: &#39;Shen&#39; }; function Animal(name, age) { this.name = name; this.age = age; } // 动物类别为哺乳类 Animal.prototype.category = &#39;mammalia&#39;; var BindFn = Animal.bind(obj, &#39;cat&#39;); var cat = new BindFn(2); console.log(cat); // Animal {name: &quot;cat&quot;, age: 2} console.log(cat.category); // mammalia bind 的原理从上面的例子已经可以看出 bind 不但能绑定 this，收集参数，返回的函数既可以直接调用，又可以作为构造函数实例化对象，而实例化的对象的方式，bind 绑定的 this 不生效，this 指向被创建的实例，实例依然可以找到原来函数原型上的属性和方法，根据 bind 的特性，模拟实现的代码如下。/* bind 的实现原理 */ // context 参数为要绑定的 this Function.prototype.bind = function (context) { // this 为调用 bind 的函数 var self = this; // 收集除了 context 以外所有的参数 var bindArgs = Array.prototype.slice.call(arguments, 1); // 返回的新函数 fBound function fBound() { // 收集 fBound 的参数 var args = Array.prototype.slice.call(arguments); // 执行调用 bind 的函数 // 若是普通函数调用，this 为 context，若是作为构造函数则 this 为实例 self.apply(this instanceof fBound ? this : context, bindArgs.concat(args)); } // 用来继承的中间函数 function fNOP() {} // 作为构造函数调用 fBound 时，为了实例可以找到调用 bind 函数的原型对象，进行继承 if (this.prototype) { // Function.prototype 为函数，可以调用 bind，当时没有原型对象，所以要判断 fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); } return fBound; } 在上面代码中，如果调用 bind 返回函数作为构造函数使用，则需要通过继承找回原函数的属性和方法，但是有一个特例，就是 Function.prototype，类型为函数，却没有 prototype 属性，所以需要判断。最后上面就是 call、apply 和 bind 的基本用法、实现原理以及区别，希望读者可以通过这篇文章加深对 call、apply 和 bind 的印象，运用自如。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"}]},{"title":"JavaScript 基础 —— new 的实现原理","date":"2017-05-22T03:59:59.000Z","path":"20170522115959/","text":"构造函数和实例化在 JavaScript 可以通过构造函数批量创建对象，这个创建的过程通过 new 关键字实现，也被称作实例化，对象被创建时会有默认的属性和原型方法。function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHi = function () { var output = &quot;My name is &quot; + this.name + &quot;, I&#39;m &quot; + this.age + &quot; years old.&quot; console.log(output); } var panda = new Person(&#39;panda&#39;, 25); panda.sayHi(); // My name is panda, I&#39;m 25 years old. new 的过程都做了什么在 new 的过程中主要做了 4 件事：创建一个空对象；将这个空对象的原型指向构造函数的原型；执行构造函数，并将默认属性挂载到这个空对象上；判断构造函数的返回值，如果是对象则返回这个对象，否则返回新创建的对象。模拟 new 关键字清楚了构造函数实例化的过程，我们就来手动实现一个 New 函数，来替代关键字 new。// New 函数的第一个参数为构造函数，剩余的参数为实例化传入的参数 function New() { var Constructor = Array.prototype.shift.call(arguments); var obj = {}; obj.__proto__ = Constructor.prototype; var result = Constructor.apply(obj, arguments); return result instanceof Object ? result : obj; } // 使用 New 创建实例 var panda = New(Person, &#39;panda&#39;, 25); console.log(panda); // Person {name: &quot;panda&quot;, age: 25} panda.sayHi(); // My name is panda, I&#39;m 25 years old. 上面的方法已经实现了 new 关键字的功能，但是美中不足的是，不能将构造函数和实例化的参数区分清晰，下面稍微优化一下。/* 优化后 */ function New(Constructor) { return function () { var obj = {}; obj.__proto__ = Constructor.prototype; var result = Constructor.apply(obj, arguments); return result instanceof Object ? result : obj; } } /* 使用 New 创建实例 */ var panda = New(Person)(&#39;panda&#39;, 25); console.log(panda); // Person {name: &quot;panda&quot;, age: 25} panda.sayHi(); // My name is panda, I&#39;m 25 years old. 与第一种相比只是 New 函数的使用方式有所变化，New 执行后返回一个函数，调用这个返回的函数，才会进行实例化，传入的参数为实例化对象的参数，这样是 New 的功能变的单一，也将构造函数与实例化的参数分开。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.overtaking.top/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.overtaking.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Hexo 中 Markdown 特殊字符的处理方法","date":"2017-05-19T05:59:03.000Z","path":"20170519135903/","text":"问题描述在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 -、.、空格、制表符等等，在正常情况下可以使用 \\ 进行转译，但是有一些字符无法转译，使用后在执行 hexo server 命令的时候会报错。报错信息：Unhandled rejection Template render error: (unknown path) [Line 7, Column 23] Error: Unable to call `worldcount`, which is undefined or falsey...... 解决方案报错的原因是，Hexo 编译时发生错误，可能是文章中存在特殊字符，如：&#123; &#91; &#40; &#41; &#93; &#125; 等等。如下面这段代码：在页面中：&lt;%= worldcount(post.content) %&gt; 在 Markdown 中：&amp;#123;&amp;#123; worldcount&amp;#40;post.content&amp;#41; &amp;#125;&amp;#125; 在 Markdown 中使用 \\ 无法转译的字符需要使用字符的命名实体或十进制编码，如上面代码中。注意：需要转义的字符只是文本中的特殊字符，代码块中的特殊字符无需转译或使用转译字符。常见特殊字符常用特殊字符转译字符对照表：特殊符号命名实体十进制编码空格&#38;&#110;&#98;&#115;&#112;&#59;&#38;&#35;&#49;&#54;&#48;&#59;全角空格&#38;&#101;&#109;&#115;&#112;&#59;&#38;&#35;&#49;&#50;&#50;&#56;&#56;&#59;‘&#38;&#97;&#112;&#111;&#115;&#59;&#38;&#35;&#51;&#57;&#59;“&#38;&#113;&#117;&#111;&#116;&#59;&#38;&#35;&#51;&#52;&#59;(—&#38;&#35;&#52;&#48;&#59;)—&#38;&#35;&#52;&#49;&#59;&lt;&#38;&#108;&#116;&#59;&#38;&#35;&#54;&#48;&#59;&gt;&#38;&#103;&#116;&#59;&#38;&#35;&#54;&#50;&#59;[—&#38;&#35;&#57;&#49;&#59;]—&#38;&#35;&#57;&#51;&#59;{—&#38;&#35;&#49;&#50;&#51;&#59;}—&#38;&#35;&#49;&#50;&#53;&#59;´&#38;&#97;&#99;&#117;&#116;&#101;&#59;&#38;&#35;&#49;&#56;&#48;&#59;°&#38;&#100;&#101;&#103;&#59;&#38;&#35;&#49;&#55;&#54;&#59;®&#38;&#114;&#101;&#103;&#59;&#38;&#35;&#49;&#55;&#52;&#59;©&#38;&#99;&#111;&#112;&#121;&#59;&#38;&#35;&#49;&#54;&#57;&#59;常用数学转译字符对照表：特殊符号命名实体十进制编码≤&#38;&#108;&#101;&#59;&#38;&#35;&#56;&#56;&#48;&#52;&#59;≥&#38;&#103;&#101;&#59;&#38;&#35;&#56;&#56;&#48;&#53;&#59;≈&#38;&#97;&#115;&#121;&#109;&#112;&#59;&#38;&#35;&#56;&#55;&#55;&#51;&#59;≠&#38;&#110;&#101;&#59;&#38;&#35;&#56;&#56;&#48;&#48;&#59;∩&#38;&#99;&#97;&#112;&#59;&#38;&#35;&#56;&#55;&#52;&#53;&#59;∪&#38;&#99;&#117;&#112;&#59;&#38;&#35;&#56;&#55;&#52;&#54;&#59;∠&#38;&#97;&#110;&#103;&#59;&#38;&#35;&#56;&#55;&#51;&#54;&#59;∞&#38;&#105;&#110;&#102;&#105;&#110;&#59;&#38;&#35;&#56;&#55;&#51;&#52;&#59;±&#38;&#112;&#108;&#117;&#115;&#109;&#110;&#59;&#38;&#35;&#49;&#55;&#55;&#59;√&#38;&#114;&#97;&#100;&#105;&#99;&#59;&#38;&#35;&#56;&#55;&#51;&#48;&#59;∑&#38;&#115;&#117;&#109;&#59;&#38;&#35;&#56;&#55;&#50;&#50;&#59;∫&#38;&#105;&#110;&#116;&#59;&#38;&#35;&#56;&#55;&#52;&#55;&#59;Δ&#38;&#68;&#101;&#108;&#116;&#97;&#59;&#38;&#35;&#57;&#49;&#54;&#59;常用希腊字母转译字符对照表：特殊符号命名实体十进制编码Φ&#38;&#80;&#104;&#105;&#59;&#38;&#35;&#57;&#51;&#52;&#59;Ω&#38;&#79;&#109;&#101;&#103;&#97;&#59;&#38;&#35;&#57;&#51;&#55;&#59;α&#38;&#97;&#108;&#112;&#104;&#97;&#59;&#38;&#35;&#57;&#52;&#53;&#59;β&#38;&#98;&#101;&#116;&#97;&#59;&#38;&#35;&#57;&#52;&#54;&#59;γ&#38;&#103;&#97;&#109;&#109;&#97;&#59;&#38;&#35;&#57;&#52;&#55;&#59;δ&#38;&#100;&#101;&#108;&#116;&#97;&#59;&#38;&#35;&#57;&#52;&#56;&#59;ε&#38;&#101;&#112;&#115;&#105;&#108;&#111;&#110;&#59;&#38;&#35;&#57;&#52;&#57;&#59;ζ&#38;&#122;&#101;&#116;&#97;&#59;&#38;&#35;&#57;&#53;&#48;&#59;η&#38;&#101;&#116;&#97;&#59;&#38;&#35;&#57;&#53;&#49;&#59;θ&#38;&#116;&#104;&#101;&#116;&#97;&#59;&#38;&#35;&#57;&#53;&#50;&#59;λ&#38;&#108;&#97;&#109;&#98;&#100;&#97;&#59;&#38;&#35;&#57;&#53;&#53;&#59;μ&#38;&#109;&#117;&#59;&#38;&#35;&#57;&#53;&#54;&#59;ξ&#38;&#120;&#105;&#59;&#38;&#35;&#57;&#53;&#56;&#59;π&#38;&#112;&#105;&#59;&#38;&#35;&#57;&#54;&#48;&#59;ρ&#38;&#114;&#104;&#111;&#59;&#38;&#35;&#57;&#54;&#49;&#59;σ&#38;&#115;&#105;&#103;&#109;&#97;&#59;&#38;&#35;&#57;&#54;&#51;&#59;φ&#38;&#112;&#104;&#105;&#59;&#38;&#35;&#57;&#54;&#54;&#59;ψ&#38;&#112;&#115;&#105;&#59;&#38;&#35;&#57;&#54;&#56;&#59;ω&#38;&#111;&#109;&#101;&#103;&#97;&#59;&#38;&#35;&#57;&#54;&#57;&#59;∂&#38;&#112;&#97;&#114;&#116;&#59;&#38;&#35;&#56;&#55;&#48;&#54;&#59;∅&#38;&#101;&#109;&#112;&#116;&#121;&#59;&#38;&#35;&#56;&#55;&#48;&#57;&#59;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.overtaking.top/tags/Hexo/"}]}]