<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Shen&#39;s Blog</title>
    <link>https://www.overtaking.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 20 Apr 2022 06:27:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode 56 —— 合并区间</title>
      <link>https://www.overtaking.top/20220418231027/</link>
      <guid>https://www.overtaking.top/20220418231027/</guid>
      <pubDate>Mon, 18 Apr 2022 15:10:27 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/merge-intervals/&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;以数组 &lt;code&gt;intervals&lt;/code&gt; 表示若干个区间的集合，其中单个区间为 &lt;strong&gt;$intervals[i] = [start_i, end_i]$&lt;/strong&gt;。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <strong>$intervals[i] = [start_i, end_i]$</strong>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>intervals = [[1, 3], [2, 6], [8, 10], [15 ,18]]</code><br><strong>输出：</strong> <code>[[1, 6], [8, 10], [15, 18]]</code><br><strong>解释：</strong> 区间 <code>[1, 3]</code> 和 <code>[2, 6]</code> 重叠, 将它们合并为 <code>[1, 6]</code>。</p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>intervals = [[1, 4], [4, 5]]</code><br><strong>输出：</strong> <code>[[1, 5]]</code><br><strong>解释：</strong> 区间 <code>[1, 4]</code> 和 <code>[4, 5]</code> 可被视为重叠区间。</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>假设区间的起点是无序的，在有序的对比区间右端点和另一个区间的左端点时，可能会出现本应该合并的区间因为对比顺序的错误而导致矛盾，所以区间一定是要按照左端点或者右断点的其中一个值进行有序排列的。</p><p>如果按照区间的左端点升序排序，那么在排序完的列表中，可以合并的区间一定是连续的，如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220418231027/sort.png" alt="左端点排序"></div><div class="image-caption">左端点排序</div></figure><p><br></p><p>因此在合并区间之前应该优先进行排序，我们默认使用快排，时间复杂度是 <strong>$O(nlogn)$</strong>，空间复杂度为 <strong>$O(1)$</strong>。</p><p>在排序后的基础上只需要进行一次线性遍历就可以完成合并的处理，代码如下：</p><pre><code class="lang-js">const merge = (intervals) =&gt; {  const result = [];  if (intervals.length &gt; 0) {    intervals.sort((a, b) =&gt; a[0] - b[0]);    let prev = intervals[0];    for (let i = 1; i &lt; intervals.length; i++) {      const cur = intervals[i];      if (prev[1] &gt;= cur[0]) {        prev[1] = Math.max(prev[1], cur[1]);      } else {        result.push(prev);        prev = cur;      }    }    result.push(prev);  }  return result;}</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(nlogn) + O(n) = O(nlogn)$</strong></li><li>空间复杂度：<strong>$O(1) + O(1) = O(1)$</strong></li></ul>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20220418231027/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 498 —— 对角线遍历</title>
      <link>https://www.overtaking.top/20220420110547/</link>
      <guid>https://www.overtaking.top/20220420110547/</guid>
      <pubDate>Mon, 18 Apr 2022 15:10:27 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/diagonal-traverse/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/diagonal-traverse/&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个大小为 &lt;code&gt;m x n&lt;/code&gt; 的矩阵 &lt;code&gt;mat&lt;/code&gt;，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diagonal-traverse/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code>，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/example.jpeg" alt="遍历路径"></div><div class="image-caption">遍历路径</div></figure><p><br></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code><br><strong>输出：</strong> <code>[1, 2, 4, 7, 5, 3, 6, 8, 9]</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>mat = [[1, 2], [3, 4]]</code><br><strong>输出：</strong> <code>[1, 2, 3, 4]</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题目描述不难分析出遍历对角线的元素时，偶数列为反方向遍历，奇数列为正方向遍历，如果全使用正方向遍历，则存储偶数列的数组只需要做翻转就可以更正顺序。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/diagonal.png" alt="正方向遍历"></div><div class="image-caption">正方向遍历</div></figure><p><br></p><p>已知矩阵共有 <code>m</code> 行和 <code>n</code> 列，通过正方向遍历图可知总共的遍历次数为 <strong>$m + n - 1$</strong> 次，其中到达拐点 <strong>$n - 1$</strong> 之前，<code>row</code> 一直为 <code>0</code>，列 <code>col</code> 递增，拐点之后，<code>col</code> 不变，<code>row</code> 开始递增。</p><p>在每次遍历时要沿着对角线再次找到对角线上的所有元素，如果当前项为 <strong>$mat[row][col]$</strong>，则对角线的下一项为 <strong>$mat[row + 1][col - 1]$</strong>，直到边界。</p><p>通过上图不难看出，边界条件限制的其实是 <code>row</code> 和 <code>col</code> 的值，<code>col</code> 不能小于 <code>0</code>，<code>row</code> 不能大于等于 <code>m</code>。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Algorithm/20220420110547/reverse.png" alt="偶数列翻转"></div><div class="image-caption">偶数列翻转</div></figure><p><br></p><p>当偶数列对角线所有项都遍历后保存，并对保存的列表进行翻转，再依次合并进最终的结果中就可以完成对角线遍历输出结果的顺序要求，实现代码如下：</p><pre><code class="lang-js">const findDiagonalOrder = (mat) =&gt; {  const m = mat.length;  const n = mat[0].length;  const result = [];  const diagonal = [];  const index = n - 1;  let row = 0;  let col = 0;  for (let i = 0; i &lt; m + n - 1; i++) {    const inflexed = i &gt; index;    row = inflexed ? i - index : 0;    col = inflexed ? index : i;    while (row &lt; m &amp;&amp; col &gt;= 0) {      diagonal.push(mat[row][col]);      row++;      col--;    }    if (i % 2 === 0) {      diagonal.reverse();    }    result.push(...diagonal);    diagonal.length = 0;  }  return result;}</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：由于矩阵的每一个点都遍历到，并且不存在重复遍历，所以时间复杂度为 <strong>$O(m * n)$</strong>；</li><li>空间复杂度：由于存储最终结果和对角线元素的数组都是在循环之外创建，故和矩阵的规模没有关系，空间复杂度为 <strong>$O(1)$</strong>。</li></ul>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20220420110547/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LeetCode 724, 1991 —— 寻找数组中心下标</title>
      <link>https://www.overtaking.top/20220418200850/</link>
      <guid>https://www.overtaking.top/20220418200850/</guid>
      <pubDate>Mon, 18 Apr 2022 12:08:50 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-pivot-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-pivot-index/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-the-middle-index-in-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-the-middle-index-in-array/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt;，请你找到 &lt;strong&gt;最左边&lt;/strong&gt; 的中间位置 &lt;code&gt;middleIndex&lt;/code&gt;（也就是所有可能中间位置下标最小的一个）。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/find-pivot-index/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-pivot-index/</a></li><li><a href="https://leetcode-cn.com/problems/find-the-middle-index-in-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code>，请你找到 <strong>最左边</strong> 的中间位置 <code>middleIndex</code>（也就是所有可能中间位置下标最小的一个）。</p><a id="more"></a><p><strong>中间位置 <code>middleIndex</code> 的数组下标满足：</strong></p><blockquote class="pullquote warning"><p><strong>$nums[0]$ $+$ $nums[1]$ $+$ $…$ $+$ $nums[middleIndex - 1]$ $===$ $nums[middleIndex + 1]$ $+$ $nums[middleIndex + 2]$ $+$ $…$ $+$ $nums[nums.length - 1]$</strong></p></blockquote><p>如果 <code>middleIndex === 0</code>，左边部分的和定义为 <code>0</code>，如果 <code>middleIndex === nums.length - 1</code> ，右边部分的和定义为 <code>0</code>。</p><p>请你返回满足上述条件 <strong>最左边</strong> 的 <code>middleIndex</code>，如果不存在这样的中间位置，请你返回 <code>-1</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [2, 3, -1, 8, 4]</code><br><strong>输出：</strong> <code>3</code><br><strong>解释：</strong><br>下标 <code>3</code> 之前的数字和为：<code>2 + 3 + -1 = 4</code><br>下标 <code>3</code> 之后的数字和为：<code>4 = 4</code></p></blockquote><p><strong>示例 2：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1, -1, 4]</code><br><strong>输出：</strong> <code>2</code><br><strong>解释：</strong><br>下标 <code>2</code> 之前的数字和为：<code>1 + -1 = 0</code><br>下标 <code>2</code> 之后的数字和为：<code>0</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [2, 5]</code><br><strong>输出：</strong> <code>-1</code><br><strong>解释：</strong><br>不存在符合要求的 <code>middleIndex</code>。</p></blockquote><p><strong>示例 4：</strong></p><blockquote class="pullquote default"><p><strong>输入：</strong> <code>nums = [1]</code><br><strong>输出：</strong> <code>0</code><br><strong>解释：</strong><br>下标 <code>0</code> 之前的数字和为：<code>0</code><br>下标 <code>0</code> 之后的数字和为：<code>0</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>暴力破解就是一边遍历一边通过累加求左侧的和，此时右侧的和未知，再嵌套循环求右侧的总和，如果左右和相等则结束循环直接返回索引，全部遍历完没有找到 <code>middleIndex</code> 则返回 <code>-1</code>。</p><pre><code class="lang-js">const findMiddleIndex = (nums) =&gt; {  let leftSum = 0;  for (let i = 0; i &lt; nums.length; i++) {    let rightSum = 0;    for (let j = i + 1; j &lt; nums.length; j++) {      rightSum += nums[j];    }    if (leftSum === rightSum) {      return i;    }    leftSum += nums[i];  }  return -1;}</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(n^2)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>在暴力破解时，之所以会在每一次循环中再次嵌套循环是因为右侧的和未知，如果已知总和为 <code>sum</code>，遍历到当前项的值为 <code>num</code>，遍历累加求出的左侧总和为 <code>leftSum</code>，则可以求出右侧总和 <code>rightSum</code> 得：</p><blockquote class="pullquote success"><p><strong>$rightSum = sum - leftSum - num$</strong></p></blockquote><p>若 <code>leftSum</code> 与 <code>rightSum</code> 相等，则：</p><blockquote class="pullquote info"><p><strong>由：$leftSum = sum - leftSum - num$</strong><br><strong>推出：$2 * leftSum + num = sum$</strong></p></blockquote><p>所以先求出 <code>sum</code>，就可以在遍历过程中通过公式计算的结果判断是否左侧和右侧的总和相等。</p><pre><code class="lang-js">const findMiddleIndex = (nums) =&gt; {  const sum = nums.reduce((sum, cur) =&gt; sum + cur, 0);  let leftSum = 0;  for (let i = 0; i &lt; nums.length; i++) {    if (2 * leftSum + nums[i] === sum) {      return i;    }    leftSum += nums[i];  }  return -1;}</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<strong>$O(n)$</strong></li><li>空间复杂度：<strong>$O(1)$</strong></li></ul>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20220418200850/#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 基础篇 —— React Hooks</title>
      <link>https://www.overtaking.top/20190507155411/</link>
      <guid>https://www.overtaking.top/20190507155411/</guid>
      <pubDate>Tue, 07 May 2019 07:54:11 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/React/20190507155411/react-hooks.jpeg&quot; title=&quot;React Hooks&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;React-Hooks-简介&quot;&gt;&lt;a href=&quot;#React-Hooks-简介&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 简介&quot;&gt;&lt;/a&gt;React Hooks 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;React Hooks&lt;/code&gt; 是 &lt;code&gt;16.8&lt;/code&gt; 版本中正式加入的特性，配合函数组件使用，在没有 &lt;code&gt;Hooks&lt;/code&gt; 之前，函数组件使用场景非常有限，只适合编写纯展示性的 &lt;code&gt;UI&lt;/code&gt; 组件，其余复杂的场景不得不使用类组件，而 &lt;code&gt;Hooks&lt;/code&gt; 的主要作用是在函数组件中使用原本所不具备的 &lt;code&gt;React&lt;/code&gt; 特性。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/React/20190507155411/react-hooks.jpeg" title="React Hooks"><p><br></p><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><blockquote class="pullquote default"><p><strong><code>React Hooks</code> 是 <code>16.8</code> 版本中正式加入的特性，配合函数组件使用，在没有 <code>Hooks</code> 之前，函数组件使用场景非常有限，只适合编写纯展示性的 <code>UI</code> 组件，其余复杂的场景不得不使用类组件，而 <code>Hooks</code> 的主要作用是在函数组件中使用原本所不具备的 <code>React</code> 特性。</strong></p></blockquote><a id="more"></a><h2 id="React-Hooks-产生的动机"><a href="#React-Hooks-产生的动机" class="headerlink" title="React Hooks 产生的动机"></a>React Hooks 产生的动机</h2><p>在业务开发中，数据主要存在两种形式，业务数据和 <code>UI</code> 数据，我们需要将这两种数据区分开，而有时数据又在组件之间存在共用关系，情况稍微复杂，参数传递的方式就无法满足需求，于是就会有状态管理进入到项目中（<code>Redux</code>、<code>Mobx</code> 等），会增加开发者的学习成本和项目的维护成本。</p><p>使用 <code>React</code> 的开发者都知道，<code>React</code> 主张组件化，就是把业务页面拆分成多个组件进行组合、嵌套、渲染，为了保证项目质量，开发者会花费大量精力在项目的模块化、状态数据最小化以及功能解耦上，而一部分组件会因为数据状态的共享耦合在一起，这时需要使用高阶组件（<code>HOC</code>）、属性渲染（<code>Render props</code>）、渲染回调（<code>Prop callback</code>）等更高级的 <code>React</code> 特性去解耦，但是会增加代码的复杂程度、降低代码的可读性，在渲染时也会增加 <code>DOM</code> 的层级。</p><p>上面这些实际问题促成了 <code>React Hooks</code> 的诞生，而在有 <code>Hooks</code> 后官方也越来越推荐使用函数组件。</p><blockquote class="pullquote success"><p><strong>推荐使用函数组件主要原因总结如下：</strong></p><ul><li><strong>为了状态相关逻辑的提取和复用；</strong></li><li><strong>解决复杂组件代码变得难以理解的问题；</strong></li><li><strong>解决类组件带给开发者一些容易混淆的点，比如 <code>this</code> 指向问题；</strong></li><li><strong>由于 <code>JS</code> 解释器在解释 <code>class</code> 关键字时的性能问题，使用函数组件代替。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong><code>React</code> 没有重大变化，完全兼容类组件，可以让开发者不必完全重写现有代码，而是在后续开发中逐步尝试使用 <code>Hooks</code>。</strong></p></blockquote><h2 id="React-Hooks-分类"><a href="#React-Hooks-分类" class="headerlink" title="React Hooks 分类"></a>React Hooks 分类</h2><blockquote class="pullquote danger"><p><strong><code>React</code> 官方主要给 <code>Hooks</code> 分为两大类：</strong></p><ul><li><strong>基础 <code>Hooks API</code>：<code>useState</code>、<code>useEffect</code>、<code>useContext</code>；</strong></li><li><strong>其他 <code>Hooks API</code>：<code>useReducer</code>、<code>useCallback</code>、<code>useImperativeHandle</code>、<code>useMemo</code>、<code>useRef</code>、<code>useLayoutEffect</code>、<code>useDebugValue</code>。</strong></li></ul></blockquote><h2 id="React-Hooks-使用规则"><a href="#React-Hooks-使用规则" class="headerlink" title="React Hooks 使用规则"></a>React Hooks 使用规则</h2><p>为了保证 <code>Hooks</code> 在使用时不会出现不可预测的问题，官方制定了一定要遵循的两条使用规则（强制遵守），在此提前声明。</p><blockquote class="pullquote warning"><ul><li><strong>只在函数组件内部最顶层调用 <code>Hook</code>，不要在循环、条件判断或者嵌套函数中调用；</strong></li><li><strong>只能在函数组件中调用 <code>Hook</code>（自定义 <code>Hook</code> 中可以调用 <code>Hook</code>），不要在其他 <code>JavaScript</code> 函数中调用。</strong></li></ul></blockquote><h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 方法用于在函数组件内部实现组件的状态管理，可以起到类组件中 <code>state</code> 一样的作用。</p><pre><code class="lang-jsx">/* 类组件实现的计数器 */import React, { Components } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;class Counter extends Components {  constructor() {    super();    this.state = { count: 0 };  }  handleClick = () =&gt; {    this.setState({ count: this.state.count + 1 })  }  render() {    return (      &lt;div&gt;        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;        &lt;button onClick={this.handleClick}&gt;          Click!        &lt;/button&gt;      &lt;/div&gt;    )  }}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><p>上面是一个类组件实现的计数器，当前计数器的值在类组件的 <code>state</code> 中进行管理。</p><pre><code class="lang-jsx">/* Hooks 实现的计数器 */import React, { useState } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Counter() {  const [ count, setCount ] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click!      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><p>使用 <code>React Hooks</code> 的 <code>useState</code> 实现的计数器和类组件实现的功能完全相同，从 <code>useState</code> 实现的代码可以看出 <code>useState</code> 是一个函数，传入的参数是状态的初始值，返回值是一个数组，数组的第一项是当前状态的值，数组的第二项是改变状态值的方法。</p><pre><code class="lang-jsx">/* 实现每次加 2 的计数器 */import React, { useState } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Counter() {  const [ count, setCount ] = useState(0);  const countAction = (preCount, n) =&gt; preCount + n;  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(countAction(count, 2))}&gt;        Click!      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><p>上面计数器功能的实现逻辑比较简单，下面来看一个类组件实现的稍微复杂的案例，然后再通过 <code>useState</code> 进行重构。</p><pre><code class="lang-jsx">/* 类组件实现的模态切换功能 */import React, { Component, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import { Button, Modal } from &#39;antd&#39;;import &#39;antd/dist/antd.css&#39;;// Toggle 组件专门提供切换状态和切换方法class Toggle extends Component {  constructor(props) {    super(props);    // 初始化 on 的值    this.state.on = this.props.initial;  }  state = { on: false }  toggle = () =&gt; {    this.setState({ on: !this.state.on });  }  render() {    return this.props.children(this.state.on, this.toggle);  }}function App() {  return (    &lt;Toggle initial={false}&gt;      {        (on, toggle) =&gt; (          &lt;Fragment&gt;            &lt;Button type=&quot;primary&quot; onClick={toggle}&gt;              Open Model            &lt;/Button&gt;            &lt;Modal visible={on} onCancel={toggle} /&gt;          &lt;/Fragment&gt;        )      }    &lt;/Toggle&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面代码中的类组件 <code>Toggle</code> 主要的作用就是管理模态框显示的状态和对状态的控制，选择使用 <code>children</code> 并传入一个函数，目的是函数可以在类组件内部通过 <code>children</code> 属性调用，并将 <code>Toggle</code> 内部的状态和方法作为参数传入，进而将功能提供给函数组件，这种高级的用法叫做 “渲染回调”，可以成功的将组件进行解耦，但是这样的方式缺点也显而易见，就是代码的逻辑抽象，可读性差，下面来使用 <code>useState</code> 进行重构。</p><pre><code class="lang-jsx">/* useState 重构切换模态的功能 */import React, { useState, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import { Button, Modal } from &#39;antd&#39;;import &#39;antd/dist/antd.css&#39;;function App() {  const [ on, setOn ] = useState(false);  return (    &lt;Fragment&gt;      &lt;Button type=&quot;primary&quot; onClick={() =&gt; setOn(true)}&gt;        Open Model      &lt;/Button&gt;      &lt;Modal visible={on} onCancel={() =&gt; setOn(false)}/&gt;    &lt;/Fragment&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><blockquote class="pullquote success"><p><strong>因为 <code>React Hooks</code> 的 <code>useState</code> 让函数组件具备了管理组件状态的能力，所以不需要单独实现 <code>Toggle</code> 组件，代码变得更精简、清晰，更函数式编程，更新的粒度更细。</strong></p></blockquote><p><code>useState</code> 解构出的用来更改状态的函数传入的参数支持函数类型，传入函数的参数为上一次的状态值，也就是说当更新状态的新值依赖于上一次的值时，会通过这样的方式解决。</p><pre><code class="lang-jsx">/* 当 useState 更新的状态依赖于上一次的值 */import React, { useState } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Counter() {  const [ count, setCount ] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(prev =&gt; prev + 1)}&gt;        Click!      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>正如 <code>useEffect</code> 钩子的命名一样，是在函数组件中专门用来处理副作用的，这个副作用是指某些操作使用了函数组件作用域外的变量，而且这个操作的结果会影响函数组件外部的环境。</p><pre><code class="lang-jsx">import React, { useState, useEffect } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function App() {  const [ count, setCount ] = useState(0);  // 每次渲染后执行  useEffect(() =&gt; {    document.title = `You clicked ${count} times`;  });  // 初次渲染后执行  useEffect(() =&gt; {    console.log(&#39;Execute once&#39;);  }, []);  // 当 count 更改时才执行  useEffect(() =&gt; {    console.log(&#39;count changed&#39;);  }, [ count ]);  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click!      &lt;/button&gt;      &lt;button onClick={() =&gt; setCount(count)}&gt;        Click no change!      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面案例是通过 <code>useState</code> 一节中的计数器案例改编，我们增加了每次点击计数器将计数器状态同步到页面标题上的功能，并使用 <code>useEffect</code> 实现，<code>useEffect</code> 函数的参数为回调函数，并在每次页面渲染之后执行（包含首次渲染和更新渲染）。</p><blockquote class="pullquote primary"><p><strong>可以使用 <code>useEffect</code> 替代类组件的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</strong></p></blockquote><p><code>useEffect</code> 还支持传入第二个参数，类型为数组，数组的值为被监听的状态（被 <code>useState</code> 监听），此时 <code>useEffect</code> 内部会做一次比较，数组中变量的值没发生变化时，传入对应 <code>useEffect</code> 的回调不会执行，当传入 <code>useEffect</code> 的数组为空时，则传入的回调只在函数组件首次渲染时执行一次，作用相当于类组件的生命周期 <code>componentDidMount</code>。</p><pre><code class="lang-jsx">import React, { useState, useEffect, Component, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 使用 Hooks 的函数组件function HooksCom() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    document.title = `You clicked ${count} times (hooks)`;  });  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click!      &lt;/button&gt;    &lt;/div&gt;  )}// 类组件class ClassCom extends Component {  constructor(props) {    super(props);    this.state = { count: 1 };  }  componentDidMount() {    document.title = `You clicked ${this.state.count} times (class)`;  }  componentDidUpdate() {    document.title = `You clicked ${this.state.count} times (class)`;  }  render() {    return (      &lt;div&gt;        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;        &lt;button onClick={() =&gt; this.setState({          count: this.state.count + 1        })}&gt;          Click!        &lt;/button&gt;      &lt;/div&gt;    )  }}function App() {  return (    &lt;Fragment&gt;      &lt;HooksCom /&gt;      &lt;ClassCom /&gt;    &lt;/Fragment&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><blockquote class="pullquote info"><p><strong>通过上面案例，对于使用了 <code>componentDidMount</code> 生命周期的类组件和使用了 <code>useEffect</code> 的函数组件对于页面标题更改的对比，<code>useEffect</code> 的执行会晚于 <code>componentDidMount</code>。</strong></p></blockquote><pre><code class="lang-jsx">import React, { useState, useEffect, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;const ChatAPI = {  handle: null,  isOnline: false,  login() {    this.isOnline = true;    this.handle &amp;&amp; this.handle({ isOnline: true });  },  logout() {    this.isOnline = false;    this.handle &amp;&amp; this.handle({ isOnline: false });  },  subscribeToFriendStatus(id, handle) {    console.log(`订阅好友：${id}`);    this.handle = handle;  },  unsubscribeToFriendStatus(id, handle) {    console.log(`清理好友：${id}`);    this.handle = null;  }};// 用于渲染好友在线状态的函数组件function FriendStatus(props) {  // 控制好友在线的变量和方法  const [ isOnline, setIsOnline ] = useState(null);  // 设置好友状态的函数  const handleStatusChange = (status) =&gt; setIsOnline(status.isOnline);  useEffect(() =&gt; {    // 订阅好友状态    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () =&gt; {      // 清除好友状态      ChatAPI.unsubscribeToFriendStatus(props.friend.id);    }  }, [ props.friend.id ]);  if (isOnline === null) {    return &#39;Loading...&#39;  }  return (    &lt;div&gt;      &lt;span&gt;计数器：{props.friend.count}&lt;/span&gt;      &lt;br/&gt;      &lt;span&gt;        登录状态：        {          isOnline ? &#39;Online&#39; : &#39;Offline&#39;        }      &lt;/span&gt;    &lt;/div&gt;  )}function App() {  const [ show, setShow ] = useState(true);  const [ count, setCount ] = useState(0);  const [ userId, setUserId ] = useState(1);  return (    &lt;div&gt;      &lt;span&gt;用户ID：{userId}&lt;/span&gt;      &lt;br/&gt;      {        show &amp;&amp; &lt;FriendStatus friend={{ id: userId, name: 'Hello' }}/&gt;      }      &lt;button onClick={() =&gt; setShow(!show)}&gt;显示/关闭&lt;/button&gt;      &lt;button onClick={() =&gt; setUserId(userId + 1)}&gt;增加用户ID&lt;/button&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;增加计数器&lt;/button&gt;      &lt;button onClick={ChatAPI.login.bind(ChatAPI)}&gt;登录&lt;/button&gt;      &lt;button onClick={ChatAPI.logout.bind(ChatAPI)}&gt;退出&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面是一个覆盖比较全的 <code>useEffect</code> 案例，用来实现组件 <code>FriendStatus</code> 内对用户的订阅和取消订阅，其中 <code>App</code> 组件中的 <code>show</code> 状态用来控制 <code>FriendStatus</code> 组件是否渲染，<code>显示/关闭</code> 按钮用来控制 <code>show</code> 的值，<code>FriendStatus</code> 默认登录状态显示 <code>Loading...</code>，<code>登录</code> 和 <code>退出</code> 按钮用来空登录状态的显示（<code>Online</code> 或 <code>Offline</code>），<code>增加用户ID</code> 和 <code>增加计数器</code> 按钮分别用来更改当前用户 <code>ID</code> 和计数器的值，计数器的 <code>count</code> 属性和 <code>setUserId</code> 通过 <code>Props</code> 的方式传递给 <code>FriendStatus</code>，我们将使用到的方法统一都放在 <code>ChatAPI</code> 对象上。</p><p>默认渲染 <code>FriendStatus</code> 在控制台发现 <code>useEffect</code> 执行了，并订阅了当前传入的用户，而点击 <code>显示/关闭</code> 按钮时发现取消订阅了用户，这说明组件卸载之前执行了 <code>useEffect</code> 回调内部返回的函数，点击增加计数器按钮，<code>FriendStatus</code> 组件发生了重新渲染，而 <code>useEffect</code> 内部并没有再次对用户进行订阅，原因是指定了 <code>useEffect</code> 的第二个参数，并将用户的 <code>ID</code> 作为元素存入数组内，也就是用户 <code>ID</code> 不发生变化的时候就不会重新执行这个 <code>useEffect</code> 去订阅用户，当点击 <code>增加用户ID</code> 按钮时，控制台首先取消订阅了上一个用户，又订阅了新的用户，这说明 <code>FriendStatus</code> 组件重新渲染时，如果需要执行 <code>useEffect</code>，则会优先执行回调内返回的取消订阅的函数。</p><blockquote class="pullquote default"><p><strong>如果在 <code>useEffect</code> 方法传入的回调中返回一个函数，这个函数会在组件卸载之前执行，或重新渲染需时要执行对应的 <code>useEffect</code> 时优先执行。</strong></p></blockquote><pre><code class="lang-jsx">/* 频繁更新未被监听的变量不变 */import React, { useState, useEffect } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Counter() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    const id = setInterval(() =&gt; setCount(count + 1), 1000);    return () =&gt; clearInterval(id);  }, []);  return &lt;h1&gt;{count}&lt;/h1&gt;;}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><p>上面的案例是一个状态频繁变化的组件，但是我们给 <code>useEffect</code> 传入的第二个参数为空数组，这就会产生一个 <code>Bug</code>，由于 <code>useEffect</code> 默认只执行一次，并没有执行清除定时器的返回函数，所以导致取到的依然是初始的状态值，还记得上面一节 <code>useState</code> 中提到使用上一次的状态去更新状态，这里我们可以通过这种方式修复这个 <code>Bug</code>。</p><pre><code class="lang-jsx">/* 解决频繁更新未被监听变量不变的问题 */import React, { useState, useEffect } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Counter() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    const id = setInterval(() =&gt; setCount(prev =&gt; prev + 1), 1000);    return () =&gt; clearInterval(id);  }, []);  return &lt;h1&gt;{count}&lt;/h1&gt;;}ReactDOM.render(&lt;Counter /&gt;, root);</code></pre><blockquote class="pullquote warning"><p><strong>所以说在有些时候，对于 <code>useEffect</code> 第二个参数传入 <code>[ ]</code> 的行为不是绝对安全的，并且不建议这样使用。</strong></p></blockquote><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，用来处理复杂的 <code>state</code> 更新，看到这个名字大家可能会想到 <code>Redux</code> 中的 <code>reducer</code>，其实 <code>useReducer</code> 就是 <code>React Hooks</code> 中用来替代 <code>Redux</code> 解决问题的，让我们从此不需要 <code>Redux</code>。</p><pre><code class="lang-jsx">import React, { useReducer, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 初始 stateconst initalCountState = { count: 0 };// reducer 函数function reducer(state, action) {  switch (action.type) {    case &#39;reset&#39;:      return { count: action.payload };    case &#39;increment&#39;:      return { count: state.count + 1 };    case &#39;decrement&#39;:      return { count: state.count - 1 };    default:      return state;  }}// 默认初始 state 函数function init(initalCountState) {  return { count: initalCountState.count + 1 };}function Counter({ initalCount }) {  const [ state, dispatch ] = useReducer(reducer, initalCountState, init);  return (    &lt;Fragment&gt;      count: { state.count }      &lt;button onClick={() =&gt; dispatch({        type: &#39;reset&#39;,        payload: initalCount      })}&gt;        Reset      &lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;    &lt;/Fragment&gt;  )}function App() {  return &lt;Counter initalCount={0} /&gt;}ReactDOM.render(&lt;App /&gt;, root);</code></pre><blockquote class="pullquote primary"><p><strong><code>useReducer</code> 有三个参数：</strong></p><ul><li><strong>第一个参数为 <code>reducer</code> 函数（根据 <code>action</code> 的类型匹配新的 <code>state</code> 值）；</strong></li><li><strong>第二个参数为监听状态对象 <code>state</code> 的初始值；</strong></li><li><strong>第三个参数是一个函数，参数为初始的 <code>state</code>，作用是输出一个新的 <code>state</code> 替换初始的 <code>state</code>，只在最初执行一次。</strong></li></ul><p><strong><code>useReducer</code> 的返回值为数组：</strong></p><ul><li><strong>数组第一项是监听的 <code>state</code> 对象；</strong></li><li><strong>数组第二项是用来触发 <code>state</code> 更新的函数，参数为 <code>action</code>。</strong></li></ul></blockquote><pre><code class="lang-jsx">/* useReducer 不传第三个参数 */import React, { useReducer, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function reducer(state, action) {  switch (action.type) {    case &#39;reset&#39;:      return { count: action.payload };    case &#39;increment&#39;:      return { count: state.count + 1 };    case &#39;decrement&#39;:      return { count: state.count - 1 };    default:      return state;  }}function Counter({ initalCount }) {  const [ state, dispatch ] = useReducer(reducer, initalCount);  return (    &lt;Fragment&gt;      count: { state.count }      &lt;button onClick={() =&gt; dispatch({        type: &#39;reset&#39;,        payload: initalCount.count      })}&gt;        Reset      &lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;    &lt;/Fragment&gt;  )}function App() {  return &lt;Counter initalCount={{ count: 0 }} /&gt;}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>这个案例跟之前的稍有差别，去掉了 <code>useReducer</code> 的第三个参数，并将 <code>Counter</code> 组件的入参 <code>initalCount</code> 作为了初始 <code>state</code>。</p><blockquote class="pullquote success"><p><strong>使用 <code>React</code> 进行过项目开发应该都是用过 <code>Redux</code> 和 <code>Mobx</code> 之类的状态管理工具，但其实他们并不是专门针对 <code>React</code> 所设计的，里面都蕴含了一些关于状态管理的编程思想和自己独立的逻辑，也可以在其他框架技术栈中使用，只是和 <code>React</code> 搭配使用时更舒适，而 <code>React hooks</code> 中提供了官方自身的状态管理解决方案，避免依赖第三方库，所以 <code>Facebook</code> 挖来了 <code>Redux</code> 的作者开发了 <code>React hooks</code> 中状态管理相关的 <code>API</code>。</strong></p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>想了解 <code>useContext</code> 首先要了解 <code>context API</code>，即 <code>React.createContext</code> 方法，执行后返回一个对象，其中包含两个属性分别为 <code>Provider</code> 和 <code>Consumer</code>，都为组件，<code>Provider</code> 用于包裹提供状态的容器组件，<code>Consumer</code> 用于包裹消费这个状态的组件，更详细的用法不在这里过多赘述，可以查看 <a href="https://react.docschina.org/docs/context.html" target="_blank">React 官方文档</a>。</p><pre><code class="lang-jsx">import React, { useState, useContext } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;const myContext = React.createContext();// 子组件function Com() {  const { count, setCount } = useContext(myContext);  return (    &lt;div&gt;      子组件：{count}      &lt;br /&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;    &lt;/div&gt;  )}// 父组件function App() {  const [ count, setCount ] = useState(0);  return (    &lt;myContext.Provider value={{ count, setCount }}&gt;      父组件：{count}      &lt;br /&gt;      &lt;Com /&gt;    &lt;/myContext.Provider&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面是 <code>useContext</code> 的一个简单用法，我们创建了 <code>context</code>，在父组件 <code>App</code> 中创建了 <code>count</code> 和更改 <code>count</code> 的函数 <code>setCount</code>，并将它们通过 <code>context</code> 的 <code>Provider</code> 组件提供给子组件 <code>Com</code>，子组件中调用 <code>useContext</code> 并传入这个创建的 <code>context</code> 对象，返回了父组件所提供的状态数据，并在子组件中点击的方式来更改，此时父、子组件中渲染的 <code>count</code> 都发生了变化。</p><p>上面说 <code>React hooks</code> 中提供了自己的状态管理解决方案，也就是说可以替代 <code>Redux</code> 的工作，实现整个项目的状态管理以及相关状态逻辑的复用，下面就使用 <code>useContext</code> 和 <code>useReducer</code> 来实现一个简单的状态管理逻辑。</p><pre><code class="lang-jsx">/* reducer.js */import React, { useReducer } from &#39;react&#39;;// 初始状态（默认值）const initalState = { count: 0 };// 导出共用的上下文export const myContext = React.createContext();// 导出 reducer 函数export function reducer(state, action) {  switch (action.type) {    case &#39;reset&#39;:      return initalState;    case &#39;increment&#39;:      return { count: state.count + 1 };    case &#39;decrement&#39;:      return { count: state.count - 1 };    default:      return state;  }}// 导出提供状态的函数组件export const ContextProvider = props =&gt; {  const [ state, dispatch ] = useReducer(reducer, initalState);  return (    &lt;myContext.Provider value={{ state, dispatch }}&gt;      {props.children}    &lt;/myContext.Provider&gt;  )}</code></pre><p>上面的 <code>reducer.js</code> 文件用来提供整个状态管理的核心逻辑，创建了初始的 <code>state</code>，创建了共用的上下文对象，创建了 <code>reducer</code> 函数（通过 <code>action</code> 来匹配并返回新的 <code>state</code>），创建了用来提供 <code>state</code> 和 <code>dispatch</code> 的公共组件 <code>ContextProvider</code>，该组件内部通过创建上下文的 <code>Provider</code> 组件给该组件中间包裹的所有子组件 <code>children</code> 通过 <code>value</code> 提供 <code>state</code> 和 <code>dispatch</code>（通过 <code>useReducer</code> 创建）。</p><pre><code class="lang-jsx">/* App.js */import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import { ContextProvider } from &#39;./reducer&#39;;import Counter from &#39;./Counter&#39;;function App() {  return (    &lt;div&gt;      &lt;ContextProvider&gt;        &lt;Counter /&gt;      &lt;/ContextProvider&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p><code>App</code> 组件，是提供状态的容器（一般使用根组件），根据 <code>reducer.js</code> 的用法，只需要引入 <code>ContextProvider</code> 组件包裹需要使用状态的子组件，与 <code>react-redux</code> 的 <code>Provider</code> 组件提供 <code>store</code> 的模式相似，这样被 <code>ContextProvider</code> 组件包裹的子组件就可以使用 <code>reducer.js</code> 中所 <code>useReducer</code> 所提供的 <code>state</code> 和 <code>dispatch</code>，<code>Counter</code> 子组件代码如下。</p><pre><code class="lang-jsx">import React, { useContext } from &#39;react&#39;;import { myContext } from &#39;./reducer&#39;;function Counter() {  const { state, dispatch } = useContext(myContext);  return (    &lt;div&gt;      Counter count: {state.count}      &lt;button onClick={() =&gt; dispatch({ type: &#39;reset&#39; })}&gt;Reset&lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;+&lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;-&lt;/button&gt;    &lt;/div&gt;  )}export default Counter;</code></pre><p>在使用 <code>reducer.js</code> 中实现的状态管理逻辑的组件中，只需要引入 <code>reducer.js</code> 提供的 <code>context</code>，并使用 <code>useContext</code> 就可以解构出 <code>state</code> 和 <code>dispatch</code>，并通过 <code>action</code> 实现三种不同的对状态的 <code>state</code> 的操作。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是 <code>React</code> 针对函数组件的优化考虑所设计的 <code>Hook API</code>，在函数被渲染时，<code>React</code> 底层是通过调用的方式去创建的，如果函数组件作用域中创建了实现某些功能的函数，则底层每次调用函数组件时，这些函数都会被重新创建，也就是指向新的引用，有了 <code>React Hooks</code> 以后，函数组件中需要的函数可以通过 <code>useCallback</code> 创建。</p><pre><code class="lang-jsx">import React, { useCallback, Component } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 用来存储 useCallback 返回的函数let fn = null;// 使用 useCallback 的函数组件function TestUseCallback({ nums, name }) {  const memoizedCallback = useCallback(() =&gt; {    console.log(nums, &#39;Hello world!&#39;);  }, [ nums ]);  console.log(&#39;callback 是否相同：&#39;, Object.is(fn, memoizedCallback));  console.log(&#39;nums &gt; &#39;, nums, &#39;name &gt; &#39;, name);  fn = memoizedCallback;  return (    &lt;div&gt;      &lt;button onClick={memoizedCallback}&gt;TestUseCallback&lt;/button&gt;    &lt;/div&gt;  )}// 用来触发重新 render 的类组件class App extends Component {  state = {    nums: [1, 2, 3],    count: 0,    name: &#39;hello&#39;  };  componentDidMount() {    setInterval(() =&gt; {      this.setState((state) =&gt; ({ count: state.count + 1 }));    }, 3000);  }  handleChangeNum = () =&gt; this.setState({ nums: [4, 5, 6], name: &#39;world&#39; });  render() {    const { nums, name } = this.state;    return (      &lt;div className=&quot;App&quot;&gt;        &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;        &lt;button onClick={this.handleChangeNum}&gt;修改传入的 nums 值&lt;/button&gt;        &lt;TestUseCallback nums={nums} name={name} /&gt;      &lt;/div&gt;    )  }}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>在上面的案例中渲染的组件 <code>App</code> 是一个类组件，该组件在挂载后会创建一个定时器，每 <code>3s</code> 更新 <code>state</code> 的 <code>count</code> 值，来完成重渲染，内部的 <code>TestUseCallback</code> 组件也会跟着重渲染，在内部检测 <code>useCallback</code> 创建的函数是否每次都会创建新的，同时打印父组件传递的参数，在通过父组件的点击事件更改的依赖的时候，观察 <code>useCallback</code> 是否会新创建返回的值。</p><blockquote class="pullquote info"><p><strong>执行 <code>useCallback</code> 方法传入的的参数为回调函数和依赖列表（数组），返回值为传入的函数，<code>React</code> 已经将传入的函数注入，只要依赖列表中的依赖没有发生变化，就不会创建新的函数返回，这样就大大减小了每次都在内存中创建新的引用来存储新函数的开销，也同时减少了 <code>GC</code> 的压力。</strong></p></blockquote><pre><code class="lang-jsx">/* 组件中不同方式事件处理函数的区别 */class Com1 extends Component {  handleClick() {    console.log(&#39;click happened&#39;);  }  render() {    return &lt;button onClick={() =&gt; this.handleClick()}&gt;Click me&lt;/button&gt;  }}class Com2 extends Component {  constructor(props) {    super(props);    this.handleClick = this.handleClick.bind(this);  }  handleClick() {    console.log(&#39;click happened&#39;);  }  render() {    return &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt;  }}function Com3() {  const handleClick = () =&gt; {    console.log(&#39;click happened&#39;);  }  return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;}function Com4() {  const memoizedHandleClick = useCallback(() =&gt; {    console.log(&#39;click happened&#39;);  }, []);  return &lt;button onClick={memoizedHandleClick}&gt;Click me&lt;/button&gt;}</code></pre><blockquote class="pullquote warning"><ul><li><strong><code>Com1</code>：类组件，直接使用箭头函数，每次重新渲染都产生新的函数；</strong></li><li><strong><code>Com2</code>：类组件，在 <code>constructor</code> 中使用 <code>bind</code> 绑定 <code>this</code>，每次重新渲染都使用同一个函数；</strong></li><li><strong><code>Com3</code>：函数组件，直接创建函数，每次重新渲染都产生新的函数；</strong></li><li><strong><code>Com4</code>：函数组件，使用 <code>useCallback</code> 创建函数，每次重新渲染都使用同一个函数；</strong></li></ul></blockquote><pre><code class="lang-jsx">import React, { useState, useCallback } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;const Child = React.memo(({ a, memo }) =&gt; {  return (    &lt;div&gt;      {console.log(&#39;Child 渲染&#39;)}      &lt;span&gt;a: {a}&lt;/span&gt;      &lt;button onClick={memo}&gt;Click in child&lt;/button&gt;    &lt;/div&gt;  )});const App = props =&gt; {  const [ a, setA ] = useState(0);  const [ b, setB ] = useState(0);  // 直接创建的函数  // const handleClick = () =&gt; console.log(&#39;click&#39;);  // 使用 useCallback 创建的函数  const handleClick = useCallback(() =&gt; console.log(&#39;click&#39;), []);  return (    &lt;div&gt;      {console.log(&#39;App 渲染&#39;)}      &lt;Child a={a} memo={handleClick} /&gt;      &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt;      &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt;      &lt;button onClick={handleClick}&gt;Click&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面案例中使用了 <code>React.memo</code> 的函数组件优化方法来进一步验证了 <code>useCallback</code> 的作用，方法 <code>React.memo</code> 的参数为一个函数组件，会返回一个高阶组件，作用是当传入的函数组件内部的 <code>props</code> 不发生变化时，则不会重新渲染。</p><p>父组件 <code>App</code> 中使用 <code>useCallback</code> 创建的函数和使用 <code>useState</code> 创建的状态 <code>a</code> 作为参数传递给子组件 <code>Child</code>，并通过点击事件改变 <code>a</code> 和 <code>b</code> 的状态，初次渲染时控制台打印 <code>App 渲染</code> 和 <code>Child 渲染</code>，当点击 <code>改变 a</code> 时，父、子组件同时渲染，是因为子组件 <code>props</code> 中的 <code>a</code> 发生变化，当点击 <code>改变 b</code> 时，父组件重新渲染，但是子组件并没有，说明 <code>useCallback</code> 并没有产生新的函数传递给子组件，当使用 <code>App</code> 组件注释中直接创建的函数时，则点击 <code>改变 b</code>，子组件也会重新渲染，是因为父组件重渲染创建了新的函数，导致子组件的参数发生变化。</p><pre><code class="lang-jsx">import React, { useState, useCallback } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 存储两个组件的函数let fun1 = null;let fun2 = null;// 使用 React.memo 改写的一个渲染耗时的组件（假设很耗时）const ExpensiveCom = React.memo(({ onClick }) =&gt; {  const date = new Date();  return (    &lt;h1 onClick={onClick}&gt;      {console.log(&#39;昂贵组件渲染了！&#39;)}      {date.getSeconds()}      我是一个昂贵的组件！渲染耗时！    &lt;/h1&gt;  )});function Com1({ p1 }) {  const fn = () =&gt; console.log(&#39;fn&#39;, p1);  console.log(&#39;Com1&#39;, Object.is(fun1, fn));  fun1 = fn;  return (    &lt;ExpensiveCom onClick={fn} /&gt;  )}function Com2({ p2 }) {  const fn = useCallback(() =&gt; console.log(&#39;fn&#39;, p2), [ p2 ]);  console.log(&#39;Com2&#39;, Object.is(fun2, fn));  fun2 = fn;  return (    &lt;ExpensiveCom onClick={fn} /&gt;  )}function App() {  const [ p1, setP1 ] = useState(0);  const [ p2, setP2 ] = useState(0);  return (    &lt;div&gt;      &lt;h2&gt;每次点击 fn 都是新的&lt;/h2&gt;      &lt;Com1 p1={p1} /&gt;      &lt;button onClick={() =&gt; setP1({ p1: p1 + 1 })}&gt;p1 + 1&lt;/button&gt;      &lt;br/&gt;      &lt;h2&gt;不用重复生成 fn&lt;/h2&gt;      &lt;Com2 p2={p2} /&gt;      &lt;button onClick={() =&gt; setP2({ p2: p2 + 1 })}&gt;p2 + 1&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面例子中假设 <code>ExpensiveCom</code> 是一个渲染非常耗时的 “昂贵” 组件，并在两个不同的容器组件 <code>Com1</code> 和 <code>Com2</code> 中对比，<code>ExpensiveCom</code> 参数是在父组件 <code>Com1</code> 和 <code>Com2</code> 中创建的函数，前者直接创建，后者使用 <code>useCallback</code> 创建，在 <code>App</code> 组件中渲染 <code>Com1</code> 和 <code>Com2</code>，分别传入状态 <code>p1</code> 和 <code>p2</code>，并在 <code>Com1</code> 和 <code>Com2</code> 内部的函数中进行打印，而创建的函数作为 “昂贵” 组件的参数，并作为内部点击的执行函数。</p><p>当在页面点击 <code>p1 + 1</code> 或 <code>p2 + 1</code> 时，都会导致 <code>App</code> 的状态变化，也就是 <code>App</code> 的重渲染，而作为 <code>App</code> 的子组件, <code>Com1</code> 和 <code>Com2</code>，也会跟着重新渲染，点击 <code>p1 + 1</code>，从控制台打印结果看，只有 <code>Com1</code> 内部的 “昂贵” 组件重新渲染，而 <code>Com2</code> 中并没有，是因为 <code>useCallback</code> 中依赖的 <code>p2</code> 没有改变，没有生成新的函数，当点击 <code>p2 + 1</code> 时，<code>Com2</code> 内部的 “昂贵” 组件重新渲染，同时 <code>Com1</code> 内部的 “昂贵” 组件也重新渲染，由此可以看出 <code>Com2</code> 的性能是要优于 <code>Com1</code> 的。</p><blockquote class="pullquote default"><p><strong>在大型的项目中，可能在内层组件中存在非常耗时耗性能的 “昂贵” 组件，如果因为在外层组件中一个函数的更新导致的所有组件重新渲染，显然性能代价是非常大的，所以合理的使用 <code>useCallback</code> 对函数组件进行优化是非常有必要的。</strong></p></blockquote><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一种优化手段，接收两个参数，第一个参数是一个函数，第二个参数是依赖列表，返回值是第一个参数传入函数执行后的返回结果，在函数组件渲染时，其中的 <code>useMemo</code> 只有在依赖列表中的依赖发生变化，才会重新计算函数的结果。</p><pre><code class="lang-jsx">import React, { useState, useMemo } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 存储 useMemo 的返回结果let ch = null;// 用于观察是否重渲染的组件const Com = ({ val }) =&gt; {  console.log(&#39;Com 重新渲染了&#39;);  return &lt;h2&gt;{val}&lt;/h2&gt;}// 父组件function Parent({ a, b }) {  const child1 = useMemo(() =&gt; (    &lt;div&gt;      {console.log(&#39;child1 重新计算&#39;)}      &lt;Com val={b} /&gt;    &lt;/div&gt;  ), [ a ]);  console.log(&#39;child1 是否和之前相等&#39;, child1 === ch);  ch = child1;  const child2 = (    &lt;div&gt;      {console.log(&#39;child2 重新计算&#39;)}      &lt;Com val={b} /&gt;    &lt;/div&gt;  )  return (    &lt;div&gt;      {child1}      {child2}    &lt;/div&gt;  )}// 提供状态的容器组件const App = props =&gt; {  const [ a, setA ] = useState(0);  const [ b, setB ] = useState(0);  return (    &lt;div&gt;      &lt;Parent a={a} b={b} /&gt;      &lt;button onClick={() =&gt; setA(a + 1)}&gt;改变 a&lt;/button&gt;      &lt;button onClick={() =&gt; setB(b + 1)}&gt;改变 b&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面例子中 <code>App</code> 组件提供状态 <code>a</code> 和 <code>b</code> 作为参数提供给 <code>Parent</code> 组件，<code>App</code> 中可以通过 <code>改变 a</code> 和 <code>改变 b</code> 按钮更新状态 <code>a</code> 和 <code>b</code>，当 <code>a</code> 和 <code>b</code> 发生变化时导致 <code>Parent</code> 组件重新渲染，内部的 <code>child1</code> 和 <code>child2</code> 分别是通过 <code>useMemo</code> 和直接创建的组件，其中分别渲染 <code>Com</code> 组件，默认情况下 <code>child1</code> 和 <code>child2</code> 都会渲染，点击 <code>改变 a</code>，<code>child1</code> 和 <code>child2</code> 重新渲染，因为 <code>child1</code> 的依赖 <code>a</code> 发生变化，点击 <code>改变 b</code>，发现只有 <code>child2</code> 重新渲染，而再此点击 <code>改变 a</code>，由于都重新渲染导致 <code>child1</code> 和 <code>child2</code> 渲染的值同步了。</p><blockquote class="pullquote primary"><p><strong><code>useMemo</code> 不仅仅可以优化耗时的复杂计算程序，同时可以优化渲染耗时且页面不要求更新的复杂组件，但有一点需要注意，就是不要在传入 <code>useMemo</code> 的函数中执行与渲染无关的操作，如副作用，这类的操作属于 <code>useEffect</code> 的范畴，而不是 <code>useMemo</code>。</strong></p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>在 <code>React</code> 组件中有一个区分方式，受控组件和非受控组件，大多场景应用于表单元素，受控组件就是通过 <code>onChange</code> 事件和 <code>state</code> 实现双向绑定，这里不过多赘述，非受控组件是通过元素的 <code>ref</code> 属性获取 <code>Dom</code> 的引用，进而对表单进行操作，在 <code>React 16.3</code> 以后推荐使用 <code>React.createRef</code> 方法创建。</p><p>类组件中使用 <code>ref</code> 通常是将引用关联到类组件的实例属性上，方便操作，而 <code>useRef</code> 就是为了在函数组件中实现这个功能而存在的。</p><pre><code class="lang-jsx">import React, { useState, useRef, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function TextInputWithFocusButton() {  const inputEl = useRef();  const onButtonClick = () =&gt; {    inputEl.current.focus();  }  return (    &lt;Fragment&gt;      &lt;input ref={inputEl} type=&quot;text&quot; /&gt;      &lt;button onClick={onButtonClick}&gt;获取焦点&lt;/button&gt;    &lt;/Fragment&gt;  )}const App = props =&gt; {  const [ count, setCount ] = useState(0);  return (    &lt;div&gt;      {count}      &lt;TextInputWithFocusButton /&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><blockquote class="pullquote success"><p><strong>在函数组件中同样可以 <code>React.createRef</code> 来实现，但是函数组件的每一次重新渲染都会导致 <code>ref</code> 对象的重新创建，浪费内存和性能，<code>useRef</code> 的参数为创建 <code>ref</code> 对象 <code>current</code> 属性的初始值，<code>ref</code> 对象创建后会作为函数组件的实例属性，除非组件卸载，否则不会重新创建。</strong></p></blockquote><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在介绍 <code>useImperativeHandle</code> 之前一定要清楚 <code>React</code> 关于 <code>ref</code> 转发（也叫透传）的知识点，是使用 <code>React.forwardRef</code> 方法实现的，该方法返回一个组件，参数为函数（<code>Prop callback</code>，并不是函数组件），函数的第一个参数为父组件传递的 <code>props</code>，第二给参数为父组件传递的 <code>ref</code>，其目的就是希望可以在封装组件时，外层组件可以通过 <code>ref</code> 直接控制内层组件或元素的行为。</p><pre><code class="lang-jsx">/* 一个关于 ref 转发的例子 */import React, { useCallback, useRef } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 实现 ref 的转发const FancyButton = React.forwardRef((props, ref) =&gt; (  &lt;div&gt;    &lt;input ref={ref} type=&quot;text&quot; /&gt;    &lt;button&gt;{props.children}&lt;/button&gt;  &lt;/div&gt;));// 父组件中使用子组件的 reffunction App() {  const ref = useRef();  const handleClick = useCallback(() =&gt; ref.current.focus(), [ ref ]);  return (    &lt;div&gt;      &lt;FancyButton ref={ref}&gt;Click Me&lt;/FancyButton&gt;      &lt;button onClick={handleClick}&gt;获取焦点&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面例子中创建了一个 <code>FancyButton</code> 组件，内部渲染了一个 <code>button</code> 元素，我们希望在父元素 <code>App</code> 中渲染 <code>FancyButton</code>，并通过传递给 <code>FancyButton</code> 的 <code>ref</code> 直接操作内部的 <code>button</code>。</p><pre><code class="lang-jsx">/* 一个官方的 useImperativeHandle 例子 */import React, { useRef, useImperativeHandle } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;const FancyInput = React.forwardRef((props, ref) =&gt; {  const inputRef = useRef();  useImperativeHandle(ref, () =&gt; ({    focus: () =&gt; {      inputRef.current.focus();    }  }));  return &lt;input ref={inputRef} type=&quot;text&quot; /&gt;});const App = (props) =&gt; {  const fancyInputRef = useRef();  return (    &lt;div&gt;      &lt;FancyInput ref={fancyInputRef} /&gt;      &lt;button onClick={() =&gt; fancyInputRef.current.focus()}&gt;        父组件调用子组件的 focus      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面这个例子中与直接转发 <code>ref</code> 不同，直接转发 <code>ref</code> 是将 <code>React.forwardRef</code> 中函数上的 <code>ref</code> 参数直接应用在了返回元素的 <code>ref</code> 属性上，其实父、子组件引用的是同一个 <code>ref</code> 的 <code>current</code> 对象，官方不建议使用这样的 <code>ref</code> 透传，而使用 <code>useImperativeHandle</code> 后，可以让父、子组件分别有自己的 <code>ref</code>，通过 <code>React.forwardRef</code> 将父组件的 <code>ref</code> 透传过来，通过 <code>useImperativeHandle</code> 方法来自定义开放给父组件的 <code>current</code>。</p><p><code>useImperativeHandle</code> 的第一个参数是定义 <code>current</code> 对象的 <code>ref</code>，第二个参数是一个函数，返回值是一个对象，即这个 <code>ref</code> 的 <code>current</code> 对象，这样可以像上面的案例一样，通过自定义父组件的 <code>ref</code> 来使用子组件 <code>ref</code> 的某些方法，进而将子组件的 <code>ref</code> 保护起来，符合开放封闭原则。</p><blockquote class="pullquote warning"><p><strong><code>useImperativeHandle</code> 和 <code>React.forwardRef</code> 是需要配合使用的，这也是为什么在开头要介绍 <code>ref</code> 的转发。</strong></p></blockquote><pre><code class="lang-jsx">import React, { useState, useRef, useImperativeHandle, useCallback } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;const FancyInput = React.forwardRef((props, ref) =&gt; {  const [ fresh, setFresh ] = useState(false)  const attRef = useRef(0);  useImperativeHandle(ref, () =&gt; ({    attRef,    fresh  }), [ fresh ]);  const handleClick = useCallback(() =&gt; {    attRef.current++;  }, []);  return (    &lt;div&gt;      {attRef.current}      &lt;button onClick={handleClick}&gt;Fancy&lt;/button&gt;      &lt;button onClick={() =&gt; setFresh(!fresh)}&gt;刷新&lt;/button&gt;    &lt;/div&gt;  )});const App = props =&gt; {  const fancyInputRef = useRef();  return (    &lt;div&gt;      &lt;FancyInput ref={fancyInputRef} /&gt;      &lt;button onClick={() =&gt; console.log(fancyInputRef.current)}&gt;        父组件访问子组件的实例属性      &lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面的案例相对于官方的例子意图更明显一些，通过 <code>useImperativeHandle</code> 将子组件的实例属性输出到父组件，而子组件内部通过 <code>ref</code> 更改 <code>current</code> 对象后，组件不会重新渲染，需要改变 <code>useState</code> 设置的状态才能更改。</p><blockquote class="pullquote info"><p><strong><code>useImperativeHandle</code> 方法还支持传入第三个参数，即依赖列表，当监听的依赖发生变化时，<code>useImperativeHandle</code> 才会重新将子组件的实例属性输出到父组件 <code>ref</code> 的 <code>current</code> 属性上，如果为空数组，则不会重新输出。</strong></p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 的使用方法和 <code>useEffect</code> 相同，唯一的区别就是执行时机不一样。</p><pre><code class="lang-jsx">/* 对比 useLayoutEffect 与 useEffect 的执行时机 */import React, { useState, useEffect, useLayoutEffect } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;function Com() {  useEffect(() =&gt; {    console.log(&#39;useEffect 执行...&#39;);    return () =&gt; {      console.log(&#39;useEffect 销毁...&#39;);    }  });  useLayoutEffect(() =&gt; {    console.log(&#39;useLayoutEffect 执行...&#39;);    return () =&gt; {      console.log(&#39;useLayoutEffect 销毁...&#39;);    }  });  return (    &lt;div&gt;      {console.log(&#39;Com 渲染&#39;)}      &lt;h2&gt;Com1&lt;/h2&gt;    &lt;/div&gt;  )}const App = props =&gt; {  const [ count, setCount ] = useState(0)  return (    &lt;div&gt;      &lt;Com /&gt;      {count}      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;count + 1&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面的例子中在 <code>Com</code> 组件中同时使用了 <code>useLayoutEffect</code> 和 <code>useEffect</code>，在页面初次渲染时可以看到控制台打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 执行...</code>。</p><p>当点击 <code>App</code> 组件按钮更新状态导致 <code>Com</code> 重新渲染，打印顺序为 <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><p>在刚接触 <code>React Hooks</code> 时，说到执行时机我们一般会和类组件的生命周期去类比，下面是一个 <code>useLayoutEffect</code>、<code>useEffect</code> 与类组件生命周期配合使用的例子。</p><pre><code class="lang-jsx">/* 对比 useLayoutEffect、useEffect 与类组件生命周期的执行时机 */import React, { useEffect, useLayoutEffect, Component } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 使用 useLayoutEffect 和 useEffect 的函数组件function Com() {  useEffect(() =&gt; {    console.log(&#39;useEffect 执行...&#39;);    return () =&gt; {      console.log(&#39;useEffect 销毁...&#39;);    }  });  useLayoutEffect(() =&gt; {    console.log(&#39;useLayoutEffect 执行...&#39;);    return () =&gt; {      console.log(&#39;useLayoutEffect 销毁...&#39;);    }  });  return (    &lt;div&gt;      {console.log(&#39;Com 渲染&#39;)}      &lt;h2&gt;Com1&lt;/h2&gt;    &lt;/div&gt;  )}// 使用生命周期的类组件class App extends Component {  state = { count: 0 }  setCount = () =&gt; {    this.setState({ count: this.state.count + 1 });  }  componentDidMount() {    console.log(&#39;App componentDidMount&#39;);  }  componentDidUpdate() {    console.log(&#39;App componentDidUpdate&#39;);  }  render() {    return (      &lt;div&gt;        {this.state.count}        &lt;Com /&gt;        {console.log(&#39;App 渲染&#39;)}        &lt;button onClick={this.setCount}&gt;count + 1&lt;/button&gt;      &lt;/div&gt;    )  }}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面例子中 <code>useLayoutEffect</code> 和 <code>useEffect</code> 依然在 <code>Com</code> 组件中使用，<code>App</code> 组件为类组件，<code>Com</code> 作为 <code>App</code> 的子组件，在首次渲染时控制台的打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidMount</code> → <code>useEffect 执行...</code>。</p><p>而点击按钮更改状态触发重渲染时，打印顺序为 <code>App 渲染</code> → <code>Com 渲染</code> → <code>useLayoutEffect 销毁...</code> → <code>useLayoutEffect 执行...</code> → <code>App componentDidUpdate</code> → <code>useEffect 销毁...</code> → <code>useEffect 执行...</code>。</p><blockquote class="pullquote default"><p><strong><code>useLayoutEffect</code> 的执行时机要早于 <code>useEffect</code>，<code>useLayoutEffect</code> 的执行在类组件生命周期前，<code>useEffect</code> 的执行在类组件生命周期后，官方的建议是要求我们尽量使用 <code>useEffect</code>，以避免阻塞视觉更新，如果是将代码从类组件重构为 <code>React Hooks</code>，并且使用 <code>useEffect</code> 出现问题，再考虑使用 <code>useLayoutEffect</code>，服务端渲染时使用 <code>useLayoutEffect</code> 会触发警告。</strong></p></blockquote><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 用于在 <code>React</code> 开发者工具（如果已安装，在浏览器控制台 <code>React</code> 选项查看）中显示 <a href="/20190507155411/#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook" target="_blank">自定义 Hook</a> 的标签。</p><pre><code class="lang-jsx">import React, { useState, useDebugValue } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 自定义 Hookfunction useMyCount(num) {  const [ count, setCount ] = useState(0);  // 调试自定义 Hook，显示在 devtools 上  useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;);  const myCount = () =&gt; {    setCount(count + 2);  }  return [ count, myCount ];}function App() {  const [ count, setCount ] = useMyCount(10);  return (    &lt;div&gt;      {count}      &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面例子中创建了 <code>useMyCount</code> 自定义 <code>Hook</code>，在内部使用 <code>useDebugValue</code> 对 <code>count</code> 的状态进行了调试，在开发工具中显示如下图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/React/20190507155411/usedebugvalue.png" alt="useDebugValue 调试效果图"></div><div class="image-caption">useDebugValue 调试效果图</div></figure><p><br></p><p><code>useDebugValue</code> 还支持第二个参数，类型为函数，函数的默认参数为 <code>debug</code> 的状态，作用是对 <code>debug</code> 的值进行格式化，官方叫做 “延迟格式化”。</p><pre><code class="lang-jsx">/* 延迟格式化 */import React, { useState, useDebugValue } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 自定义 Hookfunction useMyCount(num) {  const [ count, setCount ] = useState(0);  // 延迟格式化  useDebugValue(count &gt; num ? &#39;溢出&#39; : &#39;不足&#39;, (status) =&gt; {    return status === &#39;溢出&#39; ? 1 : 0;  });  const myCount = () =&gt; {    setCount(count + 2);  }  return [ count, myCount ];}function App() {  const [ count, setCount ] = useMyCount(10);  return (    &lt;div&gt;      {count}      &lt;button onClick={() =&gt; setCount()}&gt;setCount&lt;/button&gt;    &lt;/div&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面的例子只是做了小小的改动，增加了一个格式化函数作为 <code>useDebugValue</code> 的第二个参数，当状态为 <code>不足</code> 时显示 <code>0</code>，为 <code>溢出</code> 时显示 <code>1</code>。</p><blockquote class="pullquote info"><p><strong>提示：我们不推荐你向每个自定义 <code>Hook</code> 使用 <code>useDebugValue</code>，只有自定义 <code>Hook</code> 被复用时才最有意义。</strong></p></blockquote><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>在开篇介绍 <code>React Hooks</code> 产生的动机时，提到了在类组件中使用 “高阶组件”（<code>HOC</code>）和 “渲染回调”（<code>Prop callback</code>）的方式对状态逻辑进行复用和解耦会导致渲染嵌套的层级增多以及代码可读性差的问题，在 <code>React 16.8</code> 以后可以通过自定义 <code>Hook</code> 来解决这些问题。</p><pre><code class="lang-jsx">/* 一个没有解决问题的例子 */import React, { useState, useEffect, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 计数器 1function Counter1() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    console.log(&#39;开启一个新的定时器&#39;)    const timer = setInterval(() =&gt; {      setCount(count + 1);    }, 1000);    return () =&gt; {      console.log(&#39;销毁老的定时器&#39;)      clearInterval(timer);    }  });  return &lt;p&gt;{count}&lt;/p&gt;}// 计数器 2function Counter2() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    console.log(&#39;开启一个新的定时器&#39;)    const timer = setInterval(() =&gt; {      setCount(count + 1);    }, 1000);    return () =&gt; {      console.log(&#39;销毁老的定时器&#39;)      clearInterval(timer);    }  });  return &lt;p&gt;{count}&lt;/p&gt;}function App() {  return (    &lt;Fragment&gt;      &lt;Counter1 /&gt;      &lt;Counter2 /&gt;    &lt;/Fragment&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>上面实现了两个计数器，都有自动增加状态的更新数组的功能，并且都是使用 <code>React Hooks</code> 实现的，很明显我们可以将更新状态的逻辑抽离出来，下面是通过自定义 <code>Hook</code> 改写的例子。</p><pre><code class="lang-jsx">/* 使用自定义 Hook 对状态逻辑进行抽离 */import React, { useState, useEffect, Fragment } from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 自定义 Hookfunction useNumber() {  const [ count, setCount ] = useState(0);  useEffect(() =&gt; {    console.log(&#39;开启一个新的定时器&#39;)    const timer = setInterval(() =&gt; {      setCount(count + 1);    }, 1000);    return () =&gt; {      console.log(&#39;销毁老的定时器&#39;)      clearInterval(timer);    }  });  return count;}// 计数器 1function Counter1() {  let number = useNumber();  return &lt;p&gt;{number}&lt;/p&gt;}// 计数器 2function Counter2() {  let number = useNumber();  return &lt;p&gt;{number}&lt;/p&gt;}function App() {  return (    &lt;Fragment&gt;      &lt;Counter1 /&gt;      &lt;Counter2 /&gt;    &lt;/Fragment&gt;  )}ReactDOM.render(&lt;App /&gt;, root);</code></pre><p>使用自定义 <code>Hook</code> 就很容易的实现了状态逻辑的复用和解耦，代码简单易读，也避免了 “高阶组件” 和 “渲染回调” 造成渲染层级增加的问题。</p><blockquote class="pullquote primary"><p><strong>注意：官方建议在创建自定义 <code>Hook</code> 时，也采用 <code>use</code> 开头的命名方式，以保持命名的默认约定，便于识别，非强制，所以项目中可以使用 <code>ESlint</code> 进行检查和约束。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>React Hooks</code> 出现后让我们对使用 <code>React</code> 编程如释重负，好的技术就是应该尽量减小学习坡度和上手难度，越用越简单，编写大家都读得懂又直观的代码才是优秀的代码，上面就是在学习完 <code>React Hooks</code> 后的一些总结，最后附上相关案例的</strong> <a href="https://github.com/shenqiuhui/react-hooks-examples" target="_blank">Guthub 地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190507155411/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 获取对象属性名的方法和区别</title>
      <link>https://www.overtaking.top/20190417112536/</link>
      <guid>https://www.overtaking.top/20190417112536/</guid>
      <pubDate>Wed, 17 Apr 2019 03:25:36 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/JavaScript/20190417112536/get-object-key.png&quot; title=&quot;JavaScript 获取对象属性名的方法和区别&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;&lt;strong&gt;在 &lt;code&gt;JavaScript&lt;/code&gt; 中想获取某一个对象的属性名，有多种方法可供选择：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;for in&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/JavaScript/20190417112536/get-object-key.png" title="JavaScript 获取对象属性名的方法和区别"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>在 <code>JavaScript</code> 中想获取某一个对象的属性名，有多种方法可供选择：</strong></p><ul><li><strong><code>for in</code></strong></li><li><strong><code>Object.keys</code></strong></li><li><strong><code>Object.getOwnPropertyNames</code></strong></li><li><strong><code>Object.getOwnPropertySymbols</code></strong></li><li><strong><code>Reflect.ownKeys</code></strong></li></ul></blockquote><p>在获取对象属性名的众多方法中，其实有各自的区别和用途，但经常容易被混淆，本篇文章会将这些方法的区别介绍清楚。</p><a id="more"></a><h2 id="创建对象案例"><a href="#创建对象案例" class="headerlink" title="创建对象案例"></a>创建对象案例</h2><p>下面来创建一个对象的案例让这些方法来获取属性，再通过结果来看区别。</p><pre><code class="lang-js">/* 父类，继承自 Object.prototype */const parent = Object.create(Object.prototype, {  a: {    value: 1,    writable: true,    enumerable: true,    configurable: true  },  b: {    value: 2,    writable: true,    enumerable: false,    configurable: true  },  [Symbol(&#39;symbolParent&#39;)]: {    value: 3,    writable: true,    enumerable: true,    configurable: true  }});</code></pre><pre><code class="lang-js">/* 子类，继承自 parent */const child = Object.create(parent, {  c: {    value: 4,    writable: true,    enumerable: true,    configurable: true  },  d: {    value: 5,    writable: true,    enumerable: false,    configurable: true  },  [Symbol(&#39;symbolChild&#39;)]: {    value: 6,    writable: true,    enumerable: true,    configurable: true  }});</code></pre><p>在上面我们创建了一个对象 <code>parent</code>，上面创建了两个普通属性 <code>a</code>（可枚举）、<code>b</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolParent</code>，创建了一个对象 <code>child</code> 继承自 <code>parent</code>，上面创建了两个普通属性 <code>c</code>（可枚举）、<code>d</code>（不可枚举）和一个键为 <code>Symbol</code> 类型的属性 <code>symbolChild</code>。</p><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><pre><code class="lang-js">for (let k in child) {  console.log(k);}// c// a</code></pre><p>从结果来看，<code>for...in</code> 先遍历并获取到了自身的部分属性名，又获取到了继承的部分属性名。</p><blockquote class="pullquote info"><p><strong>总结：<code>for...in</code> 可以遍历自身和继承的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><pre><code class="lang-js">Object.keys(child);// [&quot;c&quot;]</code></pre><p>从结果来看，<code>Object.keys</code> 返回了一个数组，里面存储获取的属性的键名，不能获取继承的属性名，只能获取自身的部分属性名，这种效果相当于 <code>for...in</code> 与 <code>hasOwnProperty</code> 方法的组合。</p><pre><code class="lang-js">for (let k in child) {  if (child.hasOwnProperty(k)) {    console.log(k);  }}// c</code></pre><blockquote class="pullquote warning"><p><strong>总结：<code>Object.keys</code> 只能遍历自身的、可枚举的、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h2><pre><code class="lang-js">Object.getOwnPropertyNames(child);// [&quot;c&quot;, &quot;d&quot;]</code></pre><p>从结果看，<code>Object.getOwnPropertyNames</code> 方法返回了一个数组，存储获取对象属性的键名。</p><blockquote class="pullquote danger"><p><strong>总结：<code>Object.getOwnPropertyNames</code> 只能遍历自身的（包含不可枚举）、非 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h2><pre><code class="lang-js">Object.getOwnPropertySymbols(child);// [Symbol(symbolChild)]</code></pre><p>从结果看，<code>Object.getOwnPropertySymbols</code> 方法返回了一个数组，存储的都是 <code>Symbol</code> 类型的键，说明是专门用来处理 <code>Symbol</code> 类型的。</p><blockquote class="pullquote default"><p><strong>总结：<code>Object.getOwnPropertySymbols</code> 只能遍历自身 <code>Symbol</code> 类型的属性。</strong></p></blockquote><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys"></a>Reflect.ownKeys</h2><pre><code class="lang-js">Reflect.ownKeys(child);// [&quot;c&quot;, &quot;d&quot;, Symbol(symbolChild)]</code></pre><p><code>Reflect.ownKeys</code> 的返回值为数组，存储遍历到的属性名。</p><blockquote class="pullquote success"><p><strong>总结：<code>Reflect.ownKeys</code> 可以遍历自身的所有属性（包含不可枚举和 <code>Symbol</code> 类型）。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190417112536/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript 基础知识总结</title>
      <link>https://www.overtaking.top/20190416160637/</link>
      <guid>https://www.overtaking.top/20190416160637/</guid>
      <pubDate>Tue, 16 Apr 2019 08:06:37 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/TypeScript/20190416160637/typescript.jpeg&quot; title=&quot;Typescript&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;TypeScript-简介&quot;&gt;&lt;a href=&quot;#TypeScript-简介&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 简介&quot;&gt;&lt;/a&gt;TypeScript 简介&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;TypeScript&lt;/code&gt; 是由微软开发的开源编程语言（后面简称 &lt;code&gt;TS&lt;/code&gt;），是 &lt;code&gt;JavaScript&lt;/code&gt; 的超集（后面简称 &lt;code&gt;JS&lt;/code&gt;），由于 &lt;code&gt;JS&lt;/code&gt; 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 &lt;code&gt;Bug&lt;/code&gt; 和风险，而 &lt;code&gt;TS&lt;/code&gt; 更适合大型企业应用，是因为 &lt;code&gt;TS&lt;/code&gt; 需要编译成 &lt;code&gt;JS&lt;/code&gt; 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/TypeScript/20190416160637/typescript.jpeg" title="Typescript"><p><br></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><blockquote class="pullquote info"><p><strong><code>TypeScript</code> 是由微软开发的开源编程语言（后面简称 <code>TS</code>），是 <code>JavaScript</code> 的超集（后面简称 <code>JS</code>），由于 <code>JS</code> 过于灵活，如果使用不当，在长期维护迭代的大型企业应用中，会存在潜在的 <code>Bug</code> 和风险，而 <code>TS</code> 更适合大型企业应用，是因为 <code>TS</code> 需要编译成 <code>JS</code> 运行，所以在编译阶段可以进行语法错误，类型错误检查，提前知道代码中潜在的问题，不至于等到代码运行时报错。</strong></p></blockquote><a id="more"></a><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/TypeScript/20190416160637/ts-js.png" alt="TypeScript 与 JavaScript 关系图"></div><div class="image-caption">TypeScript 与 JavaScript 关系图</div></figure><p><br></p><p><code>TS</code> 是前端开发工程化新的趋势，目前很多的开源项目内部都是用 <code>TS</code> 编写，也有很多大牛在推广 <code>TS</code>，目前使用 <code>TS</code> 开发的典型项目有 <code>VSCode</code>、<code>Angular6</code>、<code>Vue3</code> 和 <code>React16</code> 等。</p><h2 id="如何使用-TS"><a href="#如何使用-TS" class="headerlink" title="如何使用 TS"></a>如何使用 TS</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 <code>TS</code> 之前应该先进行全局安装，安装 <code>TS</code> 的命令：</p><pre><code class="lang-bash">$ npm install typescript -g</code></pre><p>全局安装后会提供 <code>tsc</code> 命令，<code>tsc -v</code> 可以查看当前安装 <code>TS</code> 版本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>我们可以通过命令单独对文件进行编译，也可以编译整个项目的 <code>TS</code> 文件。</p><p><strong>编译单个文件：</strong></p><pre><code class="lang-bash">$ tsc &lt;filename&gt;</code></pre><blockquote class="pullquote danger"><p><strong>块级作用域变量名检测，两个文件（无论 <code>JS</code> 还是 <code>TS</code>）不允许有相同的变量名。</strong></p></blockquote><p>编译整个项目的 <code>TS</code> 文件需要在项目中设置 <code>tsconfig.json</code> 的配置文件，快速生成配置文件命令如下：</p><pre><code class="lang-bash">tsc --init</code></pre><p>生成 <code>TS</code> 配置文件以后，编译命令 <code>tsc</code> 不需要再指定文件名，会默认读取 <code>tsconfig.json</code> 文件的配置进行编译，关于 <code>tsconfig.json</code> 属性详解请看（<code>TO DO</code>）。</p><p>当 <code>TS</code> 文件发生变化时，可以通过 <code>--watch</code> 参数进行实时监听，并当 <code>TS</code> 文件变化时实时编译，也可以把命令配置在 <code>package.json</code> 中通过 <code>npm</code> 执行。</p><pre><code class="lang-json">/* package.json 文件 */{  &quot;scripts&quot;: {    &quot;build&quot;: &quot;tsc&quot;,    &quot;start&quot;: &quot;tsc --watch&quot;  }}</code></pre><h2 id="TS-的数据类型"><a href="#TS-的数据类型" class="headerlink" title="TS 的数据类型"></a>TS 的数据类型</h2><p>在 <code>TS</code> 中提供了强大的类型系统，编译时帮助我们对代码中定义的数据类型和值进行检查，如果使用支持 <code>TS</code> 比较好的编辑器，如 <code>VSCode</code>，可以在代码编写时根据智能提示及时发现错误。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型定义"><a href="#基本数据类型定义" class="headerlink" title="基本数据类型定义"></a>基本数据类型定义</h4><p><code>TS</code> 中包含了 <code>JS</code>，所以 <code>TS</code> 也有 <code>6</code> 种基本数据类型，<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>。</p><pre><code class="lang-ts">let name: string = &#39;panda&#39;;let age: number = 18;let merried: boolean = false;let un: undefined = undefined;let nu: null = null;let sym: symbol = Symbol();</code></pre><p>上面声明变量的值与所定义的数据类型必须严格符合，否则编译时报错（编辑器默认就会报错，后面统一说成报错）。</p><blockquote class="pullquote warning"><p><strong><code>undefined</code> 和 <code>null</code> 是其他基本类型的子类型：</strong></p><ul><li><strong>类型定义为 <code>undefined</code> 的变量只能赋值 <code>undefined</code>；</strong></li><li><strong>类型定义为 <code>null</code> 的变量只能赋值 <code>null</code>；</strong></li><li><strong>类型定义为除 <code>undefined</code> 和 <code>null</code> 以外的其他类型，可以赋值为 <code>undefined</code> 和 <code>null</code>。</strong></li></ul></blockquote><pre><code class="lang-ts">/* 默认会报错 */let name: string = undefined;let age: number = null;</code></pre><p>其他类型的赋值也必须严格与其定义相对应（默认行为，也被叫做严格类型检查模式），可以通过配置 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性值为 <code>false</code> 跳过严格检查。</p><pre><code class="lang-json">/* tsconfig.json 文件 */{  &quot;compilerOptions&quot;: {    &quot;strictNullChecks&quot;: false  }}</code></pre><h4 id="数据类型-any"><a href="#数据类型-any" class="headerlink" title="数据类型 any"></a>数据类型 any</h4><p>希望定义的数据类型可以赋值任何类型的值，可以将数据类型定义为 <code>any</code>，这样相当于没有使用类型校验，等同于直接使用 <code>JS</code>（戏称 <code>AnyScript</code>）。</p><pre><code class="lang-ts">let value: any = 18;value = &#39;hello world&#39;;value = true;value = null;value = undefined;value = Symbol();</code></pre><blockquote class="pullquote default"><p><strong>上面代码中的赋值操作不会报任何错误，因为变量的值类型定义为了 <code>any</code>。</strong></p></blockquote><h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>在 <code>TS</code> 中，如果定义的变量没有定义类型，则会对变量的类型进行推测，同样可以在代码编译阶段按照推测的类型校验。</p><pre><code class="lang-js">let num = 10;num = &#39;hello&#39;; // 报错，不能将类型“&quot;hello&quot;”分配给类型“number”let str = &#39;world&#39;;str = 1; // 报错，不能将类型“1”分配给类型“string”let value; // let value: any</code></pre><blockquote class="pullquote primary"><p><strong>类型推论规则：</strong></p><ul><li><strong>从报错的结果可以看出，<code>TS</code> 中声明变量如果没有指定值的类型，则会默认将声明变量时赋值数据的类型定义为该变量的值类型；</strong></li><li><strong>当声明变量没有直接赋值时，<code>TS</code> 会将变量的值类型定义为 <code>any</code>。</strong></li></ul></blockquote><h4 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h4><p><code>TS</code> 也包含基本包装类，基本数据类型是没有方法的（只有对象可以调用对应原型上的方法），在基本数据类型调用方法时是先进行包装过程，把基本类型包装成对象类型。</p><pre><code class="lang-ts">/* 基本数据类型调用方法的包装 */let num = 10;num.toFixed(2);// new Number(num).toFixed(2);</code></pre><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>有些时候定义的变量在不同场景会赋不同类型的值，我们想要指定这个变量只接受某几个固定类型的值，可以使用联合类型的方式。</p><pre><code class="lang-ts">/* 联合类型 */let value: string | number = &#39;hello&#39;;value = 10;value = true; // 报错</code></pre><p>被定义联合类型的变量可以指定符合联合类型中任意一种类型的值，定义时不同的数据类型用 <code>|</code> 隔开，当被赋值不符合联合类型时会报错。</p><blockquote class="pullquote warning"><p><strong>上面联合类型的写法如果多处相同会让代码冗余，在 <code>TS</code> 中提供了 <code>type</code> 关键字来声明类型，用法如下。</strong></p></blockquote><pre><code class="lang-ts">// 冗余的写法let x: string | number | boolean = &#39;hello&#39;;let y: string | number | boolean = 10;let z: string | number | boolean = true;// 更改后...type MyType = string | number | boolean;let x: MyType = &#39;hello&#39;;let y: MyType = 10;let z: MyType = true;</code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>被定义联合类型的变量可以通过类型断言指定为更具体的类型，不可以指定联合类型中不包含的类型。</p><pre><code class="lang-ts">let value: string | number | boolean;value = &#39;hello&#39;;value = 10;value = true;console.log((value as string).length); // 报错</code></pre><p>断言的语法是将变量使用 <code>as</code> 关键字指定要断言的类型，上面代码中因为变量 <code>value</code> 值最后已经是布尔，而强行将 <code>value</code> 指定为 <code>string</code> 类型去获取 <code>length</code> 属性报错，因为布尔值无法调用 <code>length</code> 属性。</p><h4 id="值的联合"><a href="#值的联合" class="headerlink" title="值的联合"></a>值的联合</h4><p>值的联合（又叫字面量联合）与联合类型不同的是，联合类型只是指定了变量的值类型必须为哪几种，而值的联合则限定了变量的值，变量赋值必须是值的联合中的其中某一个，否则报错。</p><pre><code class="lang-ts">let point: 1 | 6 | 10;point = 10;point = &#39;hello&#39;; // 报错let level: &#39;A&#39; | &#39;B&#39; | &#39;C&#39;;level = &#39;B&#39;;level = &#39;b&#39;; // 报错</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 <code>TS</code> 中，数组是引用类型，定义一个数组类型时需要定义数组内部元素的类型。</p><pre><code class="lang-ts">/* 普通数组类型定义 */let names: string[] = [&#39;Jim&#39;, &#39;Peter&#39;];let ages: number[] = [18, 20];</code></pre><pre><code class="lang-ts">/* 泛型定义（泛型会在后面详细说明） */let names: Array&lt;string&gt; = [&#39;Jim&#39;, &#39;Peter&#39;];let ages: Array&lt;number&gt; = [18, 20];</code></pre><p>上面两种方式定义的数组内元素类型必须统一，如果数组内要支持多种数据类型则可以使用联合类型或元组类型。</p><pre><code class="lang-ts">let data: Array&lt;string | number&gt; = [&#39;James&#39;, 25];</code></pre><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>如果让数组内部元素类型不同该怎么办，在 <code>TS</code> 中有一种特殊的数组类型定义叫做 “元组类型”（<code>tuple</code>）。</p><pre><code class="lang-ts">/* 元组类型定义 */let people: [string, number] = [&#39;Jim&#39;, 18];</code></pre><p><strong>元组的越界问题：</strong></p><pre><code class="lang-ts">let tuple: [string, number] = [&#39;hello&#39;, 100];tuple.push(false);console.log(tuple); // [&#39;hello&#39;, 100, false]tuple[2] // 报错</code></pre><p>元组类型可以越界添加元素，如使用数组的 <code>push</code> 方法，但是访问越界元素会报错，强烈不建议让元组越界。</p><p><strong>元组类型和数组类型的特点如下表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">数组</th></tr></thead><tbody><tr><td style="text-align:left">元素可以是不同类型</td><td style="text-align:left">元素必须为相同类型</td></tr><tr><td style="text-align:left">有预定的长度</td><td style="text-align:left">没有预定的长度</td></tr><tr><td style="text-align:left">用于表示一个结构</td><td style="text-align:left">用于表示一个列表</td></tr></tbody></table></div><p><br></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><code>TS</code> 可以通过 <code>object</code> 来声明对象类型。</p><pre><code class="lang-ts">let obj: object = {x: 1, y: 2};obj.x = 3; // 报错</code></pre><p>用 <code>object</code> 类型并不能定义对象上具体属性的类型，所以对 <code>x</code> 属性重新赋值会报错，也可以在创建对象时直接定义属性的类型如下：</p><pre><code class="lang-ts">let obj: {x: number, y: number} = {x: 1, y: 2};obj.x = 3</code></pre><blockquote class="pullquote info"><p><strong>对象类型内部成员的类型很少使用上面的方式，通常使用接口（后面介绍）进行定义。</strong></p></blockquote><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型是 <code>JS</code> 中所不包含的数据类型，通过 <code>enum</code> 关键字定义，在业务需求中经常会出现某个业务类型对应固定的值，前后端交互的参数都是通过这个值进行约束和传递的。</p><h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><pre><code class="lang-ts">enum Gender {  BOY,  GIRL}</code></pre><pre><code class="lang-js">/* 编译后 */var Gender;(function (Gender) {  Gender[Gender[&quot;BOY&quot;] = 0] = &quot;BOY&quot;;  Gender[Gender[&quot;GIRL&quot;] = 1] = &quot;GIRL&quot;;})(Gender || (Gender = {}));</code></pre><p>从编译结果来看，枚举类型编译成 <code>JS</code> 后帮助我们创建了一个类似于映射表的同名对象（实现原理，反向映射），所以可以在 <code>TS</code> 中通过对象属性的方式获取枚举的值。</p><pre><code class="lang-ts">/* 获取枚举值 */console.log(Gender.BOY); // 0console.log(Gender[1]); // &quot;GIRL&quot;</code></pre><blockquote class="pullquote success"><p><strong>如果给第一个枚举值设置数值类型的初始值，则后面的枚举值会依次递增。</strong></p></blockquote><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="lang-ts">enum Week {  MONDAY = &#39;1&#39;,  TUESDAY = &#39;2&#39;}</code></pre><pre><code class="lang-js">/* 编译后 */var Week;(function (Week) {  Week[&quot;MONDAY&quot;] = &quot;1&quot;;  Week[&quot;TUESDAY&quot;] = &quot;2&quot;;})(Week || (Week = {}));</code></pre><p>字符串枚举是在枚举过程中给枚举项明确赋值，值类型为字符串类型。</p><h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>异构枚举是将数字枚举和字符串枚举混合使用（容易引起混淆，不建议使用）。</p><pre><code class="lang-ts">enum Answer {  N,  Y = &#39;Yes&#39;}</code></pre><h4 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h4><p>常量枚举的语法是在创建枚举的 <code>enum</code> 关键字前使用 <code>const</code> 声明。</p><pre><code class="lang-ts">const enum Colors {  RED,  YELLOW,  BLUE}let colors: Array&lt;number&gt; = [Colors.RED, Colors.YELLOW, Colors.BLUE];</code></pre><pre><code class="lang-js">/* 编译后 */var colors = [0 /* RED */, 1 /* YELLOW */, 2 /* BLUE */];</code></pre><blockquote class="pullquote success"><p><strong>常数枚举与其他类型枚举的不同是，在编译阶段不会为枚举的类型创建对象，使用枚举类型值的位置直接编译成对应的枚举值。</strong></p></blockquote><h4 id="枚举成员"><a href="#枚举成员" class="headerlink" title="枚举成员"></a>枚举成员</h4><blockquote class="pullquote warning"><p><strong>枚举成员主要分为两类：</strong></p><ul><li><strong><code>const member</code>：以编译阶段计算结果，以常量的形式出现在运行时环境；</strong><ul><li><strong>没有初始值的枚举值；</strong></li><li><strong>对已有枚举成员的引用；</strong></li><li><strong>常量的表达式。</strong></li></ul></li><li><strong><code>computed member</code>：编译阶段不会计算，会被保留在程序的执行阶段。</strong><ul><li><strong>动态计算的表达式；</strong></li><li><strong>后面的枚举值必须赋值初始值。</strong></li></ul></li></ul></blockquote><pre><code class="lang-ts">enum Char {  // const member  a, // 无初始值  b = Char.a, // 对已有成员的引用  c = 1 + 2, // 常量表达式  // computed member  d = Math.random(),  e = &#39;123&#39;.length,}</code></pre><pre><code class="lang-ts">Char.a = 1 // 报错</code></pre><blockquote class="pullquote warning"><p><strong>枚举成员的值为只读类型，在定义后不能重新赋值。</strong></p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数类型定义"><a href="#参数类型定义" class="headerlink" title="参数类型定义"></a>参数类型定义</h4><pre><code class="lang-ts">function sum(a: number, b: number) {  return a + b;}sum(1, 2); // 3</code></pre><p>在函数中经常会定义可选参数，即非必传，但是 <code>TS</code> 中函数如果按照上面方式定义在调用时不传会报错，可选参数的类型定义如下。</p><pre><code class="lang-ts">/* 可选参数 */function people(name: string, age?: number) {  console.log(name);}people(&#39;jim&#39;);</code></pre><p>使用 <code>?:</code> 替代 <code>:</code>，即代表该参数为可选参数，在 <code>TS</code> 中也支持使用默认参数和剩余参数，使用方式如下。</p><pre><code class="lang-ts">/* 默认参数 */function fn(sum: number = 0) {  console.log(sum);}fn(); // 0</code></pre><pre><code class="lang-ts">/* 剩余参数 */function sum(prefix: string, ...args: number[]) {  return prefix + args.reduce((sum, val) =&gt; sum + val, 0);}sum(&#39;$&#39;, 1, 2, 3); // 6</code></pre><p>在使用默认参数和剩余参数时，设置的参数初始值和传入的剩余参数与定义类型不符合，则会报错。</p><h4 id="返回值类型定义"><a href="#返回值类型定义" class="headerlink" title="返回值类型定义"></a>返回值类型定义</h4><pre><code class="lang-ts">function sum(a: number, b: number): number {  return a + b;}</code></pre><blockquote class="pullquote danger"><p><strong>特殊的返回值类型：</strong></p><ul><li><strong><code>never</code>：是其他类型的子类型，代表不会出现的值，作为没有返回值的返回类型，函数无法执行完成；</strong></li><li><strong><code>void</code>：表示没有任何类型，指函数没有返回值，函数可以正常执行完，如果一个函数没有返回值，则 <code>TS</code> 认为返回值为 <code>void</code> 类型。</strong></li></ul></blockquote><pre><code class="lang-ts">/* never 为返回值类型的函数 */function fn1(): nerver {  throw new Error(&#39;报错了&#39;);  console.log(1);}function fn2(): nerver {  while (true) {}  console.log(1);}</code></pre><p>上面两个函数返回值设置为 <code>never</code>，因为抛错和死循环导致都没有执行完毕，此时函数编译不会报错。</p><pre><code class="lang-ts">/* void 为返回值类型的函数 */function fn1(): void {  console.log(1);}function fn2(): void {  return null;}</code></pre><p>上面的 <code>fn2</code> 函数只在非严格检查模式下不会报错，非严格检查模式下返回值类型被定义为 <code>void</code> 的函数可以返回 <code>null</code> 和 <code>undefined</code>。</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>之前的函数参数和返回值类型定义是函数声明的方式，声明函数同样有另外一种方式，函数表达式，即给变量赋值为函数，那如何为接收函数的变量定义类型呢？</p><pre><code class="lang-ts">let fullName: (x: string, y: string) =&gt; string;fullName = function (firstName:string, lastName:string): string {  return firstName + lastName;}</code></pre><p>括号中 <code>x</code> 和 <code>y</code> 代表定义参数的类型，箭头后代表定义返回值的类型，也可以使用 <code>type</code> 关键字进行声明。</p><pre><code class="lang-ts">type Fn = (x: string, y: string) =&gt; string;let fullName: Fn = function (firstName: string, lastName: string): string {  return firstName + lastName;}</code></pre><blockquote class="pullquote info"><p><strong>赋值函数的参数类型必须与变量声明的函数参数类型严格一致，赋值函数的返回值类型必须与变量声明的函数返回值类型严格一致。</strong></p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是强类型语言中的特性，在 <code>Java</code> 中代表多个同名函数参数不相同，而在 <code>TS</code> 中有所不同，代表为同一个函数提供多个参数类型及返回值定义。</p><pre><code class="lang-ts">// 联合类型type MyType = string | number | boolean// 重载限定函数 doublefunction double(val: string): string;function double(val: number): number;function double(val: boolean): boolean;// 函数function double(val: MyType) {  if (typeof val === &#39;string&#39;) return val + val;  if (typeof val === &#39;number&#39;) return 2 * val;  if (typeof val === &#39;boolean&#39;) return !val;}double(&#39;hello&#39;); // hellohellodouble(5); // 10double(true); // false</code></pre><p>重载限定某个函数的方式只有函数声明、函数名、参数及返回值的类型，而没有函数体。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p><code>TS</code> 类的定义与 <code>JS</code> 相同，使用 <code>class</code> 关键字声明，但可以直接对属性、方法定义参数类型和返回值类型。</p><pre><code class="lang-ts">class Person {  name: string  getName(): void {    console.log(this.name)  }}let p = new Person();p.name = &#39;neil&#39;;p.getName(); // neil</code></pre><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>在 <code>TS</code> 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为，并可以定义存取器的参数及返回值类型。</p><pre><code class="lang-ts">class Person {  myName: string,  constructor(myName: string) {    this.myName = myName;  }  get name(): string {    return this.myName;  }  set name(newVal: string) {    this.myName = newVal;  }}let p = new Person(&#39;neil&#39;);console.log(p.name); // neilp.name = &#39;jim&#39;;console.log(p.name); // jim</code></pre><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>上面都在类中定义属性，也可以使用参数属性进行简化，代码如下。</p><pre><code class="lang-ts">/* 简化前 */class Person {  name: string;  constructor(name: string) {    this.name = name;  }}</code></pre><pre><code class="lang-ts">/* 简化后 */class Person {  constructor(public myName: string) {}}let p = new Person(&#39;neil&#39;);console.log(p.myName); // neil</code></pre><p><code>public</code> 修饰符写在 <code>constructor</code> 的参数前，代表创建一个与参数同名的公有属性。</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>在 <code>TS</code> 中可以在类中定义只读属性，只需要通过 <code>readonly</code> 修饰符修饰即可，只在编译阶段进行检查。</p><pre><code class="lang-ts">class Person {  constructor(public readonly myName: string) {    this.myName = myName;  }}let p = new Person(&#39;neil&#39;);console.log(p.myName); // neilp.myName = &#39;jim&#39;; // 报错</code></pre><blockquote class="pullquote warning"><p><strong>不同类别的（非互斥）的修饰符可以同时修饰一个变量，使用空格隔开。</strong></p></blockquote><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>类与类之间通过 <code>extends</code> 关键字实现继承，子类继承父类后拥有父类的属性和方法，可以增强代码的复用性。</p><pre><code class="lang-ts">// 父类class Parent {  name: string;  age: number;  constructor(name: string, age: number) {    this.name = name;    this.age = age;  }  getName(): string {    return this.name;  }  setName(name: string): void {    this.name = name;  }}// 子类继承父类class Child extends Parent {  hobby: string;  constructor(name: string, age: number, hobby: number) {    super(name, age);    this.hobby = hobby;  }  getHobby(): number {    return this.hobby;  }}let c = new Child(&#39;neil&#39;, 20, &#39;swim&#39;);console.log(c.getHobby()); // swimconsole.log(c.getName()); // neilconsole.log(c.getAge()); // 20</code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><blockquote class="pullquote default"><p><strong>在 <code>TS</code> 的类中有三种访问控制修饰符：</strong></p><ul><li><strong><code>public</code>：公有的属性，所有地方都能访问；</strong></li><li><strong><code>protected</code>：受保护的属性，不能被实例化只能被继承，只能在自己和自己的子类中被访问；</strong></li><li><strong><code>private</code>：私有属性，既不能被实例化也不能被继承，只有自己内部可以访问。</strong></li></ul></blockquote><pre><code class="lang-ts">// 父类class Parent {  public name: string;  protected age: number;  private money: number;  constructor(name: string, age: number, money: number) {    this.name = name;    this.age = age;    this.money = money;  }  getName() {    console.log(&#39;父类：&#39; + this.name);  }  getAge() {    console.log(&#39;父类：&#39; + this.age);  }  getMoney() {    console.log(&#39;父类：&#39; + this.money);  }}// 子类class Child extends Parent {  constructor(name, age, money) {    super(name, age, money);  }  getName() {    console.log(&#39;子类：&#39; + this.name);  }  getAge() {    console.log(&#39;子类：&#39; + this.age);  }  getMoney() {    console.log(&#39;子类：&#39; + this.money); // 报错  }}</code></pre><p>在上面代码中 <code>name</code> 属性可以通过父类的实例访问、子类的实例访问，父类的 <code>getName</code> 方法访问，子类的 <code>getName</code> 方法访问，<code>age</code> 属性可以只能通过父类和子类的 <code>getAge</code> 方法访问，<code>money</code> 属性只能通过父类 <code>getMoney</code> 方法访问，其他不被允许的访问方式都会报错。</p><h3 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h3><p>在 <code>TS</code> 中给类定义私有属性和方法的修饰符为 <code>static</code>，与 <code>JS</code> 的类相同。</p><pre><code class="lang-ts">class Father {  static myName: string = &#39;hello&#39;;  static getMyName(): string {    return Father.myName;  }}console.log(Father.myName); // helloconsole.log(Father.getMyName()); // hello</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是一种抽象的概念，使用 <code>abstract</code> 关键字定义，无法被实例化（无法使用 <code>new</code>），只能被继承。</p><p>抽象类的内部包含抽象方法和抽象属性，同样使用 <code>abstract</code> 关键字定义，抽象方法不能在抽象类中实现，具体实现细节只能在抽象类的子类中实现，且必须实现。</p><pre><code class="lang-ts">abstract class Animal {  abstract name: string;  abstract speak();}class Cat extends Animal {  name: string;  speak() {    console.log(&#39;喵喵喵&#39;);  }}class Dog extends Animal {  name: string;  speak() {    console.log(&#39;汪汪汪&#39;);  }}</code></pre><blockquote class="pullquote primary"><p><strong>继承抽象类的子类中必须包含所有抽象类中所定义的内容，继承过程，子类覆盖抽象类所定义抽象方法的行为叫做 “重写”，多个子类创建不同的抽象方法的现象被叫做 “多态”。</strong></p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote class="pullquote info"><p><strong>接口是 <code>TS</code> 中的核心之一，主要有两个作用：</strong></p><ul><li><strong>用于描述或约束一种对象结构，描述属性的名称和值的类型；</strong></li><li><strong>用来表示行为的抽象，让类去实现接口。</strong></li></ul></blockquote><h3 id="接口的定义和使用"><a href="#接口的定义和使用" class="headerlink" title="接口的定义和使用"></a>接口的定义和使用</h3><p><code>TS</code> 中使用 <code>interface</code> 关键字来定义接口，接口成员可以是属性或方法名，多个成员可以使用分号、逗号或换行隔开，主要定义属性的名称和值的类型。</p><pre><code class="lang-ts">/* 定义接口，使用接口创建对象 */interface UserInterface {  name: string;  age: number;}let user: UserInterface = {  name: &#39;hello&#39;,  age: 20};</code></pre><p>上面 <code>UserInterface</code> 接口创建的对象 <code>user</code>，属性和值的类型必须与定义的接口严格对应。</p><pre><code class="lang-ts">/* 让类去实现定义的接口 */interface Flyable {  fly(): void;}class Bird implements Flyable {  fly() {    console.log(&#39;bird fly&#39;);  }}</code></pre><p>让类实现一个接口使用 <code>implements</code> 关键字，接口在定义方法时与抽象类非常类似，只需要定义方法和类型，不需要具体实现，在实现接口的类中对方法进行具体实现。</p><pre><code class="lang-ts">/* 一个类实现多个接口 */// 接口interface Speakable {  name: string;  speak(): void;}interface Eatable {  food: string;  eat(): void;}// 类class Person implements Speakable, Eatable {  name: &#39;hello&#39;;  food: &#39;cake&#39;;  speak() {    console.log(&#39;say hello&#39;);  }  eat() {    console.log(&#39;eat cake&#39;);  }}</code></pre><blockquote class="pullquote default"><p><strong>继承与实现接口的区别：</strong></p><ul><li><strong>一个类可以实现多个接口，一个接口可以被多个类实现；</strong></li><li><strong>而一个父类（包含抽象类）可以被多个类所继承，一个子类只能继承一个父类（单继承）。</strong></li></ul></blockquote><h3 id="接口的只读属性"><a href="#接口的只读属性" class="headerlink" title="接口的只读属性"></a>接口的只读属性</h3><p>接口中可以定义只读属性，这样通过接口创建对象的值在修改时会报错，可以在定义接口属性是加上 <code>readonly</code> 修饰符实现。</p><pre><code class="lang-ts">/* 接口的只读属性 */interface Person {  id: number;  readonly name: string;}let p: Person = {  id: 1;  name: &#39;hello&#39;;};console.log(p.id); // 1p.name = 2; // 报错</code></pre><h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>在上面接口定义时，创建的对象和实现接口类的属性方法都必须与接口定义的属性名、类型一致，其实在接口定义时也可以定义一些非必须的可选属性，在使用接口创建对象或使用类实现接口时，这样的属性不定义不会报错。</p><pre><code class="lang-ts">/* 接口的可选属性 */interface Person {  id: number;  name: string;  age?: number;}let p1: Person = {  id: 1,  name: &#39;hello&#39;,  age: 20};let p2: Person = {  id: 2,  name: &#39;world&#39;};</code></pre><p>定义接口的可选属性与函数定义可选参数类似，都是使用 <code>?:</code> 替代原本的 <code>:</code> 即代表可选。</p><h3 id="接口的未知属性"><a href="#接口的未知属性" class="headerlink" title="接口的未知属性"></a>接口的未知属性</h3><p>当接口中存在可选属性时，也只是满足某些属性可以在使用接口时（对象、类），可选属性可以不创建，但是如果对象和类上扩展了未知的其他任意属性，则编译会报错，此时定义接口未知属性，可以解决编译时报错的问题。</p><pre><code class="lang-ts">interface Person {  id: number;  name: string;  [proName: string]: any;}let p: Person = {  id: 1,  name: &#39;hello&#39;,  age: 20,  city: &#39;Beijing&#39;};</code></pre><blockquote class="pullquote success"><p><strong><code>proName</code> 名字是任意的，可以随意取，<code>string</code> 代表属性的类型，<code>any</code> 代表属性值的类型，上面的写法不固定，可以根据需求定义，只需满足 <code>[name: type]: type</code> 的结构即可。</strong></p></blockquote><p>根据上面的未知属性格式可以衍生出 “可索引接口” 专门用来限制长度未知的数组、属性名和属性个数未知的对象。</p><p><strong>可索引接口限制数组和对象：</strong></p><pre><code class="lang-ts">/* 限制数组 */interface UserInterface {  [index: number]: string;}let userArr: UserInterface = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];userArr = [&#39;a&#39;, &#39;b&#39;, 1]; // 报错</code></pre><p>上面的数组 <code>userArr</code> 内的的索引为数字类型，满足可索引接口的要求，但是使用 <code>UserInterface</code> 约束后，所有项必须是字符串，如果改成其他类型则会报错。</p><pre><code class="lang-ts">/* 限制对象 */interface UserInterface {  [index: string]: string;}let userObj: UserInterface = {  jim: &#39;1&#39;,  bob: &#39;2&#39;};</code></pre><p>上面的对象 <code>userObj</code> 使用 <code>UserInterface</code> 约束后，键和值必须都为字符串，否则报错。</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口的继承同类的继承相同，使用 <code>extends</code> 关键字实现，下面是一段接口继承的代码。</p><pre><code class="lang-ts">// 父接口interface Speakable {  speak(): void;}// 子接口interface SpeakChinese extends Speakable {  speakChinese(): void;}// 类实现接口class ChinesePerson implements SpeakChinese {  speak() {    console.log(&#39;speak&#39;);  }  speakChinese() {    console.log(&#39;你好&#39;);  }}</code></pre><blockquote class="pullquote warning"><p><strong>当类实现的接口继承了其他的接口，那这个类的内部需要同时实现子接口和父接口的属性和方法。</strong></p></blockquote><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>函数型接口专门对函数或方法传入的参数和返回值进行约束。</p><pre><code class="lang-ts">interface Discount {  (price: number): number;}function discount(price: number): number {  return price * 0.8;}const dFun: Discount = discount;</code></pre><p>上面代码中 <code>Discount</code> 接口内部括号内代表参数类型定义，后面代表返回值类型，函数 <code>discount</code> 定义的参数和返回值类型必须与 <code>Discount</code> 接口内部定义的类型保持一致。</p><h3 id="构造函数型接口"><a href="#构造函数型接口" class="headerlink" title="构造函数型接口"></a>构造函数型接口</h3><p>在 <code>TS</code> 中存在对构造函数或类的实例化的类型约束，即在执行 <code>new</code> 操作的时候进行约束检查。</p><pre><code class="lang-ts">// 被约束实例化动作的类class Animal {  constructor(public name: string) {}}// 约束实例化的接口interface WithNameClazz {  new (name: string): Animal;}// 工厂函数function createAnimal(Clazz: WithNameClazz, name: string) {  return new Clazz(name);}let animal = createAnimal(Animal, &#39;hellop&#39;);</code></pre><p>上面代码的 <code>interface</code> 中，<code>new</code> 代表约束的动作为实例化操作，<code>name</code> 为参数，<code>string</code> 为参数的类型，而 <code>Animal</code> 代表返回值需要是一个 <code>Animal</code> 类的实例。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote class="pullquote primary"><p><strong>“泛型” 是指在定义函数、接口和类的时候，不预先指定具体的类型，而在使用的时候再进行指定的一种特性。</strong></p></blockquote><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>在介绍泛型函数之前先创建一个普通的函数，参数为长度和值，返回一个长度为传入长度、内部元素都为传入值的数组。</p><pre><code class="lang-ts">/* 为使用泛型定义的函数 */function createArray(len: number, val: any): any[] {  const result: any[] = [];  for (let i = 0; i &lt; len; i++) {    result[i] = val;  }  return result;}console.log(createArray(3, &#39;x&#39;)); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><p>在上面函数中我们类型都是提前进行定义，包括参数、返回值和函数内部变量，这样如果函数内给数组每一项赋值操作没有使用 <code>val</code> 参数传入的值，而是使用其他值，这样无法进行限定，下面使用泛型重新编写上面的函数。</p><pre><code class="lang-ts">function createArray&lt;T&gt;(len: number, val: T): T[] {  const result: T[] = [];  for (let i = 0; i &lt; len; i++) {    result[i] = val;  }  return result;}console.log(createArray&lt;string&gt;(3, 1)); // 报错</code></pre><p>上面的 <code>T</code> 是泛型的占位符，代表 <code>Type</code> 的意思，也可以使用其他字母代替（类比函数的形参），真正定义类型的时候是在函数调用时传入的。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code class="lang-ts">class MyArray&lt;T&gt; {  list: T[] = [];  add(val: T) {    this.list.push(val);  }  getFirst(): T {    return this.list[0];  }}let myArray = new MyArray&lt;number&gt;();myArray.add(1);myArray.add(2);console.log(myArray.getFirst());</code></pre><p>泛型类与泛型函数相似，都是通过占位符 <code>T</code> 占位，在真正实例化的时候传入类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>上面接口一节中，接口内部属性及函数型接口等，成员类型也可以使用泛型进行约束，在某个具体的对象使用接口或类实现接口时传入具体类型，下面是一个函数型接口使用泛型的例子。</p><pre><code class="lang-ts">interface SUM&lt;T&gt; {  (a: T, b: T): T}const sum: SUM&lt;number&gt; = function (a: number, b: number): number {  return a + b;}</code></pre><blockquote class="pullquote danger"><p><strong>泛型占位符（上面为 <code>T</code>）只在约束的函数、类和接口内部可以使用，可类比函数的形参。</strong></p></blockquote><h3 id="默认泛型类型"><a href="#默认泛型类型" class="headerlink" title="默认泛型类型"></a>默认泛型类型</h3><p>默认泛型类型指的是定义泛型的默认值，被约束的函数、类或者接口在使用时不传入具体类型，则会使用默认类型，编译时会检查是否符合这个默认类型。</p><pre><code class="lang-ts">class MyArray&lt;T = number&gt; {  list: T[] = [];  add(val: T) {    this.list.push(val);  }}let myArray = new MyArray();myArray.add(1);myArray.add(&#39;a&#39;); // 报错</code></pre><h3 id="定义多个泛型"><a href="#定义多个泛型" class="headerlink" title="定义多个泛型"></a>定义多个泛型</h3><p>上面的泛型中都只使用了一个占位符 <code>T</code>，其实泛型是允许有多个的。</p><pre><code class="lang-ts">function swap&lt;A, B&gt;(tuple: [A, B]): [B, A] {  return [tuple[1], tuple[0]];}console.log(swap&lt;string, number&gt;([&#39;a&#39;, 1])); // [1, &#39;a&#39;]</code></pre><p>上面方法中定义了两个泛型，函数参数为一个元组类型的数组，函数返回值为两项交换后的数组。</p><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><p>在函数或类中使用泛型，由于预先不知道泛型的具体类型，所以不能随便使用泛型约束变量的属性和方法。</p><pre><code class="lang-ts">function logger&lt;T&gt;(val: T): void {  console.log(val.length); // 报错}</code></pre><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><p>如果一定要在函数或类中使用泛型约束变量的属性和方法时，可以预先通过接口定义使用的属性和方法，再通过泛型去继承这个接口即可。</p><pre><code class="lang-ts">// 接口interface LengthWise {  length: number;}// 函数function logger&lt;T extends LengthWise&gt;(val: T): void {  console.log(val.length);}logger&lt;number&gt;(&#39;hello&#39;); // 报错logger&lt;string&gt;(&#39;hello&#39;); // 5</code></pre><h3 id="泛型的流程控制"><a href="#泛型的流程控制" class="headerlink" title="泛型的流程控制"></a>泛型的流程控制</h3><p>在定义泛型的时候能够加入逻辑分支，可以使泛型更加灵活。</p><pre><code class="lang-ts">interface Fish {  nameFish: string;}interface Water {  nameWater: string;}interface Bird {  nameBird: string;}interface Sky {  nameSky: string;}type Condition&lt;T&gt; = T extends Fish ? Water : Sky;let con: Condition&lt;Fish&gt; = {  nameWater: &#39;hello&#39;}</code></pre><p>上面定义了四个接口 <code>Fish</code>、<code>Bird</code>、<code>Water</code> 和 <code>Sky</code>，定义一个 <code>Condition</code> 类型和泛型，如果泛型为 <code>Fish</code> 则继承 <code>Water</code>，否则继承 <code>Sky</code>，在变量 <code>con</code> 使用类型 <code>Condition</code> 时，传入 <code>Fish</code> 接口。</p><h3 id="泛型的别名"><a href="#泛型的别名" class="headerlink" title="泛型的别名"></a>泛型的别名</h3><p>泛型可以使用 <code>type</code> 关键字定义别名，还记得在基本数据类型一节数组的定义中有泛型的定义方式。</p><pre><code class="lang-ts">let arr: Array&lt;string&gt; = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</code></pre><p>其实上面的 <code>Array</code> 就是定义泛型的别名，<code>&lt;string&gt;</code> 则是在调用这个泛型时传入的具体类型，看了下面例子就明白了。</p><pre><code class="lang-ts">// 定义泛型别名type Cart&lt;T&gt; = { list: T[] } | T[];// 使用泛型别名let cart1: Cart&lt;string&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];let cart2: Cart&lt;string&gt; = {  list: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]};</code></pre><p>在 <code>JS</code> 中有很多类数组对象，如 <code>arguments</code>、获取的 <code>DOM</code> 元素集合等等，每一种类数组对象 <code>TS</code> 都定义了对应的泛型别名，下面看两个案例。</p><pre><code class="lang-ts">/* arguments 对象的泛型 */function sum(...args: number[]) {  let params: IArguments = arguments;  let result = 0;  for (let i = 0; i &lt; params.length; i++) {    result += params[i];  }  return result;}</code></pre><pre><code class="lang-ts">/* DOM 节点类数组对象的泛型 */let root = document.getElementById(&#39;root&#39;);let children: HTMLCollection = root.children;let childNodes: NodeListOf&lt;ChildNode&gt; = root.childNodes;</code></pre><p>上面用来定义 <code>arguments</code> 类数组对象的泛型别名为 <code>IArguments</code>，获取 <code>DOM</code> 节点的元素节点集合的泛型别名为 <code>HTMLCollection</code>，而全部子节点的泛型别名为 <code>NodeListOf&lt;ChildNode&gt;</code>，如果使用 <code>VSCode</code> 编辑器，可以将鼠标放在变量前面会自动提示对应的泛型别名。</p><blockquote class="pullquote info"><p><strong>接口和泛型别名的区别：</strong></p><ul><li><strong>接口会创建一个新的名称，而别名不会（只是用 <code>type</code> 关键字创建了一个变量）；</strong></li><li><strong>别名不能被继承和实现；</strong></li><li><strong>定义一个类型的时候使用接口，要使用联合类型或者元组类型时，泛型别名会更合适。</strong></li></ul></blockquote><h2 id="结构类型系统"><a href="#结构类型系统" class="headerlink" title="结构类型系统"></a>结构类型系统</h2><p>如果传入的变量和声明的类型不匹配，<code>TS</code> 会进行兼容性检查，不是基于定义的类型名称来决定的，而是基于类型的组成结构。</p><h3 id="基本数据类型的兼容性"><a href="#基本数据类型的兼容性" class="headerlink" title="基本数据类型的兼容性"></a>基本数据类型的兼容性</h3><p>基本数据类型也有兼容性判断，如果赋值过程中右侧值的类型符合左侧值的类型，则不会报错，如果左侧类型定义含有 <code>toString</code> 方法的约束，则右侧值凡是可以通过 <code>toString</code> 转换成字符串的都不会报错，赋值时如果右侧值传入的属性多余左侧定义的值时也会报错。</p><pre><code class="lang-ts">let num1: string | number;let str1: string;num1 = str1;let num2: {  toString(): string;};let str2: number;num2 = str2;type People = {  name: string;  age: number;}let p: People = {  name: &#39;hello&#39;,  age: 20,  gender: &#39;male&#39; // 报错};</code></pre><h3 id="枚举的兼容性"><a href="#枚举的兼容性" class="headerlink" title="枚举的兼容性"></a>枚举的兼容性</h3><p>默认的枚举类型与数字类型兼容，数字类型与枚举类型兼容，不同的枚举类型之间是不兼容的。</p><pre><code class="lang-ts">enum Colors {  RED,  YELLOW,  BLUE}// 兼容数字类型let colorRed: number = Colors.RED;// 兼容枚举类型let colorYello: Colors;colorYello = Colors.Red;colorYello = 1;</code></pre><pre><code class="lang-ts">// 所有枚举值没有初始值enum E {  a,  b}// 所有枚举值初始值都为数值enum F {  a = 1,  b = 2}// 所有枚举值类型都为字符串enum G {  a = &#39;apple&#39;,  b = &#39;banana&#39;}</code></pre><p><strong>赋值可以超出枚举值范围：</strong></p><pre><code class="lang-ts">let e: E = 3; // 不报错</code></pre><p><strong>不同枚举约束的变量不可以进行比较：</strong></p><pre><code class="lang-ts">let e: E = 1;let f: F = 2;console.log(e === f); // 报错</code></pre><p><strong>相同枚举不同枚举值约束的变量不可以进行比较：</strong></p><pre><code class="lang-ts">let e1: E.a = 1;let e2: E.b = 2;let e3: E.a = 1;console.log(e1 === e2) // 报错console.log(e1 === e3) // true</code></pre><p><strong>字符串枚举和字符串枚举值约束赋值：</strong></p><pre><code class="lang-ts">// 字符串枚举约束赋值必须是类型中的枚举值let g1: G = G.a// 字符串的枚举值约束赋值必须是这个枚举值let g2: G.b = G.b</code></pre><h3 id="函数的兼容性"><a href="#函数的兼容性" class="headerlink" title="函数的兼容性"></a>函数的兼容性</h3><p>比较函数的兼容性时要先比较函数的参数，再比较函数的返回值。</p><h4 id="参数的兼容性"><a href="#参数的兼容性" class="headerlink" title="参数的兼容性"></a>参数的兼容性</h4><pre><code class="lang-ts">/* 参数的类型比较 */type SumFunc = (a: number, b: number) =&gt; number;let sum: SumFunc;// 不报错的赋值sum = function(a: number, b: number): number {  return a + b;}sum = function(a: number): number {  return a;}sum = function(): number {  return 0;}// 报错的赋值sum = function(a: number, b: number, c: number): number {  return a + b + c;}</code></pre><p>函数的类型检查可以兼容少传参数或不传参数，但是多传参数会报错。</p><h4 id="参数的双向协变"><a href="#参数的双向协变" class="headerlink" title="参数的双向协变"></a>参数的双向协变</h4><p>参数的 “双向协变” 是指变量定义的参数类型去兼容变量赋值定义的参数类型，或者变量赋值的参数类型去兼容定义的参数类型，只要有一个成立即可，所谓兼容必须是包含的关系。</p><pre><code class="lang-ts">type LogFunc = (val: number | string) =&gt; void;let log: LogFunc;// 变量定义类型兼容赋值定义类型log = function (val: string) {  console.log(val);}// 变量赋值类型兼容变量定义的类型log = function (val: number | string | boolean) {  console.log(val);}</code></pre><h4 id="返回值的兼容性"><a href="#返回值的兼容性" class="headerlink" title="返回值的兼容性"></a>返回值的兼容性</h4><pre><code class="lang-ts">/* 返回值的类型比较 */type GetPerson = () =&gt; { name: string, age: number };let getPerson: GetPerson;// 不报错的赋值getPerson = function () {  return { name: &#39;hello&#39;, age: 20 };}getPerson = function () {  return { name: &#39;hello&#39;, age: 20, gender: 1 };}// 报错的赋值getPerson = function () {  return { name: &#39;hello&#39; };}// 可能调用 age 属性的方法getPerson().age.toFixed(2);</code></pre><p>返回值可以兼容多返回的属性，属性少了会报错，因为可能会调用返回值缺失属性的方法。</p><h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><pre><code class="lang-ts">class Parent {  name: string;}class Child extends Parent {  age: number;}let p1: Parent = new Parent();let c1: Child = new Child();let p2: Parent = new Child();let c2: Child = new Parent(); // 报错</code></pre><p>父类和子类能不能赋值给限制了父类或子类泛型的变量，能不能赋值和是父类或子类没任何关联，主要看属性是否满足，而上面 <code>p2</code> 没有报错的原因是子类的实例继承了父类的属性，所以提供了父类泛型所要求的属性，而 <code>c2</code> 报错是因为父类的实例并没有提供子类泛型要求的属性。</p><h3 id="接口的兼容性"><a href="#接口的兼容性" class="headerlink" title="接口的兼容性"></a>接口的兼容性</h3><h4 id="比较属性的兼容性"><a href="#比较属性的兼容性" class="headerlink" title="比较属性的兼容性"></a>比较属性的兼容性</h4><p>在检查参数类型时，并不是真正的比较接口类型，而是比较具体的属性是否兼容。</p><pre><code class="lang-ts">interface Person {  name: string;  age: number;  gender: number;}let p: Person = {  name: &#39;hello&#39;,  age: 20,  gender: 0};</code></pre><h4 id="鸭式变形法"><a href="#鸭式变形法" class="headerlink" title="鸭式变形法"></a>鸭式变形法</h4><p>“鸭式变形法” 是很多动态语言的类型风格，指的是一只鸟如果看起来像鸭子，游起来像鸭子，叫起来像鸭子，这只鸟就可以被当做一直鸭子，回到 <code>TS</code> 中，传入接口的对象只要符合接口的必要条件，即传入的属性不必接口约束的少，就认为可以通过校验，不会报错。</p><p>上面的案例可以稍微做改造如下：</p><pre><code class="lang-ts">interface Animal {  name: string;  age: number;}interface Person {  name: string;  age: number;  gender: number;}let p: Person = {  name: &#39;hello&#39;,  age: 20,  gender: 0};function getName(a: Animal): string {  return a.name;}getName(p); // hello;</code></pre><p>上面的代码中定义了两个接口 <code>Animal</code> 和 <code>Person</code>，<code>Person</code> 定义的属性更多，当一个符合 <code>Person</code> 的对象传给参数用 <code>Animal</code> 约束的函数时，检测的是接口的属性，只要提供的属性不比约束的属性少，则不会报错。、</p><p>在实际的开发应用中，有一个常见的场景，就是前端代码要对后端返回的数据进行定义和约束，往往后端返回的数据及类型对于前端并不是全部必要的，则可以利用该特性使用接口对必要的字段进行兼容。</p><pre><code class="lang-ts">interface List {  id: number;  name: string;}interface Result {  data: List[];}function render(result: Result) {  result.data.forEach(({ id, name }) =&gt; {    console.log(id, name)  });}render({  data: [    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错    {id: 2, name: &#39;B&#39;}  ]});</code></pre><blockquote class="pullquote danger"><p><strong>有一种特殊情况，就是直接传入对象字面量，则 <code>TS</code> 会对额外的字段进行检查，绕过检查的方式一共有三种：</strong></p><ul><li><strong>将对象字面量直接赋值给变量；</strong></li><li><strong>使用类型断言；</strong></li><li><strong>在定义接口时使用可索引签名；</strong></li></ul></blockquote><pre><code class="lang-ts">// 第一种方式：对象字面量赋值给变量let result = {  data: [    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;},    {id: 2, name: &#39;B&#39;},  ]};render(result);</code></pre><pre><code class="lang-ts">// 第二种方式：使用类型断言render({  data: [    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错    {id: 2, name: &#39;B&#39;},  ]} as Result);// 或// React 中容易产生歧义render(&lt;Result&gt;{  data: [    {id: 1, name: &#39;A&#39;, sex: &#39;male&#39;}, // 报错    {id: 2, name: &#39;B&#39;},  ]});</code></pre><pre><code class="lang-ts">// 第三种方式：定义接口使用可索引签名interface List {  id: number;  name: string;  [x: string]: any;}</code></pre><h4 id="可索引接口的兼容性"><a href="#可索引接口的兼容性" class="headerlink" title="可索引接口的兼容性"></a>可索引接口的兼容性</h4><p>用数值类型去索引一个接口，相当于给数组创建接口，可索引返回值的具体类型约束数组成员类型。</p><pre><code class="lang-ts">interface StringArray {  [index: number]: string;}const chars: StringArray = [&#39;A&#39;, &#39;B&#39;]</code></pre><p><strong>使用字符串类型作为可索引类型，则不能添加其他类型的属性：</strong></p><pre><code class="lang-ts">interface Names {  [x: string]: string;  y: number; // 报错}</code></pre><p><strong>可是使用字符串和数值类型同时作为可索引类型，数字类型返回值必须是字符串类型返回值的子类型：</strong></p><pre><code class="lang-ts">interface Names {  [x: string]: string;  [y: number]: string;}</code></pre><h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体类型，再进行兼容性的判断，即用到了就会比较，没用到就不会比较。</p><pre><code class="lang-ts">/* 空接口 */interface Empty&lt;T&gt; {}let x: Empty&lt;string&gt;;let y: Empty&lt;number&gt;;x = y;</code></pre><pre><code class="lang-ts">/* 属性使用了泛型的接口 */interface NotEmpty&lt;T&gt; {  data: T;}let x: NotEmpty&lt;string&gt;;let y: NotEmpty&lt;number&gt;;x = y; // 报错，因为 number 类型的属性不能赋值给 string 类型的定义// 等价于interface NotEmptyString{  data: string}interface NotEmptyNumber{  data: number}let xString: NotEmptyString;let yNumber: NotEmptyNumber;xString = yNumber; // 报错</code></pre><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>类型保护就是一些表达式在编译时，能通过类型信息确保某个具体作用域内变量的类型。</p><h3 id="typeof-和-instanceof-类型保护"><a href="#typeof-和-instanceof-类型保护" class="headerlink" title="typeof 和 instanceof 类型保护"></a>typeof 和 instanceof 类型保护</h3><pre><code class="lang-ts">/* typeof 类型保护 */function double(val: string | number | boolean) {  if (typeof val === &#39;string&#39;) {    return val.repeat(2);  }  if (typeof val === &#39;number&#39;) {    return val * 2;  }  if (typeof val === &#39;boolean&#39;) {    return !val;  }}</code></pre><p>上面方法因为使用 <code>typeof</code> 做了类型判断，所以分别在 <code>if</code> 判断的作用域内 <code>val</code> 的值会变成判断后对应的类型，可以调用类型对应的方法，而在判断的外面无法确认值的类型，调用方法编译时报错。</p><pre><code class="lang-ts">/* instanceof 类型保护 */class Bird {  nameBird: string;}class Dog {  nameDog: string;}function getName(animal: Bird | Dog) {  if (animal instanceof Bird) {    return animal.nameBird;  }  if (animal instanceof Dog) {    return animal.nameDog;  }}</code></pre><p>与 <code>typeof</code> 类似，使用 <code>instanceof</code> 判断了函数 <code>getName</code> 是否是 <code>Bird</code> 和 <code>Dog</code> 类的实例，判断的作用域内可以获取判断结果对应类上定义的属性。</p><h3 id="null-类型保护"><a href="#null-类型保护" class="headerlink" title="null 类型保护"></a>null 类型保护</h3><p>之前我们提到过在 <code>tsconfig.json</code> 文件 <code>compilerOptions</code> 的 <code>strictNullChecks</code> 属性设置为 <code>true</code> 时，则会对 <code>null</code> 进行严格检查，此时下面代码将会报错。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {  return str.charAt(0); // 报错}</code></pre><p>此时的报错就是由于对 <code>null</code> 的类型保护引起的，有如下解决方法。</p><pre><code class="lang-ts">/* 方法一 */function getFirstLetter(str: string | null) {  str = str || &#39;&#39;;  return str.charAt(0);}</code></pre><pre><code class="lang-ts">/* 方法二 */function getFirstLetter(str: string | null) {  if (str == null) {    return &#39;&#39;;  }  return str.charAt(0);}</code></pre><p>上面两种方式第一种是通过设置初始值的方式来保证在调用字符串方法时 <code>str</code> 的值已经是一个字符串类型，第二种则是通过判断直接返回，没有走到调用字符串方法的代码，类型检查自然不会报错，下面还有一个稍微复杂的案例。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {  function log() {    console.log(str.tirm()); // 报错  }  str = str || &#39;&#39;;  log();  return str.charAt(0);}</code></pre><p>上面代码中，<code>str</code> 调用 <code>tirm</code> 方法的代码封装在了函数 <code>log</code> 内部，当 <code>log</code> 调用时 <code>str</code> 的值已经变为了字符串，但是还是报错了，原因是代码编译阶段由上至下一行一行解析，所以解析函数 <code>log</code> 的时候就已经在函数内部报错了。</p><pre><code class="lang-ts">function getFirstLetter(str: string | null) {  function log() {    console.log(str!.tirm()); // 强制调用  }  str = str || &#39;&#39;;  log();  return str.charAt(0);}</code></pre><p>上面代码在 <code>log</code> 函数中，<code>str</code> 调用 <code>tirm</code> 方法时加了一个 <code>!</code>，意思为强行调用，不管类型是否符合都会调用，相当于忽略了函数 <code>getFirstLetter</code> 的参数类型检查。</p><h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>上面的强制调用方式虽然通能过编译，但是在运行时有报错的风险，应该慎用，在 <code>JS</code> 中有一个提案叫链判断运算符，针对上面情况，会先判断是否为字符串再去调用字符串方法，这样写起来比较繁琐，而链判断运算符就是用来解决这个问题，通过 <code>?.</code> 来调用。</p><pre><code class="lang-js">/* 链判断运算符的几种用法 */a?.b;// 如果 a 不含有 b 属性则返回 undefined，否则返回 a.b，等同于a == null ? undefined : a.b;a?.[b];// 如果 a 不含有键为 b 变量值的属性则返回 undefined，否则返回 a[b]，等同于a == null ? undefined : a[b];a?.b()// 如果 a 不含 b 属性则返回 undefined，否则执行 a.b()，如果 a.b 不是一个函数抛出类型错误，等同于a == null ? undefined : a.b();a?.()// 如果 a 不是函数则返回 undefined，否则执行 a()，等同于a == null ? undefined : a();</code></pre><h3 id="可辨识的联合类型"><a href="#可辨识的联合类型" class="headerlink" title="可辨识的联合类型"></a>可辨识的联合类型</h3><p>可辨识的联合类型是指，通过联合类型中的共同属性进行类型保护的一种技巧，通过同属性值的判断可以确定联合类型中的具体类型。</p><pre><code class="lang-ts">interface WarningButton {  class: &#39;warning&#39;;  name1: &#39;modified&#39;;}interface DangerButton {  class: &#39;danger&#39;;  name2: &#39;delete&#39;;}// 定义联合类型type Button = WarningButton | DangerButton;function getButton(button: Button) {  if (button.class === &#39;warning&#39;) {    return button.name1;  }  if (button.class === &#39;danger&#39;) {    return button.name2;  }}</code></pre><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>在可辨识的联合类型中如果没有共同的属性，共同属性判断不同值区分的方法行不通，这时可以用 <code>in</code> 操作符和不同属性判断进行类型保护。</p><pre><code class="lang-ts">interface Bird {  talon: number;}interface Dog {  leg: number;}function getNumber(animal: Bird | Dog) {  if (&#39;talon&#39; in animal) {    console.log(animal.talon);  }  if (&#39;leg&#39; in animal) {    console.log(animal.leg);  }}</code></pre><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p><code>TS</code> 中的上面用到的类型保护大部分为表达式，其实可以不使用这些表达式，通过自定义类型保护函数的方式实现同样的效果。</p><pre><code class="lang-ts">interface Bird {  talon: number;}interface Dog {  leg: number;}// 自定义类型保护函数function isBird(animal: Bird | Dog): animal is Bird {  // return (animal as Bird).talon &gt; 0;  return (&lt;Bird&gt;animal).talon &gt; 0;}function getNumber(animal: Bird | Dog) {  if (isBird(animal)) {    console.log(animal.talon);  } else {    console.log(animal.leg);  }}</code></pre><p>上面的自定义保护函数 <code>isBird</code> 中参数类型与 <code>getNumber</code> 参数一致，返回值的 <code>animal is Bird</code> 是一个类型谓词，语法为 <code>param is type</code>，代表返回是否满足 <code>Bird</code> 接口，由于 <code>animal</code> 并不知道自己符合哪一个接口，所以使用类型断言指定成了 <code>Bird</code>，<code>isBird</code> 代码中注释和非注释两种方式都可以实现类型断言，这样自定义类型检查函数 <code>isBird</code> 就可以在 <code>getNumber</code> 中使用并实现类型保护。</p><h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型表示为将多个类型合并为一个类型。</p><pre><code class="lang-ts">interface Bird {  name: string;  fly(): void;}interface Person {  name: string;  eat(): void;}// 取的是接口的并集type BirdMan = Bird &amp; Person;// 实现接口必须包含两个接口所有的属性和方法let birdMan: BirdMan = {  name: &#39;niao&#39;,  fly() {    console.log(&#39;fly&#39;);  },  eat() {    console.log(&#39;eat&#39;);  }};</code></pre><h3 id="typeof-获取类型"><a href="#typeof-获取类型" class="headerlink" title="typeof 获取类型"></a>typeof 获取类型</h3><p>在 <code>TS</code> 使用时如果数据内容在变化，要不停的更改对应的接口，此时可以使用 <code>typeof</code> 关键字快速获取一个变量的类型。</p><pre><code class="lang-ts">/* 先定义类型，后定义变量 */interface People {  name: string;  age: number;}let p: People = {  name: &#39;hello&#39;,  age: 20;};</code></pre><pre><code class="lang-ts">/* 先定义变量，后定义接口 */let p: People = {  name: &#39;hello&#39;,  age: 20;};type People = typeof p;function getName(p: People) {  return p.name;}</code></pre><p>上面获取的类型定义 <code>People</code> 是根据 <code>p</code> 对象的属性和值生成，然后可以使用获取的类型去限制其他对象。</p><h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><p><code>TS</code> 中的索引访问操作符指可以通过 <code>[]</code> 获取一个类型的子类型。</p><pre><code class="lang-ts">// 定义嵌套类型接口interface Person {  name: string;  age: number;  // 对象，包含 name 属性  job: {    name: string;  };  // 成员为对象组成的数组，对象中含有 name 和 level 属性  hobbies: { name: string; level: number }[];}// 获取 Person 接口 job 对象中 name 属性的类型定义为 FEJob 的类型let FEJob: Person[&quot;job&quot;] = {  name: &quot;FE&quot;};// 获取数组中任意一项中 level 属性的类型作为 hobbyLevel 的类型let hobbyLevel: Person[&#39;hobbies&#39;][0][&#39;level&#39;] = 10;</code></pre><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><code>TS</code> 中定义的关键字 <code>keyof</code> 是索引类型查询操作符，用来定义类型，当定义一个获取对象属性值的函数，传入的值为对象和属性名，这样属性名参数的类型定义为 <code>string</code> 不准确，因为很可能传入一个对象本身没有的属性字符串，<code>keyof</code> 就是用来解决类似这样问题的。</p><pre><code class="lang-ts">interface Person {  name: string;  age: number;  gender: &#39;male&#39; | &#39;female&#39;;}// 使用 keyof 定义类型type PersonKey = keyof Person;function getValueByKey(p: Person, key: PersonKey) {  return p[key];}let: person: Person = {  name: &#39;hello&#39;,  age: 20,  gender: &#39;male&#39;};getValueByKey(person, &#39;name&#39;); // hellogetValueByKey(person, &#39;say&#39;); // 报错</code></pre><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>在某一个类型定义中使用 <code>in</code> 操作符和 <code>keyof</code> 操作符批量映射修改一个新的类型定义。</p><pre><code class="lang-ts">interface Person {  name: string;  age: number;  gender: &#39;male&#39; | &#39;female&#39;;}// 映射 Person 接口定义的类型，把每一个属性都变成可选的type PartPerson = {  [key in keyof Person]?: Person[key];}let p1: PartPerson = {  name: &#39;hello&#39;};</code></pre><p>上面的代码中 <code>keyof Person</code> 取到了 <code>Person</code> 接口的每一个属性的类型，<code>key</code> 通过运算符 <code>in</code>（批量映射）代表获取的每一个属性名，<code>?:</code> 代表可选，<code>Person[key]</code> 代表对应的值。</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p>在 <code>TS</code> 内部内置了一些工具类型来帮助我们更好、更方便的使用类型系统。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial</code> 可以将传入类型定义的属性由非可选变为可选，功能跟映射类型一节实现的功能非常相似，只是具体被映射的类型是通过参数传入的，所以底层是使用泛型实现的。</p><pre><code class="lang-ts">// 定义接口interface Person {  name: string;  age: number;}// 使用 Partiallet p: Partial&lt;Person&gt; = {  name: &#39;hello&#39;};// Partial 的原理type Partial&lt;T&gt; = {  [key in keyof T]?: T[key]}</code></pre><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required</code> 可以将传入类型定义的属性变为必选，使用 <code>-?:</code> 替换原有的 <code>:</code> 也可以实现。</p><pre><code class="lang-ts">// 定义接口interface Person {  name: string;  age: number;}// 使用 Requiredlet p: Required&lt;Person&gt; = {  name: &#39;hello&#39;}; // 报错// Required 的原理type MyRequired&lt;T&gt; = {  [key in keyof T]-?: T[key]}</code></pre><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p><code>Readonly</code> 可以将传入类型定义的属性每一项都加上 <code>readonly</code> 修饰符来实现属性的只读。</p><pre><code class="lang-ts">// 定义接口interface Person {  name: string;  age: number;}// 使用 Readonlylet p: Readonly&lt;Person&gt; = {  name: &#39;hello&#39;,  age: 10};p.name = &#39;world&#39;; // 报错// Readonly 的原理type MyReadonly&lt;T&gt; = {  readonly [key in keyof T]: T[key];}</code></pre><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick</code> 可以摘取传入类型定义的属性中的某一项返回。</p><pre><code class="lang-ts">// 定义接口interface Person {  name: string;  age: number;}// 使用 Picklet p: Pick&lt;Person, &#39;name&#39;&gt; = {  name: &#39;hello&#39;};// Pick 的原理type MyPick&lt;T, K extends keyof T&gt; = {  [key in K]: T[key];}</code></pre><h3 id="内置条件类型"><a href="#内置条件类型" class="headerlink" title="内置条件类型"></a>内置条件类型</h3><p>还记得在泛型一节中提到了泛型的流程控制，在 <code>TS</code> 中内置了一些常用的条件类型。</p><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><pre><code class="lang-ts">// 定义Exclude&lt;T, U&gt; // 从 T 可分配给的类型中排除 U// 使用type E = Exclude&lt;string | number, string&gt;let x: E = 10;let y: E = &#39;hello&#39;; // 报错</code></pre><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><pre><code class="lang-ts">// 定义Extract&lt;T, U&gt; // 从 T 可分配的类型中提取 U// 使用type E = Extract&lt;string | number, string&gt;let x: E = 10; // 报错let y: E = &#39;hello&#39;;</code></pre><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><pre><code class="lang-ts">// 定义NonNullable&lt;T&gt; // 从 T 中排除 null 和 undefined// 使用type E = NonNullable&lt;string | null | undefined&gt;let x: E = null; // 报错let y: E = &#39;hello&#39;;</code></pre><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><pre><code class="lang-ts">// 定义ReturnType&lt;T&gt; // 获取函数类型的返回类型// 使用function getUserInfo() {  return { name: &quot;hello&quot;, age: 10 };}type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;let user: UserInfo = {  name: &#39;haha&#39;,  age: 18};</code></pre><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h4><pre><code class="lang-ts">// 定义InstanceType&lt;T&gt; // 获取构造函数类型的实例类型// 使用class Person {  constructor(public name) {}  getName() {    console.log(this.name);  }}type P = InstanceType&lt;typeof Person&gt;;let p: P = {  name: &#39;hello&#39;,  getName() {    console.log(&#39;myName&#39;);  }};</code></pre><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190416160637/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Node.js 实现一个提交自动检测的 Git Hook</title>
      <link>https://www.overtaking.top/20190409024640/</link>
      <guid>https://www.overtaking.top/20190409024640/</guid>
      <pubDate>Mon, 08 Apr 2019 18:46:40 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Git/20190409024640/git-hooks-location.png&quot; title=&quot;Git Hook&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;什么是-Git-Hook&quot;&gt;&lt;a href=&quot;#什么是-Git-Hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git Hook&quot;&gt;&lt;/a&gt;什么是 Git Hook&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Git Hook&lt;/code&gt; 是能在 &lt;code&gt;Git&lt;/code&gt; 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 &lt;code&gt;.git/hooks&lt;/code&gt; 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 &lt;code&gt;.sample&lt;/code&gt;，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190409024640/git-hooks-location.png" title="Git Hook"><p><br></p><h2 id="什么是-Git-Hook"><a href="#什么是-Git-Hook" class="headerlink" title="什么是 Git Hook"></a>什么是 Git Hook</h2><blockquote class="pullquote info"><p><strong><code>Git Hook</code> 是能在 <code>Git</code> 操作的特定重要动作发生时触发自定义脚本，也被称为 “钩子”，这样的脚本被存储在 <code>.git/hooks</code> 目录中，脚本分为客户端的和服务端两种，这些钩子文件的后缀名默认为 <code>.sample</code>，其存在的目的就是为了让这些脚本默认不被执行，如果需要其被执行则去掉后缀名，可以通过项目需求制定钩子的功能和程序编写。</strong></p></blockquote><a id="more"></a><h2 id="实现-Hook-功能介绍"><a href="#实现-Hook-功能介绍" class="headerlink" title="实现 Hook 功能介绍"></a>实现 Hook 功能介绍</h2><blockquote class="pullquote success"><p><strong>本次将使用 <code>Node.js</code> 实现一个 <code>Git Hook</code>，功能为在提交代码之前检测功能如下：</strong></p><ul><li><strong>检测是否为 <code>Git</code> 项目；</strong></li><li><strong>检测邮箱是否符合规格；</strong></li><li><strong>检测代码是否含有冲突；</strong></li><li><strong>自动执行 <code>Eslint</code>，并检测问题。</strong></li></ul></blockquote><h2 id="需求的由来"><a href="#需求的由来" class="headerlink" title="需求的由来"></a>需求的由来</h2><p>在开始代码的编写之前，一定要清楚，团队开发时为什么需要这样的 <code>hook</code>，下面列举的场景可能都会对团队项目持续集成的历史 “树” 造成污染，或在协同开发时对团队成员造成麻烦。</p><p><strong>邮箱错误：</strong></p><p>当团队 <code>Gitlab</code> 仓库对邮箱格式进行了严格的限制，必须为公司邮箱才可以进行推送，很可能邮箱配置错误进行了提交，而推代码到远端时发现邮箱错了，要对本地的 <code>commit</code> 记录修正，再重新推到远端。</p><blockquote class="pullquote warning"><p><strong>容易造成邮箱设置错误的常见原因：</strong></p><ul><li><strong>新入职员工刚刚领了新的笔记本或老员工电脑重做系统；</strong></li><li><strong>维护不同团队的开源项目太多，不同项目需要配置不同的邮箱，很可能导致邮箱配置错误；</strong></li><li><strong>当团队中有外包开发人员，且由于权限问题同一套代码是存放在两个仓库，正式员工需要在本地项目中通过 <code>remote</code> 来同时指定两个仓库地址，并在本地代码修改后拉取外包仓库的代码进行合并，同时同步到正式仓库和外包仓库，如果正式仓库对推送过来的提交邮箱格式进行了严格的限制，并且外包提交记录的邮箱错误，就导致正式员工合并后的提交被正式仓库拒绝，如果使用 <code>rebase</code> 强行修正错误的邮箱，变基后的 <code>commit</code> 哈希发生变化可能与远端仓库不一致，需要进行强推到两个仓库，并全员的本地回滚到 <code>rebase</code> 之前的公共 <code>commit</code> 节点。</strong></li></ul></blockquote><p><strong>代码冲突：</strong></p><p>开发时和其他人同时修改了相同部分造成冲突，如果冲突不能及时被发现，提交并推送到远端是对远端仓库的污染，也可能其他开发人员正好拉取了这样的代码，会对团队造成麻烦。</p><blockquote class="pullquote danger"><p><strong>容易造成冲突未及时处理的原因：</strong></p><ul><li><strong>项目过大，文件较多；</strong></li><li><strong>编辑器不智能；</strong></li><li><strong>前端项目使用了路由懒加载，不切换到冲突代码所在的路由对组件进行渲染，项目不会报错。</strong></li></ul></blockquote><p><strong><code>Eslint</code> 检查：</strong></p><p>有些团队的项目对代码规范要求高，并为了减小线上 <code>Bug</code> 率，会在项目中集成 <code>Eslint</code> 对代码风格进行检查，通常都是在命令行手动执行检测命令，有些时候可能忘记执行命令进行检测，就将代码进行了提交和推送。</p><blockquote class="pullquote default"><p><strong>为了规避上面的情况，所以才有了这次关于 <code>Git Hook</code> 的需求，以及下面的代码实现，目的是防患于未然，将大家在开发时容易犯的错误或对项目代码持续集成和管理的潜在风险扼杀在摇篮中。</strong></p></blockquote><h2 id="目录结构及文件简介"><a href="#目录结构及文件简介" class="headerlink" title="目录结构及文件简介"></a>目录结构及文件简介</h2><pre class="language-treeview">  <code class="language-treeview">    git-hooks      |- default-events.js      |- default-rules.js      |- git-checker.js      |- pre-commit.js  </code></pre><blockquote class="pullquote info"><ul><li><strong><code>default-events.js</code>：用来编写默认的检测事件；</strong></li><li><strong><code>default-rules.js</code>：用来管理默认检测事件用到的规则（正则）；</strong></li><li><strong><code>git-checker.js</code>：用来构建 <code>Hook</code> 的核心逻辑；</strong></li><li><strong><code>pre-commit.js</code>：用来编写执行检测的调用逻辑。</strong></li></ul></blockquote><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>在编写这个 <code>hook</code> 之前需要用到第三方模块 <a href="https://www.npmjs.com/package/husky" target="_blank">husky</a>，这个模块的作用是根据项目中 <code>package.json</code> 的配置来向 <code>.git/hooks</code> 中的脚本写入我们的逻辑，项目中需要安装。</p><pre><code class="lang-bash">$ npm install husky</code></pre><h2 id="代码设计思路分析"><a href="#代码设计思路分析" class="headerlink" title="代码设计思路分析"></a>代码设计思路分析</h2><p>设计这个 <code>hook</code> 时提供了 <code>Git</code> 目录检测、邮箱验证、冲突检测、和执行 <code>Eslint</code> 的功能，当然我们希望检测函数不是强制的，是可以选择性使用，而使用者也可以编写自己需要的检测函数来覆盖其他的场景。</p><p><strong>项目中的 <code>husky</code> 配置如下：</strong></p><pre><code class="lang-json">/* 使用 hook 项目的 package.json */{  &quot;husky&quot;: {    &quot;hooks&quot;: {      &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot;    }  }}</code></pre><p>可以看出，<code>husky</code> 帮我们执行了 <code>git-hooks/pre-commit.js</code> 文件。</p><p><strong>我们希望使用者的用法如下：</strong></p><pre><code class="lang-js">/* ~git-hooks/pre-commit.js */const GitChecker = require(&#39;./git-checker&#39;);const commitChecker = new GitChecker(&#39;pre-commit&#39;, {  // default event names  defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;, &#39;conflict&#39;, &#39;eslint&#39;],  rules: {    // your costom rules  },  checkEvents: {    // your custom check events  }});commitChecker.checkStart();</code></pre><p>上面的用法通过创建实例来创建 <code>checker</code>，即 “检测者”，调用 <code>checkStart</code> 方法帮助我们检测，创建实例的参数为 <code>options</code>，类型为对象。</p><p>上面的用法既可以让用户通过配置 <code>options</code> 的 <code>defaultEventNames</code> 属性来选择性的使用默认的检测函数，又可以通过 <code>checkEvents</code> 属性来让使用者编写检测函数。</p><p><code>rules</code> 属性是来存放使用者编写检测函数时使用的正则，会和默认检测函数中的正则合并，我们专门用 <code>default-rules.js</code> 文件来管理默认检测函数中使用的正则。</p><pre><code class="lang-js">/* ~git-hooks/default-rules.js */module.exports = {  emailCheck: /\S+((@youemail\.com)|(@enterprise\.com))(\n|\r\n)*$/,  conflictCheck: &#39;^&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\s|^=======$|^&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\s&#39;};</code></pre><h2 id="GitChecker-类的实现"><a href="#GitChecker-类的实现" class="headerlink" title="GitChecker 类的实现"></a>GitChecker 类的实现</h2><p>我们需要一个工厂创造 “检测者”，取名为 <code>GitChecker</code>，在 <code>GitChecker</code> 中需要使用发布订阅模式，对检测函数进行注册，并在执行实例的 <code>checkStart</code> 方法时依次执行，代码如下：</p><pre><code class="lang-js">/* ~git-hooks/git-checker.js */// 引入依赖const EventEmitter = require(&#39;events&#39;);const exec = require(&#39;child_process&#39;).execSync;const chalk = require(&#39;chalk&#39;);const defaultRules = require(&#39;./default-rules&#39;);const defaultEvents = require(&#39;./default-events&#39;);const { log } = console;// 创建 GitChecker 类并继承 EventEmitter，目的是继承 on 和 emitclass GitChecker extends EventEmitter {  constructor(type, options) {    super();    // 防止使用者 options 内部属性传错，进行初始化    const {      rules = {},      defaultEventNames = [],      checkEvents = {}    } = options;    // 合并默认检测函数使用的正则和用户自定义检测函数使用的正则统一管理    this.rules = Object.assign(defaultRules, rules);    // 合并用户选择使用的默认检测函数和自定义检测函数    this.checkEvents = Object.assign(this.getDefaultEvents(defaultEventNames), checkEvents);    this.type = type; // git 操作类型    this.isCommit = true; // 当前是否可以被提交    this.gitConfigEnvs = [&#39;local&#39;, &#39;global&#39;, &#39;system&#39;]; // 取邮箱时的环境    // 将提交状态更改为禁止，绑定 this 是为了防止在检测函数内解构更改指向    this.forbiddenCommit = this.forbiddenCommit.bind(this);    this.init(); // 初始化  }  init() {    // 将检测函数常用方法挂载到实例上    this.log = log;    this.exec = exec;    this.chalk = chalk;    // 注册当前类型 git 操作对应的检测函数    this.register(this.type);  }  getDefaultEvents(eventsNames) {    return eventsNames.reduce((memo, eventName) =&gt; {      memo[eventName + &#39;CheckTask&#39;] = defaultEvents[eventName + &#39;CheckTask&#39;];      return memo;    }, {});  }  register(type) {    Object.keys(this.checkEvents).forEach((event) =&gt; {      // 订阅事件，每一个函数传入当前实例，方便取实例上的属性和方法      this.on(type, () =&gt; this.checkEvents[event](this));    });  }  forbiddenCommit() {    this.isCommit = false;  }  async checkStart() {    log(chalk.green(&#39;开始代码检测&#39;));    // 发布执行检测函数    await this.emit(this.type);    // 结束后结束当前 git 操作进程    this.checkEnd();  }  checkEnd() {    // 如果当前状态为不可提交，则退出进程号不为 0（git 规定）    if (!this.isCommit) process.exit(1);    log(chalk.green(&#39;检测通过&#39;));    process.exit(0);  }}module.exports = GitChecker;</code></pre><p>在上面的设计中之所以将一些常用方法都挂载在了实例上，目的是为了让使用者编写自定义检测函数时不再需要引入依赖和更方便的获取实例上的属性、方法，当然也方便了我自己编写默认检测函数。</p><h2 id="默认检测函数的实现"><a href="#默认检测函数的实现" class="headerlink" title="默认检测函数的实现"></a>默认检测函数的实现</h2><p>由于检测工厂 <code>GitChecker</code> 已经将自己创建的 “检测者” 塞入了检测函数的参数中去，那就可以把所有的默认检测函数放入一个 <code>default-events.js</code> 文件中统一管理。</p><h3 id="检测目录是否被-Git-管理"><a href="#检测目录是否被-Git-管理" class="headerlink" title="检测目录是否被 Git 管理"></a>检测目录是否被 Git 管理</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */exports.isGitCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; {  // 执行 git 命令，如果跑出异常证明不是一个 git 管理的项目  try {    exec(&#39;git status&#39;);  } catch (e) {    log(chalk.red(&#39;错误：当前不是一个git项目目录&#39;));    forbiddenCommit(); // 更改提交状态太为不能提交  }};</code></pre><p>检测是否为一个 <code>Git</code> 所管理的项目只需执行 <code>git status</code> 来检测一下文件变化，如果抛出异常则说明不被 <code>Git</code> 所管理。</p><h3 id="检测邮箱是否合规"><a href="#检测邮箱是否合规" class="headerlink" title="检测邮箱是否合规"></a>检测邮箱是否合规</h3><blockquote class="pullquote primary"><p><strong>上一个方法使用了从参数解构的方式获取实例属性和方法，为了更便于理解这个方法正常使用参数。</strong></p></blockquote><pre><code class="lang-js">/* ~git-hooks/default-events.js */exports.emailCheckTask = (checker) =&gt; {  const checkEmailEnvs = (i) =&gt; {    // 取出正则和获取 git 邮箱的环境参数集合    const gitConfigEnvs = checker.gitConfigEnvs;    const rules = checker.rules;    // 获取邮箱的 git 命令    const command = &#39;git config --&#39; + gitConfigEnvs[i] + &#39; user.email&#39;;    // 如果获取邮箱成功，则校验邮箱是否合规    try {      const userEmail = checker.exec(command).toString();      const isValidate = rules.emailCheck.test(userEmail);      if (!isValidate) {        checker.log(checker.chalk.red(&#39;错误：请使用正确的邮箱提交代码&#39;));        checker.log(checker.chalk.yellow(&#39;你当前的邮箱是：&#39; + userEmail));        checker.forbiddenCommit();      } else {        checker.log(checker.chalk.green(&#39;邮箱校验通过&#39;));      }    } catch (e) {      if (i === gitConfigEnvs.length) {        checker.log(checker.chalk.red(&#39;错误：请设置git的提交邮箱&#39;));        checker.forbiddenCommit();      } else {        checkEmailEnvs(i + 1);      }    }  };  checkEmailEnvs(0);};</code></pre><blockquote class="pullquote info"><p><strong>在 <code>Git</code> 中有三个参数设置邮箱，分别 <code>--local</code>、<code>--global</code>、<code>--system</code>，分别对应项目、用户和系统三个环境，顺序即为获取优先级，所以获取也是如此。</strong></p></blockquote><p>该方法使用了递归的思想实现，从优先级最高的环境开始获取邮箱，如果取到邮箱则进行验证，没取到则选择优先级次之的环境获取，直到取到邮箱为止，若都取不到则提示用户设置邮箱，如果取到邮箱，校验不通过则提示用户当前邮箱，并提醒用户设置正确的邮箱。</p><h3 id="检测冲突"><a href="#检测冲突" class="headerlink" title="检测冲突"></a>检测冲突</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */exports.conflictCheckTask = (checker) =&gt; {  // 对文件进行正则匹配的 git 命令  const command = &#39;git grep -n -P -E &quot;&#39; + rules.conflictCheck + &#39;&quot;&#39;;  // 如果没有成功匹配，则抛出异常，成功匹配打印冲突代码  try {    const conflicts = checker.exec(command, { encoding: &#39;utf-8&#39; });    if (conflicts) {      checker.log(checker.chalk.red(&#39;错误：发现冲突，请解决后再提交&#39;));      checker.log(checker.chalk.red(&#39;错误代码：&#39;));      checker.log(checker.chalk.red(conflicts.trim()));      checker.forbiddenCommit();    }  } catch (e) {    checker.log(checker.chalk.green(&#39;未发现冲突&#39;));  }};</code></pre><blockquote class="pullquote warning"><p><strong>在上面的 <code>Git</code> 命令中，<code>-n</code> 为显示匹配文件的行号，因为 <code>shell</code> 的正则支持不全，<code>-P</code> 和 <code>-E</code> 是为了支持正则扩展，保证正则生效。</strong></p></blockquote><h3 id="执行-Eslint"><a href="#执行-Eslint" class="headerlink" title="执行 Eslint"></a>执行 Eslint</h3><pre><code class="lang-js">/* ~git-hooks/default-events.js */exports.eslintCheckTask = ({ exec, log, chalk, forbiddenCommit }) =&gt; {  try {    exec(&#39;lint-staged&#39;);    log(chalk.green(&#39;Eslint 校验通过&#39;));  } catch (e) {    log(chalk.red(&#39;错误：Eslint 校验不通过&#39;));    forbiddenCommit();  }};</code></pre><blockquote class="pullquote default"><p><strong><code>Eslint</code> 本身具备检测冲突的功能，检测冲突的函数更适用于没有集成 <code>Eslint</code> 的项目，如果项目已经集成了 <code>Eslint</code> 可以不适用检测冲突函数。</strong></p></blockquote><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>当需求变更，需要在 <code>push</code> 之前执行某些脚本应该怎么办，可以在 <code>git-hooks</code> 文件夹增加一个 <code>pre-push.js</code> 文件，文件内容如下。</p><pre><code class="lang-js">/* ~git-hooks/pre-push.js */const GitChecker = require(&#39;./git-checker&#39;);const pushChecker = new GitChecker(&#39;pre-push&#39;, {  defaultEventNames: [&#39;isGit&#39;, &#39;email&#39;], // default event names  rules: {    // your costom rules  },  checkEvents: {    myHook: ({ log, chalk, forbiddenCommit }) =&gt; {      log(chalk.red(&#39;check prev push&#39;));      forbiddenCommit();    }  }});commitChecker.checkStart();</code></pre><p>由于我们的 <code>hook</code> 依赖于 <code>husky</code>，所以项目 <code>package.json</code> 中的 <code>husky</code> 也有所修改如下：</p><pre><code class="lang-json">/* 使用 hook 项目的 package.json */{  &quot;husky&quot;: {    &quot;hooks&quot;: {      &quot;pre-commit&quot;: &quot;node git-hooks/pre-commit&quot;,      &quot;pre-push&quot;: &quot;node git-hooks/pre-push&quot;    }  }}</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote class="pullquote success"><p><strong>以上就是本次 <code>Git Hook</code> 的使用场景和实现，也希望通过本文，能让大家对 <code>Git Hook</code> 的相关知识有一定了解，另附赠 <code>Github</code> 地址</strong> <a href="https://github.com/shenqiuhui/git-hooks/tree/master" target="_blank">git-hooks</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190409024640/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 Github 团队协作</title>
      <link>https://www.overtaking.top/20190327025116/</link>
      <guid>https://www.overtaking.top/20190327025116/</guid>
      <pubDate>Tue, 26 Mar 2019 18:51:16 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Git/20190327025116/github.jpeg&quot; title=&quot;Github 团队协作&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;Github-的由来&quot;&gt;&lt;a href=&quot;#Github-的由来&quot; class=&quot;headerlink&quot; title=&quot;Github 的由来&quot;&gt;&lt;/a&gt;Github 的由来&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;尽管当时 &lt;code&gt;Git&lt;/code&gt; 对于代码的管理以及团队协作方面已经非常出色，但是 &lt;code&gt;Git&lt;/code&gt; 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 &lt;code&gt;Git&lt;/code&gt; 特性的代码平台的诉求成为必然，基于 &lt;code&gt;Git&lt;/code&gt; 的这个局限，&lt;code&gt;Github&lt;/code&gt; 就这样诞生了。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/github.jpeg" title="Github 团队协作"><p><br></p><h2 id="Github-的由来"><a href="#Github-的由来" class="headerlink" title="Github 的由来"></a>Github 的由来</h2><blockquote class="pullquote default"><p><strong>尽管当时 <code>Git</code> 对于代码的管理以及团队协作方面已经非常出色，但是 <code>Git</code> 无法帮助开发人员寻找优秀的开源项目，同时很多程序员开发的优秀开源项目又变得不为人知，基于这样的历史背景下，一个既可以托管所有项目、提高协作又能充分利用 <code>Git</code> 特性的代码平台的诉求成为必然，基于 <code>Git</code> 的这个局限，<code>Github</code> 就这样诞生了。</strong></p></blockquote><a id="more"></a><h2 id="如何在-Github-高效的搜索项目"><a href="#如何在-Github-高效的搜索项目" class="headerlink" title="如何在 Github 高效的搜索项目"></a>如何在 Github 高效的搜索项目</h2><p>如今 <code>Github</code> 已经非常火爆，也因此被戏称为 “世界最大的同性交友平台”，在 <code>Github</code> 上托管的仓库数量巨大，这对在 <code>Github</code> 上寻找需要的开源项目造成了困扰，其实在 <code>Github</code> 上搜索项目也有一定的技巧，下面我们就来说一下如何高效的找到自己需要的开源项目。</p><p>在登录 <code>Github</code> 后，让搜索项目的搜索框获取焦点并敲下回车键，会跳转到一个搜索页面，这个页面上点击 <code>Advanced search</code>（高级搜索）就会跳转到高级搜索页面。</p><blockquote class="pullquote success"><ul><li><strong><code>From these owners</code>：按照作者名搜索，格式 <code>user:username</code>；</strong></li><li><strong><code>In these repositories</code>：按照仓库名称搜索，格式 <code>repo:username/reponame</code>；</strong></li><li><strong><code>Created on the dates</code>：按照创建日期搜索，格式 <code>created:&lt;YYYY-MM-DD</code>；</strong></li><li><strong><code>Written in this language</code>：按照语言进行搜索，格式 <code>language:JavaScript</code>；</strong></li><li><strong><code>With this many stars</code>：按照星星数查找，格式 <code>stars:&gt;1000</code>；</strong></li></ul></blockquote><p>上面列举只是常用的部分搜索方式和格式，具体可以查看 <a target="_blank" href="https://github.com/search/advanced">https://github.com/search/advanced</a>，也可以不通过高级搜索的页面直接将规则写在 <code>Github</code> 主页的搜索框内，多个搜索规则可同时使用，格式之间用空格隔开，当然也可以按照内容是否在哪一个文件中来搜索，如 <code>partcontent in readme</code>。</p><h2 id="Organizations（组织）"><a href="#Organizations（组织）" class="headerlink" title="Organizations（组织）"></a>Organizations（组织）</h2><p>在 <code>Github</code> 中的仓库可以创建在个人仓库中，也可以创建在组织中，创建在个人仓库时项目的管理者只有项目的所有者，不方便团队层面的管理和协作，如果想要多人共同的管理项目可以通过组织的形式进行。</p><blockquote class="pullquote info"><p><strong>创建组织步骤（如 <code>Github</code> 功能更新请搜索最新教程或自行探索）如下：</strong></p><ul><li><strong>个人信息 <code>setting</code>；</strong></li><li><strong>进入界面点击左侧 <code>Organizations</code>；</strong></li><li><strong>点击右上角 <code>new organization</code>；</strong></li><li><strong>填好组织信息后点击下方 <code>Create organization</code>。</strong></li></ul></blockquote><p>添加后的组织会出现在用户 <code>setting</code> 页面的 <code>Organizations</code> 选项中，点击进入某个组织，可以添加 <code>Github</code> 中能搜索到的成员进行协同开发、在组织下新建仓库、创建团队对仓库做更精细化的管理，也可以对团队里的每个成员针对仓库设置读写权限。</p><h2 id="怎样选择适合团队的工作流"><a href="#怎样选择适合团队的工作流" class="headerlink" title="怎样选择适合团队的工作流"></a>怎样选择适合团队的工作流</h2><p>一个团队在协作的时候一定会分工到所有人完成的工作变成一个产品的过程，“工作流” 对于研发团队来讲，可以理解成分支管理的流程。</p><h3 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h3><p>主干开发是围绕着一条主开发分支进行开发，团队所有成员的 <code>commit</code> 都及时的集成在这条主分支，让团队其他成员第一时间知道。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/master-flow.png" alt="主分支开发工作流"></div><div class="image-caption">主分支开发工作流</div></figure><p><br></p><blockquote class="pullquote warning"><p><strong>适用团队：</strong></p><ul><li><strong>适用于开发团队系统设计和开发能力强，有快速迭代场景，并且有一套有效的特性切换的实施机制（发布系统），保证上线后无序修改代码就能够修改系统行为；</strong></li><li><strong>适用于组件开发的团队（一些基础服务的部门，专门造轮子），成员能力强，人员少，沟通顺畅，用户升级、切换组件成本低。</strong></li></ul></blockquote><h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><code>Git Flow</code> 工作流定义了一个围绕项目发布的严格分支模型，工作流虽然复杂，但提供了一个健壮的用于管理大型项目的框架，具体的工作流程如下图：</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/git-flow.png" alt="Git Flow 工作流"></div><div class="image-caption">Git Flow 工作流</div></figure><p><br></p><blockquote class="pullquote default"><ul><li><strong><code>master</code>：专门用来存储正式发布的历史；</strong></li><li><strong><code>develop</code>：作为功能的集成分支，可以多团队、跨迭代同时在 <code>develop</code> 分支集成；</strong></li><li><strong><code>feature</code>：专门用来开发某一个新功能，仅仅只和 <code>develop</code> 交互；</strong></li><li><strong><code>release</code>：发布（提测）分支，当快要到达发既定发布时间，从 <code>develop</code> 分支分出用来 <code>bugfix</code>、上线、与 <code>master</code> 进行合并，同时与 <code>develop</code> 进行合并；</strong></li><li><strong><code>hotfix</code>：上线后从 <code>master</code> 分出用来修复线上 <code>Bug</code>。</strong></li></ul></blockquote><blockquote class="pullquote success"><p><strong>适用团队：对项目质量要求较高，不具备主干开发能力，有预定发布周期且需要严格执行发布流程的团队。</strong></p></blockquote><h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p><code>Github Flow</code> 工作流就是基于 <code>master</code> 的某一个 <code>commit</code> 拉一条特性分支进行开发，在开发完毕后再重新集成到 <code>master</code> 的工作流。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/github-flow.png" alt="Github 工作流"></div><div class="image-caption">Github 工作流</div></figure><p><br></p><blockquote class="pullquote primary"><p><strong>适用团队：不具备主干开发能力，随时集成随时发布，分支集成时经历代码评审和自动化测试，通过后就可立即发布的应用。</strong></p></blockquote><h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><p><code>Github Flow</code> 是在 <code>Github Flow</code> 的基础上做了一些优化，新增了平行的 <code>production</code> 分支，用于随时准备发布上线，也可以多一些针对不同测试环境的待测试分支。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190327025116/gitlab-flow.png" alt="Gitlab 工作流"></div><div class="image-caption">Gitlab 工作流</div></figure><p><br></p><blockquote class="pullquote danger"><p><strong>适用团队：</strong></p><ul><li><strong>适用于不具备主干开发能力，需要逐个通过测试环境的验证才能发布的应用；</strong></li><li><strong>适用同一个时间节点项目发布出去会有多个版本同时存在的情况（公共库）。</strong></li></ul></blockquote><h2 id="Create-pull-request"><a href="#Create-pull-request" class="headerlink" title="Create pull request"></a>Create pull request</h2><p>在多人开发的项目或开源项目中，其他人拉出一条分支进行开发，在上线之前需要合并到 <code>master</code> 主分支，需要提交 <code>pull request</code>，在 <code>Github</code> 项目页面点击上面的 <code>Pull requests</code> 按钮，上面有两个选项：</p><blockquote class="pullquote success"><ul><li><strong><code>base</code>：目标分支；</strong></li><li><strong><code>compare</code>：合并的特性分支。</strong></li></ul></blockquote><p>在选好 <code>base</code>（目标分支） 和 <code>compare</code>（合并的特性分支） 后，点击下方 <code>Create pull request</code>，填写提交的描述信息后再次点击 <code>Create pull request</code>，此时会在下方显示与目标分支相比新增的提交信息并自动检查冲突。</p><blockquote class="pullquote info"><p><strong><code>pull request</code> 有三种模式：</strong></p><ul><li><strong><code>Create a merge commit</code>：直接将某一个特性分支通过 <code>merge</code> 的方式合并到 <code>master</code>；</strong></li><li><strong><code>Squash and merge</code>：会将特性分支的所有变更集组合成一个 <code>commit</code> 合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立；</strong></li><li><strong><code>Rebase and merge</code>：会将特性分支变更集直接合并到 <code>master</code> 当前指向的节点之后，特性分支的树将独立。</strong></li></ul></blockquote><p>选择 <code>pull request</code> 模式后，需要对这个 <code>pull request</code> 进行再次确认，填写确认信息并点击 <code>Confirm merge</code> 确认合并，在完成合并后 <code>Github</code> 会给我们提供删除特性分支的快捷按钮 <code>Delete branch</code>，一般会等到项目稳定后才会删除特性分支。</p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p><code>Issues</code> 用于追踪需求和任务，在开源项目中使用者发现 <code>Bug</code> 或有新的需求都是通过 <code>Issues</code> 提出，在 <code>Issues</code> 的 <code>Labels</code> 中有开发者设置的代表当前处理状态的标签，通过 <code>Issue</code> 上的状态标签可以知道 <code>Issue</code> 的处理进度。</p><h3 id="创建-Issue"><a href="#创建-Issue" class="headerlink" title="创建 Issue"></a>创建 Issue</h3><blockquote class="pullquote warning"><p><strong>创建 <code>Issue</code> 的步骤：</strong></p><ul><li><strong>点击项目的 <code>Issues</code> 进入 <code>Issues</code> 页面；</strong></li><li><strong>点击 <code>New Issue</code>;</strong></li><li><strong>填写 <code>Issues</code> 的标题及内容；</strong></li><li><strong>点击 <code>Submit new issue</code> 创建 <code>Issue</code>。</strong></li></ul></blockquote><h3 id="创建-Issue-模版"><a href="#创建-Issue-模版" class="headerlink" title="创建 Issue 模版"></a>创建 Issue 模版</h3><blockquote class="pullquote primary"><p><strong><code>Issues</code> 的类型不是单一的，项目的所有者是可以给项目的 <code>Issues</code> 添加分类模版的，操作如下：</strong></p><ul><li><strong>进入项目的 <code>Setting</code> 页面；</strong></li><li><strong>点击 <code>Issues</code> 选项的 <code>Set up templates</code> 按钮进入设置页面；</strong></li><li><strong>通过下拉框选择 <code>Issues</code> 模版的类型，分类如下：</strong><ul><li><strong><code>Bug report</code>：用来提出项目中的 <code>Bug</code>；</strong></li><li><strong><code>Feature request</code>：用来提出新的需求和功能；</strong></li><li><strong><code>Custom issue template</code>：自定义的模版类型，由项目所有者创建时决定具体用途。</strong></li></ul></li><li><strong>点击 <code>Preview and edit</code> 对添加的 <code>Issue</code> 模版进行编辑，编辑后点击 <code>Close preview</code> 保存编辑的内容；</strong></li><li><strong>添加 <code>Issues</code> 模版后点击 <code>Propose changes</code>；</strong></li><li><strong>添加本次修改的记录，同时可以选择用 <code>master</code> 分支还是新创建分支来管理这些 <code>Issues</code>；</strong></li><li><strong>点击 <code>Commit changes</code> 则会生成模版，再次执行创建 <code>Issues</code> 的步骤时可以看到设置的模版；</strong></li><li><strong>点击模版对应的 <code>Get started</code> 快速生成对应的模版。</strong></li></ul></blockquote><blockquote class="pullquote default"><p><strong>在编辑模版后，模版会生成对应 <code>markdown</code> 文件被保存在项目中的 <code>.github/ISSUE_TEMPLATE</code> 路径下。</strong></p></blockquote><p><code>Issues</code> 更大的好处是，在追踪需求和任务的同时，任何人都可以在下面对这个 <code>Issue</code> 中的内容进行评论交流，甚至可以直接 <code>@</code> 评论者、项目所有者、开发者、甚至是项目的整个团队，有助于快速解决 <code>Issue</code> 中提出的问题。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><p>在开源项目开发时可以为当前项目的某个正在进行的迭代创建 <code>Project</code>，创建的 <code>Project</code> 类似于一个看板的形式，可以非常便捷的管理正在进行修复的 <code>Issue</code> 和 <code>pull request</code>（需要在创建 <code>Issue</code> 和 <code>pull request</code> 时选中关联这个 <code>Project</code>）。</p><blockquote class="pullquote success"><p><strong>创建 <code>Project</code> 步骤如下：</strong></p><ul><li><strong>进入项目的 <code>Projects</code> 页面；</strong></li><li><strong>点击 <code>Create a project</code>；</strong></li><li><strong>填写项目的名称和描述并点击下方 <code>Create project</code>。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>在看板中分别对应四个区域如下：</strong></p><ul><li><strong><code>To do</code>：将要完成的任务；</strong></li><li><strong><code>In progress</code>：正在进行中的任务；</strong></li><li><strong><code>Needs review</code>：需要复盘的任务；</strong></li><li><strong><code>Reviewer approved</code>：已经审核通过的任务。</strong></li></ul></blockquote><p>任务可以通过拖动来改变当前的进度和状态，可以非常便捷的实现项目的任务进度监控和管理，有效的推进项目进程。</p><h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 <code>Github</code> 的项目中，可以对指定的分支定义规则来进行保护，防止强制推送、以及分支被删除等操作，目的是为了防止误操作对重要分支造成无法挽回的后果。</p><blockquote class="pullquote danger"><p><strong>设置分支保护步骤：</strong></p><ul><li><strong>进入项目的 <code>Setting</code> 页面；</strong></li><li><strong>选中左侧的 <code>Branches</code> 选项；</strong></li><li><strong>点击 <code>Add rule</code> 来添加保护规则；</strong></li><li><strong><code>Branch name pattern</code> 内制定要保护的分支名字；</strong></li><li><strong><code>Rule settings</code> 中可以设置分支保护规则。</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>可选规则（可根据项目需求和要保护分支的安全级别多选）如下：</strong></p><ul><li><strong><code>Require pull request reviews before merging</code>：选中该项后所有的提交合并都必须通过 <code>pull request</code> 进行，下面有三个子选项如下：</strong><ul><li><strong><code>Required approving reviews</code>：同意 <code>pull request</code> 的人数，就是说设置后必须有对应设置的人数的相关人员批准，才可以合并；</strong></li><li><strong><code>Dismiss stale pull request approvals when new commits are pushed</code>：勾选后在有新的 <code>pull request</code> 时会撤销旧的 <code>pull request</code>；</strong></li><li><strong><code>Require review from Code Owners</code>：勾选该项后，<code>pull request</code> 必须通过项目所有者的通过才能进行合并。</strong></li></ul></li><li><strong><code>Require status checks to pass before merging</code>：在合并前必须通过状态检查才能合并，状态检查如下：</strong><ul><li><strong><code>Require branches to be up to date before merging</code>：要求分支在合并之前是最新的。</strong></li></ul></li><li><strong><code>Require signed commits</code>：勾选该项后要求在提交时验证签名；</strong></li><li><strong><code>Include administrators</code>：加入管理员执行所有限制的配置。</strong></li></ul></blockquote><h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><code>Wiki</code> 是 <code>Github</code> 提供的说明文档功能，点击项目上的 <code>Wiki</code> 选项进入文档页面，在项目从来没有编辑过文档页面时，会默认出现 <code>Create the first page</code> 按钮，点击则会跳转编辑 <code>Wiki</code> 的页面，可以输入 <code>Wiki</code> 标题、内容和提交信息，内容支持 <code>Markdown</code> 语法编写。</p><p>当已经创建过一个 <code>Wiki page</code> 后再次进入项目的 <code>Wiki</code> 页面，会在右上角显示 <code>Edit</code> 和 <code>New page</code> 按钮，分别用于修改和新增 <code>Wiki page</code>，在左侧有所有 <code>Wiki page</code> 的列表，最下面是 <code>Wiki</code> 的仓库地址，也可以通过编辑器在本地创建 <code>Wiki page</code>，编写后通过 <code>Git</code> 推送到 <code>Wiki</code> 仓库。</p><p>在 <code>Wiki</code> 页面还有两个扩展功能，分别为 <code>Add a custom footer</code> 和 <code>Add a custom sidebar</code>，用于创建自定义底部和侧边栏（如编写目录等）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong><code>Github</code> 管理项目实现协同开发是非常便捷的，在 <code>Github</code> 中每一个的操作的参与者和被参与者都会收到 <code>Github</code> 邮件进行通知，进入邮件链接也可以直接对项目变化进行 <code>code review</code>，在企业级项目中目前 <code>Gitlab</code> 的私有仓库更流行，基本功能与 <code>Github</code> 大同小异，在基本功能的基础上增加了更高级的功能和内置的持续集成插件。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190327025116/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之实战技及巧注意事项总结</title>
      <link>https://www.overtaking.top/20190315115008/</link>
      <guid>https://www.overtaking.top/20190315115008/</guid>
      <pubDate>Fri, 15 Mar 2019 03:50:08 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Git/20190315115008/git.png&quot; title=&quot;Git 实战技及注意事项&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Git&lt;/code&gt; 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 &lt;code&gt;Git&lt;/code&gt; 的基础上来详细总结一下这些注意事项&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190315115008/git.png" title="Git 实战技及注意事项"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong><code>Git</code> 作为当前应用最广泛的代码管理和版本控制工具，在实际开发时有很多的注意事项，本篇的目的就是在已经会使用 <code>Git</code> 的基础上来详细总结一下这些注意事项</strong>。</p></blockquote><a id="more"></a><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>在日常开发时，我们经常都是在某一个分支下进行的，<code>commit</code> 操作也是在某些分支上进行，换句话说我们的每一个提交一般来讲都是与分支挂钩的，在 <code>Git</code> 中有一种情况，我们所修改的代码不与任何一个分支有关连，这种情况下叫做分离头指针。</p><p>那么如何操作才能实现分离头指针呢，在开发时我们可能会对某一个 <code>commit</code> 非常的感兴趣，并希望在这个 <code>commit</code> 下去做一些事情，可以执行下面命令实现。</p><pre><code class="lang-git">$ git checkout ef5aaed0707989ebc069efcd842424f6315ab4e2</code></pre><p>当切换分支后对某些文件做一些修改，并重新 <code>commit</code>。</p><pre><code class="lang-git">$ git add .$ git commit -m &#39;分离头指针测试&#39;$ git log</code></pre><p>执行上面命令后我们发现新的 <code>commit</code> 信息后面不在对应某一个分支，而是 <code>HEAD</code>，这种情况下就代表着我们的 <code>Git</code> 目前已经处于分离头指针的状态了。</p><p>分离头指针是 “双刃剑” 有好处也有坏处，在分离头指针的状态下所有的 <code>commit</code> 在重新切换分支时，会被 <code>Git</code> 当作无用提交回收掉，因为这些提交没有跟任何分支有所联系。</p><blockquote class="pullquote warning"><p><strong>分离头指针优缺点：</strong></p><ul><li><strong>优点：尝试性的 <code>commit</code> 可以在分离头指针的状态下进行；</strong></li><li><strong>缺点：当发布需要到其他分支修复问题或紧急发布时，切分支后会导致分离头指针状态下的 <code>commit</code> 丢失。</strong></li></ul></blockquote><p>在切换分支后，如果还想保留分离头指针状态下的提交，可以为这个提交创建一个新的分支。</p><pre><code class="lang-git">$ git branch 分支名 分离头指针状态的提交（哈希值）</code></pre><h2 id="修改本地-commit"><a href="#修改本地-commit" class="headerlink" title="修改本地 commit"></a>修改本地 commit</h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a>修改最近一次提交</h3><pre><code class="lang-git">$ git commit --amend</code></pre><blockquote class="pullquote primary"><p><strong><code>--amend</code> 可以将暂存区新存入的内容同时提交到最近的一次 <code>commit</code> 中，而不会生成新的 <code>commit</code>，同时也可以修改 <code>commit</code> 时的提交信息。</strong></p></blockquote><h3 id="修改任意一次提交"><a href="#修改任意一次提交" class="headerlink" title="修改任意一次提交"></a>修改任意一次提交</h3><pre><code class="lang-git">$ git rebase -i a4d56bb</code></pre><p>该操作为 <code>git rebase</code> 命令的交互模式，即输入 <code>-i</code> 命令，后面所输入的 <code>commit</code> 哈希值并不是要修改的 <code>commit</code>，而是要修改的 <code>commit</code> 的父级 <code>commit</code> 哈希值，在执行命令后会弹出修改的交互界面如下。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">pick 52f3935 add css file- pick 91bd053 change css+ reword 91bd053 change css# Rebase a4d56bb..91bd053 onto a4d56bb (2 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# ...</code></pre><p>从上面的信息来看第一条代表当前要修改的 <code>commit</code>，第二条代表该分支最新的 <code>commit</code>，下面注释为修改参数，由于要修改提交信息，所以此处将第一行的 <code>pick</code> 修改成 <code>reword</code> 并保存，保存后会弹出下一个修改提交信息的界面如下。</p><p><strong>第二个交互界面：</strong></p><pre><code class="lang-diff">- css content+ add css content# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## Date:      Tue Mar 19 14:48:22 2019 +0800## interactive rebase in progress; onto a4d56bb# Last command done (1 command done):#    reword 9e4f711 add css content# Next command to do (1 remaining command):#    pick c220cf2 change css# You are currently editing a commit while rebasing branch &#39;test&#39; on &#39;a4d56bb&#39;.## Changes to be committed:#       new file:   index.css</code></pre><p>该界面上为 <code>commit</code> 的 <code>message</code>，修改后保存，就完成了对该 <code>commit</code> 的修改，值得注意的是，使用 <code>git log</code> 查看历史可以发现，修改 <code>commit</code> 时指定的父级 <code>commit</code> 后所有的 <code>commit</code> 哈希值都会发生变化。</p><p><strong>修改 commit 后的提示信息：</strong></p><pre><code class="lang-bash">[detached HEAD de48b04] add css content Date: Tue Mar 19 14:48:22 2019 +0800 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 index.cssSuccessfully rebased and updated refs/heads/test.</code></pre><blockquote class="pullquote success"><p><strong>可以看出，其实使用 <code>git rebase</code> 命令修改 <code>commit</code> 的原理也是分离头指针，只是在分离头指针修改 <code>commit</code> 后又重新将当前分支的指针指回了最新的 <code>commit</code>。</strong></p></blockquote><h3 id="将多个连续的-commit-合并成一个"><a href="#将多个连续的-commit-合并成一个" class="headerlink" title="将多个连续的 commit 合并成一个"></a>将多个连续的 commit 合并成一个</h3><p>将多个 <code>commit</code> 合并成一个的原理与修改任意一个 <code>commit</code> 的原理相同，都是通过 <code>git rebase</code> 命令的交互模式实现的（<code>-i</code>），参数为合并几个 <code>commit</code> 的父级 <code>commit</code> 哈希值。</p><p><strong>查看历史：</strong></p><pre><code class="lang-git">$ git log --oneline</code></pre><pre><code class="lang-bash"># edd2400 (HEAD -&gt; test) add content to readme# 50a015c add background css# 15237d2 change css# 4a8fd80 add css content# 5149bad new READ.md# 7f73a76 new html</code></pre><p>现在我们尝试将 <code>50a015c</code>、<code>15237d2</code> 和 <code>4a8fd80</code> 这三个 <code>commit</code> 合并成一个，与修改 <code>commit</code> 唯一不同的是被修改的 <code>commit</code> 参数不再是 <code>reword</code>，而是 <code>squash</code>，多个要合并的 <code>commit</code> 之中有一个目标 <code>commit</code>，这个 <code>commit</code> 的参数必须是 <code>pick</code>。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">pick 4a8fd80 add css content- pick 15237d2 change css- pick 50a015c add background css+ squash 15237d2 change css+ squash 50a015c add background csspick edd2400 add content to readme# Rebase 5149bad..edd2400 onto 5149bad (4 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# ...</code></pre><p>对上面的交互界面保存后同样会弹出第二个交互界面，合并多个 <code>commit</code> 与修改单个 <code>commit</code> 不同的是，第二个界面会展示所有被合并 <code>commit</code> 的信息，我们可以为合并后的 <code>commit</code> 添加一个新的 <code>message</code>。</p><p><strong>第二个交互界面：</strong></p><pre><code class="lang-diff"># This is a combination of 3 commits.++ css changes+# This is the 1st commit message:add css content# This is the commit message #2:change css# This is the commit message #3:add background css# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## Date:      Tue Mar 19 14:48:22 2019 +0800## interactive rebase in progress; onto 5149bad# Last commands done (3 commands done):#    squash 15237d2 change css#    squash 50a015c add background css# Next command to do (1 remaining command):#    pick edd2400 add content to readme# You are currently rebasing branch &#39;test&#39; on &#39;5149bad&#39;.## Changes to be committed:#       new file:   index.css</code></pre><p><strong>查看合并提交后的历史：</strong></p><pre><code class="lang-git">$ git log --oneline</code></pre><pre><code class="lang-bash"># 2c84584 (HEAD -&gt; test) add content to readme# ac001bc css changes# 5149bad new READ.md# 7f73a76 new html</code></pre><h3 id="将多个间隔的-commit-合并成一个"><a href="#将多个间隔的-commit-合并成一个" class="headerlink" title="将多个间隔的 commit 合并成一个"></a>将多个间隔的 commit 合并成一个</h3><p>上面的 <code>commit</code> 合并方式可能满足不了需求，有些时候我们想把对同一个文件的提交或同一类操作的提交合并成一个，但是在历史 <code>commit</code> 中要合并的树是间隔的，使用 <code>git rebase</code> 命令同样可以做到。</p><p><strong>查看历史：</strong></p><pre><code class="lang-git">$ git log --oneline</code></pre><pre><code class="lang-bash"># 23d6939 (HEAD -&gt; test) append content into readme# 178ea29 link css in html# 2c84584 add content to readme# ac001bc css changes# 5149bad new READ.md# 7f73a76 new html</code></pre><p>在之前使用 <code>git rebase</code> 命令时都是将操作 <code>commit</code> 的父级 <code>commit</code> 作为参数，如果我们要操作的 <code>commit</code> 已经没有父级 <code>commit</code>，接下来在合并多个间隔的 <code>commit</code> 时来测试一下这样的情况，接下来将 <code>7f73a76</code> 和 <code>178ea29</code> 两个关于 <code>html</code> 文件的操作合并成一个。</p><p><strong>执行命令：</strong></p><pre><code class="lang-git">$ git rebase -i 7f73a76</code></pre><p>由于我们要操作的 <code>commit</code> 已经没有了父级，所以我们就在执行命令时传入这个 <code>commit</code>，在弹出的第一个交互界面我么明显能看到其实上面是少了我们要操作的 <code>commit</code>，所以需要手动补上，而间隔的 <code>commit</code> 要移动到和合并的目标 <code>commit</code> 连续的位置。</p><p><strong>第一个交互界面：</strong></p><pre><code class="lang-diff">+ pick 7f73a76+ squash 178ea29 link css in htmlpick 4a8fd80 add css contentpick 5149bad new READ.mdpick ac001bc css changespick 2c84584 add content to readme- pick 178ea29 link css in htmlpick 23d6939 append content into readme# Rebase 7f73a76..23d6939 onto 7f73a76 (5 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# ...</code></pre><p>在保存后出现如下报错信息，是因为 <code>commit</code> 的父节点是我们新增上去导致的。</p><p><strong>提示信息：</strong></p><pre><code class="lang-bash">The previous cherry-pick is now empty, possibly due to conflict resolution.If you wish to commit it anyway, use:    git commit --allow-emptyOtherwise, please use &#39;git reset&#39;interactive rebase in progress; onto 7f73a76Last command done (1 command done):   pick 7f73a76Next commands to do (5 remaining commands):   squash 178ea29 link css in html   pick 5149bad new READ.mdYou are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;.nothing to commit, working tree cleanCould not apply 7f73a76...</code></pre><p><strong>执行 <code>git status</code> 提示信息：</strong></p><pre><code class="lang-bash">Last command done (1 command done):   pick 7f73a76Next commands to do (5 remaining commands):   squash 178ea29 link css in html   pick 5149bad new READ.md  (use &quot;git rebase --edit-todo&quot; to view and edit)You are currently rebasing branch &#39;test&#39; on &#39;7f73a76&#39;.  (all conflicts fixed: run &quot;git rebase --continue&quot;)nothing to commit, working tree clean</code></pre><p><strong>想继续合并：</strong></p><pre><code class="lang-git">$ git rebase --continue</code></pre><p><strong>想还原回合并之前：</strong></p><pre><code class="lang-git">$ git rebase --abort</code></pre><p>如果在继续合并后没有出现第二个交互界面（与合并连续 <code>commit</code> 类似，用来新增合并后 <code>commit</code> 的信息），说明合并时出现冲突，此时需要解决冲突后将新的变更提交到暂存区，再重新执行合并命令。</p><p><strong>查看合并后的历史：</strong></p><pre><code class="lang-git">$ git log --oneline</code></pre><pre><code class="lang-bash"># 4d4f771 (HEAD -&gt; test) append content into readme# a83f526 add content to readme# 463fd85 css changes# 7e44e19 new READ.md# 753ebcd about html changes</code></pre><blockquote class="pullquote warning"><p><strong>注意：当前对 <code>commit</code> 的变更和合并操作只是对 <code>commit</code> 做了整理，并没有改变文件内容，并且这些操作仅限于要修改或合并的 <code>commit</code> 还没有共享到集成分支上去，如果已经推送到远端，进行上面操作会对其他协同开发的人员造成麻烦和困扰。</strong></p></blockquote><h3 id="删除后提交的-commit"><a href="#删除后提交的-commit" class="headerlink" title="删除后提交的 commit"></a>删除后提交的 commit</h3><p>在开发中有这样一种情景，就是我们在修改代码时提交了一个或者几个新的 <code>commit</code>，但是发现有更好的方案，想要删除这些 <code>commit</code>，这时可以通过将 <code>HEAD</code> 指针重新指向这些 <code>commit</code> 之前的提交，命令如下。</p><pre><code class="lang-git">$ git reset --hard 版本号</code></pre><p>这样的操作会导致工作区、暂存区的代码都会到这个 <code>commit</code> 的状态，当然也有 “后悔药”，可以使用 <code>git reflog</code> 找到所有的 <code>commit</code> 版本号 包含已删除），再通过同样的方式将 <code>HEAD</code> 的指针指回去。</p><pre><code class="lang-git">$ git reflog$ git reset --hard 已删除的版本号</code></pre><h2 id="忽略上传的文件"><a href="#忽略上传的文件" class="headerlink" title="忽略上传的文件"></a>忽略上传的文件</h2><p>在开发过程中，有些文件是不需要我们上传到远端的，可能因为这个文件对于开发项目来讲是无用的，如编辑器自动生成的 <code>.idea</code> 等，或者这个文件夹非常的大，如 <code>node_modules</code>，我们可以通过 <code>.gitignore</code> 文件来配置忽略上传的文件。</p><p>在 <code>.gitignore</code> 文件中有很多规则，在此不去讨论，在这里我们要说的是如果某些想要忽略的文件由于失误没有被写进 <code>.gitignore</code>，被推送到远端后，想忽略这个文件，并在下次推送的时候让远端不再有这个文件该怎么做。</p><p><strong>先将要忽略的文件添加到 <code>.gitignore</code>，然后执行下面命令对之前添加的文件进行删除操作。</strong></p><pre><code class="lang-git">$ git rm --cached 文件名/文件夹</code></pre><h2 id="在开发当中处理紧急发布（CR）任务"><a href="#在开发当中处理紧急发布（CR）任务" class="headerlink" title="在开发当中处理紧急发布（CR）任务"></a>在开发当中处理紧急发布（CR）任务</h2><p>在开发时经常有这样一种场景，在上一版本代码上线以后，突然发现线上出现 <code>Bug</code> 需要修复并紧急上线，而这个时候刚好又在同一个分支上已经有了其他的新代码，此时需要将代码还原到线上版本，并保证当前开发代码不丢失，待问题修复后，将新开发的代码合并到修复后的代码上继续开发，当然根据实际情况的不同，复杂程度也会有所差别，下面是一些思路。</p><blockquote class="pullquote success"><p><strong>当前代码跟要修复代码在同一条分支：</strong></p><ul><li><strong>将当前代码暂存；</strong></li><li><strong>修复代码后合并到 dev 发布测试环境验证，通过后发布；</strong></li><li><strong>恢复暂存代码继续开发；</strong></li></ul><pre><code class="lang-git">$ git stash$ git stash pop</code></pre></blockquote><blockquote class="pullquote info"><p><strong>当前代码跟要修复的代码不在同一条分支：</strong></p><ul><li><strong>提交当前分支代码；</strong></li><li><strong>切换到 <code>master</code> 分支创建一条新分支；</strong></li><li><strong>修复问题并提测；</strong></li><li><strong>验证通过后合并到 <code>master</code> 或 <code>dev</code> 分支发布；</strong></li><li><strong>回到开发新功能 <code>feature</code> 分支将修复代码（<code>hotfix</code>）集成进来并继续开发。</strong></li></ul><pre><code class="lang-git">$ git add .$ git commit -m &#39;message&#39;$ git checkout master$ git checkout -b 修复问题分支$ git checkout 测试分支$ git merge 修复问题分支$ git checkout 开发分支$ git rebase 测试分支</code></pre></blockquote><p>当然上面的思路仅供参考，因为不同的团队规范有所差异，问题的复杂度也不尽相同，在某些特殊时候可能要本地代码回退版本，需要借助 <code>git reset</code> 命令实现。</p><h2 id="non-fast-forwards-和-fast-forwards"><a href="#non-fast-forwards-和-fast-forwards" class="headerlink" title="non-fast-forwards 和 fast-forwards"></a>non-fast-forwards 和 fast-forwards</h2><p>在实际项目开发中我们将本地代码推送到远端的时候可能会遇到下面这样的报错信息。</p><p><strong>推送代码时的错误信息：</strong></p><pre><code class="lang-bash">error: failed to push some refs to &#39;git@github.yourRepository.git&#39;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code></pre><p><code>fast-forwards</code> 是指将本地分支推送到远端，<code>tree</code> 上两个分支拥有共同的 “祖先”，可以自动合并成一个 <code>tree</code>，而 <code>non-fast-forwards</code> 正好相反，两个分支的 <code>tree</code> 是完全独立的，没有任何联系，一般会造成这种现象的原因是推送的目标分支和我们当前分支拥有不同的代码，所以我们需要将推送的目标分支和本地分支的 <code>tree</code> 整理成 <code>fast-forwards</code> 的状态。</p><p>实现方式就是先拉取远端分支在本地进行处理（如果有冲突先处理冲突），变成 <code>fast-forwards</code> 状态后再进行推送，拉取远端分支可以使用 <code>fetch</code> 或 <code>pull</code>，区别在于 <code>fetch</code> 拉取回来的代码仍然是 <code>non-fast-forwards</code> 状态，需要手动 <code>merge</code> 进行合并或 <code>rebase</code>（因为有些团队比较喜欢线性的提交记录以便追溯）操作，而 <code>pull</code> 将 <code>fetch</code> 和 <code>merge</code> 这两个步骤合二为一。</p><blockquote class="pullquote default"><p><strong>注意：使用 <code>fetch</code> 拉取代码在进行 <code>merge</code> 时存在一种特殊情况，就是这个仓库的代码是第一次被拉取到本地（与本地分支没有共同的提交），且与本地代码的差异是新建仓库时添加 <code>README.md</code> 等文件造成的，则需要在 <code>merge</code> 时加上 <code>--allow-unrelated-histories</code> 参数去允许历史上完全独立的两棵树进行合并，达到 <code>fast-forwards</code> 的状态。</strong></p></blockquote><p><strong>合并不相关的树：</strong></p><pre><code class="lang-git">$ git merge 本地分支 --allow-unrelated-histories 远端分支</code></pre><p>执行命令后会弹出交互界面可以修改本次合并的 <code>message</code>。</p><h2 id="Git-多人单分支集成协作"><a href="#Git-多人单分支集成协作" class="headerlink" title="Git 多人单分支集成协作"></a>Git 多人单分支集成协作</h2><h3 id="多人协同开发时本地仓库与远端的同步"><a href="#多人协同开发时本地仓库与远端的同步" class="headerlink" title="多人协同开发时本地仓库与远端的同步"></a>多人协同开发时本地仓库与远端的同步</h3><p>在项目的开发迭代中，我们习惯每一个版本迭代都新建一个分支开发，并推送到远端，如果多个人同时要在这个分支开发该迭代的新功能，而以前又已经克隆过这个项目到本地，此时除了这条分支的创建者以外，其他人查看远端分支时是看不见这个新建分支的，需要执行以下命令对仓库进行同步并开发。</p><p><strong>同步新分支信息：</strong></p><pre><code class="lang-git">$ git fetch 地址别名</code></pre><p><strong>查看新分支：</strong></p><pre><code class="lang-git">$ git branch -av</code></pre><p><strong>拉取新分支到本地：</strong></p><pre><code class="lang-git">$ git checkout -b 新分支名 地址别名/新分支名</code></pre><p>还有一种场景也需要通过上面的方式来同步仓库信息，就是在 <code>Github</code> 中帮助别人的项目贡献代码或修复 <code>Issue</code> 时，首先需要 <code>Fork</code> 别人的仓库，但是 <code>Fork</code> 过来的仓库代码并不会随着原作者仓库的代码更新而更新，为了在开发之前使 <code>Fork</code> 的仓库和原作者仓库代码及分支保持一致，执行上面命令，开发完毕后再通过给原作者提交 <code>push request</code> 的方式让原作者进行代码审核并合并到原始仓库。</p><h3 id="不同人修改不同文件的处理方式"><a href="#不同人修改不同文件的处理方式" class="headerlink" title="不同人修改不同文件的处理方式"></a>不同人修改不同文件的处理方式</h3><p>在实际开发中，两个人在一条分支开发，当 <code>A</code> 同学修改了 <code>a</code> 文件，<code>B</code> 同学修改了 <code>b</code> 文件时，此时 <code>B</code> 同学先进行了提交，<code>A</code> 同学并不知道的情况下，在 <code>A</code> 同学推送代码到远端时会变成 <code>non-fast-forwards</code> 状态（推送失败），并提示超前一个版本，落后一个版本，意思是本地代码有一个提交远端没有，远端代码有一个提交本地没有，一般情况下大多数的处理是选择先拉去远端代码进行合并，再推送到远端。</p><p>由于两个人修改的是不同文件，在拉取远端代码后合并会比较顺利，并不会产生冲突，但同时产生新的问题，就是多了一条关于合并的提交记录，如果想让提交的历史树更干净整洁，也有另一种做法，就是推送失败的一方主动将本地 <code>commit</code> 回退到与远端完全一致的 <code>commit</code> 版本，主动拉取代码与工作区合并，再重新提交到本地版本库并推送到远端。</p><p><strong>撤销本地新的提交：</strong></p><pre><code class="lang-git">$ git reset 与远端相同的提交</code></pre><h3 id="不同的人修改相同文件不同区域的处理方式"><a href="#不同的人修改相同文件不同区域的处理方式" class="headerlink" title="不同的人修改相同文件不同区域的处理方式"></a>不同的人修改相同文件不同区域的处理方式</h3><p>我们将上面 <code>A</code>、<code>B</code> 两个同学的操作场景稍微做些改动，就是两个人同时操作了同一个文件的不同区域，此时如果 <code>B</code> 先提交到远端，<code>A</code> 不知情的情况下推送代码到远端，一样会变成 <code>non-fast-forwards</code>，同样可以通过上面的方式处理，<code>Git</code> 比较智能，可以将两个平行的修改过不同区域的文件进行合并，变成 <code>fast-forwards</code> 状态。</p><h3 id="不同的人修改相同文件相同区域的处理方式"><a href="#不同的人修改相同文件相同区域的处理方式" class="headerlink" title="不同的人修改相同文件相同区域的处理方式"></a>不同的人修改相同文件相同区域的处理方式</h3><p>依然沿用上面 <code>A</code>、<code>B</code> 同学的操作场景，不同的是这次两人修改了相同文件的相同区域，<code>B</code> 先提交到远端，<code>A</code> 在提交到远端时有因为状态为 <code>non-fast-forwards</code> 被拒绝，同样的方式处理时发现了新的问题，代码虽然成功拉合并，但是控制台报错了。</p><p><strong>合并后报错：</strong></p><pre><code class="lang-bash">...Auto-merging yourfileCONFLICT (content): Merge conflict in yourfileAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>由于两个人操作了同一个区域导致 <code>Git</code> 无法判断两个内容应该怎样去保留或替换，所以将合并失败的错误抛出让开发者认为的介入。</p><blockquote class="pullquote danger"><p><strong>在解决冲突时可能存在的情况：</strong></p><ul><li><strong>两人将都要保留的功能代码写在了相同文件的相同区域，这种情况需要都保留；</strong></li><li><strong>两个人开发功能重复了，需要进行沟通协商决定保留哪一个。</strong></li></ul></blockquote><p>在手动处理冲突对文件进行合并时，可以通过 <code>git status</code> 查看合并后的状态，如果这个人为的合并是需要的可以创建一个新的提交推送到远端，如果觉得没有处理好，可以执行下面命令还原到合并之前。</p><p><strong>撤销合并：</strong></p><pre><code class="lang-git">$ git merge --abort</code></pre><h3 id="不同的人同时变更文件名的处理方式"><a href="#不同的人同时变更文件名的处理方式" class="headerlink" title="不同的人同时变更文件名的处理方式"></a>不同的人同时变更文件名的处理方式</h3><p>在不同人同时修改同一个文件名时，<code>Git</code> 时无法处理的，当然会变成 <code>non-fast-forwards</code> 状态，在通过常规的处理后，本地会出现两个文件，分别为两人所更改的文件名，这时需要两个人进行协商，保留协商后的文件名，删除多余的文件并推送到远端让其他人进行同步。</p><pre><code class="lang-git">$ git rm oldfilename$ git add newfilename$ git commit -m &#39;merge message&#39;$ git push</code></pre><blockquote class="pullquote success"><p><strong>在一个人修改文件名，其他人修改内容的情况下，<code>Git</code> 的文件内容都是通过</strong> <a href="/20190310233856/#tree%E3%80%81commit%E3%80%81blob-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank">blob</a> <strong>对象进行存储，而非文件的形式，所以当多人协同某个人对文件名进行变更时 <code>Git</code> 可以非常智能的检测并同步。</strong></p></blockquote><h3 id="禁止在已共享的集成分支使用强推"><a href="#禁止在已共享的集成分支使用强推" class="headerlink" title="禁止在已共享的集成分支使用强推"></a>禁止在已共享的集成分支使用强推</h3><p>“强推” 是指使用 <code>git push -f</code> 将本地分支推送到远端，之前在多人写作中远程分支拒绝推送的原因都是因为 <code>non-fast-forwards</code> 状态，我们可以理解为这是 <code>Git</code> 防止代码被推送到远端而产生冲突的一种保护机制，而 “强推” 就是忽略了 <code>non-fast-forwards</code> 状态强行将代码推送到远端。</p><blockquote class="pullquote danger"><p><strong>在大部分团队中都是禁止在集成分支使用这条命令的，可能会在远端产生冲突只是原因之一，操作不正确也可能导致远端集成分支整个团队的提交历史丢失的严重后果，比如当前本地分支版本远远落后于远端，此时直接推送会进入 <code>non-fast-forwards</code> 状态，远端拒绝推送，而向远端 “强推”，远端在这个本地版本库 <code>HEAD</code> 指向的 <code>commit</code> 之后所有的提交历史都将丢失。</strong></p></blockquote><h3 id="禁止在已共享的集成分支上做变基操作"><a href="#禁止在已共享的集成分支上做变基操作" class="headerlink" title="禁止在已共享的集成分支上做变基操作"></a>禁止在已共享的集成分支上做变基操作</h3><p>还记得前面 <a href="/20190315115008/#修改本地-commit">修改本地 commit</a> 一节中强调 <code>rebase</code> 操作只适用于修改本地还未同步到远端的 <code>commit</code>，这是因为如果对已经同步到远端的进行了变基操作会导致 <code>commit</code> 的版本号发生变化，如果推送到远端，此时协同开发的人是基于远端旧的 <code>commit</code> 之上在做新的开发，会导致无法将本地代码推送到远端。</p><blockquote class="pullquote warning"><p><strong>有些团队严令禁止对集成分支做变基操作，被称作 “<code>rebase</code> 黄金定律”，如果一定要对集成分支做变基操作的，一定要在当前远端最后的 <code>commit</code> 之后做变基操作。</strong></p></blockquote><p>如果不幸真的有同事这样去做了，我们虽然会很恼火，但也还是有办法去解决这样的问题，可以直接执行下面命令：</p><pre><code class="lang-git">$ git pull --rebase</code></pre><p>或者分为两步走，把远端变基后的分支 <code>fetch</code> 到本地，再把本地的当前分支基于 <code>fetch</code> 下来的远端分支做 <code>rebase</code> 操作，命令如下：</p><pre><code class="lang-git">$ git fetch$ git rebase 地址别名/分支名</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote info"><p><strong>本文内容是自己在对 <code>Git</code> 的学习和工作中总结的笔记，另外想了解 <code>rebase</code> 和 <code>merge</code> 更详细的信息推荐阅读</strong> <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank">git rebase vs git merge 详解</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190315115008/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git 系列之 .git 内部刨析</title>
      <link>https://www.overtaking.top/20190310233856/</link>
      <guid>https://www.overtaking.top/20190310233856/</guid>
      <pubDate>Sun, 10 Mar 2019 15:38:56 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Git/20190310233856/git.jpg&quot; title=&quot;.git 内部刨析&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;HEAD-文件&quot;&gt;&lt;a href=&quot;#HEAD-文件&quot; class=&quot;headerlink&quot; title=&quot;HEAD 文件&quot;&gt;&lt;/a&gt;HEAD 文件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;HEAD&lt;/code&gt; 文件内容：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;lang-vim&quot;&gt;ref: refs/heads/master
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ref&lt;/code&gt; 代表引用，&lt;code&gt;refs/heads/master&lt;/code&gt; 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支操作时，&lt;code&gt;HEAD&lt;/code&gt; 文件中的 &lt;code&gt;ref&lt;/code&gt; 值会随着切换的分支变化。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Git/20190310233856/git.jpg" title=".git 内部刨析"><p><br></p><h2 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h2><p><strong><code>HEAD</code> 文件内容：</strong></p><pre><code class="lang-vim">ref: refs/heads/master</code></pre><blockquote class="pullquote info"><p><strong><code>ref</code> 代表引用，<code>refs/heads/master</code> 代表当前引用所指向的分支，即当前工作区所在的分支，当执行切换分支操作时，<code>HEAD</code> 文件中的 <code>ref</code> 值会随着切换的分支变化。</strong></p></blockquote><a id="more"></a><h2 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h2><p><strong><code>config</code> 文件基本内容：</strong></p><pre><code class="lang-vim">[core]    repositoryformatversion = 0    filemode = true    bare = false    logallrefupdates = true    ignorecase = true    precomposeunicode = true[user]    name = yourname    email = youremail</code></pre><blockquote class="pullquote warning"><p><strong><code>[core]</code> 代表当前 <code>Git</code> 管理中的主要配置，<code>[user]</code> 代表用户配置，随着 <code>Git</code> 管理的不断复杂，所有的配置项都将被存放在 <code>config</code> 文件中。</strong></p></blockquote><h2 id="refs-文件夹"><a href="#refs-文件夹" class="headerlink" title="refs 文件夹"></a>refs 文件夹</h2><h3 id="分支-heads"><a href="#分支-heads" class="headerlink" title="分支 heads"></a>分支 heads</h3><p><code>heads</code> 文件夹存储的是本地所有分支文件，文件名与分之名一一对应，文件内容为当前分支所在的提交历史记录的 <code>commit</code> 对象。</p><p><strong>查看 <code>heads</code> 文件夹：</strong></p><pre><code class="lang-bash">$ ls -al .git/refs/heads# drwxr-xr-x  3 systemname  staff   96  2 24 17:31 .# drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..# -rw-r--r--  1 systemname  staff   41  2 24 17:31 master</code></pre><p><strong>查看分支文件：</strong></p><pre><code class="lang-bash">$ cat .git/refs/tags/master# ef5aaed0707989ebc069efcd842424f6315ab4e2</code></pre><pre><code class="lang-git">$ git cat-file -t ef5aaed0707989ebc069efcd842424f6315ab4e2# commit</code></pre><blockquote class="pullquote primary"><p><strong>其实使用 <code>git checkout</code> 命令切换分支时，就是在更改 <code>HEAD</code> 文件的引用内容，即上面提到的 <code>ref: refs/heads/branchname</code>，进而找到 <code>heads</code> 文件夹内对应的分支文件内的提交记录，将工作区代码还原到该提交记录的版本。</strong></p></blockquote><h3 id="标签-tags"><a href="#标签-tags" class="headerlink" title="标签 tags"></a>标签 tags</h3><p>在项目开发中，经常会在某些阶段达到某一个 “里程碑”，比如版本从 <code>v0.0.1</code> 开发到 <code>v1.0.0</code>，可以专门为这个版本的 <code>commit</code> 打上一个标签，而 <code>refs/tags</code> 文件夹就是用来存放这些标签的（文件名与标签名相同），每一个标签文件内存储的是这个 “里程碑” 提交的历史记录的 <code>tag</code> 对象，<code>tag</code> 对象中存储着当前标签对应历史版本的 <code>commit</code> 对象。</p><p><strong>查看 <code>tags</code> 文件夹：</strong></p><pre><code class="lang-bash">$ ls -al .git/refs/tags# drwxr-xr-x  6 systemname  staff  192  2 24 17:31 .# drwxr-xr-x  5 systemname  staff  160  2 12 17:35 ..# -rw-r--r--  1 systemname  staff   41  2 15 18:33 1.0.0</code></pre><p><strong>查看标签文件：</strong></p><pre><code class="lang-bash">$ cat .git/refs/tags/1.0.0# ef5aaed0707989ebc069efcd842424f6315ab4e2</code></pre><pre><code class="lang-git">$ git cat-file -p ef5aaed0707989ebc069efcd842424f6315ab4e2# object bcadbfea5e937e9b5eaed113dd8149c86124d72a# type commit# tag 1.0.0# tagger yourusername &lt;youruseremail&gt; 1550212832 +0800$ git cat-file -t bcadbfea5e937e9b5eaed113dd8149c86124d72a# commit</code></pre><blockquote class="pullquote success"><p><strong>可以使用 <code>git cat-file</code> 命令查看文件对象类型。</strong></p></blockquote><h2 id="objects-文件夹"><a href="#objects-文件夹" class="headerlink" title="objects 文件夹"></a>objects 文件夹</h2><h3 id="查看-objects-内部"><a href="#查看-objects-内部" class="headerlink" title="查看 objects 内部"></a>查看 objects 内部</h3><pre><code class="lang-bash">$ ls -al .git/objects# drwxr-xr-x  72 systemname  staff  2304  2 24 17:31 .# drwxr-xr-x  13 systemname  staff   416  3 14 15:43 ..# drwxr-xr-x   4 systemname  staff   128  2 24 17:29 00# ...# drwxr-xr-x   3 systemname  staff    96  2 24 17:29 f9# drwxr-xr-x   2 systemname  staff    64  2 12 16:59 info# drwxr-xr-x   2 systemname  staff    64  2 12 16:59 pack</code></pre><p>在 <code>objects</code> 文件夹中，除了 <code>info</code> 和 <code>pack</code> 存储的都是十六进制命名的文件夹，在文件夹内部存储着以哈希值命名的文件，在 <code>Git</code> 中的策略是将十六进制文件名和哈希值的文件名进行组合，使用 <code>git cat-file</code> 可以查看该完整哈希值的对象类型，肯能为 <code>tree</code>、<code>blob</code>、<code>commit</code>。</p><blockquote class="pullquote default"><p><strong><code>Git</code> 对象：</strong></p><ul><li><strong><code>tree</code>：树对象，存储内容为 <code>blob</code> 对象的哈希值和对应的文件名称；</strong></li><li><strong><code>blob</code>：存储文件内容，只要文件内容相同，则始终生成唯一一个 <code>blob</code> 对象；</strong></li><li><strong><code>commit</code>：存储提交的相关信息。</strong></li></ul></blockquote><h3 id="tree、commit、blob-对象的关系"><a href="#tree、commit、blob-对象的关系" class="headerlink" title="tree、commit、blob 对象的关系"></a>tree、commit、blob 对象的关系</h3><p>在 <code>Git</code> 中最重要的就是这三个对象以及它们之间的关系，这对于理解 <code>Git</code> 的原理非常有帮助，下面有一张关系图。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/Git/20190310233856/git-objects.png" alt="tree、commit、blob 关系图"></div><div class="image-caption">tree、commit、blob 关系图</div></figure><p><br></p><p><code>commit</code> 对象中，<code>tree</code> 代表提交时所在的树，一个 <code>commit</code> 对象只会对应一棵树，<code>tree</code> 对象存储的只是当前 <code>commit</code> 时，所有文件目录的一个 “快照”，<code>tree</code> 对象中的 <code>tree</code> 对象代表该文件夹中还有文件夹，<code>tree</code> 中的 <code>blob</code> 对象代表文件，<code>blob</code> 对象中存储的是文件内容，<code>Git</code> 在这里存储时忽略文件名，只要文件内容一样就只会存储一份，大大的节约了存储空间。</p><blockquote class="pullquote info"><p><strong><code>blob</code> 对象是在将文件增加到暂存区后创建的，<code>commit</code> 和 <code>tree</code> 对象在进行提交操作后创建。</strong></p></blockquote><h2 id="hooks-文件夹"><a href="#hooks-文件夹" class="headerlink" title="hooks 文件夹"></a>hooks 文件夹</h2><p><code>hooks</code> 文件夹，默认存储了一系列的 <code>hook</code> 文件，用于在执行某些特定的 <code>Git</code> 命令时，在某个生命周期执行，内部可以编写 <code>shell</code> 脚本，也可以通过 <code>hasky</code> 等 <code>npm</code> 包来介入。</p><p><strong>例如下面文件：</strong></p><pre><code class="lang-bash"># ...pre-commit.sample # 提交前执行pre-push.sample # 推送前执行pre-rebase.sample # 变基前执行# ...</code></pre><blockquote class="pullquote danger"><p><strong>上面的文件默认扩展名为 <code>sample</code>，即默认不生效，要想在某个 <code>Git</code> 操作时可以执行对应的 <code>hook</code> 文件，只需要去掉对应 <code>hook</code> 文件的扩展名即可。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20190310233856/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 应用篇</title>
      <link>https://www.overtaking.top/20181115105656/</link>
      <guid>https://www.overtaking.top/20181115105656/</guid>
      <pubDate>Thu, 15 Nov 2018 02:56:56 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Compile/20181115105656/webpack-use.jpg&quot; title=&quot;webpack use&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;系列文章链接：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/20181002041434/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 基础篇&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/20181110203121/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 优化篇&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;多页面打包通用方案&quot;&gt;&lt;a href=&quot;#多页面打包通用方案&quot; class=&quot;headerlink&quot; title=&quot;多页面打包通用方案&quot;&gt;&lt;/a&gt;多页面打包通用方案&lt;/h2&gt;&lt;h3 id=&quot;多页面应用简介&quot;&gt;&lt;a href=&quot;#多页面应用简介&quot; class=&quot;headerlink&quot; title=&quot;多页面应用简介&quot;&gt;&lt;/a&gt;多页面应用简介&lt;/h3&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;多页面（&lt;code&gt;MPA&lt;/code&gt;）和单页面（&lt;code&gt;SPA&lt;/code&gt;）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 &lt;code&gt;.html&lt;/code&gt; 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181115105656/webpack-use.jpg" title="webpack use"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181002041434/" target="_blank">Webpack4 —— 基础篇</a></li><li><a href="/20181110203121/" target="_blank">Webpack4 —— 优化篇</a></li></ul></blockquote><h2 id="多页面打包通用方案"><a href="#多页面打包通用方案" class="headerlink" title="多页面打包通用方案"></a>多页面打包通用方案</h2><h3 id="多页面应用简介"><a href="#多页面应用简介" class="headerlink" title="多页面应用简介"></a>多页面应用简介</h3><blockquote class="pullquote info"><p><strong>多页面（<code>MPA</code>）和单页面（<code>SPA</code>）是对应用两种不同的处理方式，单页面应用一般是只有一个主页面，其他的页面切换都是靠路由和组件切换来实现，多页应用是每次跳转的时候服务端会返回一个新的 <code>.html</code> 页面，每一个页面是一个独立的应用，只是多个应用之间共用了同一个域名。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote danger"><p><strong>多页面的优势是页面与页面之间是相互解耦的，对 <code>SEO</code> 更加友好，缺点是每次新增或删除页面都需要更改构建的配置。</strong></p></blockquote><h3 id="基础的多页面配置"><a href="#基础的多页面配置" class="headerlink" title="基础的多页面配置"></a>基础的多页面配置</h3><pre><code class="lang-js">const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = {  entry: {    admin: path.resolve(__dirname. &#39;src/pages/admin/index.js&#39;),    search: path.resolve(__dirname. &#39;src/pages/search/index.js&#39;)  },  output: {    filename: &#39;[name][chunkhash:8].js&#39;,    path: &#39;./dist&#39;  },  plugins: [    new HtmlWebpackPlugin({      template: &#39;./src/index.html&#39;, // 模板文件路径      filename: &#39;index.html&#39;, // 输出文件名称      // ...    }),    new HtmlWebpackPlugin({      template: &#39;./src/search.html&#39;,      filename: &#39;search.html&#39;,      // ...    }),  ]  // ...}</code></pre><p>上面是一个基础的多页面配置，如果开发过程成页面的增加非常快速，且多人同时开发，这样每增加一个页面都需要在 <code>entry</code> 中增加一个入口，在 <code>plugins</code> 中增加一个 <code>HtmlWebpackPlugin</code> 插件的实例，这样的维护方式并不优雅。</p><p>我们更希望增加页面时不需要更改 <code>Webpack</code> 配置文件，而是可以动态的向 <code>entry</code> 和 <code>plugins</code> 中添加配置。</p><h3 id="动态的多页面配置"><a href="#动态的多页面配置" class="headerlink" title="动态的多页面配置"></a>动态的多页面配置</h3><p>按照上面的优化思路，我们需要在 <code>Webpack</code> 配置中读取本地某一个固定目录的文件，以知道有哪些页面需要配置，当然我们可以使用 <code>fs</code> 模块自己实现，在这里更推荐使用 <code>glob</code> 模块，<code>glob</code> 模块可以通过通配符的方式按照定义的规则去匹配文件目录。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install glob html-webpack-plugin -D</code></pre><p><strong>动态生成页面配置：</strong></p><pre><code class="lang-js">const path = require(&#39;path&#39;);const glob = require(&#39;glob&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const setMPA = () =&gt; {  const entry = {};  const htmlPlugins = [];  const pathMatch = path.resolve(__dirname, &#39;./src/pages/*/index.js&#39;)  const entryFiles = glob.sync(pathMatch);  entryFiles.map((pagePath) =&gt; {    const pageName = pagePath.match(/.*\/(.*)\/index.js/)[1];    entry[pageName] = pagePath;    htmlPlugins.push(new HtmlWebpackPlugin({      template: &#39;./src/pages/&#39; + pageName + &#39;/index.html&#39;, // 模板文件路径      filename: pageName + &#39;.html&#39;, // 输出文件名称      chunks: [pageName], // 使用的 chunk 名称      inject: true, // 将 js 资源放在 body 底部      minify: {        collapseWhitespace: true, // 是否删除空白符与换行符        removeAttributeQuotes: true, // 是否移除引号        minifyCSS: true, // 压缩 CSS        minifyJS: true, // 压缩 JS        removeComments: true // 是否移除 HTML 中的注释      }    }));  });  return {    entry,    htmlPlugins  };}module.exports = setMPA();</code></pre><p>首先我们创建一个模块，模块中创建 <code>setMPA</code> 函数专门用来对页面进行动态化处理，函数返回 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的实例，首先通过 <code>glob</code> 的 <code>sync</code> 同步读取本地目录 <code>pages</code> 下的文件，获取页面文件的绝对路径（数组），循环的过程中匹配页面名称，并根据页面名称动态的创建 <code>entry</code> 和 <code>HtmlWebpackPlugin</code>。</p><p><strong>动态化配置示例：</strong></p><pre><code class="lang-js">const path = require(&#39;path&#39;);const {entry, htmlPlugins} = require(&#39;./setMPA&#39;);module.exports = {  entry,  output: {    path: path.resolve(__dirname, &#39;dist&#39;),    filename: &#39;[name][chunkhash:8].js&#39;  },  plugins: [    ...htmlPlugins  ]}</code></pre><p>在 <code>Webpack</code> 配置中只需要引入 <code>setMPA</code> 模块，解构出 <code>entry</code> 和 <code>HtmlWebpackPlugin</code> 的集合，并写在对应的配置上，这样就化解了有人新增页面就要增加对应页面配置的尴尬。</p><h2 id="集成-ESlint"><a href="#集成-ESlint" class="headerlink" title="集成 ESlint"></a>集成 ESlint</h2><h3 id="ESlint-介绍"><a href="#ESlint-介绍" class="headerlink" title="ESlint 介绍"></a>ESlint 介绍</h3><p><code>ESlint</code> 的作用是对项目的 <code>JS</code> 代码进行规范检查和风格统一，可以减少代码中的隐患和潜在问题，团队越大开发人员越多体现越明显，团队也可以根据实际情况制定规范。</p><p><code>ESlint</code> 可以与 <code>lint-staged</code> 和 <code>husky</code> 等模块在代码提交阶段进行检测，可以与 <code>Gitlab</code> 和 <code>Github</code> 等代码管理平台中的 <code>CI/CD</code> 进行集成，也可以在发布平台云构建过程中进行规范检查。</p><pre><code class="lang-json">/* package.json */{  &quot;script&quot;: {    &quot;precommit&quot;: &quot;lint-staged&quot;  },  &quot;husky&quot;: {    &quot;hooks&quot;: {      &quot;pre-commit&quot;: &quot;lint-staged&quot;    }  },  &quot;lint-staged&quot;: {    &quot;linters&quot;: {      &quot;*.{js,scss}&quot;: [        &quot;eslint --fix&quot;,        &quot;git add&quot;      ]    }  }}</code></pre><p>也有些优秀的 <code>ESlint</code> 规范模块可以使用，如腾讯的 <code>eslint-config-airbnb</code>、<code>eslint-config-airbnb-base</code> 等。</p><h3 id="Webpack-中使用-ESlint"><a href="#Webpack-中使用-ESlint" class="headerlink" title="Webpack 中使用 ESlint"></a>Webpack 中使用 ESlint</h3><p>也可以在 <code>Webpack</code> 构建中集成 <code>ESlint</code> 规范检查，需要借助 <code>eslint-loader</code>，如果代码不符合 <code>ESlint</code> 规范，构建会中断。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader eslint-loader -D</code></pre><p><strong><code>Webpack</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  module: {    rules: [      // ...      {        test: /.js$/,        exclude: /node_modules/, // 排除项        use: [          &#39;babel-loader&#39;,          &#39;eslint-loader&#39;        ]      }      // ...    ]  }}</code></pre><p><strong><code>ESlint</code> 配置示例：</strong></p><pre><code class="lang-js">/* .eslint.js */module.exports = {  parser: &#39;babel-eslint&#39;, // 使用的 eslint 规范  extends: [&#39;airbnb&#39;], // 继承的 eslint 规犯  // 启用的环境  env: {    browser: true,    node: true  }  // 自定义规则  rules: {    // 规则名称    indent: [      &#39;error&#39;, // 错误级别      2 // 配置项的值    ]  }}</code></pre><blockquote class="pullquote success"><p><strong>自定义 <code>ESlint</code> 规则或想要根据成熟的 <code>ESlint</code> 规则做定制化修改，可以在 <code>.eslintrc</code> 、<code>.eslint.js</code> 或 <code>.eslint.yml</code> 文件中进行配置。</strong></p></blockquote><h2 id="通过-Webpack-构建组件和基础库"><a href="#通过-Webpack-构建组件和基础库" class="headerlink" title="通过 Webpack 构建组件和基础库"></a>通过 Webpack 构建组件和基础库</h2><h3 id="构建描述"><a href="#构建描述" class="headerlink" title="构建描述"></a>构建描述</h3><p>这里所说的打包组件和基础库其实就是 “造轮子” 时，对于自己封装的模块进行构建，在做这个事情的时候使用 <code>rollup</code> 其实更适合，因为 <code>rollup</code> 更纯粹，也更简单一些，<code>Webpack</code> 功能比较强大，除了对于平时开发的业务项目进行构建，对于打包组件和基础库也完全胜任。</p><blockquote class="pullquote warning"><p><strong>开发组件或基础库通常需要满足下面两个要求：</strong></p><ul><li><strong>输出的文件要构建成压缩版本和非压缩版本，非压缩版本用于开发阶段，压缩版本用于线上；</strong></li><li><strong>要支持多种模块化方式，如 <code>AMD</code>、<code>CommonJS</code>、<code>ES-Module</code> 以及 <code>script</code> 标签引入。</strong></li></ul></blockquote><p><strong>各种引入方式：</strong></p><pre><code class="lang-js">/* AMD */require([&#39;large-number&#39;], function (largeNumber) {  largeNumber.add(&#39;999&#39;, &#39;1&#39;);})</code></pre><pre><code class="lang-js">/* CommonJS */const largeNumber = require(&#39;large-number&#39;);largeNumber.add(&#39;999&#39;, &#39;1&#39;);</code></pre><pre><code class="lang-js">/* ES-Module */import * as largeNumber from &#39;large-number&#39;;largeNumber.add(&#39;999&#39;, &#39;1&#39;);</code></pre><pre><code class="lang-html">&lt;!-- script --&gt;&lt;script src=&quot;//xxcnd/large-number.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  largeNumber.add(&#39;999&#39;, &#39;1&#39;);&lt;/script&gt;</code></pre><h3 id="构建一个基础库"><a href="#构建一个基础库" class="headerlink" title="构建一个基础库"></a>构建一个基础库</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>下面我们封装一个计算大数字加法的库，并把这个库作为第三方模块使用 <code>Webpack</code> 进行构建，项目目录结构如下：</p><pre class="language-treeview">  <code class="language-treeview">    large-number      |- dist      | |- large-number.js      | |- large-number.min.js      |- src      | |- index.js      |- index.js      |- package.json      |- webpack.config.js  </code></pre><blockquote class="pullquote primary"><ul><li><strong><code>dist</code> 是我们希望输出的目录，<code>large-number.js</code> 为非压缩版，<code>large-number.min.js</code> 为非压缩版；</strong></li><li><strong><code>src</code> 是构建的目录，<code>index.js</code> 是大整数加法功能函数所在文件；</strong></li><li><strong><code>index.js</code>：入口文件；</strong></li><li><strong><code>package.josn</code>：依赖配置文件；</strong></li><li><strong><code>webpack.config.js</code>：<code>Webpack</code> 配置文件。</strong></li></ul></blockquote><h4 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h4><pre><code class="lang-js">/* ~src/index.js */export default function add(a, b) {  // 相加两数的当前位的指针  let i = a.length - 1;  let j = b.length - 1;  let carry = 0; // 是否进位  let ret = &#39;&#39;; // 最后输出结果  // 循环，个位个位相加，十位十位相加...  while (i &gt;= 0 || j &gt;= 0) {    let x = 0; // a 的当前位    let y = 0; // b 的当前位    let sum; // 当前位数的和    // 如果存在当前位数将 a 的数字转化为数字，并将指针指向上一位    if (i &gt;= 0) {      x = a[i] - &#39;0&#39;;      i--;    }    // 如果存在当前位数将 b 的数字转化为数字，并将指针指向上一位    if (j &gt;= 0) {      y = b[j] - &#39;0&#39;;      j--;    }    sum = x + y + carry; // 求总和    // 如果总和大于 10 进位，并修正当前位数    if (sum &gt;= 10) {      carry = 1;      sum -= 10;    } else {      carry = 0;    }    ret = sum + ret; // 将求和数子转换字符串  }  // 循环结束，如果仍然存在进位，则将进位的值与之前结果拼接  if (carry) {    ret = carry + ret;  }  return ret; // 返回最终结果}</code></pre><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><pre><code class="lang-json">{  &quot;name&quot;: &quot;large-number&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;大整数加法&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack&quot;,    &quot;prepublish&quot;: &quot;npm run build&quot;  },  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: {    &quot;terser-webpack-plugin&quot;: &quot;^2.1.3&quot;,    &quot;webpack&quot;: &quot;^4.41.2&quot;,    &quot;webpack-cli&quot;: &quot;^3.3.9&quot;  }}</code></pre><p>其中 <code>main</code> 是模块指定执行的文件，指向根目录的主文件。</p><h4 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h4><pre><code class="lang-js">/* index.js */if (process.env.NODE_ENV === &#39;production&#39;) {  module.exports = require(&#39;./dist/large-number.min.js&#39;);} else {  module.exports = require(&#39;./dist/large-number.js&#39;);}</code></pre><p>主文件中根据当前的引用环境区分提供压缩版和非压缩文件版。</p><h4 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h4><p>下面是整个模块构建最重要的，就是 <code>Webpack</code> 的配置文件。</p><pre><code class="lang-js">/* webpack.config.js */const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);module.exports = {  mode: &#39;none&#39;,  entry: {    &#39;large-number&#39;: &#39;./src/index.js&#39;,    &#39;large-number.min&#39;: &#39;./src/index.js&#39;  },  output: {    filename: &#39;[name].js&#39;,    library: &#39;largeNumber&#39;,    libraryExport: &#39;default&#39;,    libraryTarget: &#39;umd&#39;  },  optimization: {    minimize: true,    minimizer: [      // 压缩的同时转换 ES6 语法，基于 uglifyPlugin 改造      new TerserWebpackPlugin({        include: /\.min\.js$/      })    ]  }}</code></pre><blockquote class="pullquote success"><p><strong>配置文件参数解析：</strong></p><ul><li><strong><code>entry</code>：</strong><ul><li><strong><code>large-number</code>：压缩版入口文件路径；</strong></li><li><strong><code>large-number.min</code>：非压缩版入口文件路径。</strong></li></ul></li><li><strong><code>output</code>：</strong><ul><li><strong><code>filename</code>：出口文件名；</strong></li><li><strong><code>library</code>：导出的文件所提供的全局变量名；</strong></li><li><strong><code>libraryExport</code>：默认值为 <code>default</code>，如不配置访问导出对象的<code>default</code> 属性才可以获取对应的方法；</strong></li><li><strong><code>libraryTarget</code>：打包的模块规则，如 <code>CommonJS</code>，<code>ES-Module</code> 等，详情见</strong> <a href="https://webpack.js.org/configuration/output/#outputlibrarytarget" target="_blank">Webpack 官网</a><strong>。</strong></li></ul></li><li><strong><code>TerserWebpackPlugin</code>：基于 <code>UglifyPlugin</code> 插件实现的，相较于 <code>UglifyPlugin</code>，压缩的同时可以转换 <code>ES6</code> 语法。</strong><ul><li><strong><code>include</code>：属性的值为正则，默认匹配了 <code>large-number.min.js</code> 文件。</strong></li></ul></li></ul></blockquote><h2 id="构建-SSR-应用"><a href="#构建-SSR-应用" class="headerlink" title="构建 SSR 应用"></a>构建 SSR 应用</h2><h3 id="为什么要有-SSR-应用"><a href="#为什么要有-SSR-应用" class="headerlink" title="为什么要有 SSR 应用"></a>为什么要有 SSR 应用</h3><blockquote class="pullquote default"><p><strong>通常的客户端渲染流程如下：</strong></p><ul><li><strong>开始加载（白屏）；</strong></li><li><strong><code>HTML</code> 加载成功（提供 <code>loading</code>）;</strong></li><li><strong>请求 <code>CSS</code>、<code>JS</code> 等资源；</strong></li><li><strong>解析 <code>CSS</code>、<code>JS</code> 等资源；</strong></li><li><strong>页面渲染样式、执行 <code>JS</code> 逻辑；</strong></li><li><strong>如发送数据、图片请求；</strong></li><li><strong>页面达到可交互状态。</strong></li></ul></blockquote><p>从客户端的渲染流程看，我们可以发现从请求 <code>HTML</code> 到达到可交互状态中的请求是串行执行的，会导致白屏时间长，并且刚刚请求回的 <code>.html</code> 文件上的动态数据是空的，不利于搜索引擎的爬虫分析页面（不利于 <code>SEO</code>）。</p><h3 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h3><p><code>SSR</code>（<code>Server Side Rendering</code>） 又称为服务端渲染，将渲染后的 <code>.html</code> 整个返回给客户端，可以让客户端在加载 <code>.html</code> 后直接看到页面。</p><blockquote class="pullquote warning"><p><strong>服务端渲染流程：</strong></p><ul><li><strong>开始加载（白屏）；</strong></li><li><strong>服务端同构，将 <code>HTML</code>、<code>Data</code>、<code>CSS</code> 等进行组合；</strong></li><li><strong>返回给客户端解析并渲染；</strong></li><li><strong>页面达到可交互状态。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>跟客户端渲染的流程对比，可以发现服务端渲染的优势：</strong></p><ul><li><strong>串行的请求在服务端，内网拉取资源更快；</strong></li><li><strong>服务端渲染把客户端渲染的多个串行的请求优化成了一个请求（减少请求数）；</strong></li><li><strong>返回页面就能直接渲染出内容，减少了白屏的时间；</strong></li><li><strong>页面返回首屏所有数据，对 <code>SEO</code> 更友好。</strong></li></ul></blockquote><p><strong>客户端渲染和服务端渲染的差别对比：</strong></p><table><thead><tr><th style="width:20%"></th><th style="width:40%">客户端渲染</th><th>服务端渲染</th></tr></thead><tbody><tr><td>请求</td><td>多个请求（HTML，数据等）</td><td>1 个请求</td></tr><tr><td>加载过程</td><td>HTML 与数据串行加载</td><td>1 个请求返回 HTML 和数据</td></tr><tr><td>渲染</td><td>前端渲染</td><td>服务端渲染（如 Node.js）</td></tr><tr><td>可交互</td><td colspan="2">图片等静态资源加载完成，JS 逻辑执行完成可交互</td></tr></tbody></table><p><br></p><h3 id="构建服务端和客户端"><a href="#构建服务端和客户端" class="headerlink" title="构建服务端和客户端"></a>构建服务端和客户端</h3><p>假设负责服务端渲染的服务是由 <code>Express</code> 实现的，前端是使用 <code>React</code> 实现的，代码如下：</p><pre><code class="lang-bash">$ npm install express -D</code></pre><pre><code class="lang-js">/* ~server/index.js 服务端 */const express = require(&#39;express&#39;);const fs = require(&#39;fs&#39;);const axios = require(&#39;axios&#39;);// React 内部提供的方法，用于将 JSX 转换成 HTML 字符const { renderToString } = require(&#39;react-dom/server&#39;);// 引入需要转换的 JSXconst SSR = require(&#39;./dist/index-server&#39;);// 引入构建后的模板const html = fs.readFile(&#39;./dist/index.html&#39;, &#39;utf-8&#39;);// 增加 hask，防止属于浏览器的对象在服务端报错if (window === undefined) {  global.window = {};}const server = (port) =&gt; {  const app = express();  app.use(express.static(&#39;dist&#39;));  app.get(&#39;/&#39;, (req, res) =&gt; {    const html = renderMarkup(renderToString(SSR));    res.status(200).send(html);  });  app.listen(port, () =&gt; {    console.log(`server start ${port}`);  });}const renderMarkup = async (str) =&gt; {  const data = await axios.get(&#39;/xxx/xxx&#39;);  return html.replace(&#39;&lt;!-- HTML_PLACEHOLDER --&gt;&#39;, str).replace(    &#39;&lt;!-- INITAIL_DATA_PLACEHOLDER --&gt;&#39;，    &#39;&lt;script&gt;window.__inital_data = &#39; + data + &#39;&lt;/script&gt;&#39;  );}server(process.env.PORT || 3000);</code></pre><pre><code class="lang-html">&lt;!-- ~dist/index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Search&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 占位符，用于插入 HTML --&gt;  &lt;div id=&quot;root&quot;&gt;&lt;!-- HTML_PLACEHOLDER --&gt;&lt;/div&gt;  &lt;!-- 数据占位符，用于插入数据 --&gt;  &lt;!-- INITAIL_DATA_PLACEHOLDER --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="lang-jsx">/* ~dist/index-server.js 客户端 */const React = require(&#39;react&#39;);class App extends React.Component {  render() {    return &lt;h1&gt;Hello world!&lt;/h1&gt;  }}module.exports = &lt;App /&gt;;</code></pre><blockquote class="pullquote danger"><p><strong>注意：由于 <code>React</code> 组件的 <code>JSX</code> 要通过服务端进行转换、渲染，所以不能使用 <code>ReactDom.render</code> 进行渲染，需要使用 <code>require</code> 引入， <code>module.exports</code> 导出。</strong></p></blockquote><h3 id="构建配置-1"><a href="#构建配置-1" class="headerlink" title="构建配置"></a>构建配置</h3><pre><code class="lang-js">const path = require(&#39;path&#39;);module.exports = {  // ...  output: {    path: path.join(__dirname, &#39;dist&#39;),    filename: &#39;[name]-server.js&#39;    libararyTarget: &#39;umd&#39;  },  module: {    rules: [      {        test: /\.css$/,        use: [          &#39;ignore-loader&#39; // 使用构建后 `dist` 目录的 CSS        ]      }    ]  }  // ...}</code></pre><h3 id="Webpack-SSR-注意的问题"><a href="#Webpack-SSR-注意的问题" class="headerlink" title="Webpack SSR 注意的问题"></a>Webpack SSR 注意的问题</h3><blockquote class="pullquote warning"><ul><li><strong>需要兼容浏览器的全局变量，如 <code>window</code>、<code>document</code> 等；</strong></li><li><strong>组件适配：将不兼容的组件根据打包环境适配，如服务端为 <code>CommonJS</code> 模块化规范；</strong></li><li><strong>请求适配：将 <code>fetch</code> 或者 <code>ajax</code> 请求的写法改写成 <code>isomorphic-fetch</code> 或者 <code>axios</code>（对于服务端做过适配）；</strong></li><li><strong>样式无法解析，服务端打包通过 <code>ignore-loader</code> 忽略掉 <code>CSS</code> 解析，或者将 <code>style-loader</code> 替换成 <code>isomorphic-style-loader</code>（使用 <code>CSS-Module</code> 的编码方式）。</strong></li></ul></blockquote><h2 id="定制构建命令行的显示日志"><a href="#定制构建命令行的显示日志" class="headerlink" title="定制构建命令行的显示日志"></a>定制构建命令行的显示日志</h2><p>在每一次构建时，默认在命令行都会打印一堆的日志信息，但是对于一个关注业务的开发者来说，更希望在构建错误时才去关注日志，并且快速定位错误，在 <code>Webpack</code> 中提供了 <code>stat</code> 配置用来控制日志内容的显示。</p><p><strong>生产环境配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  stat: &#39;errors-only&#39;  // ...}</code></pre><p><strong>开发环境配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  devServer: {    // ...    stat: &#39;errors-only&#39;    // ...  }  // ...}</code></pre><blockquote class="pullquote default"><p><strong>生产环境控制执行构建命令时的日志显示，如 <code>npm run build</code>，而开发环境控制代码热更新重新构建时的日志显示。</strong></p></blockquote><p><strong><code>stat</code> 可选值如下：</strong></p><table><thead><tr><th style="width:30%">可选值</th><th>描述</th></tr></thead><tbody><tr><td>errors-only</td><td>只在发生错误时输出</td></tr><tr><td>errors-warnings</td><td>只在发生错误或有新的编译时输出</td></tr><tr><td>minimal</td><td>只在发生错误或有新的编译时输出</td></tr><tr><td>none</td><td>没有输出</td></tr><tr><td>normal</td><td>标准输出</td></tr><tr><td>verbose</td><td>全部输出</td></tr><tr><td>detailed</td><td>全部输出除了 chunkModules 和 chunkRootModules</td></tr></tbody></table><p>目前存在一个问题是成功、警告以及失败的日志信息不够明显，使用 <code>FriendlyErrorsWebpackPlugin</code> 插件，可以通过颜色区分更明显的标注日志信息。</p><p><strong>插件安装：</strong></p><pre><code class="lang-bash">$ npm install friendly-errors-webpack-plugin -D</code></pre><p><strong>插件配置示例：</strong></p><pre><code class="lang-js">const FriendlyErrorsWebpackPlugin = require(&#39;friendly-errors-webpack-plugin&#39;);module.exports = {  // ...  plugins: [    new FriendlyErrorsWebpackPlugin()  ]  // ...}</code></pre><h2 id="构建异常和中断处理"><a href="#构建异常和中断处理" class="headerlink" title="构建异常和中断处理"></a>构建异常和中断处理</h2><p>在执行构建时，如果构建成功，接下来可能会执行发布操作，如果构建失败，可能会做错误上报的操作，这就需要我们的 <code>Webpack</code> 配置中能构处理构建异常和中断，其实在 <code>Webpack4</code> 中每次进程执行构建后都会抛出结束的状态码，<code>0</code> 为构建成功，其他只为构建失败。</p><pre><code class="lang-bash"># 查看状态码echo $?</code></pre><p>但我们的目的并不是通过命令拿到错误码，而是在构建过程刚结束时，可以针对状态码去做不同的处理，其实根据 <code>Webpack</code> 的底层对象 <code>Compiler</code> 的特性去实现一个插件就可以实现构建异常和中断处理，在插件中通过 <code>process.exit</code> 抛出状态码。</p><blockquote class="pullquote info"><p><strong><code>process.exit</code> 方法：</strong></p><ul><li><strong>状态码为 <code>0</code>，构建成功，回调函数中 <code>err</code> 参数为 <code>null</code>；</strong></li><li><strong>状态码为其他值，构建失败或中断，回调函数中 <code>err</code> 为错误对象，<code>err.code</code> 就是状态码。</strong></li></ul></blockquote><p><strong>插件简易实现和配置：</strong></p><pre><code class="lang-js">module.exports = {  // ...  plugins: [    // ...    function () {      const interceptor = (stats) =&gt; {        if (stats.complation.errors &amp;&amp; process.argv.includes(&#39;--watch&#39;)) {          // 处理错误，上报          process.exit(1);        }      }      if (this.hooks) {        this.hooks.done.tap(&#39;done&#39;, interceptor); // Webpack4      } else {        this.plugin(&#39;done&#39;, interceptor); // Webpack3      }    }    // ...  ]  // ...}</code></pre><p><code>plugins</code> 不一定是类 <code>new</code> 出的插件实例对象，也可以是函数，上面的函数就可以作为插件被执行，在 <code>Webpack</code> 构建结束后会自动执行 <code>done</code> 事件，可以在 <code>done</code> 事件的回调函数中获取状态码和错误信息，做进一步的处理。</p><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181115105656/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 优化篇</title>
      <link>https://www.overtaking.top/20181110203121/</link>
      <guid>https://www.overtaking.top/20181110203121/</guid>
      <pubDate>Sat, 10 Nov 2018 12:31:21 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Compile/20181110203121/webpack-optimization.png&quot; title=&quot;webpack optimization&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;系列文章链接：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/20181002041434/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 基础篇&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/20181115105656/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 应用篇&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;文件指纹&quot;&gt;&lt;a href=&quot;#文件指纹&quot; class=&quot;headerlink&quot; title=&quot;文件指纹&quot;&gt;&lt;/a&gt;文件指纹&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181110203121/webpack-optimization.png" title="webpack optimization"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181002041434/" target="_blank">Webpack4 —— 基础篇</a></li><li><a href="/20181115105656/" target="_blank">Webpack4 —— 应用篇</a></li></ul></blockquote><h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><blockquote class="pullquote info"><p><strong>“文件指纹” 就是打包后的文件名的后缀，文件指纹的好处如下：</strong></p><ul><li><strong>版本管理，文件发生变化，文件指纹发生变化，只将发生变化的文件进行发布；</strong></li><li><strong>没有修改文件指纹的文件可以继续使用浏览器缓存，减少网络带宽，加速页面访问。</strong></li></ul></blockquote><a id="more"></a><blockquote class="pullquote success"><p><strong>“文件指纹” 的种类：</strong></p><ul><li><strong><code>Hash</code>：和整个项目的构建有关，只要项目中有文件发生变化，使用该配置的文件名的 “指纹” 就会发生变化；</strong></li><li><strong><code>ChunkHash</code>：和 <code>Webpack</code> 打包的 <code>chunk</code> 有关，不同的 <code>entry</code>（多页应用时）会生成不同的 “指纹”，页面对应的文件发生变化才会影响该页面的 “指纹”；</strong></li><li><strong><code>ContentHash</code>：根据具体文件的内容生成 “指纹”，在具体某一个页面下引用的多个文件中，如果使用 <code>ChunkHash</code> 会导致一个文件变化其他的文件 “指纹” 也发生变化，使用 <code>ContentHash</code> 可以保证文件内容不变不会 “指纹” 不会发生变化。</strong></li></ul></blockquote><p><strong>合理使用 “文件指纹”：</strong></p><pre><code class="lang-js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module.exports = {  entry: {    app: &#39;./pages/app.js&#39;,    appAdmin: &#39;./pages/appAdmin.js&#39;  },  output: {    // 不同页面出口文件使用 chunkhash    filename: &#39;[name][chunkhash:8].js&#39;,    path: __dirname + &#39;dist&#39;  },  module: {    rules: [      // ...      {        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;,        ],      },      {        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,        loader: &#39;url-loader&#39;,        options: {          limit: 10000,          // MD5 根据文件内容生成，字体文件同理          name: &#39;[name].[hash:8].[ext]&#39;        }      }      // ...    ]  }  plugins: [    // 使用该插件将 CSS 文件单独提取    new MiniCssExtractPlugin({      // 该 contenthash 同图片的 hash      filename: &#39;[name][contenthash:8].css&#39;    })  ]  // ...}</code></pre><blockquote class="pullquote danger"><p><strong>“指纹” 配置不能和热更新插件 <code>HotModuleReplacementPlugin</code> 同时使用，因此也突出了 <code>Webpack</code> 配置根据环境（<code>mode</code>）区分的重要性。</strong></p></blockquote><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>在项目正式上线时，代码压缩是非常必要的，因为代码压缩后资源的字节会更少，文件大小会更小，这样在文件传输过程中也会节约带宽进而加快文件的访问速度。</p><h3 id="JS-压缩"><a href="#JS-压缩" class="headerlink" title="JS 压缩"></a>JS 压缩</h3><p>在 <code>Webpack4</code> 中内置了 <code>uglifyjs-webpacl-plugin</code> 插件，在 <code>mode</code> 配置为 <code>production</code> 时会默认实现 <code>.js</code> 文件的压缩，也可以手动安装该插件去配置关于压缩的其他参数，如并行压缩等（非必要）。</p><h3 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h3><p>在 <code>Webpack</code> 旧版本中可以通过 <code>css-loader</code> 中配置参数来实现压缩，但是后来 <code>css-loader</code> 去掉了这个配置，所以在 <code>Webpack4</code> 中可以通过 <code>OptimizeCssAssetsWebpackPlugin</code> 插件来实现对 <code>.css</code> 文件的压缩。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install cssnano optimize-css-assets-webpack-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 在 plugins 中配置 */const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);// 用于匹配 CSS 文件的处理器（默认）const Cssnano = require(&#39;cssnano&#39;);module.exports = {  // ...  plugins: [    new OptimizeCssPlugin({      assetNameRegExp: /\.css$/g,      cssProcessor: Cssnano,      cssProcessorOptions: {        // 注释处理        discardComments: {          removeAll: true // 移除所有注释        },        normalizeUnicode: false // 防止 unicode-range 时产生乱码      }    })  ]}</code></pre><pre><code class="lang-js">/* 在 optimization 中配置 */const OptimizeCssPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);// 用于匹配 CSS 文件的处理器（默认）const Cssnano = require(&#39;cssnano&#39;);module.exports = {  // ...  optimization: {    // ...    minimizer: [      new OptimizeCssPlugin({        assetNameRegExp: /\.css$/g,        cssProcessor: Cssnano,        cssProcessorOptions: {          // 注释处理          discardComments: {            removeAll: true // 移除所有注释          },          normalizeUnicode: false // 防止 unicode-range 时产生乱码        }      })    ]    // ...  }}</code></pre><h3 id="Html-压缩"><a href="#Html-压缩" class="headerlink" title="Html 压缩"></a>Html 压缩</h3><p>压缩 <code>.html</code> 文件主要还是依靠 <code>HtmlWebpackPlugin</code> 插件，通过生产环境构建时配置一些参数来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = {  // ...  plugins: [    new HtmlWebpackPlugin({      template: &#39;./src/index.html&#39;, // 模板文件路径      filename: &#39;index.html&#39;, // 输出文件名称      inject: true, // 将 js 资源放在 body 底部      minify: {        collapseWhitespace: true, // 是否删除空白符与换行符        removeAttributeQuotes: true, // 是否移除引号        minifyCSS: true, // 压缩 CSS        minifyJS: true, // 压缩 JS        removeComments: true // 是否移除 HTML 中的注释      }    })  ]  // ...}</code></pre><h2 id="资源内联"><a href="#资源内联" class="headerlink" title="资源内联"></a>资源内联</h2><blockquote class="pullquote default"><p><strong>资源内联就是将资源的代码放在 <code>.html</code> 文件中一起请求回来，资源内联优化的意义大致可以分为两个层面，代码层面和网络层面。</strong></p><ul><li><strong>在代码层面可以内联一些 <code>meta</code> 标签，便于维护管理文件，可以内联一些页面框架的初始化脚本、上报埋点相关的脚本，也可以将首屏使用的 <code>CSS</code> 内联，防止网络不好的情况下页面闪动；</strong></li><li><strong>从网络层面，对一些小图片和字体资源进行内联可以减少请求次数，增加页面的响应速度。</strong></li></ul></blockquote><h3 id="Html-和-JS-的内联"><a href="#Html-和-JS-的内联" class="headerlink" title="Html 和 JS 的内联"></a>Html 和 JS 的内联</h3><p>内联 <code>Html</code> 和 <code>JS</code> 文件需要依赖 <code>raw-loader</code> 加载器，<code>raw-loader</code> 的功能其实就是读取一个文件，然后把文件读取的内容以字符串形式返回并插入到对应的位置。</p><p><strong>安装依赖（0.5.1 版本比较稳定）：</strong></p><pre><code class="lang-bash">$ npm install raw-loader@0.5.1 -D</code></pre><p><strong>使用示例：</strong></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;!-- html 内联可以直接放在对应位置 --&gt;  ${ require(&#39;raw-loader!./meta.html&#39;) }  &lt;!-- js 内联需要包裹在 script 标签中，防止存在 ES6 代码需要添加 babel-loader --&gt;  &lt;script&gt;${ require(&#39;raw-loader!babel-loader!./xxx.js&#39;) }&lt;/script&gt;  &lt;title&gt;注入 Html 和 JS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote class="pullquote info"><p><strong>由于 <code>Webpack</code> 使用编译模板的插件是 <code>HtmlWebpackPlugin</code>，默认模板使用的是 <code>ejs</code>，所以支持上面 <code>${}</code> 的模板语法。</strong></p></blockquote><h3 id="CSS-内联"><a href="#CSS-内联" class="headerlink" title="CSS 内联"></a>CSS 内联</h3><blockquote class="pullquote primary"><p><strong><code>CSS</code> 内联需要两个步骤：</strong></p><ul><li><strong>如果直接使用 <code>style-loader</code> 会把所有打包后的 <code>CSS</code> 样式都动态的注入 <code>.html</code> 文件中，所以需要使用 <code>MiniCssExtractPlugin</code> 插件优先对 <code>CSS</code> 进行抽离；</strong></li><li><strong>将抽离后首屏的 <code>.css</code> 文件注入到 <code>.html</code> 文件中，借助 <code>HtmlInlineCssWebpackPlugin</code> 插件来实现。</strong></li></ul></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install mini-css-extract-plugin html-webpack-plugin html-inline-css-webpack-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);const HtmlInlineCssWebpackPlugin = require(&#39;html-inline-css-webpack-plugin&#39;);module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader,          &#39;css-loader&#39;        ]      }      // ...    ]  },  plugins: [    new MiniCssExtractPlugin({      filename: &#39;[name][contenthash:8].css&#39;    }),    new HtmlWebpackPlugin({      template: &#39;./src/index.html&#39;,      filename: &#39;index.html&#39;    }),    new HtmlInlineCssWebpackPlugin()    // ...  ]  // ...}</code></pre><blockquote class="pullquote warning"><p><strong>需要注意的是 <code>HtmlWebpackPlugin</code> 插件应该在 <code>HtmlInlineCssWebpackPlugin</code> 之前，因为这两个插件的执行顺序有所依赖，必须先产生 <code>index.html</code> 文件后才能对 <code>CSS</code> 进行注入。</strong></p></blockquote><h3 id="图片、字体的内联"><a href="#图片、字体的内联" class="headerlink" title="图片、字体的内联"></a>图片、字体的内联</h3><p>一些小图标和字体如果体积非常小的情况下发出多个请求是没有必要的，所以最好是转换成 <code>Base64</code> 直接内联在 <code>.html</code> 和 <code>.css</code> 文件中，可以通过 <code>url-loader</code> 在构建中实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install url-loader -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.(png|svg|gif|jpe?g)$/,        use: [          {            loader: &#39;url-loader&#39;,            options: {              limit: 10240 // 图片小于 10k 转为 Base64            }          }        ]      },      {        test: /\.(woff2?|eot|ttf|otf)$/,        use: [          {            loader: &#39;url-loader&#39;, // 字体小于 10k 转为 Base64            options: {              limit: 10240            }          }        ]      }      // ...    ]  }  // ...}</code></pre><blockquote class="pullquote default"><p><strong>这样的方式最大的问题是只能根据图片大小控制所有满足条件的图片和字体资源，而不能单独控制某一个资源，想要单独控制某一个资源可以使用自己编写 <code>Webpack</code> 插件或类似功能的第三方插件。</strong></p></blockquote><h2 id="抽取公共依赖"><a href="#抽取公共依赖" class="headerlink" title="抽取公共依赖"></a>抽取公共依赖</h2><p>在开发中的很多页面使用了相同的基础库，或者这些基础库之间引用了相同的依赖，或不同的组件中使用了相同的模块，以及 <code>node_modules</code> 中有些模块使用相同的依赖，这样直接打包会对公共部分重复打包，造成打包后的文件体积非常的大，这也是一个可以优化的点，可以将公共的部分按照优先级、权重、同步异步加载的方式进行抽取，进而对文件进行拆分，减小打包后文件的体积。</p><h3 id="基础库分离"><a href="#基础库分离" class="headerlink" title="基础库分离"></a>基础库分离</h3><p>假如我们是做 <code>React</code> 开发，默认情况下是会对 <code>react</code> 和 <code>react-dom</code> 构建并打包到 <code>bundle</code> 中去，可以通过 <code>CDN</code> 的方式进行引入，在打包的时候每一次都忽略 <code>react</code> 和 <code>react-dom</code> 文件，以减小 <code>bundle</code> 的体积，我们可以通过 <code>HtmlWebpackExternalsPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-externals-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const HtmlWebpackExternalsPlugin = require(&#39;html-webpack-externals-plugin&#39;);module.exports = {  // ...  plugins: [    // ...    new HtmlWebpackExternalsPlugin({      externals: [        {          module: &#39;react&#39;, // 模块名称          entry: &#39;//xxcnd.com/boudle/react.min.js&#39;, // cdn 地址          global: &#39;React&#39; // 全局变量名        },        {          module: &#39;react-dom&#39;,          entry: &#39;//xxcnd.com/boudle/react-dom.min.js&#39;,          global: &#39;ReactDom&#39;        }      ]    })    // ...  ]  // ...}</code></pre><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在 <code>Webpack4</code> 中内置了代码分割的功能插件，非常强大，可以通过将公共依赖抽离成单独文件的方式减小 <code>bundle</code> 的体积，这也是官方建议使用的方式。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 默认参数 */module.exports = {  // ...  optimization: {    // ...    splitChunks: {      chunks: &#39;all&#39;,      minSize: 30000,      maxSize: 0,      minChunks: 1,      maxAsyncRequests: 5,      maxInitalRequests: 3,      automaticNameDelimiter: &#39;~&#39;,      name: true    }    // ...  }  // ...}</code></pre><blockquote class="pullquote success"><p><strong><code>splitChunks</code> 参数详解：</strong></p><ul><li><strong><code>chunks</code>：</strong><ul><li><strong><code>async</code>：异步引入的库进行分离（默认）；</strong></li><li><strong><code>inital</code>：同步引入的库进行分离；</strong></li><li><strong><code>all</code>：所有引入的库进行分离（推荐）。</strong></li></ul></li><li><strong><code>minSize</code>：抽离公共包最小字节数；</strong></li><li><strong><code>maxSize</code>：抽离公共包最大字节数；</strong></li><li><strong><code>minChunks</code>：抽离公共包最小使用次数；</strong></li><li><strong><code>maxAsyncRequests</code>：浏览器同时请求同步资源的个数；</strong></li><li><strong><code>maxInitalRequests</code>：浏览器同时请求异步资源的个数；</strong></li><li><strong><code>automaticNameDelimiter</code>：抽离插件的文件名间隔符；</strong></li><li><strong><code>name</code>：值为 <code>true</code> 根据模块名称和缓存组（<code>cacheGroups</code>）的键自动选择名称。</strong></li></ul></blockquote><p><strong>使用自定义缓存组 <code>cacheGroups</code> 配置示例：</strong></p><pre><code class="lang-js">/* 自定义缓存组拆分同步异步模块 */module.exports = {  // ...  optimization: {    // ...    splitChunks: {      chunks: &#39;all&#39;,      cacheGroups: {        &#39;commons&#39;: {          chunks: &#39;initial&#39;,          name: &#39;commons&#39;,          minChunks: 2,          minSize: 0,          reuseExistingChunk: true,          priority: -5        },        &#39;async-commons&#39;: {          chunks: &#39;async&#39;,          name: &#39;async-commons&#39;,          minChunks: 2,          minSize: 0,          reuseExistingChunk: true,          priority: 5        },        &#39;vendors&#39;: {          test: /[\\/]node_modules[\\/]/,          name: &#39;vendors&#39;,          chunks: &#39;initial&#39;,          minChunks: 2,          priority: 10,          enforce: true,          reuseExistingChunk: true        },        &#39;async-vendors&#39;: {          test: /[\\/]node_modules[\\/]/,          minChunks: 2,          chunks: &#39;async&#39;,          name: &#39;async-vendors&#39;,          priority: 15,          enforce: true,          reuseExistingChunk: true        }      }    }    // ...  }  // ...}</code></pre><blockquote class="pullquote info"><p><strong><code>cacheGroups</code> 参数详解：</strong></p><ul><li><strong><code>commons</code>：所有代码中的公共依赖（同步）；</strong><ul><li><strong><code>test</code>：匹配依赖代码的文件夹，通常匹配 <code>node_modules</code>；</strong></li><li><strong><code>reuseExistingChunk</code>：允许重用现有模块，而不是在模块完全匹配时创建新模块；</strong></li><li><strong><code>priority</code>：权重，当被多个规则重用时会根据权重打包到对应策略的文件中；</strong></li><li><strong><code>enforce</code>：设置为 <code>true</code> 强制按照该规则拆分出一个文件，忽略文件大小；</strong></li></ul></li><li><strong><code>async-commons</code>：所有代码中的公共依赖（异步）；</strong></li><li><strong><code>vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（同步）；</strong></li><li><strong><code>async-vendors</code>：依赖代码（<code>node_modules</code>）中的公共依赖（异步）；</strong></li></ul></blockquote><blockquote class="pullquote warning"><p><strong>注意：在使用 <code>cacheGroups</code> 属性进行代码分割后，产生的新 <code>chunks</code> 名称必须在页面 <code>HtmlWebpackPlugin</code> 实例的 <code>chunks</code> 属性中进行一一对应的配置。</strong></p></blockquote><p><strong><code>HtmlWebpackPlugin</code> 配置：</strong></p><pre><code class="lang-js">/* HtmlWebpackPlugin 使用前需安装 */const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = {  // ...  plugins: [    // ...    new HtmlWebPackPlugin({      template: &#39;./src/index.html&#39;,      filename: &#39;index.html&#39;,      // 包含 splitChunks.cacheGroups 中 key 值和页面的出口文件名称      chunks: [        &#39;commons&#39;,        &#39;async-commons&#39;,        &#39;vendors&#39;,        &#39;async-vendors&#39;,        &#39;index&#39;      ]      // ...    })    // ...  ]  // ...}</code></pre><h2 id="tree-shaking-优化"><a href="#tree-shaking-优化" class="headerlink" title="tree-shaking 优化"></a>tree-shaking 优化</h2><h3 id="配置-tree-shaking"><a href="#配置-tree-shaking" class="headerlink" title="配置 tree-shaking"></a>配置 tree-shaking</h3><p>这个优化的名字是非常形象的，像摇晃树一样，把多余的枯叶都晃掉，其实指的就是一个模块中有多个方法，在打包的 <code>uglify</code> 阶段擦除掉没有使用（被标记）的方法，通过不打包无用代码的方式来减小 <code>bundle</code> 的体积，进而减小资源的加载时间。</p><p>这个优化的思想借鉴了 <code>rollup</code>，并在 <code>Webpack2</code> 中进行了实现，通过插件配置，目前 <code>Webpack4</code> 版本已经内置了 <code>tree-shaking</code> 优化，在 <code>mode</code> 被配置为 <code>production</code>（生产环境）时默认生效，如果需要在开发环境中使用配置如下。</p><pre><code class="lang-json">/* .babelrc */{  &quot;presets&quot;: [    &quot;@babel/preset-env&quot;,  ]}</code></pre><blockquote class="pullquote success"><p><strong>想要使 <code>tree-shaking</code> 生效的注意点：</strong></p><ul><li><strong>引入模块必须使用 <code>ES6</code> 的模块化语法，因为 <code>tree-shaking</code> 的实现依赖于 <code>ES6</code> 模块化的静态特性；</strong></li><li><strong>导出的函数不能存在 “副作用”，即导出的函数需要是纯函数，否则默认的 <code>tree-shaking</code> 也会失效。</strong></li></ul></blockquote><h3 id="tree-shaking-原理简介"><a href="#tree-shaking-原理简介" class="headerlink" title="tree-shaking 原理简介"></a>tree-shaking 原理简介</h3><p>说到 <code>tree-shaking</code> 的原理是应该先了解 <code>DCE</code>（<code>dead code elimination</code>）的概念，就是指 “死” 代码消除。</p><blockquote class="pullquote default"><p><strong><code>DCE</code> 有以下情况：</strong></p><ul><li><strong>代码不会被执行，不可到达；</strong></li><li><strong>代码只会影响死变量，只写不读；</strong></li><li><strong>代码执行的结果不会被用到。</strong></li></ul></blockquote><pre><code class="lang-js">/* 代码不会被执行，不可到达 */if (false) {  console.log(&#39;dead code&#39;);}</code></pre><pre><code class="lang-js">/* 代码只会影响死变量，只写不读 */let hello = &#39;nihao&#39;;</code></pre><pre><code class="lang-js">/* 代码执行的结果不会被用到 */// tool.jsexport const fn1 = () =&gt; {  return &#39;hello&#39;;}fn1();export const fn2 = () =&gt; {  return &#39;world&#39;;}// main.jsimport { fn2 } from &#39;./tool.js&#39;;fn2();</code></pre><p><code>tree-shaking</code> 就是通过检查具有上面特性的代码并做相应处理来达到擦除多余代码的目的，并且依赖 <code>ES6</code> 模块化的静态特性，原因是哪些代码是多余的哪些代码是有用的在编译阶段就需要确定下来，<code>ES6</code> 模块的静态特性正好符合编译阶段对代码的分析，<code>CommonJS</code> 的模块化规范就明显不适合，因为模块的引入是动态的，由运行时决定。</p><blockquote class="pullquote primary"><p><strong>依赖模块静态化特性的原因：</strong></p><ul><li><strong>只能在顶层使用 <code>import</code> 引用模块；</strong></li><li><strong>引用的变量都是常量；</strong></li><li><strong>引入的模块对象的不可更改（<code>immutable</code>）特性。</strong></li></ul></blockquote><h3 id="深度-tree-shaking"><a href="#深度-tree-shaking" class="headerlink" title="深度 tree-shaking"></a>深度 tree-shaking</h3><p>如果函数中存在副作用，默认的 <code>tree-shaking</code> 之所以失效了是因为只能够在编译阶段做词法分析，而不能做作用域（<code>scope</code>）分析，如下面代码。</p><pre><code class="lang-js">// tool.jsimport lodash from &#39;lodash-es&#39;;export const fn1 = () =&gt; {  console.log(&#39;hello&#39;);}export const fn2 = (arg) =&gt; {  console.log(lodash.isArray(arg));}// main.jsimport { fn1 } from &#39;./tool.js&#39;;fn1();</code></pre><p>在上面案例中并没有使用 <code>fn2</code>，但是由于 <code>fn2</code> 函数中有副作用，即引用了 <code>lodash</code>，所以还是对 <code>lodash</code> 和 <code>fn2</code> 进行了打包，这种情况下如果想要继续实现 <code>tree-shaking</code>，需要借助 <code>WebpackDeepScopePlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install webpack-deep-scope-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const WebpackDeepScopePlugin = require(&#39;webpack-deep-scope-plugin&#39;);module.exports = {  // ...  plugins: [    // ...    new WebpackDeepScopePlugin()    // ...  ]  // ...}</code></pre><h2 id="Scope-Hoisting-优化"><a href="#Scope-Hoisting-优化" class="headerlink" title="Scope Hoisting 优化"></a>Scope Hoisting 优化</h2><p>由于浏览器对模块化语法支持依然不好，为了保证代码可以在各个浏览器中可执行，所以使用 <code>Webpack</code> 进行构建。</p><pre><code class="lang-js">/* 构建前 */// a.jsexport default &#39;xxx&#39;;// b.jsimport index from &#39;./a.js&#39;;console.log(index);</code></pre><pre><code class="lang-js">/* 构建后 */(function (module, __webpack_exports__, __webpack_require__) {  &quot;use strict&quot;  // 模块 b 构建内容，省略...})(function (module, __webpack_exports__, __webpack_require__) {  &quot;use strict&quot;  // 模块 a 构建内容，省略...})</code></pre><p>被 <code>Webpack</code> 转换后的模块会包裹一层自执行函数，构建后的代码会存在大量的闭包，其中 <code>import</code> 会被转换成 <code>__webpack_require__</code> 的调用，<code>export</code> 会被转换成 <code>__webpack_exports__</code> 对象属性的的赋值。</p><blockquote class="pullquote warning"><p><strong>会导致的问题：</strong></p><ul><li><strong>大量函数闭包包裹的代码会导致体积增大，模块越多越明显；</strong></li><li><strong>运行代码时创建的函数作用域变多，内存开销变大。</strong></li></ul></blockquote><p><code>Scope Hoisting</code> 又被称为作用域提升，借鉴于 <code>rollup</code>，在 <code>Webpack3</code> 中被提出，将所有模块的代码按照引用顺序存放在一个函数作用域里，然后适当的重命名来防止变量命名冲突，用来减少函数声明代码，减小内存开销。</p><p>在 <code>Webpack4</code> 中当 <code>mode</code> 为 <code>production</code>（生产环境）时会默认开启 <code>Scope Hoisting</code>，当想在开发环境或 <code>Webpack3</code> 中配置开启，需要依赖 <code>Webpack</code> 的内置插件 <code>ModuleConcatenationPlugin</code> 来实现。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">const Webpack = require(&#39;webpack&#39;);module.exports = {  // ...  plugins: [    // ...    new Webpack.optimize.ModuleConcatenationPlugin()    // ...  ]  // ...}</code></pre><blockquote class="pullquote info"><p><strong>开启 <code>Scope Hoisting</code> 后，在多个模块中都会引用的模块会单独提取出来形成闭包函数，否则会将多个引用的模块按照引用顺序放在同一个闭包函数中。</strong></p></blockquote><h2 id="资源懒加载"><a href="#资源懒加载" class="headerlink" title="资源懒加载"></a>资源懒加载</h2><p><code>Webpack</code> 所特有的 <code>require.ensure()</code> 可以实现懒加载，符合 <code>CommonJS</code> 规范，目前已经被 <code>ES6+</code> 的动态 <code>import()</code> 取代，属于代码分割的一部分，对于大型 <code>Web</code> 单页面应用来讲，将所有代码都放在一个 <code>bundle</code> 文件中是没有必要的，特别是某些代码块不是经常被用到，大大降低了首屏的加载速度，使用动态 <code>import</code> 优化可以使类似这样的代码在使用时才去加载，使得初始化的时候代码体积更小。</p><p>在 <code>Webpack</code> 中要解析动态 <code>import()</code> 语法需要依赖 <code>babel</code> 中的 <code>@babel/plugin-syntax-dynamic-import</code> 插件。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install @babel/preset-env @babel/plugin-syntax-dynamic-import -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-json">/* .babelrc */{  &quot;presets&quot;: [    &quot;@babel/preset-env&quot;  ],  &quot;plugins&quot;: [    &quot;@babel/plugin-syntax-dynamic-import&quot;  ]}</code></pre><blockquote class="pullquote default"><p><strong>只要使用了动态 <code>import()</code> 语法加载的模块，在 <code>Webpack</code> 构建时都会打包出单独的 <code>chunk</code>，构建的代码内当需要加载模块时是通过 <code>JSONP</code> 的方式去加载的。</strong></p></blockquote><blockquote class="pullquote success"><p><strong>未完待续…</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181110203121/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 策略模式</title>
      <link>https://www.overtaking.top/20181006014812/</link>
      <guid>https://www.overtaking.top/20181006014812/</guid>
      <pubDate>Fri, 05 Oct 2018 17:48:12 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20181006014812/strategy.jpg&quot; title=&quot;策略模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181006014812/strategy.jpg" title="策略模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote primary"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li></ul></blockquote><h2 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h2><p>“策略模式” 是将定义的一组算法封装起来，使其可以相互替换，封装的算法具有一定的独立性，让算法独立于客户端而变化，可以大大减少 <code>if...else</code> 和 <code>switch...case</code> 等判断。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181006014812/strategy-uml.jpg" alt="策略模式 UML 图"></div><div class="image-caption">策略模式 UML 图</div></figure><p><br></p><h2 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h2><p>下面是一个关于会员打折的逻辑，根据顾客身份不同输出不同的支付金额，是未使用 “策略模式” 的实现。</p><pre><code class="lang-js">/* 未使用策略模式 */class Customer {  constructor(type) {    this.type = type;  }  pay(amount) {    if (this.type === &#39;member&#39;) {      return amount * 0.9;    } else if (this.type === &#39;vip&#39;) {      return amount * 0.8;    } else {      return amount;    }  }}const c1 = new Customer(&#39;normal&#39;);const c2 = new Customer(&#39;member&#39;);const c3 = new Customer(&#39;vip&#39;);console.log(c1.pay(100)); // 100console.log(c2.pay(100)); // 90console.log(c3.pay(100)); // 80</code></pre><p>上面的代码与 <a href="/20181005161213/" target="_blank">状态模式</a> 一节中的问题类似，违反开放封闭原则和单一职责原则，代码冗余且判断条件过多，“状态模式” 虽然可以解决状态不同时不同复杂逻辑的抽离和解耦，但是并不能解决过多条件判断的问题，下面就是用 “策略模式” 来对这个点进行优化。</p><pre><code class="lang-js">/* 使用策略模式优化 —— 策略类 */class Customer {  constructor(kind) {    this.kind = kind;  }  pay(amount) {    return this.kind.pay(amount);  }}// 策略类class Normal {  pay(amount) {    return amount;  }}class Member {  pay(amount) {    return amount * 0.9;  }}class VIP {  pay(amount) {    return amount * 0.8;  }}const c1 = new Customer(new Normal());const c2 = new Customer(new Member());const c3 = new Customer(new VIP());console.log(c1.pay(100)); // 100console.log(c2.pay(100)); // 90console.log(c3.pay(100)); // 80</code></pre><p>上面是使用策略类对复杂判断逻辑的内容进行了抽象，并将原本 <code>if...else</code> 中的逻辑分别放在了不同的策略类中维护，如果每一个策略类中要维护的逻辑并不是很复杂，也可以使用第二种方案，即使用策略对象维护不同的逻辑。</p><pre><code class="lang-js">/* 使用策略模式优化 —— 策略对象 */class Customer {  constructor() {    // 策略对象    this.kinds = {      normal(amount) {        return amount;      },      member(amount) {        return amount * 0.9;      },      vip(amount) {        return amount * 0.8;      }    };  }  pay(kind, amount) {    return this.kinds[kind](amount);  }}const c1 = new Customer();const c2 = new Customer();const c3 = new Customer();console.log(c1.pay(&#39;normal&#39;, 100)); // 100console.log(c2.pay(&#39;member&#39;, 100)); // 90console.log(c3.pay(&#39;vip&#39;, 100)); // 80</code></pre><h2 id="策略模式的应用"><a href="#策略模式的应用" class="headerlink" title="策略模式的应用"></a>策略模式的应用</h2><h3 id="jQuery-的-animate-动画"><a href="#jQuery-的-animate-动画" class="headerlink" title="jQuery 的 animate 动画"></a>jQuery 的 animate 动画</h3><p>在 <code>jQuery</code> 的源码实现中，<code>animate</code> 方法就用到了 “策略模式”，通过不同的状态定义了动画不同的行为，使用代码如下：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;jQuery-animate&lt;/title&gt;  &lt;style&gt;    #content{      width: 100px;      height: 100px;      background-color: pink;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;bigger&quot;&gt;变大&lt;/button&gt;  &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;  &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    $(&#39;#bigger&#39;).on(&#39;click&#39;, function () {      $(&#39;#content&#39;).animate({        width: &#39;200px&#39;,        height: &#39;200px&#39;      }, 1000, &#39;linear&#39;); // linear 参数为动画策略的一种类型    });  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>在 <a href="/20180928030105/" target="_blank">装饰器模式</a> 一节中也有表单校验的应用，代码如下：</p><pre><code class="lang-html">&lt;!-- 表单校验应用装饰器模式 --&gt;&lt;form&gt;  用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;  密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;  &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt;&lt;form&gt;&lt;script&gt;  const submitBtn = document.getElementById(&#39;submit-btn&#39;);  // 添加切面函数  Function.prototype.before = function (beforeFn) {    const _this = this;    return function () {      let result = beforeFn.apply(this, arguments);      result &amp;&amp; _this.apply(this, arguments);    }  }  // 表单提交事件  function submit() {    console.log(&#39;提交表单&#39;);  }  // 验证用户名  submit = submit.before(function () {    const username = document.getElementById(&#39;username&#39;).value;    if (!username) {      return alert(&#39;请输入用户名&#39;);    }    return true;  });  // 验证  submit = submit.before(function () {    const password = document.getElementById(&#39;password&#39;).value;    if (!password) {      return alert(&#39;请输入密码&#39;);    }    return true;  });  submitBtn.addEventListener(&#39;click&#39;, submit);&lt;/script&gt;</code></pre><p>“装饰器模式” 是将对每个表单校验逻辑，通过增加切面（<code>AOP</code>）的方式插入在了 <code>submit</code> 事件之前，如果有一个校验不通过则不会执行下一个切面的校验操作或提交表单，但是这样的表单校验有局限性，如果页面表单校验非常多需要对校验逻辑进行统一管理，并且大多数场景下是所有的表单都校验后对所有的表单进行错误提示，这是就需要 “策略模式” 的策略对象来管理所有的校验逻辑。</p><pre><code class="lang-html">&lt;!-- 表单校验应用策略模式 --&gt;&lt;form id=&quot;userform&quot;&gt;  用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;  密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;  手机号：&lt;input type=&quot;text&quot; name=&quot;mobile&quot;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script&gt;  const form = document.getElementById(&#39;userform&#39;);  const validator = (function () {    const rules = {      noEmpty(val, msg) {        if (val === &#39;&#39;) return msg;      },      minLength(val, min, msg){        if (val === &#39;&#39; || val.length &lt; min) return msg;      },      isMobile(val, msg) {        if (!/1\d{10}/.test(val)) return msg;      }    };    // 存储    const checks = [];    // 增加校验的项目    function add(element, rule) {      checks.push(function () {        // [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;]        const name = rule.shift();        // [val, 6, &#39;密码长度不能少于 6 位&#39;]        rule.unshift(element.value);        return rules[name] &amp;&amp; rules[name].apply(element, rule);      });    }    // 给策略对象增加新的功能    function addRule(name, rule){      rules[name] = rule;    }    // 开始校验    function start() {      for (let i = 0; i &lt; checks.length; i++) {        const msg = checks[i]();        if (msg) return msg;      }    }    return { add, addRule, start };  })();  // 添加自定义规则  validator.addRule(&#39;maxLength&#39;, function (val, max, msg) {    if (val === &#39;&#39; || val.length &gt; max) return msg;  });  form.onsubmit = function () {    validator.add(form.username, [&#39;noEmpty&#39;, &#39;用户名不能为空&#39;]);    validator.add(form.password, [&#39;minLength&#39;, 6, &#39;密码长度不能少于 6 位&#39;]);    validator.add(form.password, [&#39;maxLength&#39;, 12, &#39;密码长度不能大于 12 位&#39;]);    validator.add(form.mobile, [&#39;isMobile&#39;, &#39;必须输入合法的手机号&#39;]);    const msg = validator.start();    alert(msg || &#39;校验通过&#39;);    return !msg;  }&lt;/script&gt;</code></pre><p>通过对比两段代码可以显而易见的看出 “策略模式” 在对于表单校验的功能上比 “装饰器模式” 更加健壮，可以在保证可维护性的基础上支持更多复杂的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“策略模式” 和 “状态模式” 都有上下文、策略和状态类，上下文把这些请求委托给这些类来执行，“策略模式” 中，各个类是平等的，没有关系，客户端需要知道算法主动切换，“状态模式” 中，状态的切换和行为被封装好了，客户端不需要了解细节，所以 “策略模式” 真正意义的解决了状态过多时条件判断过多的问题，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/10.strategy" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181006014812/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 状态模式</title>
      <link>https://www.overtaking.top/20181005161213/</link>
      <guid>https://www.overtaking.top/20181005161213/</guid>
      <pubDate>Fri, 05 Oct 2018 08:12:13 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20181005161213/state.jpg&quot; title=&quot;状态模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote danger&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181005161213/state.jpg" title="状态模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote danger"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="状态模式简介"><a href="#状态模式简介" class="headerlink" title="状态模式简介"></a>状态模式简介</h2><p>有些情况下一个对象的行为取决于一个或者多个动态变化的属性，这样的属性叫做状态，这个对象叫做有状态的对象，这种情况下通常有很多的判断来处理状态不同时代码的执行逻辑，执行逻辑可能会非常复杂，让代码变得难以维护，“状态模式” 就是将这些逻辑委托给外面的对象或类来单独维护，来减少状态对象的逻辑，增强代码的维护性。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181005161213/state-uml.jpg" alt="状态模式 UML 图"></div><div class="image-caption">状态模式 UML 图</div></figure><p><br></p><h2 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h2><p>下面是一个类，功能为根据电池不同状态打印当前不同的颜色，下面是正常的实现方式。</p><pre><code class="lang-js">class Battery {  constructor() {    this.amount = &#39;high&#39;; // 电量高  }  show() {    if (this.amount === &#39;high&#39;) {      console.log(&#39;显示绿色&#39;);      this.amount = &#39;middle&#39;; // 电量中等    } else if (this.amount === &#39;middle&#39;) {      console.log(&#39;显示黄色&#39;);      this.amount = &#39;low&#39;; // 电量低    } else if (this.amount === &#39;low&#39;) {      console.log(&#39;显示红色&#39;);    }  }}const battery = new Battery();battery.show(); // 显示绿色battery.show(); // 显示黄色battery.show(); // 显示红色</code></pre><p>上面的代码虽然实现了我们想要的功能，但是代码中 <code>show</code> 方法违反了开放封闭原则和单一职责原则，状态切换逻辑不明显，判断条件太多，维护性和扩展性差，下面使用状态模式进行优化。</p><pre><code class="lang-js">class Battery {  constructor() {    this.amount = &#39;high&#39;; // 电量高    this.state = new SuccessState(); // 绿色状态  }  show() {    // 把显示逻辑委托给状态对象    this.state.show();    if (this.amount === &#39;high&#39;) {      this.amount = &#39;middle&#39;; // 电量中等      this.state = new WarningState(); // 黄色状态    } else if (this.amount === &#39;middle&#39;) {      this.amount = &#39;low&#39;; // 电量低      this.state = new ErrorState(); // 红色状态    }  }}class SuccessState {  show() {    console.log(&#39;显示绿色&#39;);  }}class WarningState {  show() {    console.log(&#39;显示黄色&#39;);  }}class ErrorState {  show() {    console.log(&#39;显示红色&#39;);  }}const battery = new Battery();battery.show(); // 显示绿色battery.show(); // 显示黄色battery.show(); // 显示红色</code></pre><p>经过 “状态模式” 的优化，我们将状态拆分成三个类，无论关于状态操作的多复杂的逻辑都在拆分出的类中实现，而不再需要在状态对象 <code>Battery</code> 中。</p><h2 id="状态模式的应用"><a href="#状态模式的应用" class="headerlink" title="状态模式的应用"></a>状态模式的应用</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>点赞是我们在项目开发中经常见到的功能，点赞后也可以取消点赞，这就出现了按钮关于点赞状态的切换和按钮文案的切换，下面是使用 “状态模式” 来实现的点赞功能。</p><pre><code class="lang-html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script&gt;  // 维护点赞渲染逻辑的对象  const likeState = {    render(element) {      element.innerHTML = &#39;赞&#39;;    }  };  // 维护取消点赞渲染逻辑的对象  const likedState = {    render(element) {      element.innerHTML = &#39;取消&#39;    }  }  class Button {    constructor(container) {      this.liked = false; // 默认为未点赞状态      this.state = likeState; // 设置当前的状态为未点赞      this.element = document.createElement(&#39;button&#39;);      container.appendChild(this.element);      this.render(); // 初始化渲染    }    setState(state) {      this.state = state; // 修改渲染状态      button.liked = !button.liked; // 修改状态属性      this.render(); // 重新渲染    }    render() {      this.state.render(this.element);    }  }  // 获取按钮对象并添加点击事件  const button = new Button(document.getElementById(&#39;root&#39;));  button.element.addEventListener(&#39;click&#39;, () =&gt; {    button.setState(button.liked ? likeState : likedState);  });&lt;/script&gt;</code></pre><p>上面代码使用 “状态模式” 统一封装了按钮的类 <code>Button</code>，传入的参数为渲染按钮的容器元素，按钮类的内部创建按钮并添加到容器元素中，统一管理了点赞状态，点赞渲染对象，如果想要切换状态只需要执行 <code>button</code> 对象提供的 <code>setState</code> 方法通过传入的不同状态对象进行状态切换和页面渲染。</p><h3 id="React-组件显示隐藏"><a href="#React-组件显示隐藏" class="headerlink" title="React 组件显示隐藏"></a>React 组件显示隐藏</h3><p>在 <code>React</code> 中，经常会出现通过事件切换组件的显示隐藏，最简单的方式是通过类组件状态来控制，但其实也可以使用 “状态模式” 在组件外编写对状态更改的逻辑，这样可以使组件的逻辑更清晰，代码更精简。</p><pre><code class="lang-jsx">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;// 状态管理对象const States = {  show() {    console.log(&#39;显示 Banner&#39;);    this.setState({ isShow: true });  },  hide() {    console.log(&#39;隐藏 Banner&#39;);    this.setState({ isShow: false });  }};class Banner extends React.Component {  state = { isShow: true }  toggle = () =&gt; {    const currentState = this.state.isShow ? &#39;hide&#39; : &#39;show&#39;;    States[currentState] &amp;&amp; States[currentState].apply(this);  }  render() {    return (      &lt;div&gt;        {          isShow &amp;&amp; (            &lt;nav&gt;导航&lt;/nav&gt;          )        }        &lt;button&gt;toggle&lt;/button&gt;      &lt;/div&gt;    )  }}ReactDOM.render(&lt;Banner /&gt;, document.getElementById(&#39;root&#39;));</code></pre><p>在上面代码中组件外部的 <code>States</code> 就是管理切换状态逻辑的对象，就是说 “状态模式” 也可以在框架中单独使用。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>其实 “状态模式” 来源一个有限状态机的概念，有限状态机是指一个事物拥有多种状态，但是同一时间只会处于一种状态，可以通过动作来改变当前的状态，在 <code>JavaScript</code> 中拥有第三方模块 <code>javascript-state-machine</code> 专门帮我们来做这件事。</p><h3 id="javascript-state-machine-使用"><a href="#javascript-state-machine-使用" class="headerlink" title="javascript-state-machine 使用"></a>javascript-state-machine 使用</h3><p><code>javascript-state-machine</code> 提供一个类，创建实例时传入的参数为一个 <code>options</code> 对象，属性 <code>init</code> 用来定义初始状态值，属性 <code>transitions</code> 用来定义属性变化，<code>methods</code> 用来定义属性发生变化时所触发的钩子。</p><pre><code class="lang-js">// 有限状态机对象const StateMachine = require(&#39;javascript-state-machine&#39;);const fsm = new StateMachine({  init: &#39;solid&#39;, // 初始状态（固态）  transitions: [    { from: &#39;solid&#39;, to: &#39;liquid&#39;, name: &#39;melt&#39; },    { from: &#39;liquid&#39;, to: &#39;solid&#39;, name: &#39;freeze&#39; },    { from: &#39;liquid&#39;, to: &#39;gas&#39;, name: &#39;vaporize&#39; },    { from: &#39;gas&#39;, to: &#39;liquid&#39;, name: &#39;condense&#39; }  ],  methods: {    onMelt() {      console.log(&#39;melt&#39;);    },    onFreeze() {      console.log(&#39;freeze&#39;);    },    onVaporize() {      console.log(&#39;vaporize&#39;);    },    onCondense() {      console.log(&#39;condense&#39;);    }  }});console.log(fsm.state); // solidconsole.log(fsm.can(&#39;gas&#39;)); // falseconsole.log(fsm.cannot(&#39;gas&#39;)); // trueconsole.log(fsm.transitions()); // [ &#39;melt&#39; ]console.log(fsm.allTransitions());// [ &#39;init&#39;, &#39;melt&#39;, &#39;freeze&#39;, &#39;vaporize&#39;, &#39;condense&#39; ]console.log(fsm.allStates()); // [ &#39;none&#39;, &#39;solid&#39;, &#39;liquid&#39;, &#39;gas&#39; ]fsm.melt(); // meltconsole.log(fsm.state); // liquidconsole.log(fsm.transitions()); // [ &#39;freeze&#39;, &#39;vaporize&#39; ]</code></pre><blockquote class="pullquote warning"><ul><li><strong><code>fsm.state</code>：当前状态；</strong></li><li><strong><code>fsm.can</code>：查看是否可直接转换到某个状态，参数为要转换的状态值；</strong></li><li><strong><code>fsm.cannot</code>：查看是否不能直接转换到某个状态，参数为要转换的状态值；</strong></li><li><strong><code>fsm.transitions</code>：返回可转换状态的方法列表；</strong></li><li><strong><code>fsm.allTransitions</code>：返回所有状态转换方法列表；</strong></li><li><strong><code>fsm.allStates</code>：返回定义的所有状态。</strong></li></ul></blockquote><h3 id="javascript-state-machine-原理"><a href="#javascript-state-machine-原理" class="headerlink" title="javascript-state-machine 原理"></a>javascript-state-machine 原理</h3><p>根据 <code>javascript-state-machine</code> 的用法我们模拟实现最基本的逻辑，构建一个有限状态机，代码如下：</p><pre><code class="lang-js">class StateMachine {  constructor(options) {    const {      init = &#39;none&#39;,      transitions = [],      methods = {}    } = options;    this.state = init;    transitions.forEach(transition =&gt; {      const { from, to, name } = transition;      this[name] = function () {        if (this.state === from) {          this.state = to;          const method = &#39;on&#39; + name.slice(0, 1).toUpperCase() + name.slice(1);          methods[method] &amp;&amp; methods[method]();        }      }    });  }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“状态模式” 实现的有限状态机可以更大限度的让状态变化与状态对象进行解耦，更减少了大量的判断逻辑，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/9.state" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181005161213/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 发布/订阅和观察者模式</title>
      <link>https://www.overtaking.top/20181004114907/</link>
      <guid>https://www.overtaking.top/20181004114907/</guid>
      <pubDate>Thu, 04 Oct 2018 03:49:07 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20181004114907/observer.jpg&quot; title=&quot;观察者模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote primary&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181004114907/observer.jpg" title="观察者模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote primary"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote warning"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><h3 id="发布-订阅模式实现"><a href="#发布-订阅模式实现" class="headerlink" title="发布/订阅模式实现"></a>发布/订阅模式实现</h3><p>在说 “观察者模式” 之前一定要说一下 “发布/订阅模式”，因为这两个模式非常相似又有些不同，最重要的是在设计模式中使用频繁。</p><pre><code class="lang-js">/* 发布/订阅的类 */class Event {  constructor() {    this.events = {};  }  on(type, fn) {    (this.events[type] || (this.events[type] = [])).push(fn)  }  emit(type) {    if (this.events[type]) {      this.events[type].forEach(fn =&gt; fn());    }  }}</code></pre><p>上面的类有一个基本属性 <code>events</code>，值为对象，用来存储不同类型的事件集合，原型方法 <code>on</code> 是用来订阅事件，第一个参数 <code>type</code> 为订阅事件的类型，<code>fn</code> 是要被执行的事件，<code>emit</code> 方法用来执行某个类型所有的事件。</p><pre><code class="lang-js">/* 发布/订阅的使用 */const event = new Event();// 订阅事件event.on(&#39;say&#39;, () =&gt; console.log(&#39;hello&#39;));event.on(&#39;say&#39;, () =&gt; console.log(&#39;world&#39;));// 发布事件event.emit(&#39;say&#39;);// hello// world</code></pre><h3 id="发布-订阅模式的应用"><a href="#发布-订阅模式的应用" class="headerlink" title="发布/订阅模式的应用"></a>发布/订阅模式的应用</h3><p><strong>浏览器事件监听：</strong></p><pre><code class="lang-html">&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;script&gt;  const btn = document.getElementById(&#39;btn&#39;);  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(1));  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(2));  btn.addEventListener(&#39;click&#39;, () =&gt; console.log(3));&lt;/script&gt;</code></pre><p>当点击按钮触发事件时，三个回调函数会按照添加的顺序依次执行。</p><p><strong><code>Promise</code> 的异步调用的回调管理：</strong></p><pre><code class="lang-js">const promise = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; resolve(&#39;res&#39;), 3000);});promise.then(data =&gt; console.log(1, data));promise.then(data =&gt; console.log(2, data));</code></pre><p>上面给同一个 <code>Promise</code> 实例的 <code>then</code> 方法中添加了两个回调函数，因为在创建 <code>Promise</code> 实例时内部使用了定时器，所以状态的变化延后了 <code>3s</code>，其实在 <code>Promise</code> 内部也是通过队列来对 <code>then</code> 的回调进行统一管理，在状态发生变化后立即循环执行。</p><blockquote class="pullquote danger"><p><strong>在 <code>Node.js</code> 中，有一个核心模块 <code>events</code> 提供的类 <code>EventEmitter</code>，几乎所有的事件都是基于这个模块实现的，如流的 <code>data</code> 和 <code>end</code> 事件、<code>http</code> 的 <code>request</code> 事件，而 <code>EventEmitter</code> 的内部原理就是 “发布/订阅模式”。</strong></p></blockquote><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="观察者模式的简单实现"><a href="#观察者模式的简单实现" class="headerlink" title="观察者模式的简单实现"></a>观察者模式的简单实现</h3><p>下面我们是 “观察者模式” 的案例，通过上面 “发布/订阅模式” 的实现来对比一下异同。</p><pre><code class="lang-js">/* 观察者模式 */// 被观察者类class Star {  constructor(name) {    this.name = name;    this.state = &#39;&#39;;    this.observers = [];  }  getState() {    return this.state;  }  setState(state) {    this.state = state;    this.notify(); // 更新状态后通知  }  attach(observer) {    this.observers.push(observer); // 添加观察者  }  notify() {    // 订阅状态的观察者更新修改后的状态    this.observers.forEach(observer =&gt; observer.update());  }}// 观察者类class Fan {  constructor(name, star) {    this.name = name;    this.star = star;    this.star.attach(this);  }  update() {    console.log(&#39;我喜欢的明星喜欢&#39; + this.star.getState() + &#39;，我也喜欢。&#39;);  }}</code></pre><p>在 “观察者模式” 中有两个基本的类，观察者和被观察者，被观察者提供状态 <code>state</code>，观察者去使用这个状态，当被观察者更新状态时会主动发布到订阅了状态的观察中，实现同步更新。</p><pre><code class="lang-js">const star = new Star(&#39;Super Star&#39;);const fan = new Fan(&#39;张三&#39;, star);star.setState(&#39;绿色&#39;);// 我喜欢的明星喜欢绿色，我也喜欢。</code></pre><h3 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h3><p><strong><code>Vue</code> 框架的数据响应式原理及 <code>watch</code> 方法：</strong></p><pre><code class="lang-html">&lt;div id=&quot;root&quot;&gt;  &lt;p&gt;FullName: {{fullName}}&lt;/p&gt;  &lt;p&gt;    FirstName:    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt;  &lt;/p&gt;  &lt;p&gt;    LastName:    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt;  &lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script&gt;  new Vue({    el: &#39;#root&#39;,    data: {      firstName: &#39;张&#39;,      lastName: &#39;三&#39;,      fullName: &#39;张三&#39;    },    watch: {      firstName(newName, oldName) {        this.fullName = newName + this.lastName;      }    }  });&lt;/script&gt;</code></pre><p>在 <code>Vue 2.x</code> 版本的数据响应式和 <code>watch</code> 监听的底层，就使用了 “观察者模式”，在模板解析过程中为变量添加观察者（<code>watcher</code>），在使用 <code>Object.defineProperty</code> 的 <code>getter</code> 和 <code>setter</code> 进行劫持数据，数据获取和更改会触发 <code>get</code> 和 <code>set</code> 方法，进而执行订阅和通知的逻辑，而通知的过程中调用了被统一管理的观察者的 <code>update</code> 方法，实现了视图层与数据层的同步。</p><p><strong><code>redux</code> 的 <code>createStore</code> 方法：</strong></p><pre><code class="lang-js">function createStore(reducer) {  let state;  let listeners = [];  // 获取 store  const getState = () =&gt; JSON.parse(JSON.stringify(state));  // 订阅方法  const subscribe = fn =&gt; {    listeners.push(fn);    // 取消订阅方法    return () =&gt; {      listeners = listeners.filter(listener =&gt; listener !== fn);    };  }  // 派发动作  const dispatch = action =&gt; {    state = reducer(state, action);    listeners.forEach(listener =&gt; listener());  }  dispatch({ type: &#39;@INIT&#39; });  return {    getState,    subscribe,    dispatch  };}</code></pre><p>在 <code>redux</code> 的实现思想中也包含了 “观察者模式”，例如在 <code>redux</code> 与 <code>React</code> 的配合使用，<code>redux</code> 提供了订阅的方法 <code>subscribe</code> 和派发动作更新 <code>store</code> 的方法 <code>dispatch</code>，<code>React</code> 组件会使用 <code>store</code> 中提供的状态数据，这个 <code>store</code> 就是被观察者，而观察者就是 <code>React</code> 的各个组件，当使用 <code>dispatch</code> 派发动作更新数据时，会执行所有的观察者中的监听函数，实现组件数据与 <code>store</code> 的同步。</p><h2 id="发布-订阅模式和观察者模式"><a href="#发布-订阅模式和观察者模式" class="headerlink" title="发布/订阅模式和观察者模式"></a>发布/订阅模式和观察者模式</h2><p>观察者模式是由 “发布/订阅模式” 演变过来的，都存在订阅、通知的事件机制，“发布/订阅模式” 是对订阅的事件进行统一管理，主动触发通知，依次执行订阅的事件，而 “观察者模式” 是通过一个单独类去订阅观察者，当状态发生变化时通知到各个 “观察者” 实现状态的更新同步。</p><blockquote class="pullquote info"><p><strong>“发布/订阅模式” 与 “观察者模式” 的区别：</strong></p><ul><li><strong>“发布/订阅模式” 事件是统一由调度中心调度，订阅发布不存在依赖；</strong></li><li><strong>“观察者模式” 事件是被观察者调度，订阅与发布是存在依赖的；</strong></li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“观察者模式” 的意义就在于可以使多个对象数据重合的部分进行复用，同时还可以对各个对象之间解耦，最重要的是数据更新可以及时通知所有数据的使用者进行数据同步，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/8.observe" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181004114907/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Webpack4 —— 基础篇</title>
      <link>https://www.overtaking.top/20181002041434/</link>
      <guid>https://www.overtaking.top/20181002041434/</guid>
      <pubDate>Mon, 01 Oct 2018 20:14:34 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/Compile/20181002041434/webpack-basic.png&quot; title=&quot;webpack basic&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;系列文章链接：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/20181115105656/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 应用篇&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/20181110203121/&quot; target=&quot;_blank&quot;&gt;Webpack4 —— 优化篇&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;为什么需要构建工具？&quot;&gt;&lt;a href=&quot;#为什么需要构建工具？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要构建工具？&quot;&gt;&lt;/a&gt;为什么需要构建工具？&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;转换 &lt;code&gt;ES6+&lt;/code&gt; 语法；&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;转换 &lt;code&gt;JSX&lt;/code&gt; 语法 / &lt;code&gt;Vue&lt;/code&gt; 指令；&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;CSS&lt;/code&gt; 私有前缀补全 / 预处理器（&lt;code&gt;less&lt;/code&gt;，&lt;code&gt;sass&lt;/code&gt;）；&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;压缩混淆 / 图片压缩；&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/Compile/20181002041434/webpack-basic.png" title="webpack basic"><p><br></p><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20181115105656/" target="_blank">Webpack4 —— 应用篇</a></li><li><a href="/20181110203121/" target="_blank">Webpack4 —— 优化篇</a></li></ul></blockquote><h2 id="为什么需要构建工具？"><a href="#为什么需要构建工具？" class="headerlink" title="为什么需要构建工具？"></a>为什么需要构建工具？</h2><blockquote class="pullquote info"><ul><li><strong>转换 <code>ES6+</code> 语法；</strong></li><li><strong>转换 <code>JSX</code> 语法 / <code>Vue</code> 指令；</strong></li><li><strong><code>CSS</code> 私有前缀补全 / 预处理器（<code>less</code>，<code>sass</code>）；</strong></li><li><strong>压缩混淆 / 图片压缩；</strong></li></ul></blockquote><a id="more"></a><h2 id="为什么选择-Webpack？"><a href="#为什么选择-Webpack？" class="headerlink" title="为什么选择 Webpack？"></a>为什么选择 Webpack？</h2><p>早期的打包工具有 <code>Grount</code>，把打包构建分成一个一个的任务，队列式的处理每一个任务，如解析 <code>html</code> 任务、解析 <code>CSS</code> 任务、解析 <code>JS</code> 任务、图片压缩任务、代码压缩任务等等，每一个任务处理完成之后会将任务结果存放在本地磁盘的 <code>.temp</code> 目录，由于产生了 <code>IO</code> 操作，会导致打包速度比较慢。</p><p>后来产生了 <code>Glup</code>，原理与 <code>Grount</code> 类似，管道式的处理打包任务，不同的是 <code>Gulp</code> 有文件流的概念，每一个任务构建后的结果不会存放磁盘，而是存在内存中，在下一个步骤中可以直接使用上一个步骤内存中的结果，提高了打包速度。</p><p>目前最火爆的打包工具是 <code>Webpack</code>，在打包性能优于上面工具的基础上，更归功于丰富的生态社区、配置灵活的 <code>loader</code> 和 <code>plugin</code>，可以通过很灵活的配置完成团队项目个性化的打包需求，并且拥有强大的官方团队进行更新迭代，维护了众多稳定的 <code>loader</code> 和 <code>plugin</code>，更新速度非常快。</p><h2 id="安装-Webpack-及打包命令"><a href="#安装-Webpack-及打包命令" class="headerlink" title="安装 Webpack 及打包命令"></a>安装 Webpack 及打包命令</h2><p><strong>安装：</strong></p><pre><code class="lang-bash">$ npm install webpack webpack-cli -D</code></pre><p>使用 <code>Webpack</code> 进行打包执行的其实是 <code>./node_modules/.bin</code> 目录的 <code>webpack</code> 文件。</p><pre><code class="lang-bash"># 打包命令$ ./node_modules/.bin/webpack</code></pre><p>为了方便项目中通常将打包命令配置在 <code>package.json</code> 的 <code>scripts</code> 中。</p><pre><code class="lang-json">/* 打包命令配置 */{  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack&quot;  }}</code></pre><p><strong>执行配置后的打包命令：</strong></p><pre><code class="lang-bash">$ npm run build</code></pre><h2 id="Webpack-基础配置"><a href="#Webpack-基础配置" class="headerlink" title="Webpack 基础配置"></a>Webpack 基础配置</h2><h3 id="零配置"><a href="#零配置" class="headerlink" title="零配置"></a>零配置</h3><p>在 <code>Webpack4</code> 中，在不编写配置文件也可以进行打包，这就是 <code>4.x</code> 版本号称的 “零配置”，其实内部默认对入口文件（<code>entry</code>）和出口文件（<code>output</code>）进行了配置。</p><pre><code class="lang-js">/* 零配置默认值 */module.exports = {  entry: &#39;./src/index.js&#39;,  output: &#39;./dist/main.js&#39;}</code></pre><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p><code>mode</code> 是 <code>Webpack4</code> 新提出的概念，用来指定当前构建环境是开发环境（<code>production</code>）、生产环境（<code>development</code>）或 <code>none</code>，默认为 <code>production</code>，设置 <code>mode</code> 可以使用 <code>Webpack</code> 的一些参数值和内置的函数，也可以在打包时针对不同的环境配置不同的打包和优化策略。</p><p><strong><code>mode</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  mode: &#39;development&#39;  // ...}</code></pre><blockquote class="pullquote warning"><p><strong>设置为 <code>development</code> 开启的参数如下：</strong></p><ul><li><strong>设置 <code>process.env.NODE_ENV</code> 值为 <code>development</code>；</strong></li><li><strong>开启 <code>NamedChunksPlugin</code>、<code>NamedModulesPlugin</code>，在代码热更新阶段标识更新的 <code>chunk</code> 和具体模块。</strong></li></ul><p><strong>设置为 <code>production</code> 开启的参数如下：</strong></p><ul><li><strong>设置 <code>process.env.NODE_ENV</code> 值为 <code>production</code>；</strong></li><li><strong>开启 <code>FlagDependencyUsagePlugin</code>、<code>FlagIncludedChunksPlugin</code>、<code>NoEmitOnErrorsPlugin</code>、<code>ModuleConcatenationPlugin</code>、<code>OccurrenceOrderPlugin</code>、<code>SideEffectsFlagPlugin</code>、<code>TerserPlugin</code>，开启这些插件 <code>Webpack</code> 会对 <code>JS</code> 压缩，识别 <code>package.json</code> 文件中标识代码是否存在副作用的参数等。</strong></li></ul><p><strong>将 <code>mode</code> 设置为 <code>none</code> 不开启任何优化选项。</strong></p></blockquote><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p><code>entry</code> 用于配置打包文件的入口，这个文件中会存在一些依赖关系，依赖的模块又存在依赖关系，最后形成一棵依赖树，<code>Webpack</code> 则将这些模块根据依赖关系，最后打包成多个静态资源，<code>entry</code> 主要有两种应用场景（单页应用和多页应用），配置如下。</p><pre><code class="lang-js">/* 单入口（SPA） */module.exports = {  entry: &#39;./src/index.js&#39;}</code></pre><pre><code class="lang-js">/* 多入口（多页应用） */module.exports = {  entry: {    app: &#39;./src/pages/app.js&#39;,    adminApp: &#39;./src/pages/adminApp.js&#39;  }}</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>entry</code> 配置是用于指定的是源代码，那 <code>output</code> 就是用于指定 <code>Webpack</code> 打包后的结果代码，即用来告诉 <code>Webpack</code> 如何将编译后的文件输出到磁盘。</p><pre><code class="lang-js">module.exports = {  // ...  output: {    filename: &#39;bundle.js&#39;,    path: __dirname + &#39;/dist&#39;  }}</code></pre><p><code>output</code> 属性值为对象，其中 <code>filename</code> 属性用于指定打包输出后的文件名，<code>path</code> 用于指定打包输出的目录，如果是多页应用，可以使用占位符保证打包后输出多个出口文件名字的唯一性。</p><pre><code class="lang-js">/* 多页应用 */module.exports = {  entry: {    app: &#39;./src/pages/app.js&#39;,    adminApp: &#39;./src/pages/adminApp.js&#39;  },  output: {    filename: &#39;[name].js&#39;,    path: __dirname + &#39;/dist&#39;  }}</code></pre><p>上面的 <code>[name]</code> 打包后最后输出的出口文件与入口配置的文件名对应，即 <code>app.js</code> 和 <code>adminApp.js</code>。</p><h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p><code>Webpack</code> 默认情况下只支持 <code>js</code> 和 <code>json</code> 两种文件类型，<code>loader</code> （加载器）是专门用来支持其他文件类型并把其他文件转换成有效的模块添加到依赖树中，每一个 <code>loader</code> 都默认导出一个函数，接受源文件作为参数，并返回转换的结果，<code>loaders</code> 选项是专门用来配置这些加载器的。</p><p><strong>常见 loader 表：</strong></p><table><thead><tr><th style="width:30%">名称</th><th>描述</th></tr></thead><tbody><tr><td>babel-loader</td><td>转化 ES6、ES7 等 JS 新特性</td></tr><tr><td>css-loader</td><td>支持 .css 文件的加载和解析</td></tr><tr><td>less-loader</td><td>将 less 文件转换成 css</td></tr><tr><td>ts-loader</td><td>将 TS 转换成 JS</td></tr><tr><td>file-loader</td><td>对图片、字体等文件的打包</td></tr><tr><td>raw-loader</td><td>将文件以字符串的形式导入</td></tr><tr><td>thread-loader</td><td>多进程打包 JS 和 CSS</td></tr></tbody></table><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      {        test: /\.txt$/, // 指定匹配规则（文件后缀名）        use: &#39;raw-loader&#39; // 指定使用的 loader 名称      }    ]  }}</code></pre><h4 id="解析-ES6-语法"><a href="#解析-ES6-语法" class="headerlink" title="解析 ES6+ 语法"></a>解析 ES6+ 语法</h4><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader @babel/preset-env -D</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.js$/,        use: &#39;babel-loader&#39;      }      // ...    ]  }  // ...}</code></pre><blockquote class="pullquote success"><p><strong>在工程中添加 <code>.babelrc</code> 文件来对解析的 <code>ES6+</code> 语法进行配置。</strong></p></blockquote><p><strong><code>.babelrc</code> 配置示例：</strong></p><pre><code class="lang-json">/* 以 babel7 为例 */{  &quot;presets&quot;: [    &quot;@babel/preset-env&quot;  ],  &quot;plugins&quot;: [    &quot;@babel/proposal-class-properties&quot;    // ...  ]}</code></pre><blockquote class="pullquote primary"><p><strong><code>babel</code> 配置主要包含两部分，<code>presets</code> 和 <code>plugins</code>，<code>plugins</code> 中配置的每一项都是为了解析某一个语法，而 <code>presets</code> 配置的是这些功能的集合。</strong></p></blockquote><h4 id="解析-React-的-JSX-语法"><a href="#解析-React-的-JSX-语法" class="headerlink" title="解析 React 的 JSX 语法"></a>解析 React 的 JSX 语法</h4><p>由于 <code>React</code> 是在 <code>.js</code> 或 <code>.jsx</code> 的文件中使用 <code>JSX</code> 语法，所以解析 <code>JSX</code> 语法也是解析 <code>JS</code> 工作的一部分，同样需要 <code>babel-loader</code>，需要在 <code>Webpack</code> 配置文件的 <code>loader</code> 配置中增加识别 <code>.jsx</code> 文件以及在 <code>.babelrc</code> 配置文件的 <code>presets</code> 中专门增加解析 <code>JSX</code> 功能的集合。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install babel-loader @babel/preset-env @babel/preset-react -D</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.(jsx?)$/,        use: &#39;babel-loader&#39;      }      // ...    ]  }  // ...}</code></pre><p><strong><code>.babelrc</code> 配置示例：</strong></p><pre><code class="lang-json">{  &quot;presets&quot;: [    &quot;@babel/preset-env&quot;,    &quot;@babel/preset-react&quot;  ],  &quot;plugins&quot;: [    &quot;@babel/proposal-class-properties&quot;    // ...  ]}</code></pre><h4 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h4><blockquote class="pullquote default"><p><strong>解析 <code>CSS</code> 主要靠 <code>css-loader</code> 和 <code>style-loader</code>：</strong></p><ul><li><strong><code>css-loader</code>：用于加载 <code>.css</code> 文件，并转换成 <code>CommonJS</code> 对象；</strong></li><li><strong><code>style-loader</code>：将样式通过 <code>&lt;style&gt;&lt;/style&gt;</code> 标签插入到 <code>html</code> 文件的 <code>head</code> 中。</strong></li></ul></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader -D</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.css$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]      }      // ...    ]  }  // ...}</code></pre><blockquote class="pullquote warning"><p><strong>值得注意的是，在处理同一个类型文件使用多个 <code>loader</code> 时，是链式调用的，<code>loader</code> 的执行顺序是从右向左的，所以在编写解析 <code>CSS</code> 加载器配置时应该 <code>style-loader</code> 在前，<code>css-loader</code> 在后，即先通过 <code>css-loader</code> 解析 <code>.css</code> 文件，将解析好的结果传递给 <code>style-loader</code> 处理并插入到页面的 <code>head</code> 中。</strong></p></blockquote><h4 id="解析-Less-和-Sass"><a href="#解析-Less-和-Sass" class="headerlink" title="解析 Less 和 Sass"></a>解析 Less 和 Sass</h4><p><code>Less</code> 和 <code>Sass</code> 作为 <code>CSS</code> 的预编译语言，加入了很多编程的特性，功能更强，对样式的组织也更加的灵活，但是浏览器依然不识别，所以也需要 <code>Webpack</code> 进行编译转换。</p><p><strong>安装依赖（<code>Less</code>）：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader less-loader less -D</code></pre><p><strong>安装依赖（<code>Sass</code>）：</strong></p><pre><code class="lang-bash">$ npm install css-loader style-loader sass-loader node-sass -D</code></pre><p><strong><code>loader</code> 配置示例：</strong></p><pre><code class="lang-js">/* less 配置 */module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.less$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      }      // ...    ]  }  // ...}</code></pre><pre><code class="lang-js">/* sass 配置 */module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.scss$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]      }      // ...    ]  }  // ...}</code></pre><h4 id="解析图片和字体资源"><a href="#解析图片和字体资源" class="headerlink" title="解析图片和字体资源"></a>解析图片和字体资源</h4><p><code>Webpack</code> 对其他类型的文件进行打包编译需要依赖 <code>file-loader</code>（专门用于处理文件）。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install file-loader -D</code></pre><p><strong><code>file-loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.(png|svg|gif|jpe?g)$/, // 解析图片        use: &#39;file-loader&#39;      },      {        test: /\.(woff2?|eot|ttf|otf)$/, // 解析字体        use: &#39;file-loader&#39;      }      // ...    ]  }  // ...}</code></pre><blockquote class="pullquote default"><p><strong>也可以使用 <code>url-loader</code> 来实现对图片和字体资源的解析，<code>url-loader</code> 相比 <code>file-loader</code> 而言，支持更颗粒化的解析方式，可以配置解析后出口文件的具体目录，也可以根据资源大小设置将资源转换成 <code>base64</code>。</strong></p></blockquote><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install url-loader -D</code></pre><p><strong><code>url-loader</code> 配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.(png|svg|gif|jpe?g)$/, // 解析图片        use: [          {            loader: &#39;url-loader&#39;,            options: {              limit: 10240, // 资源小于该数值转为 base64              name: &#39;img/[name].[ext]&#39; // 打包后的输出路径            }          }        ]      }      // 字体资源同理...    ]  }  // ...}</code></pre><h4 id="PostCSS-对-CSS-的增强"><a href="#PostCSS-对-CSS-的增强" class="headerlink" title="PostCSS 对 CSS 的增强"></a>PostCSS 对 CSS 的增强</h4><p>在开发 <code>CSS</code> 时，存在着很多让我们头疼的的问题，比如有些 <code>CSS3</code> 的属性由于各浏览器的实现标准不同要加上不同的私有前缀，也比如为了在移动端进行页面适配使用的 <code>rem</code>、<code>vw</code> 单位与 <code>px</code> 的转换问题等等，其中的一部分问题其实是可以在 <code>Webpack</code> 构建的过程中直接解决的。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install postcss-loader autoprefixer postcss-px2rem -D</code></pre><p>可以通过 <code>Webpack</code> 配置文件中直接配置，也可以 <code>PostCSS</code> 配置文件中进行配置。</p><p><strong>配置示例：</strong></p><pre><code class="lang-js">/* 配置在 Webpack 配置文件 */module.exports = {  module: {    rules: [      // ...      {        test: /\.css/,        use: [          &#39;style-loader&#39;,          &#39;css-loader&#39;,          {            loader: &#39;postcss-loader&#39;, // 使用 postcss-loader            options: {              plugins: [                // 添加私有前缀                require(&#39;autoprefixer&#39;)({                  // 兼容浏览器版本（最后两个版本、使用率大于 1%，ios 7 以上）                  browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;]                }),                // px 自动转换 rem                require(&#39;postcss-px2rem&#39;)({                  remUnit: 75, // 75 px 等于 1 rem                  remPrecision: 8 // 换算结果小数点后面保留几位小数                })                // ...              ]            }          }        ]      }      // ...    ]  }}</code></pre><pre><code class="lang-js">/* 在 postcss.config.js 中配置 */module.exports = {  plugins: [    require(&#39;autoprefixer&#39;)({      browers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;]    }),    require(&#39;postcss-px2rem&#39;)({      remUnit: 75,      remPrecision: 8    })    // ...  ]}</code></pre><p>如果使用其他 <code>PostCSS</code> 的功能也是类似的，需要先下载对应的 <code>PostCSS</code> 插件，然后在配置文件中进行配置。</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p><code>plugins</code> 通常用来对 <code>Webpack</code> 打包功能的增强，对打包过程和出口文件大小的优化、资源管理和环境变量的注入，可以作用域整个构建过程。</p><p><strong>常见 plugin 表：</strong></p><table><thead><tr><th style="width:35%">名称</th><th>描述</th></tr></thead><tbody><tr><td>CommonsChunkPlugin</td><td>将 chunks 相同的模块代码提取成公共 js</td></tr><tr><td>CleanWebpackPlugin</td><td>清理构建目录</td></tr><tr><td>ExtracTextWebpackPlugin</td><td>将 CSS 从 bundle 文件里提取成一个独立的 .css 文件</td></tr><tr><td>CopyWebpackPlugin</td><td>将文件或者文件夹拷贝到构建的输出目录</td></tr><tr><td>HtmlWebpackPlugin</td><td>创建 html 文件并注入 bundle 文件</td></tr><tr><td>UglifyjsWebpackPlugin</td><td>压缩 .js 文件</td></tr><tr><td>ZipWebpackPlugin</td><td>将打包出的资源生成一个 .zip 包</td></tr></tbody></table><p><br></p><h4 id="自动生成-index-html"><a href="#自动生成-index-html" class="headerlink" title="自动生成 index.html"></a>自动生成 index.html</h4><p>自动生成 <code>index.html</code> 文件主要通过 <code>HtmlWebpackPlugin</code> 插件实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install html-webpack-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">// 引入插件const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = {  // ...  plugins: [    // 创建插件的实例    new HtmlWebpackPlugin({      template: &#39;./src/index.html&#39;, // 模板文件路径      filename: &#39;index.html&#39; // 输出文件名称    })    // ...  ]}</code></pre><h4 id="抽取-CSS-文件"><a href="#抽取-CSS-文件" class="headerlink" title="抽取 CSS 文件"></a>抽取 CSS 文件</h4><p><code>Webpack</code> 在上面对 <code>CSS</code> 的解析中，使用了 <code>css-loader</code> 和 <code>style-loader</code>，通过构建后的结果发现 <code>.css</code> 文件被注入到了 <code>.js</code> 文件中，在生产环境通常会为了减小出口文件的体积对 <code>.css</code> 文件进行抽离，在 <code>Webpack4</code> 中使用 <code>MiniCssExtractPlugin</code> 插件来实现。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install mini-css-extract-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);module.exports = {  // ...  module: {    rules: [      // ...      {        test: /\.css$/,        use: [          MiniCssExtractPlugin.loader, // 用于将 CSS 抽离的加载器          &#39;css-loader&#39;,        ]      }      // ...    ]  },  plugins: [    // ...    new MiniCssExtractPlugin({      filename: &#39;[name].css&#39; // 抽离的文件名    })    // ...  ]  // ...}</code></pre><blockquote class="pullquote info"><p><strong>解析 <code>.css</code> 文件无论哪种方式需要使用 <code>css-loader</code>，但 <code>MiniCssExtractPlugin</code> 提供的 <code>loader</code> 与 <code>style-loader</code> 的功能是互斥的，<code>style-loader</code> 用于将解析的 <code>CSS</code> 注入，而 <code>MiniCssExtractPlugin.loader</code> 意在单独抽离。</strong></p></blockquote><h4 id="自动清理构建目录"><a href="#自动清理构建目录" class="headerlink" title="自动清理构建目录"></a>自动清理构建目录</h4><p>如果输出的文件配置了 <code>hash</code> 且在每次构建时没有及时删除指定的输出目录（如 <code>dist</code>），会导致输出目录中的文件越来越多，不容易区分哪些是新构建出来的文件，所以应该让 <code>Webpack</code> 在每次构建之前清除输出的目录。</p><p>当然清除的方式可以多种，比如手动删除，或者在 <code>package.json</code> 中配置的构建命令中增加前置命令如下。</p><pre><code class="lang-json">/* 不优雅的方式 */{  &quot;scripts&quot;: {    &quot;build&quot;: &quot;rm -rf ./dist &amp;&amp; webpack&quot;  }}</code></pre><p>这种方式并不优雅，完全可以通过 <code>Webpack</code> 配置中增加 <code>CleanWebpackPlugin</code> 插件来解决这个问题，这样在每次构建之前就会自动清除输出目录。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install clean-webpack-plugin -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);module.exports = {  // ...  output: {    filename: &#39;[name][chunkhash:8].js&#39;,    path: __dirname + &#39;dist&#39;  }  plugins: [    new CleanWebpackPlugin()  ]  // ...}</code></pre><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>Webpack</code> 中，文件监听是指发现源文件发生变化时，自动重新构建出新的输出文件。</p><blockquote class="pullquote success"><p><strong><code>Webpack</code> 开启监听模式有两种方式：</strong></p><ul><li><strong>启动 <code>Webpack</code> 命令时带上 <code>--watch</code> 参数，可以在 <code>package.json</code> 中进行配置；</strong></li><li><strong>在 <code>Webpack</code> 配置文件中进行设置。</strong></li></ul></blockquote><p><strong>添加参数：</strong></p><pre><code class="lang-json">/* 配置命令 */{  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack&quot;,    &quot;watch&quot;: &quot;webpack --watch&quot;  }}</code></pre><p><strong>执行命令：</strong></p><pre><code class="lang-bash">$ npm run watch</code></pre><p><strong><code>Webpack</code> 配置文件：</strong></p><pre><code class="lang-js">/* webpack 配置文件 */module.exports = {  // ...  watch: true, // 开启监听  watchOptions: {    // 忽略监听的文件目录    ignored: /node_modules/,    // 监听到发生变化会等待 300ms 去重新构建（防止多次保存），默认 300ms    aggregateTimeout: 300，    // 每秒检查 1000 次    poll: 1000  }  // ...}</code></pre><p><strong><code>watch</code> 监听原理分析：</strong></p><blockquote class="pullquote warning"><p><strong><code>Webpack</code> 会轮询的判断文件的最后编辑时间是否发生变化，如果某个文件发生变化不会立即重新构建，而是会将变化缓存起来，等待 <code>aggregateTimeout</code> 配置的时间后重新构建，这样做是为了防止短时间的多次变化或产生了新的变化文件，在该时间到达时将变化的文件列表进行统一构建，以提高性能，这样的监听方式的缺陷是浏览器不会自动刷新，需要手动刷新查看文件修改后的效果。</strong></p></blockquote><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p><code>webpack-dev-server</code> 是在本地启动服务来监听文件的变化，不是以输出文件的形式更新，而是即时将重新构建的结果放在内存中。</p><p><strong>安装依赖：</strong></p><pre><code class="lang-bash">$ npm install webpack-dev-server -D</code></pre><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  mode: &#39;development&#39;, // 由于 webpack-dev-server 在开发环境中使用  devServer: {    host: &#39;localhost&#39;, // 本地服务的域名    contentBase: &#39;./dist&#39;, // server 作用的目录    port: 8080, // 端口号    compress: true // 是否启动服务器压缩  }  // ...}</code></pre><p><strong>配置服务启动命令：</strong></p><pre><code class="lang-json">{  &quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;  }}</code></pre><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>在 <code>Webpack</code> 构建后的代码中，经过了压缩、混淆等，会出现一个新的问题，就是代码执行出错后不容定位错误是在源代码中哪一个位置产生的，而 <code>devtool</code> 的配置的作用就是让我们更容易定位错误的位置。</p><p><strong><code>devtool</code> 的关键词：</strong></p><table><thead><tr><th style="width:30%">关键词</th><th>作用</th></tr></thead><tbody><tr><td>evel</td><td>使用 evel 函数包裹代码</td></tr><tr><td>source-map</td><td>产生 .map 文件</td></tr><tr><td>cheap</td><td>不含列信息</td></tr><tr><td>inline</td><td>将 .map 内容作为 DataURI 嵌入，不单独生成 .map 文件</td></tr><tr><td>module</td><td>包含 loader 的 source-map</td></tr></tbody></table><p><code>devtool</code> 属性的值就是由上面的关键词组成的，不同的名字会使用不同的调试策略，而名字中的关键词则包含了上面特性，下面是 <code>Webpcak</code> 官网给出的不同构建策略对应的信息。</p><table><thead><tr><th style="width:36%">devtool</th><th style="width:8%">首次构建</th><th style="width:8%">二次构建</th><th style="width:14%">是否适合生产环境</th><th>可以定位的代码</th></tr></thead><tbody><tr><td>none</td><td>+++</td><td>+++</td><td>yes</td><td>最终输出的代码</td></tr><tr><td>eval</td><td>+++</td><td>+++</td><td>no</td><td>Webpack 生成的代码（一个个的模块）</td></tr><tr><td>cheap-eval-source-map</td><td>+</td><td>++</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>cheap-module-eval-source-map</td><td>o</td><td>++</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>eval-source-map</td><td>--</td><td>+</td><td>no</td><td>源代码</td></tr><tr><td>cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>inline-cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>经过 loader 转换后的代码（只能看到行）</td></tr><tr><td>inline-cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>源代码（只能看到行）</td></tr><tr><td>source-map</td><td>--</td><td>--</td><td>yes</td><td>源代码</td></tr><tr><td>inline-source-map</td><td>--</td><td>--</td><td>no</td><td>源代码</td></tr><tr><td>hidden-source-map</td><td>--</td><td>--</td><td>yes</td><td>源代码</td></tr><tr><td>nosources-source-map</td><td>--</td><td>--</td><td>yes</td><td>无源代码</td></tr></tbody></table><blockquote class="pullquote info"><p><strong><code>+++</code> 非常快速，<code>++</code> 快速，<code>+</code> 比较快，<code>o</code> 中等，<code>-</code> 比较慢，<code>--</code> 慢</strong></p></blockquote><p><strong>配置示例：</strong></p><pre><code class="lang-js">module.exports = {  // ...  devtool: &#39;evel&#39;  // ...}</code></pre><p>使用不同的 <code>devtool</code> 会带来不同的效果，使用 <code>evel</code> 不安全，使用 <code>inline</code> 注入会增加打包文件的大小、线上环境生成 <code>.map</code> 文件会容易被人反编译进而暴露业务逻辑等等，所以在 <code>devtool</code> 使用时还是根据自己的需要和安全考虑来权衡。</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><h3 id="配置热更新的方式"><a href="#配置热更新的方式" class="headerlink" title="配置热更新的方式"></a>配置热更新的方式</h3><p><code>webpack-dev-server</code> 可以配合自带的插件实现热更新，即文件修改后，不刷新浏览器的情况下自动构建并在浏览器中响应渲染。</p><pre><code class="lang-js">/* 使用 webpack-dev-server */const webpack = require(&#39;webpack&#39;);module.exports = {  // ...  mode: &#39;development&#39;,  devServer: {    host: &#39;localhost&#39;,    contentBase: &#39;./dist&#39;,    port: 8080,    compress: true  },  plugins: [    new webpack.HotModuleReplacementPlugin()  ]  // ...}</code></pre><p>想要颗粒度更细致的控制 <code>Webpack</code> 的热更新，也可以使用另一种方式，即借助 <code>Express</code> 或 <code>Koa</code> 自己创建一个服务，并借助 <code>webpack-dev-middleware</code> 来实现热更新，这种方式更适合灵活的定制化场景。</p><pre><code class="lang-js">/* 使用 webpack-dev-middleware */const express = require(&#39;express&#39;);const webpack = require(&#39;webpack&#39;);const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;);const config = require(&#39;./webpack.config.js&#39;);const app = express();const compiler = webpack(config);app.use(webpackDevMiddleware(compiler, {  publicPath: config.output.publicPath}));app.listen(3000, function () {  console.log(&#39;server start 3000&#39;);});</code></pre><h3 id="热更新原理简介"><a href="#热更新原理简介" class="headerlink" title="热更新原理简介"></a>热更新原理简介</h3><blockquote class="pullquote primary"><p><strong>热更新的实现分为服务端和浏览器两个部分：</strong></p><ul><li><strong>Webpack Dev Server</strong><ul><li><strong><code>Webpack Compile</code>：<code>Webpack</code> 的编译器，作用是将 <code>JS</code> 编译成 <code>Bundle</code>；</strong></li><li><strong><code>HMR Server</code>：将热更新的文件输出给 <code>HMR Runtime</code>；</strong></li><li><strong><code>Bundle Server</code>：提供文件在浏览器以服务器的方式访问。</strong></li></ul></li><li><strong>Browser</strong><ul><li><strong><code>HMR Runtime</code>：开发阶段打包过程中，会被注入到浏览器，使浏览器的 <code>bundle.js</code> 和服务器建立 <code>websocket</code> 链接，以更新文件的变化；</strong></li><li><strong><code>bundle.js</code>：构建输出的文件。</strong></li></ul></li></ul></blockquote><blockquote class="pullquote success"><p><strong><code>Webpack</code> 在将本地文件显示在浏览器其实有两个阶段：</strong></p><ul><li><strong>第一个阶段为启动阶段通过 <code>Webpack Compile</code> 将文件系统中的文件进行构建，然后将文件传递给 <code>Bundle Server</code>，<code>Bundle Server</code> 将 <code>bundle.js</code> 响应给浏览器；</strong></li><li><strong>第二个阶段为热更新阶段，依然通过 <code>Webpack Compile</code> 对文件系统中修改的文件进行构建，将构建后的结果传递给 <code>HMR Server</code>，<code>HMR Server</code> 通过 <code>Websocket</code> 协议将文件变化的结果通知浏览器端的 <code>HMR Runtime</code>，执行代码并刷新页面。</strong></li></ul></blockquote><blockquote class="pullquote info"><p><strong>未完待续…</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181002041434/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 外观模式</title>
      <link>https://www.overtaking.top/20181001165125/</link>
      <guid>https://www.overtaking.top/20181001165125/</guid>
      <pubDate>Mon, 01 Oct 2018 08:51:25 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20181001165125/facade.jpg&quot; title=&quot;外观模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote default&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181001165125/facade.jpg" title="外观模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote default"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote warning"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="外观模式简介"><a href="#外观模式简介" class="headerlink" title="外观模式简介"></a>外观模式简介</h2><p>“外观模式” 就是把一些复杂的流程封装成一个接口，提供给外部更简单的使用。</p><blockquote class="pullquote info"><p><strong>在外观模式中存在三种角色如下：</strong></p><ul><li><strong>门面角色（<code>Facade</code>）：是 “外观模式” 的核心，它熟悉子系统的功能，并被客户角色调用，内部实现了客户角色需求功能的组合；</strong></li><li><strong>子系统角色（<code>System</code>）：实现了子系统的功能（多个），对于客户角色是未知的；</strong></li><li><strong>客户角色（<code>Client</code>）：通过调用 <code>Facede</code> 来完成要实现的功能。</strong></li></ul></blockquote><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20181001165125/facade-uml.jpg" alt="外观模式 UML 图"></div><div class="image-caption">外观模式 UML 图</div></figure><p><br></p><h2 id="外观模式的实现"><a href="#外观模式的实现" class="headerlink" title="外观模式的实现"></a>外观模式的实现</h2><p>上面已经介绍了 “外观模式” 的各个角色，下面是简单的代码实现。</p><pre><code class="lang-js">// 子系统角色 Sumclass Sum {  sum(a, b) {    return a + b;  }}// 子系统角色 Minusclass Minus {  minus(a, b) {    return a - b;  }}// 子系统角色 Multipyclass Multipy {  multipy(a, b) {    return a * b;  }}// 子系统角色 Divideclass Divide {  divide(a, b) {    return a / b;  }}// 门面角色 Calculatorclass Calculator {  constructor() {    this.sumObj = new Sum();    this.minusObj = new Minus();    this.multipyObj = new Multipy();    this.divideObj = new Divide();  }  sum(...args) {    return this.sumObj.sum(...args);  }  minus(...args) {    return this.minusObj.minus(...args);  }  multipy(...args) {    return this.multipyObj.multipy(...args);  }  divide(...args) {    return this.divideObj.divide(...args);  }}// 客户角色const calculator = new Calculator();console.log(calculator.sum(1, 2)); // 3console.log(calculator.minus(1, 2)); // -1console.log(calculator.multipy(1, 2)); // 2console.log(calculator.divide(1, 2)); // 0.5</code></pre><p>我们在上面代码中实现了一个计算器功能，计算器具备的功能为加、减、乘、除，我们把这四个功能分别拆分成为四个子系统，用门面类 <code>Calculator</code> 来进行连接，这样只需要调用 <code>Calculator</code> 的实例（客户角色）就可以调用四个子系统模块分别提供的功能，但是上面的代码实现功能比较简洁，并没达到 “外观模式” 的真正作用，就是可以随意组合各个子系统的功能。</p><pre><code class="lang-js">/* 组合子系统功能 */// 子系统角色 CPUclass CPU {  start() {    console.log(&#39;CPU 启动&#39;);  }}// 子系统角色 Memoryclass Memory {  start() {    console.log(&#39;内存启动&#39;);  }}// 子系统角色 Diskclass Disk {  start() {    console.log(&#39;硬盘启动&#39;);  }}// 门面角色 Computerclass Computer {  constructor() {    this.cpu = new CPU();    this.memory = new Memory();    this.disk = new Disk();  }  start() {    // 组合子系统功能    this.cpu.start();    this.memory.start();    this.disk.start();  }}// 客户角色const computer = new Computer();computer.start();// CPU 启动// 内存启动// 硬盘启动</code></pre><p>上面代码打印了一个计算机的启动过程，功能来自于各个子系统，也可以通过门面角色实现子系统功能的多种组合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“外观模式” 的作用是可以对复杂功能解耦合，分散到各个子系统，使子系统与子系统互相独立，并对各个子系统提供外界访问的功能组合模块，这样既提高了子系统的维护性，又增加了外界访问功能的扩展性，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/7.facade" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20181001165125/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 代理模式</title>
      <link>https://www.overtaking.top/20180929025641/</link>
      <guid>https://www.overtaking.top/20180929025641/</guid>
      <pubDate>Fri, 28 Sep 2018 18:56:41 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20180929025641/proxy.jpg&quot; title=&quot;代理模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180929025641/proxy.jpg" title="代理模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote info"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a>代理模式概念</h2><p>由于某些情况下一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介作用或者实现控制，这样的模式叫 “代理模式”。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180929025641/proxy-uml.jpg" alt="代理模式 UML 图"></div><div class="image-caption">代理模式 UML 图</div></figure><p><br></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><pre><code class="lang-js">// 假设无法客户端无法直接使用这个类class Google {  get(url) {    return url + &#39; is google&#39;;  }}// 只能通过代理操作 Google 类class Proxy {  constructor() {    this.google = new Google();  }  get(url) {    return this.google.get(url);  }}const proxy = new Proxy();const result = proxy.get(&#39;http://www.google.com&#39;);console.log(result); // http://www.google.com is google</code></pre><p>假设 <code>Google</code> 类我们无法直接使用，只有 <code>Proxy</code> 可以使用 <code>Google</code>，我们可以通过 <code>Proxy</code> 类去操作使用 <code>Google</code> 类，此时 <code>Proxy</code> 类就是一个代理。</p><h2 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h2><p>在 <code>ES6</code> 标准以后，<code>JavaScript</code> 提供了原生的代理模式 <code>Proxy</code> 类，可以代理其他对象，并在对象属性的获取和赋值时增加拦截。</p><pre><code class="lang-js">/* ES6 Proxy 的使用 */const lucy = {  name: &#39;lucy&#39;,  age: 20,  height: 165};const lucyMother = new Proxy(lucy, {  get(target, key) {    if (key === &#39;age&#39;) {      return target.age - 2;    } else if (key === &#39;height&#39;) {      return target.height + 5;    } else {      return target[key];    }  },  set(target, key, val) {    if (key === &#39;boyfriend&#39;) {      if (val.age &gt; 40) {        console.log(&#39;太老了&#39;);      } else if (val.salary &lt; 20000) {        console.log(&#39;太穷了&#39;);      } else {        target[key] = val;      }    }  }});console.log(lucyMother.name); // lucyconsole.log(lucyMother.age); // 18console.log(lucyMother.height); // 170lucyMother.boyfriend = {  age: 42,  salary: 25000}// 太老了lucyMother.boyfriend = {  age: 36,  salary: 18000}// 太穷了</code></pre><p>上面是一个接地气的案例，创建一个对象存储 <code>lucy</code> 的基本信息，使用代理创建 <code>lucyMother</code> 为 <code>lucy</code> 找男朋友，通过代理对象获取 <code>lucy</code> 的基本信息时会虚报年龄和身高，而在设置男朋友对象时会检查是否符合要求。</p><h2 id="代理模式、适配器模式和装饰器模式"><a href="#代理模式、适配器模式和装饰器模式" class="headerlink" title="代理模式、适配器模式和装饰器模式"></a>代理模式、适配器模式和装饰器模式</h2><p>从代码实现来看，代理模式、适配器模式、装饰器模式非常的相似，非常容易混淆，但其实是有本质区别的。</p><blockquote class="pullquote info"><ul><li><strong>代理模式和适配器模式：代理模式不会改变原有的接口，代理类和被代理的类属性方法使用方式完全一致，而适配器模式是因为旧的接口无法使用，通过适配器创建新的接口去兼容旧的接口；</strong></li><li><strong>代理模式和装饰器模式：装饰器功能会保证被装饰类功能正常使用的情况下新增功能，而代理模式保证原有接口，但会改变原来接口的功能；</strong></li><li><strong>适配器模式和装饰器模式：装饰器是对一个类的包装，而适配器更多是去建立提供接口的类与无法适配的类之间的联系。</strong></li></ul></blockquote><h2 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是浏览器事件注册的一种优化手段，如果同类型的元素非常多，且都有相同的事件，如列表，则不必给每一个元素注册这个事件，而是将事件注册给父元素，即将事件委托给父元素，避免了相同事件的重复注册，这种优化利用了 “代理模式”，又称事件代理。</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;事件委托&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;ul id=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    const ulList = document.getElementById(&#39;list&#39;);    ulList.addEventListener(&#39;click&#39;, function (event) {      console.log(event.target.innerHTML);    });  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在浏览器中，委托给父元素的事件触发后，可以通过事件对象的属性 <code>target</code> 获取到具体触发事件的子元素。</p><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片加载是一个提高用户体验的功能，也是非常常见的，原因是浏览器向服务器请求资源图片是需要等待的，由于网络等因素的影响会导致等待的时间更长，此时我们需要一个 <code>loading</code> 图片来过渡，这就是图片加载的基本需求。</p><pre><code class="lang-js">/* node 服务器 */const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();app.get(&#39;/loading.gif&#39;, function (req, res) {  res.sendFile(path.resolve(&#39;img&#39;, &#39;loading.gif&#39;));});app.get(&#39;/img/:name&#39;, function (req, res) {  setTimeout(function () {    res.sendFile(path.join(__dirname, req.path));  }, 3000);});app.use(express.static(__dirname));app.listen(3000, function () {  console.log(&#39;server start 3000&#39;);});</code></pre><p>上面服务器模拟了加载图片响应慢的场景，<code>loading</code> 图片立即响应，其他图片则延迟 <code>3s</code> 响应。</p><pre><code class="lang-html">&lt;!-- Dom 结构 --&gt;&lt;ul id=&quot;menu&quot;&gt;  &lt;li data-src=&quot;/img/bg1.jpg&quot;&gt;图片1&lt;/li&gt;  &lt;li data-src=&quot;/img/bg2.jpg&quot;&gt;图片2&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;bgimg&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="lang-js">/* 没有实现 loading */const menu = document.getElementById(&#39;menu&#39;);const bgimg = document.getElementById(&#39;bgimg&#39;);const background = (function () {  const img = new Image();  bgimg.appendChild(img)  return {    setSrc(src) {      img.src = src;    }  }})();menu.addEventListener(&#39;click&#39;, function (event) {  const src = event.target.dataset.src;  background.setSrc(src);});</code></pre><p>上面的代码是没有实现懒加载的，当点击按钮向服务器请求图片时，并没有加入 <code>loading</code> 图片过渡，之所以说图片加载应用了 “代理模式” 并不是指加载功能本身，而是我们的实现方式，编写的代码质量要高至少要遵循单一职责原则和开放封闭原则，就是说最好不要直接在事件监听的函数中增加 <code>loading</code> 过渡的逻辑，而是把这个过渡功能交给代理对象去处理。</p><pre><code class="lang-js">/* 使用代理对象实现 loading 过渡 */const menu = document.getElementById(&#39;menu&#39;);const bgimg = document.getElementById(&#39;bgimg&#39;);// 请求图片的对象const background = (function () {  const img = new Image();  bgimg.appendChild(img)  return {    setSrc(src) {      img.src = src;    }  }})();// 增加 loading 过度的代理对象const proxyBackground = (function () {  const img = new Image();  img.onload = function () {    background.setSrc(this.src);  }  return {    setSrc(src) {      background.setSrc(&#39;./img/loading.gif&#39;);      img.src = src;    }  }})();// 监听获取图片的事件中使用的是代理对象 proxyBackgroundmenu.addEventListener(&#39;click&#39;, function (event) {  const src = event.target.dataset.src;  // 防止缓存  proxyBackground.setSrc(src + &#39;?time=&#39; + Date.now());});</code></pre><p>上面的实现方式就符合 “代理模式”，<code>background</code> 对象是提供基本功能，而<code>proxyBackground</code>（代理对象）增强了基本功能，却并没有改变接口的使用方式，依然通过 <code>setSrc</code> 方法去请求图片。</p><h3 id="防抖代理"><a href="#防抖代理" class="headerlink" title="防抖代理"></a>防抖代理</h3><p>防抖的作用是在做一个操作时不需要很频繁，如搜索查询，在连续输入时如果每次触发输入事件都向后端发送请求，性能是极差的，我们希望的是连续输入只在最后一次统一发送请求，这种处理叫做防抖处理，是前端优化的手段。</p><pre><code class="lang-html">&lt;!-- 未使用防抖代理处理 --&gt;&lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;&lt;script&gt;  const ipt = document.getElementById(&#39;ipt&#39;);  function post() {    console.log(&#39;发送请求了&#39;);  }  ipt.addEventListener(&#39;input&#39;, post);&lt;/script&gt;</code></pre><p>上面代码未使用防抖代理，每次输入都会打印 “发送请求了”。</p><pre><code class="lang-html">&lt;!-- 使用防抖代理优化 --&gt;&lt;input type=&quot;text&quot; id=&quot;ipt&quot;&gt;&lt;script&gt;  const ipt = document.getElementById(&#39;ipt&#39;);  function post() {    console.log(&#39;发送请求了&#39;);  }  // 代理函数去执行 post  const debouncePost = (function () {    let timer = null;    return function () {      clearInterval(timer);      timer = setTimeout(function () {        post();      }, 500);    }  })();  ipt.addEventListener(&#39;input&#39;, debouncePost);&lt;/script&gt;</code></pre><p>使用防抖代理函数优化后，保留了原有功能的基础上进行了增强，实现了连续输入停止 <code>500ms</code> 后统一发送一次请求，防抖的实现方式有很多种，包括并不限于函数式编程等，而上面代码使用了 “代理模式” 实现 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>使用 “代理模式” 的场景在后端会更多，比如代理跨域，<code>Nginx</code> 代理等等，还有一点需要注意的是，“代理模式” 并非单一的，对于同一个对象，可以有多个代理对象去增强不同的功能，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/6.proxy" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20180929025641/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 装饰器模式</title>
      <link>https://www.overtaking.top/20180928030105/</link>
      <guid>https://www.overtaking.top/20180928030105/</guid>
      <pubDate>Thu, 27 Sep 2018 19:01:05 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20180928030105/decorator.jpg&quot; title=&quot;装饰器模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote warning&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180928030105/decorator.jpg" title="装饰器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote warning"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote default"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180927230432/" target="_blank">设计模式 JS 表现 —— 适配器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="装饰器模式概念"><a href="#装饰器模式概念" class="headerlink" title="装饰器模式概念"></a>装饰器模式概念</h2><p>“装饰器模式” 是结构型模式之一，在不改变原有对象结构的前提下，给对象添加新功能，也可以理解 “装饰器模式” 是将一个对象嵌入另一个对象之中，相当于一个对象被另一个对象包装，包装其他对象的对象被称为 “装饰器”。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180928030105/decorator-uml.jpg" alt="装饰器模式 UML 图"></div><div class="image-caption">装饰器模式 UML 图</div></figure><p><br></p><h2 id="装饰器模式和适配器模式"><a href="#装饰器模式和适配器模式" class="headerlink" title="装饰器模式和适配器模式"></a>装饰器模式和适配器模式</h2><pre><code class="lang-js">/* 装饰器模式案例 */// 类 Duckclass Duck {  constructor(name) {    this.name = name;  }  eat(food) {    console.log(this.name + &#39;吃&#39; + food);  }}// 装饰器类 TangDuck，装饰 Duck 类class TangDuck {  constructor(name) {    this.duck = new Duck(name);  }  eat(food) {    this.duck.eat(food);    console.log(&#39;说谢谢&#39;);  }}const tangDuck = new TangDuck(&#39;唐老鸭&#39;);tangDuck.eat(&#39;苹果&#39;);// 唐老鸭吃苹果// 说谢谢</code></pre><pre><code class="lang-js">/* 适配器模式案例 */// 类 Powerclass Power {  charge() {    return &#39;220V&#39;;  }}// 适配器class Adaptor {  constructor(Power) {    this.power = new Power();  }  chargeTransform() {    return this.power.charge() + &#39; =&gt; 22v&#39;;  }}// 类 Power 的使用者class Notepad {  constructor(Power) {    this.adaptor = new Adaptor(Power);  }  use() {    console.log(this.adaptor.chargeTransform());  }}</code></pre><p>上面分别是 “装饰器模式” 和 “适配器模式” 的案例，但直接看代码可能会将两者混淆，原因是 “适配器” 和 “装饰器” 的类都存在了一个被装饰或者适配转换的类的引用，不同的是，“装饰器” 仅仅是对某一个类进行包装，并不会改变原来类的结构，而 “适配器” 的作用更多是去建立一个类和另一个类之间的关系和转换。</p><h2 id="装饰器模式和继承"><a href="#装饰器模式和继承" class="headerlink" title="装饰器模式和继承"></a>装饰器模式和继承</h2><p>通过上一节，我们已经知道了什么是 “装饰器模式”，下面有一个更直观的例子，我们有一个基础类 <code>Coffee</code>，组成是咖啡加水，这个基础上可以加奶、糖、冰，需求是可以组合加入上面的其他原料，并计算出对应的价格，大家可能第一时间想到的是继承的方式实现。</p><pre><code class="lang-js">/* 继承的实现方式 */// 水 + 咖啡class Coffee {  make(water) {    return water + &#39; + 咖啡&#39;  }  cost() {    return 10;  }}// 水 + 奶 + 咖啡class MilkCoffee extends Coffee {  constructor() {    super();  }  make(water) {    return super.make(water) + &#39; + 奶&#39;;  }  cost() {    return super.cost() + 3;  }}// 水 + 糖 + 咖啡class SugarCoffee extends Coffee {  constructor() {    super();  }  make(water) {    return super.make(water) + &#39; + 糖&#39;;  }  cost() {    return super.cost() + 2;  }}// 水 + 糖 + 奶 + 咖啡class SugarMilkCoffee extends SugarCoffee {  constructor() {    super();  }  make(water) {    return super.make(water) + &#39; + 奶&#39;;  }  cost() {    return super.cost() + 3;  }}// 水 + 奶 + 糖 + 咖啡class MilkSugarCoffee extends MilkCoffee {  constructor() {    super();  }  make(water) {    return super.make(water) + &#39; + 糖&#39;;  }  cost() {    return super.cost() + 2;  }}</code></pre><p>从继承的代码看，虽然可以实现给咖啡任意加入其他原料，但是每一种不同的排列组合都需要单独创建类，当原料种类众多时，则难以管理代码，下面是 “装饰器模式” 的实现。</p><pre><code class="lang-js">/* 装饰器模式的实现方式 */class Coffee {  make(water) {    return water + &#39; + 咖啡&#39;;  }  cost() {    return 10;  }}class MilkCoffee {  constructor(parent) {    this.parent = parent;  }  make(water) {    return this.parent.make(water) + &#39; + 奶&#39;;  }  cost() {    return this.parent.cost() + 3;  }}class SugarCoffee {  constructor(parent) {    this.parent = parent;  }  make(water) {    return this.parent.make(water) + &#39; + 糖&#39;;  }  cost() {    return this.parent.cost() + 2;  }}class IceCoffee {  constructor(parent) {    this.parent = parent;  }  make(water) {    return this.parent.make(water) + &#39; + 冰&#39;;  }  cost() {    return this.parent.cost() + 1;  }}const coffee = new Coffee();const milkCoffee = new MilkCoffee(coffee);const sugarCoffee = new SugarCoffee(milkCoffee);const iceCoffee = new IceCoffee(sugarCoffee);console.log(milkCoffee.make(&#39;水&#39;), milkCoffee.cost());console.log(sugarCoffee.make(&#39;水&#39;), sugarCoffee.cost());console.log(iceCoffee.make(&#39;水&#39;), iceCoffee.cost());// 水 + 咖啡 + 奶 13// 水 + 咖啡 + 奶 + 糖 15// 水 + 咖啡 + 奶 + 冰 16</code></pre><p>从 “装饰器模式” 的实现代码来看，我们只需要创建和原料相同多的类就可以了，其他的方式加料只需要对上一个类进行包装即可，部分加料的顺序，当类的种类越多时，“装饰器” 的意义则体现的越明显。</p><blockquote class="pullquote info"><p><strong>装饰器模式有时候会优于继承，尤其是很多的类通过继承存在排列组合的关系时，则使用 “装饰器模式” 可以更好更高效的解决问题。</strong></p></blockquote><h2 id="装饰器模式和-AOP-编程"><a href="#装饰器模式和-AOP-编程" class="headerlink" title="装饰器模式和 AOP 编程"></a>装饰器模式和 AOP 编程</h2><p>在软件业，<code>AOP</code> 为 <code>Aspect Oriented Programming</code> 的缩写，意为面向切面编程，通过预编译方式和运行其动态代理实现程序功能统一维护的一种技术。</p><p>在 <code>JavaScript</code> 中的 <code>AOP</code> 就是在函数之前或之后添加一些额外的逻辑，而不需要修改函数本身逻辑。</p><pre><code class="lang-js">/* AOP 编程的案例 */// 给函数扩展 before 方法Function.prototype.before = function (beforeFn) {  let _this = this;  return function () {    beforeFn.apply(this, arguments);    _this.apply(this, arguments);  }}// 给函数扩展 after 方法Function.prototype.after = function (afterFn) {  let _this = this;  return function () {    _this.apply(this, arguments);    afterFn.apply(this, arguments);  }}// 原函数function buy(money, goods) {  console.log(&#39;花&#39; + money + &#39;元钱买&#39; + goods);}// 使用 before 方法给函数增加前切面buy = buy.before(function () {  console.log(&#39;向媳妇要1元钱&#39;);});// 使用 before 方法给函数增加后切面buy = buy.after(function () {  console.log(&#39;还给媳妇0.2元钱&#39;);})buy(0.8, &#39;盐&#39;);// 向媳妇要1元钱// 花0.8元钱买盐// 还给媳妇0.2元钱</code></pre><blockquote class="pullquote default"><p><strong><code>AOP</code> 编程是由 “装饰器模式” 进化而来，或者说 “装饰器模式” 属于 <code>AOP</code> 编程的一种。</strong></p></blockquote><h2 id="装饰器模式的应用"><a href="#装饰器模式的应用" class="headerlink" title="装饰器模式的应用"></a>装饰器模式的应用</h2><h3 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法，埋点主要分为服务器层面的埋点和客户端层面的埋点，服务器层面的埋点主要是通过客户端的请求进行分析，客户端层面的埋点分为代码埋点、自动化埋点，第三方埋点（百度、友盟等）。</p><pre><code class="lang-html">&lt;!-- 一个埋点的简单案例 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;埋点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;button data-name=&quot;wetermelon&quot; id=&quot;wetermelon&quot;&gt;西瓜&lt;/button&gt;  &lt;button data-name=&quot;apple&quot; id=&quot;apple&quot;&gt;苹果&lt;/button&gt;  &lt;script&gt;    const wetermelon = document.getElementById(&#39;wetermelon&#39;);    const apple = document.getElementById(&#39;apple&#39;);    // 添加切面    Function.prototype.after = function (afterFn) {      let _this = this;      return function () {        _this.apply(this, arguments);        afterFn.apply(this, arguments);      }    }    // 事件处理函数    function click() {      console.log(&#39;你点击了&#39; + this.dataset.name);    }    click = click.after(function () {      // 向服务器发送统计数据      const img = new Image();      img.src = &#39;http://localhost:3000/report?name=&#39; + this.dataset.name;    });    // 给所有的    Array.from(document.querySelectorAll(&#39;button&#39;)).forEach(button =&gt; {      button.addEventListener(&#39;click&#39;, click);    });  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="lang-js">/* 负责统计点击次数的服务 */const express = require(&#39;express&#39;);const app = express();// 存储按钮的点击次数const goods = {};app.get(&#39;/report&#39;, function (req, res) {  const name = req.query.name;  if (goods[name]) {    goods[name]++;  } else {    goods[name] = 1;  }  res.json(goods);});app.listen(3000, function () {  console.log(&#39;server start 3000&#39;);});</code></pre><p>上面的埋点就是通过 <code>AOP</code> 的方式在点击事件后添加了切面，用来向服务器发送请求，符合 “单一职责原则”，可以使点击事件和埋点逻辑进行 “解耦”，服务器在接收到请求之后立即对点击次数进行统计并储存，也可以通过调用 <code>report</code> 接口来获取当前各个按钮的点击次数。</p><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>“装饰器模式” 的思想同样可以用在表单校验，通常表单校验逻辑是在 <code>submit</code> 事件触发时提交之前发生的，我们经常会将校验逻辑和提交逻辑写在一起，形成 “强耦合”，下面我们使用 <code>AOP</code> 的方式来实现表单校验，对校验逻辑和提交逻辑进行 “解耦”。</p><pre><code class="lang-html">&lt;!-- 应用于表单校验 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;表单校验&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;  密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;  &lt;button id=&quot;submit-btn&quot;&gt;提交&lt;/button&gt;  &lt;script&gt;    const submitBtn = document.getElementById(&#39;submit-btn&#39;);    // 添加切面函数    Function.prototype.before = function (beforeFn) {      let _this = this;      return function () {        let result = beforeFn.apply(this, arguments);        result &amp;&amp; _this.apply(this, arguments);      }    }    // 表单提交事件    function submit() {      console.log(&#39;提交表单&#39;);    }    // 验证用户名    submit = submit.before(function () {      const username = document.getElementById(&#39;username&#39;).value;      if (!username) {        return alert(&#39;请输入用户名&#39;);      }      return true;    });    // 验证    submit = submit.before(function () {      const password = document.getElementById(&#39;password&#39;).value;      if (!password) {        return alert(&#39;请输入密码&#39;);      }      return true;    });    submitBtn.addEventListener(&#39;click&#39;, submit);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>在 <code>JavaScript</code> 中 “装饰器模式” 和 <code>AOP</code> 编程非常相似，应用也非常多，如 <code>axios</code> 中对请求、响应的拦截方法，<code>Koa</code> 中间件，都包含这样的编程思想，而在 <code>ES6</code> 之后 <code>JavaScript</code> 已经支持了原生的 “装饰器” 语法，使用起来更方便，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/5.decorator" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20180928030105/#disqus_thread</comments>
    </item>
    
    <item>
      <title>设计模式 JS 表现 —— 适配器模式</title>
      <link>https://www.overtaking.top/20180927230432/</link>
      <guid>https://www.overtaking.top/20180927230432/</guid>
      <pubDate>Thu, 27 Sep 2018 15:04:32 GMT</pubDate>
      <description>
      
        &lt;img src=&quot;//static.overtaking.top/images/DesignPatterns/20180927230432/adapter.jpg&quot; title=&quot;适配器模式&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote class=&quot;pullquote info&quot;&gt;&lt;p&gt;&lt;strong&gt;这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 &lt;code&gt;JavaScript&lt;/code&gt; 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 &lt;code&gt;JavaScript&lt;/code&gt; 表现。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180927230432/adapter.jpg" title="适配器模式"><p><br></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote class="pullquote info"><p><strong>这是关于设计模式的系列文章，在每篇文章中将对常见设计模式进行讲解，因为针对前端方向，而且前端常用语言 <code>JavaScript</code> 本身是弱类型，面向对象（模拟面向对象）编程的实现相较于其他强类型语言实现更为繁琐，所以代码主要以 <code>JavaScript</code> 表现。</strong></p></blockquote><a id="more"></a><blockquote class="pullquote primary"><p><strong>系列文章链接：</strong></p><ul><li><a href="/20180925190503/" target="_blank">设计模式 JS 表现 —— 工厂模式</a></li><li><a href="/20180926201447/" target="_blank">设计模式 JS 表现 —— 单例模式</a></li><li><a href="/20180928030105/" target="_blank">设计模式 JS 表现 —— 装饰器模式</a></li><li><a href="/20180929025641/" target="_blank">设计模式 JS 表现 —— 代理模式</a></li><li><a href="/20181001165125/" target="_blank">设计模式 JS 表现 —— 外观模式</a></li><li><a href="/20181004114907/" target="_blank">设计模式 JS 表现 —— 发布/订阅和观察者模式</a></li><li><a href="/20181005161213/" target="_blank">设计模式 JS 表现 —— 状态模式</a></li><li><a href="/20181006014812/" target="_blank">设计模式 JS 表现 —— 策略模式</a></li></ul></blockquote><h2 id="适配器模式的概念"><a href="#适配器模式的概念" class="headerlink" title="适配器模式的概念"></a>适配器模式的概念</h2><p>“适配器模式” 是指类的使用者和类的接口定义格式不符合时，通过一个中间类进行转换。</p><p><br></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div><img loading="lazy" src="//static.overtaking.top/images/DesignPatterns/20180927230432/adapter-uml.jpg" alt="适配器模式 UML 图"></div><div class="image-caption">适配器模式 UML 图</div></figure><p><br></p><pre><code class="lang-js">// 类 Powerclass Power {  charge() {    return &#39;220V&#39;;  }}// 适配器class Adaptor {  constructor(Power) {    this.power = new Power();  }  chargeTransform() {    return this.power.charge() + &#39; =&gt; 22V&#39;;  }}// 类 Power 的使用者class Notepad {  constructor(Power) {    this.adaptor = new Adaptor(Power);  }  use() {    console.log(this.adaptor.chargeTransform());  }}const notepad = new Notepad(Power);notepad.use(); // 220V =&gt; 22V</code></pre><p>上面代码中有三个类，<code>Power</code> 类为电源，提供 <code>220V</code> 电压，<code>Notepad</code> 为我们的电子设备，使用电压 <code>22V</code>，明显两个类是不匹配的，此时的 <code>Adaptor</code> 就是一个适配器，作用是连接 <code>Power</code> 与 <code>Notepad</code>，将 <code>220V</code> 转换为 <code>22V</code>。</p><blockquote class="pullquote warning"><p><strong>适配器模式中，通常作为适配器的类内部会存储被转换类实例的引用。</strong></p></blockquote><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配参数和返回数据"><a href="#适配参数和返回数据" class="headerlink" title="适配参数和返回数据"></a>适配参数和返回数据</h3><p>在浏览器通过 <code>Ajax</code> 与服务端交互时，封装的请求方法会有默认参数，如果传入了参数则使用传入的参数，如果没有传入，则使用默认的参数，这是参数的适配。</p><p>在请求响应后，后端会返回给我们 <code>JSON</code> 格式的数据，我们在使用时希望转换成对象使用，这个转换的适配是数据接口的适配。</p><pre><code class="lang-js">// 请求方法function ajax(options) {  const defaultOptions = {    method: &#39;GET&#39;,    dataType: &#39;JSON&#39;  };  initParams(options, defaultOptions); // 适配参数}// 参数适配器function initParams(options, defaultOptions) {  for (let attr in options) {    defaultOptions[attr] = options[attr] || defaultOptions[attr];  }  return defaultOptions;}// 数据适配器function tranformData(data) {  return JSON.parse(data);}// 使用适配器ajax({  url: &#39;www.pandashen.com&#39;,  method: &#39;POST&#39;,  success(json) {    const result = tranformData(json); // 适配返回数据    console.log(result);  }});</code></pre><h3 id="适配转换-Promise"><a href="#适配转换-Promise" class="headerlink" title="适配转换 Promise"></a>适配转换 Promise</h3><p>在 <code>Node.js</code> 的 <code>fs</code> 模块中有很多异步的方法，比如 <code>readFile</code>，读取文件获取结果后想要继续读取下一个文件，以此类推就产生了 “回调地狱”，代码的可读性和维护性会变差，我们可以通过 “适配器模式” 将这些方法转化为 <code>Promise</code> 实例。</p><pre><code class="lang-js">const fs = require(&#39;fs&#39;);// 适配成 Promisefunction promisify(fn) {  return function (...args) {    return new Promise((resolve, reject) =&gt; {      fn.call(null, ...args, (err, data) =&gt; {        err ? reject(err) : resolve(data);      });    });  }}// 使用适配后的方法const readFile = promisify(fs.readFile);readFile(&#39;index.txt&#39;, &#39;utf-8&#39;).then(data =&gt; {  console.log(data); // Hello world});</code></pre><h3 id="适配技术栈变更后的旧代码"><a href="#适配技术栈变更后的旧代码" class="headerlink" title="适配技术栈变更后的旧代码"></a>适配技术栈变更后的旧代码</h3><p>在一些老项目是 <code>jQuery</code> 的技术栈，请求也使用的是自带的 <code>$.ajax</code>，如果一天项目中决定移除 <code>jQuery</code>，请求方法 <code>$.ajax</code> 自然也跟着移除了，假设我们想使用 <code>fetch</code> 来代替 <code>$.ajax</code>，则要修改大量的代码，这时 “适配器模式” 可以对 <code>fetch</code> 进行适配，让我们继续沿用 <code>$.ajax</code> 的写法。</p><pre><code class="lang-js">// 适配器window.$ = {  ajax(options) {    return fetch(options.url, {      method: options.type || &#39;GET&#39;,      body: JSON.stringifily(options.data || {})    }).then(res =&gt; res.json());  }};// $.ajax 的旧代码$.ajax({  url: &#39;pandashen.com/info&#39;,  type: &#39;POST&#39;,  dataType: &#39;json&#39;,  data: { id: 1 }}).then(function (data) {  console.log(data);});</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote class="pullquote success"><p><strong>“适配器模式” 是很常用的设计模式之一，<code>Vue</code> 的 <code>computed</code> 计算属性、<code>Koa</code> 兼容 <code>1.x</code> 和 <code>2.x</code> 版本的转换中间件 <code>koa-convert</code> 都应用了 “适配器模式”，最后附上</strong> <a href="https://github.com/shenqiuhui/design-pattern-js/tree/master/4.adapter" target="_blank">案例地址</a><strong>。</strong></p></blockquote>]]></content:encoded>
      
      <comments>https://www.overtaking.top/20180927230432/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
